<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis | 方圆的博客</title><meta name="author" content="方圆"><meta name="copyright" content="方圆"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="自己在学习Redis知识时候记得一些笔记， 它用Redis实现了短信登录，缓存查询，优惠券秒杀，附近商户，UV统计，用户签到，好友关注，达人探店等功能">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://www.mfyuan.top/2024/04/07/Java/Redis/index.html">
<meta property="og:site_name" content="方圆的博客">
<meta property="og:description" content="自己在学习Redis知识时候记得一些笔记， 它用Redis实现了短信登录，缓存查询，优惠券秒杀，附近商户，UV统计，用户签到，好友关注，达人探店等功能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_26.webp">
<meta property="article:published_time" content="2024-04-07T00:56:42.516Z">
<meta property="article:modified_time" content="2024-05-22T10:23:35.905Z">
<meta property="article:author" content="方圆">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_26.webp"><link rel="shortcut icon" href="/img/github-mark.png"><link rel="canonical" href="http://www.mfyuan.top/2024/04/07/Java/Redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-22 18:23:35'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_26.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="方圆的博客"><span class="site-name">方圆的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-07T00:56:42.516Z" title="发表于 2024-04-07 08:56:42">2024-04-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-22T10:23:35.905Z" title="更新于 2024-05-22 18:23:35">2024-05-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>131分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="理论Redis"><a href="#理论Redis" class="headerlink" title="理论Redis"></a>理论Redis</h1><h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p> Redis是一种键值型的NoSql数据库</p>
<ul>
<li><p>键值型：以key，value形式存储</p>
</li>
<li><p>Nosql:</p>
</li>
</ul>
<h2 id="Nosql：非关系型数据库"><a href="#Nosql：非关系型数据库" class="headerlink" title="Nosql：非关系型数据库"></a>Nosql：非关系型数据库</h2><h3 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a><strong>结构化与非结构化</strong></h3><ul>
<li><p>传统的关系型数据库，每一张表都有严格的约束信息：字段，字段数，阻断类型等</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240407220028661.png" alt="image-20240407220028661"></p>
</li>
<li><p>Nosql则对数据库格式没有严格的约束，往往形式松散自由</p>
</li>
</ul>
<p>​	可以是键值型key-value，文档型Document，图形Graph等</p>
<h3 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h3><p>传统的数据库表之际，往往存在外键，进行关联</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240407215900787.png" alt="image-20240407215900787"></p>
<p>而非关系型数据库不存在关联关系，维护要么靠代码中的业务实现逻辑，要么靠数据之间的耦合</p>
<h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>传统的查询方式：基于SQL查询</p>
<p>不同的非关系型数据库，查询方法五花八门</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240407220420128.png" alt="image-20240407220420128"></p>
<h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>传统的数据库能满足事物的四个特性：原子性，一致性，隔离性，持久性</p>
<p>非关系型：不支持事物，只能实现基本的一致性</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240407220804368.png" alt="image-20240407220804368"></p>
<p>扩展性</p>
<ul>
<li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li>
<li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li>
<li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li>
</ul>
<h1 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h1><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p>
<p><strong>特征</strong>：</p>
<ul>
<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端</li>
</ul>
<p><strong>作者</strong>：Antirez</p>
<p>Redis的官方网站地址：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><h2 id="1-Linux下安装"><a href="#1-Linux下安装" class="headerlink" title="1.Linux下安装"></a>1.Linux下安装</h2><p>麻烦，但是跟着教程学一遍</p>
<h2 id="1-3-安装Redis"><a href="#1-3-安装Redis" class="headerlink" title="1.3.安装Redis"></a>1.3.安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p>
<p>此处选择的Linux版本为CentOS 7.</p>
<h3 id="1-3-1-依赖库"><a href="#1-3-1-依赖库" class="headerlink" title="1.3.1.依赖库"></a>1.3.1.依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure>



<h3 id="1-3-2-上传安装包并解压"><a href="#1-3-2-上传安装包并解压" class="headerlink" title="1.3.2.上传安装包并解压"></a>1.3.2.上传安装包并解压</h3><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/SyjanS5.png"></p>
<p>例如，我放到了&#x2F;usr&#x2F;local&#x2F;src 目录：</p>
<p>解压缩：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>



<p>进入redis目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure>



<p>运行编译命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>如果没有出错，应该就安装成功了。</p>
<p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p>
<p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p>
<ul>
<li>redis-cli：是redis提供的命令行客户端</li>
<li>redis-server：是redis的服务端启动脚本</li>
<li>redis-sentinel：是redis的哨兵启动脚本</li>
</ul>
<h3 id="1-3-3-启动"><a href="#1-3-3-启动" class="headerlink" title="1.3.3.启动"></a>1.3.3.启动</h3><p>redis的启动方式有很多种，例如：</p>
<ul>
<li>默认启动</li>
<li>指定配置启动</li>
<li>开机自启</li>
</ul>
<h3 id="1-3-4-默认启动"><a href="#1-3-4-默认启动" class="headerlink" title="1.3.4.默认启动"></a>1.3.4.默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/v7xWsqC.png"></p>
<p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p>
<h3 id="1-3-5-指定配置启动"><a href="#1-3-5-指定配置启动" class="headerlink" title="1.3.5.指定配置启动"></a>1.3.5.指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211211082225509.png" alt="image-20211211082225509"></p>
<p>我们先将这个配置文件备份一份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure>



<p>然后修改redis.conf文件中的一些配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure>



<p>Redis的其它常见配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure>



<p>启动Redis：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>



<p>停止服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure>



<h3 id="1-3-6-开机自启"><a href="#1-3-6-开机自启" class="headerlink" title="1.3.6.开机自启"></a>1.3.6.开机自启</h3><p>我们也可以通过配置来实现开机自启。</p>
<p>首先，新建一个系统服务文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<p>然后重载系统服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>



<p>现在，我们可以用下面这组命令来操作redis了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure>



<p>执行下面的命令，可以让redis开机自启：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure>



<h2 id="2-Docker镜像安装"><a href="#2-Docker镜像安装" class="headerlink" title="2.Docker镜像安装"></a>2.Docker镜像安装</h2><p>傻瓜式一键安装，但怕出问题，按教程走一遍</p>
<h2 id="安装遇到的问题"><a href="#安装遇到的问题" class="headerlink" title="安装遇到的问题"></a>安装遇到的问题</h2><p><strong>问题</strong>：Xftp7想Linux内传输文件的时候，传输报错</p>
<p><strong>解决</strong>：我已经sudo按照root用户登陆了，不知道为什么还是没有权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 777 /usr/local/src</span><br></pre></td></tr></table></figure>

<p>解释：charGpt</p>
<ul>
<li><code>sudo</code>: 以超级用户权限执行命令。</li>
<li><code>chmod</code>: 是 change mode 的缩写，用于修改文件或文件夹的权限。</li>
<li><code>777</code>: 权限表示法，其中每个数字代表一组用户：第一个数字表示所有者的权限，第二个数字表示所属组的权限，第三个数字表示其他用户的权限。每个数字可以取值范围是 0 到 7，其中 0 表示没有权限，1 表示执行权限，2 表示写权限，4 表示读权限。而数字 7 表示读、写、执行权限的组合，因此 <code>777</code> 表示所有用户都拥有读、写、执行的权限。</li>
<li><code>/usr/local/src</code>: 指定要修改权限的文件夹路径。</li>
</ul>
<p><strong>问题</strong>：使用图像化界面Resp连接Linux，Redis的时候，连接不成功</p>
<p><strong>解决：</strong>端口被防火墙阻止了。关闭防火墙或者开放这个6379端口即可</p>
<p>命令顾名思义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"><span class="comment">#（--permanent永久生效，没有此参数重启后失效）</span></span><br><span class="line"><span class="comment">#注：可以是一个端口范围，如1000-2000/tcp</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent    </span><br><span class="line">firewall-cmd --list-port</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，value包含很多不同的数据类型</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408084656979.png" alt="image-20240408084656979"></p>
<h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>部分通用数据类型，都可以使用的指令</p>
<ul>
<li>KEYS：查看符合模板的所有的key</li>
<li>DEL：删除一个指定的key</li>
<li>EXISTS：判断key是否存在</li>
<li>EXPIRE：给key设置一个有效期，到期时该key会被自动删除</li>
<li>TTL：查看一个KEY的剩余有效期</li>
</ul>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p>
<p><strong>2.2.1.String的常见命令</strong></p>
<p>String的常见命令有：</p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<h2 id="key结构"><a href="#key结构" class="headerlink" title="key结构"></a>key结构</h2><p>通过给key添加前缀加以区分</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>

<p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p>
<p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><p>user相关的key：<strong>heima:user:1</strong></p>
</li>
<li><p>product相关的key：<strong>heima:product:1</strong></p>
</li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p>
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody><tr>
<td>heima:user:1</td>
<td>{“id”:1,  “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody></table>
<p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p>
<h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>hash类型，散列，value是一个无序列表，类似于HashMap</p>
<p>即：key里面存的value，又是一个key-value</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/x2zDBjf.png"></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/VF2EPt0.png"></p>
<p>Hash的常见命令有：</p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
</li>
<li><p>HGET key field：获取一个hash类型key的field的值</p>
</li>
<li><p>HMSET：批量添加多个hash类型key的field的值</p>
</li>
<li><p>HMGET：批量获取多个hash类型key的field的值</p>
</li>
<li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p>
</li>
<li><p>HKEYS：获取一个hash类型的key中的所有的field</p>
</li>
<li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p>
</li>
<li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p>
</li>
</ul>
<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的类型与Java中的LinkedList类似，可以看做是一个双向链表，可以正向检索，也可以反向检索</p>
<p>特点也与LinkedList相似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入删除快</li>
<li>查询一般</li>
</ul>
<p>List的常见命令有：</p>
<ul>
<li>LPUSH key element … ：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element … ：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key star end：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<p><strong>思考：如何用List模拟一个栈？</strong></p>
<p>​		入口和出口在同一边，只用LPUSH和LPOP</p>
<p><strong>如何用List模拟一个队列？</strong></p>
<p>​		入口出口在不同边，LPUSH，RPOP  或者  RPUSH，LPOP</p>
<p><strong>如何用List模拟一个阻塞队列？</strong></p>
<p>​		入口出口在不同边，出队采用BLPOP，BRPOP</p>
<h2 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h2><p>与Java中的HashSet类似，可以看做一个value为null的HashMap，也是hash表，具备和HashSet类似的特性：</p>
<ul>
<li><p>无序</p>
</li>
<li><p>元素不可重复</p>
</li>
<li><p>查找快</p>
</li>
<li><p>支持交集，并集，差集的等功能</p>
</li>
</ul>
<p>Set的常见命令有：</p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
<li>SDIFF key1 key2…：求差集</li>
<li>SUNION key1 key2…：就并集</li>
</ul>
<p>例如两个集合：s1和s2:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/ha8x86R.png"></p>
<p>求交集：SINTER s1 s2</p>
<p>求s1与s2的不同：SDIFF s1 s2</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/L9vTv2X.png"></p>
<h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现<strong>排行榜</strong>这样的功能。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p>
</li>
<li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p>
</li>
</ul>
<h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408103756796.png" alt="image-20240408103756796"></p>
<p>标记为*的就是推荐使用的java客户端，包括：</p>
<ul>
<li><strong>Jedis和Lettuce</strong>：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而<strong>SpringDataRedis</strong>又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li>
<li><strong>Redisson</strong>：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li>
</ul>
<h2 id="Jedis客户端"><a href="#Jedis客户端" class="headerlink" title="Jedis客户端"></a>Jedis客户端</h2><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建jedis对象，建立连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.239.129&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">set</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;FangYuan&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + set);</span><br><span class="line">    <span class="comment">//获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用Redis的命令去操作jedis</p>
<p>释放资源</p>
<h2 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h2><p>jedis是线程不安全的，频繁创建和销毁连接会有性能的损耗，因此，使用jedis线程连接池的方式，代替上面的jedis直连方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.jedis.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//最大连接</span></span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//最大空闲连接</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//最小连接</span></span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//设置最长等待时间，ms</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;192.168.239.129&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//静态获取jedis工具类</span></span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<ul>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<p>SpringDataRedis中提供了<strong>RedisTemplate工具类</strong>，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/UFlNIV0.png"></p>
<p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置Redis</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure>

<p>再去@Autowired自动注入<strong>RedisTemplate</strong>即可</p>
<h2 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h2><p>RedisTemplate可以接收任意Object作为值写入Redis</p>
<p>但是写入的时候，<strong>RedisTemplate会把Object序列化，写入Redis</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408152103748.png" alt="image-20240408152103748"></p>
<p>只不过，默认采用的是JDk序列化，我们写入的汉字会转成这样</p>
<p>可读性差，并且内存占用大</p>
<p><strong>这就需要我们自定义RedisTemplate的序列化方式</strong></p>
<p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p>
<p>自定义Redisconfig类，添加@Configuration标记为配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            							<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里采用了<strong>JSON序列化来代替默认的JDK序列化方式</strong>。最终结果如图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408152706738.png" alt="image-20240408152706738"></p>
<p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。</p>
<p><strong>不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</strong></p>
<h2 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a><strong>StringRedisTemplate</strong></h2><p>为了节省内存空间，我们可以不使用JSON序列化来处理value，而使用统一的String序列化器，要求只能存储String类型的key和value，当我们要存储Java对象的时候，<strong>手动完成对象的序列化和反序列化</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408153418445.png" alt="image-20240408153418445"></p>
<p>如图所示，先用mapper或者fastJSON手动吧对对象序列化为JSON字符串，存入Redis</p>
<p>读取结果是JSON字符串，在手动反序列化，放入对象中</p>
<p><strong>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了</strong>。</p>
<p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">// JSON序列化工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实战篇Redis"><a href="#实战篇Redis" class="headerlink" title="实战篇Redis"></a>实战篇Redis</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408154408431.png" alt="image-20240408154408431"></p>
<ul>
<li>短信登陆：Redis共享session来实现</li>
<li>商户缓存查询：了解缓存击穿，缓存穿透，缓存雪崩问题</li>
<li><strong>优惠券秒杀</strong>：Redis的计数功能，结合Lua完成高性能的Redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</li>
<li>附近的商户：使用Redis的GEOHash来完成对地理坐标的操作</li>
<li>UV统计：主要使用Redis来实现计数功能</li>
<li>用户签到：使用Redis的BitMap数据统计功能</li>
<li>好友关注：基于Set集合的关注，关注取消，共同关注等功能</li>
<li>达人探店：基于List完成点赞列表的操作，同时基于SortedSet来完成点赞排行傍的功能</li>
</ul>
<h2 id="导入项目框架"><a href="#导入项目框架" class="headerlink" title="导入项目框架"></a>导入项目框架</h2><p><strong>问题1：mysql建表错误</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tb_seckill_voucher`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_seckill_voucher`  (</span><br><span class="line">  `voucher_id` <span class="type">bigint</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;关联的优惠券的id&#x27;</span>,</span><br><span class="line">  `stock` <span class="type">int</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `begin_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;生效时间&#x27;</span>,</span><br><span class="line">  `end_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;失效时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`voucher_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;秒杀优惠券表，与优惠券是一对一关系&#x27;</span> ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>错误分析：</p>
<p>错误分析：<br>DEFAULT ‘0000-00-00 00:00:00’（零时间戳），这不满足sql_mode中的NO_ZERO_DATE而报错。</p>
<p>注：sql_mode有两种，一种是空值，一种是严格模式，会给出很多默认设置。在MySQL5.7之后默认使用严格模式。</p>
<p>解决方式：1.修改不为0时间戳，</p>
<p>2.或者在mysql安装目录下，打开my.ini文件，修改配置文件，去除sql_mode下的NO_ZERO_DATE</p>
<p>(不建议2，我修改配置文件后，MySQL80直接重启失败了，吓我一身冷汗，以为又要重装MySQL了)</p>
<p><strong>问题2：导入别人初始框架的时候</strong></p>
<p><strong>JDK9~17+Springboot3 @Resource常见问题和解决方案</strong></p>
<p>因为JDK版本升级的改动，在Jdk9~17环境下，搭建Springboot项目，会出现原有@Resource（javax.annotation.Resource）不存在的问题，导致项目从<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Jdk8&spm=1001.2101.3001.7020">Jdk8</a>迁移到高版本时遇到的问题</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java EE 即 java Enterprise Edition，企业级应用，目标是制定一系列企业级应用的标准服务。常见的 javax.servlet, javax.annotation。</span><br><span class="line"></span><br><span class="line">Oracle 收购了创造 java 的 SUN 公司，Oracle 又不想发展 java EE 了，</span><br><span class="line">就把 java EE 交给 Eclipse 社区了，但是又因为不知名的原因，禁止社区使用 javax 这个名字。</span><br><span class="line">所以，javax.servlet 就变成了 jakarta.servlet, jakarta.annotation。api无法向前兼容。</span><br><span class="line"></span><br><span class="line"> java ee 的最后一个版本也是 8，以后就再也没有 java ee 的新版本</span><br></pre></td></tr></table></figure>

<p>解决：使用Jakarta包下的类</p>
<h1 id="1-短信登陆"><a href="#1-短信登陆" class="headerlink" title="1.短信登陆"></a>1.短信登陆</h1><h2 id="基于session的流程"><a href="#基于session的流程" class="headerlink" title="基于session的流程"></a>基于session的流程</h2><p><strong>短信验证码登录、注册：</strong></p>
<p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p>
<p><strong>校验登录状态:</strong></p>
<p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409073742479.png" alt="image-20240409073742479"></p>
<p>基于session的实现流程:</p>
<p><strong>我看不懂的地方全部写满了注释</strong>！！！</p>
<p><strong>发送验证码接口：&#x2F;user&#x2F;code</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//校验手机号,调用工具类中的正则表达式</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成验证码,使用radom生成</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存验证码到session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">//保存验证码到Redis</span></span><br><span class="line">    <span class="comment">//通过 opsForValue() 方法获取到一个用于操作字符串类型的 Redis 操作对象，</span></span><br><span class="line">    <span class="comment">// 然后使用 set() 方法将验证码 code 存储在 Redis 中，并设置了过期时间为 2 分钟</span></span><br><span class="line">    <span class="comment">//stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY +phone,code,5, TimeUnit.MINUTES);</span></span><br><span class="line">    <span class="comment">//发送验证码 假设发送成功了</span></span><br><span class="line">    <span class="comment">// TODO 调用阿里云的第三方接口依赖服务去实现</span></span><br><span class="line">    log.info(<span class="string">&quot;验证码发送成功，验证码：&#123;&#125;&quot;</span>,code);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>短信认证接口：&#x2F;user&#x2F;login</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//校验手机号，校验验证码,不一致的话，报错</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">        <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">code</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginFormCode</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">        <span class="keyword">if</span>(code == <span class="literal">null</span> || !code.toString().equals(loginFormCode))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*     一致的话，根据用户查询手机号,select * from tb_user where phone = #&#123;phone&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         这行代码使用了MyBatis-Plus框架提供的条件构造器 query() 方法</span></span><br><span class="line"><span class="comment">         它用于创建一个查询条件构造器对象。然后使用 eq(&quot;phone&quot;, phone) 方法，</span></span><br><span class="line"><span class="comment">         该方法表示等值查询，用于添加一个查询条件，</span></span><br><span class="line"><span class="comment">         要求查询的表中的 phone 字段的值等于变量 phone 的值。</span></span><br><span class="line"><span class="comment">         最后调用 one() 方法表示只查询符合条件的结果中的第一条数据，并返回一个 User 对象。*/</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户是否存在,不存在的话，创建新用户，并且把用户数据保存到session中</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            user = createWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存用户信息到session中,去除敏感信息，只返回VO前端需要的信息</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user,UserDTO.class);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>,userDTO);</span><br><span class="line">        <span class="comment">//登陆成功</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>校验登录状态：</p>
<ul>
<li><p>设置一个登录拦截器，loginInterceptor，实现HandlerInterceptor类中的preHandle(前置拦截)</p>
</li>
<li><p>并且再设置一个webConfig类去配置拦截器的拦截范围，配置类用@Configuration标注，告诉spring在启动时加载配置，在配置类中将拦截器的对象@Autowired，再去配置拦截的过滤属性即可</p>
</li>
</ul>
<p><strong>Interception</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拦截器在session中获取用户信息，再存储到线程池</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//获取session</span></span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">    <span class="comment">//获取session用户</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="comment">//判断用户是否存在，不存在的话，拦截或者抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        response.setStatus(<span class="number">401</span>);</span><br><span class="line">        <span class="comment">// TODO 设置全局异常处理器去拦截</span></span><br><span class="line">        <span class="comment">//throw new Exception()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在的话，保存用户信息到线程</span></span><br><span class="line">    UserHolder.saveUser((UserDTO) user);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>webconfig</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RefreshTokenInterceptor refreshTokenInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 登录拦截器,排除不需要的拦截逻辑，固定代码</span></span><br><span class="line">    registry.addInterceptor(loginInterceptor)</span><br><span class="line">            .excludePathPatterns(</span><br><span class="line">                    <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">            ).order(<span class="number">1</span>);<span class="comment">//数字越小，优先级越高</span></span><br><span class="line">    <span class="comment">// token刷新的拦截器,先拦截所有请求，保存当前</span></span><br><span class="line">    registry.addInterceptor(refreshTokenInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程ThreadLocal"><a href="#线程ThreadLocal" class="headerlink" title="线程ThreadLocal"></a>线程ThreadLocal</h2><h3 id="Tomcat运行原理"><a href="#Tomcat运行原理" class="headerlink" title="Tomcat运行原理"></a>Tomcat运行原理</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409152613464.png" alt="image-20240409152613464"></p>
<ul>
<li>Tomcat是一个开源的运行Java应用程序的Web服务器，springboot自带Tomcat服务器，我们启动Web服务就会自带</li>
<li>当用户发起请求的时候，会访问我们Tomcat注册的端口</li>
<li>当监听线程直到用户想与Tomcat建立链接的时候，会由监听线程创建socket链接</li>
<li>socket都是成对出现的，用户通过socket相互传送数据</li>
<li>当Tomcat中的socket接受到数据后，此时监听线程会从Tomcat的线程池取出一个线程来执行用户的请求</li>
<li>线程会找到我们用户想要访问的工程，用这个线程转到工程中测controller，service，mapper层，并访问数据库完成相应的操作</li>
<li>执行完毕后，再统一返回，找到Tomcat端的socket，将数据写会到用户端的socket，完成请求相应</li>
</ul>
<p>我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p>
<p><strong>温馨小贴士：关于threadlocal</strong></p>
<p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p>
<h2 id="session共享的问题"><a href="#session共享的问题" class="headerlink" title="session共享的问题"></a>session共享的问题</h2><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p>
<p>2、session拷贝数据时，可能会出现延迟</p>
<p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p>
<h2 id="Redis的实现思路"><a href="#Redis的实现思路" class="headerlink" title="Redis的实现思路"></a>Redis的实现思路</h2><p><strong>1.设计存储的key和value的结构</strong></p>
<p>key用字串，value用map&lt;k，v&gt;结构</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409154552378.png" alt="image-20240409154552378" style="zoom:50%;">

<p>在设计这个key的时候，我们之前讲过需要满足两点</p>
<p>1、key要具有唯一性</p>
<p>2、key要方便携带</p>
<p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p>
<p><strong>整体的访问流程</strong></p>
<p>发送短信验证码端不变，短信登录注册端和登录校验端，有变化，拦截器优化</p>
<ul>
<li>主要是涉及到从session中获取数据，到Redis中获取存入和获取数据</li>
<li>当注册完成后， 用户登录会去校验手机号和验证码，</li>
<li>如果一致，用MB查询用户信息，不存在则创建，</li>
<li>最后将用户信息保存到Redis中，并且生成随机token，作为Redis的key，设置key的有效期</li>
<li>当我们拦截器校验用户是否登录的时候，前端会携带token去访问</li>
<li>拦截器1拦截所有，从Redis中取出token对应的value，判断是否有这个数据</li>
<li>直接将其保存到ThreadLocal线程当中，刷新token有效期，再放行到拦截器2</li>
<li>拦截器2，拦截校验请求，判断ThreadLocal之中是否有用户，没有拦截，有则放行</li>
</ul>
<p><strong>我敲了一遍，主要的难点在于，使用stringRedisTemplate访问Redis的api不熟悉</strong></p>
<p><strong>将实体类转为hash用的工具类不熟悉</strong></p>
<p><strong>敲多了就熟悉了</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409164244140.png" alt="image-20240409164244140"></p>
<p><strong>短信验证码的登录</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">     <span class="comment">//1.校验手机号，校验验证码,不一致的话，报错</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">     <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//2.从Redis中获取验证码</span></span><br><span class="line">     <span class="comment">//opsForValue() 方法获取到一个用于操作字符串类型的 Redis 操作对象</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">     <span class="type">String</span> <span class="variable">loginFormCode</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">     <span class="keyword">if</span> (code == <span class="literal">null</span> || !code.equals(loginFormCode)) &#123;</span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3，一致,MP查询用户</span></span><br><span class="line">     <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//4.判断用户是否存在,不存在的话，创建新用户，并且把用户数据保存到数据库中</span></span><br><span class="line">     <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">         user = createWithPhone(phone);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//5.保存用户信息到Redis中</span></span><br><span class="line">     <span class="comment">//6.随机生成token，作为登陆令牌</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">     <span class="comment">//7.将user转为Hash存储。调用工具类</span></span><br><span class="line">     <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">     Map&lt;String, Object&gt; usermap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">             CopyOptions.create()</span><br><span class="line">                     .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                     .setFieldValueEditor((Name, Value) -&gt; Value.toString())</span><br><span class="line">     );</span><br><span class="line">     <span class="comment">//8.存储到Redis中，并且设置token有效期</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">     stringRedisTemplate.opsForHash().putAll(tokenKey,usermap);</span><br><span class="line">     stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br><span class="line">     <span class="comment">//9.返回token</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(token);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">createWithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//保存到数据库中</span></span><br><span class="line">        save(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409165657548.png" alt="image-20240409165657548"></p>
<p><strong>interceptor1</strong>：拦截所有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>interceptor2</strong>：拦截校验请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//拦截前执行，返回true，放行</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截器在Redis中获取用户信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-商品查询缓存"><a href="#2-商品查询缓存" class="headerlink" title="2.商品查询缓存"></a>2.商品查询缓存</h1><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>:Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); 本地用于高并发</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>:<span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存</span><br><span class="line"></span><br><span class="line">例<span class="number">3</span>:Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>(); 本地缓存</span><br></pre></td></tr></table></figure>

<p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效;</p>
<p>吗</p>
<h2 id="添加商品缓存"><a href="#添加商品缓存" class="headerlink" title="添加商品缓存"></a>添加商品缓存</h2><p>标准的操作方式，是我们再查询商户信息的时候，直接从数据库中去查询，比较慢，所以添加缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//这里是直接查询数据库</span></span><br><span class="line">    <span class="keyword">return</span> shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缓存的思路：</strong>在查数据库之前，如果缓存存在，则直接从缓存中返回，如果不存在，则查询数据库，然后再将缓存写入Redis</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409210411503.png" alt="image-20240409210411503"></p>
<p><strong>service层实现逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopMapper, Shop&gt; <span class="keyword">implements</span> <span class="title class_">IShopService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//不为空，直接返回给controller</span></span><br><span class="line">        <span class="keyword">if</span>(!StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不为空，则根据ID查询数据库</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查到后，写入Redis,将shop转为JSON格式</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习：给店铺类型查询业务添加缓存"><a href="#练习：给店铺类型查询业务添加缓存" class="headerlink" title="练习：给店铺类型查询业务添加缓存"></a>练习：给店铺类型查询业务添加缓存</h2><p>比较：只是由单个的String字符串在Redis中的查取，转为了list链表在Redis中的查取</p>
<p>解决：多记几个api函数（无奈！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;cache:shop:type:key&quot;</span>;</span><br><span class="line">        <span class="comment">//先从Redis中查.获取索引为0到-1(最后一个元素)的列表</span></span><br><span class="line">        List&lt;String&gt; shopTtpes = stringRedisTemplate.opsForList().range(key, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!shopTtpes.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将集合元素转为，ShopType类型的对象</span></span><br><span class="line">            ArrayList&lt;ShopType&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String s : shopTtpes)&#123;</span><br><span class="line">                <span class="type">ShopType</span> <span class="variable">type</span> <span class="operator">=</span> JSONUtil.toBean(s, ShopType.class);</span><br><span class="line">                list.add(type);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有则去数据库查</span></span><br><span class="line">        List&lt;ShopType&gt; list = query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺类型不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数据库中查到的，转为JSON，存入Redis</span></span><br><span class="line">        <span class="keyword">for</span>(ShopType s : list)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> JSONUtil.toJsonStr(s);</span><br><span class="line">            shopTtpes.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForList().leftPushAll(key,shopTtpes);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shopTtpes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis缓存更新策略"><a href="#Redis缓存更新策略" class="headerlink" title="Redis缓存更新策略"></a>Redis缓存更新策略</h2><p>内存数据宝贵，我们向Redis插入太多数据，可能会导致缓存中的数据过多，多以Redis对部分数据更新，删除</p>
<p><strong>内存淘汰</strong>：Redis自动进行，当内存达到设定的max-memory后,会自动触发淘汰机制,淘汰一些不重要的数据</p>
<p><strong>超时剔除</strong>: 当我们给Redis中的数据插入过期时间ttl后，Redis会把过期的数据删除，方便继续有空间使用缓存</p>
<p><strong>主动更新</strong>：我们可以设置手动调用的方式 ，通常用于解决，缓存和数据库数据不一致的问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410144258576.png" alt="image-20240410144258576"></p>
<p><strong>数据缓存不一致解决方案</strong></p>
<p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p>
<p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p>
<p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p>
<p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410151745879.png" alt="image-20240410151745879"></p>
<p><strong>方案一</strong>：手动调用更新缓存，需要自己去编写代码开发，但是一致性好</p>
<p><strong>方案二</strong>：调用服务，想维护比较复杂，找不到现成这样的服务</p>
<p><strong>方案三</strong>：简化调用者的开发，只关心缓存，由一个线程异步将缓存数据持久化到数据库中去，批量从缓存中插入数据库，保存最终一致，一致性差</p>
<p>使用方案一问题：</p>
<p><strong>1.更新缓存还是删除缓存？</strong></p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存的话，不读取缓存，无效的写入缓存过多了</li>
<li>删除缓存：更新数据库的时候，让缓存失效，查询的时候，再去更新缓存</li>
</ul>
<p><strong>2.如何保证缓存与数据库操作的同时成功或者失败</strong></p>
<ul>
<li>单体系统，@Transaction，事物</li>
<li>分布式系统，利用TTC等分布式事物解决方案</li>
</ul>
<p><strong>3.先操作缓存还是先操作数据库？</strong></p>
<p>应当先操作数据库，再删除缓存</p>
<p>如下图所示，原因是，写入缓存的数据快，而写入数据库的数据慢，这就导致先删后写的空间大，容易被其他线程操作，而带来数据的不一致，所以需要先操作数据库，再删除缓存</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410160140150.png" alt="image-20240410160140150"></p>
<h2 id="实现商铺缓存与数据库缓存双写一致"><a href="#实现商铺缓存与数据库缓存双写一致" class="headerlink" title="实现商铺缓存与数据库缓存双写一致"></a>实现商铺缓存与数据库缓存双写一致</h2><p>核心思路如下：</p>
<p>修改ShopController中的业务逻辑，满足下面的需求：</p>
<p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p>
<p>根据id修改店铺时，先修改数据库，再删除缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + shop.getId();</span><br><span class="line">    <span class="comment">//更新数据库</span></span><br><span class="line">    updateById(shop);</span><br><span class="line">    <span class="comment">//如果是分布式系统，这里需要用MQ去异步的通知对方</span></span><br><span class="line">    <span class="comment">//删除缓存</span></span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>缓存穿透</strong>：客户端请求的数据在数据库和缓存中都不存在，这样缓存永远都不会说生效，这写请求都会传到数据库中</p>
<p>​	如果恶意用户通过查询一个数据库中不存在的数据去直接访问数据库，导致缓存无效，直接打在数据库中，从而达到给数据库造成巨大压力的情况</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p>
<p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，<strong>通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在</strong>，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p>
<p>假设布隆过滤器判断这个数据不存在，则直接返回</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410163212126.png" alt="image-20240410163212126"></p>
<h2 id="编码解决缓存穿透问题"><a href="#编码解决缓存穿透问题" class="headerlink" title="编码解决缓存穿透问题"></a>编码解决缓存穿透问题</h2><p>核心思路如下：</p>
<p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p>
<p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410163505694.png" alt="image-20240410163505694"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="comment">//存在，直接返回给controller</span></span><br><span class="line">       <span class="comment">//isBlank()，方法，只有有值的时候，返回true，空，null，换行符/n/t，都返回false;</span></span><br><span class="line">       <span class="keyword">if</span>(!StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">           <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">           <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的是否为空值</span></span><br><span class="line">       <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不为空，则根据ID查询数据库</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">       <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">           stringRedisTemplate.opsForValue()</span><br><span class="line">                   .set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//查到后，写入Redis,将shop转为JSON格式</span></span><br><span class="line">       stringRedisTemplate.opsForValue()</span><br><span class="line">               .set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">       <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>小总结：</strong></p>
<p>缓存穿透产生的原因是什么？</p>
<ul>
<li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li>
</ul>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li><strong>缓存null值</strong></li>
<li><strong>布隆过滤</strong></li>
<li><strong>增强id的复杂度，避免被猜测id规律</strong></li>
<li><strong>做好数据的基础格式校验</strong></li>
<li><strong>加强用户权限校验</strong></li>
<li><strong>做好热点参数的限流</strong></li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>问题以及解决思路</strong></p>
<p><strong>缓存雪崩</strong>：同地段大量的缓存<strong>key同时失效</strong>或者<strong>Redis宕机</strong>，导致大量请求直接到达数据库，带来巨大压力</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410230812500.png" alt="image-20240410230812500"></p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿问题，也叫<strong>热点击穿</strong>问题，就是被一个<strong>高并发并且缓存重建业务复杂的key突然失效了</strong>，无数的访问请求会瞬间给数据库带来巨大冲击</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<p>假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410235244817.png" alt="image-20240410235244817"></p>
<p>解决方案一、使用锁来解决：</p>
<p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p>
<p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653328288627.png" alt="1653328288627"></p>
<p>解决方案二、逻辑过期方案</p>
<p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p>
<p>我们把过期时间设置在 redis的value中，注意：<strong>这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理</strong>。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653328663897.png" alt="1653328663897"></p>
<p>进行对比</p>
<p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p>
<p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>
<h2 id="用互斥锁解决缓存击穿问题"><a href="#用互斥锁解决缓存击穿问题" class="headerlink" title="用互斥锁解决缓存击穿问题"></a>用互斥锁解决缓存击穿问题</h2><p>核心思路：相较于原先从缓存中查不到数据后直接查询数据库而言，现在的方案是查询之后，如果缓存中没有查到数据，就进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有活的到，则说明有线程已经去访问了，则先休眠，过一会儿再去访问，知道获取到了锁为止，才能进行查询</p>
<p>如果有线程获取到了锁，再去进行查询，查询后将数据写入Redis，再释放锁，返回数据，利用互斥锁就保证只能有一个线程去执行数据库操作的逻辑，防止缓存击穿</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240411102547011.png" alt="image-20240411102547011"></p>
<p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//缓存穿透</span></span><br><span class="line">       <span class="comment">//Shop shop = queryWihPassThrough(id);</span></span><br><span class="line">       <span class="comment">//互斥锁</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithMutex(id);</span><br><span class="line">       <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="comment">//存在，直接返回给controller</span></span><br><span class="line">       <span class="comment">//isBlank()，方法，只有有值的时候，返回true，空，null，换行符/n/t，都返回false;</span></span><br><span class="line">       <span class="keyword">if</span>(!StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的是否为空值</span></span><br><span class="line">       <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不为空，先加互斥锁，注意互斥锁的key与缓存的key不一样</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               log.info(<span class="string">&quot;未获取到互斥锁，休眠，再重试&quot;</span>);</span><br><span class="line">               <span class="comment">//未获取到互斥锁，休眠，再重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//获取锁成功，再检测Redis，做doubleCheck</span></span><br><span class="line">           shopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">           <span class="keyword">if</span>(!StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">               <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//根据ID查询数据库</span></span><br><span class="line">           shop = getById(id);</span><br><span class="line">           <span class="comment">//模拟高并发下的场景</span></span><br><span class="line">           Thread.sleep(<span class="number">500</span>);</span><br><span class="line">           <span class="comment">//数据库没有则写入缓存空值</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">               stringRedisTemplate.opsForValue()</span><br><span class="line">                       .set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//数据库有的话，写入Redis,将shop转为JSON格式</span></span><br><span class="line">           stringRedisTemplate.opsForValue()</span><br><span class="line">                   .set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//释放互斥锁</span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取锁的方法,如果值存在，则不设置，不存在则设置</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//释放锁的方法</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">       stringRedisTemplate.delete(key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong>：删了缓存，加了500毫秒的延时，在每秒100次的请求冲击下，有大量的线程未获取到互斥锁，休眠再重试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240411151627555.png" alt="image-20240411151627555"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240411151422648.png" alt="image-20240411151422648"></p>
<p>当500毫秒过去后，就可以正常从缓存中读取程序了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240411151904963.png" alt="image-20240411151904963"></p>
<p>查询数据库的操作，夹在大量线程的中间，数据库仅仅被查询了一次，达到了用互斥解决缓存击穿的目的</p>
<h2 id="用逻辑过期解决缓存击穿问题"><a href="#用逻辑过期解决缓存击穿问题" class="headerlink" title="用逻辑过期解决缓存击穿问题"></a>用逻辑过期解决缓存击穿问题</h2><p>思路：当用户开始查询Redis的时候，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回Redis中的数据，如果过期了，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240411155621660.png" alt="image-20240411155621660"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建了10个线程池</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span></span><br><span class="line">           <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">   <span class="comment">//逻辑过期解决缓存击穿</span></span><br><span class="line">   <span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">//1.从Redis查缓存，判断是否命中</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="keyword">if</span>(StrUtil.isBlank(json))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.缓存中查到，需要把JSON反序列化成对象RedisData</span></span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">       <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject)redisData.getData();</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(data, Shop.class);</span><br><span class="line">       <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">       <span class="comment">//3.判断是否过期</span></span><br><span class="line">       <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">           <span class="comment">//未过期。返回店铺信息</span></span><br><span class="line">           <span class="keyword">return</span> shop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//已过期，需要缓存重建</span></span><br><span class="line">       <span class="comment">//获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">       <span class="comment">//判断锁是否成功</span></span><br><span class="line">       <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">           <span class="comment">//获取锁成功，则开启独立线程，用线程池</span></span><br><span class="line">           CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   saveShopToRedis(id,<span class="number">20L</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   unlock(lockKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       log.info(<span class="string">&quot;逻辑过期时间：&#123;&#125;&quot;</span>,redisData.getExpireTime());</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取锁的方法,如果值存在，则不设置，不存在则设置</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//释放锁的方法</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">       stringRedisTemplate.delete(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShopToRedis</span><span class="params">(Long id, Long expireSeconds)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">//1.查询店铺数据</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">       <span class="comment">//模拟延时</span></span><br><span class="line">       Thread.sleep(<span class="number">500</span>);</span><br><span class="line">       <span class="comment">//2.封装过期时间</span></span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">       redisData.setData(shop);</span><br><span class="line">       redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">       <span class="comment">//3.写入Redis</span></span><br><span class="line">       stringRedisTemplate.opsForValue().</span><br><span class="line">               set(RedisConstants.CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试：我们先在用test测试在缓存中预处理了一个RedisData对象，并且设置了逻辑过期时间为当前时间+10秒</strong></p>
<p><strong>再10秒后，我们去测试100个线程同时访问，看看已经过期的情况下，会有多少个数据库查询？</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412014628062.png" alt="image-20240412014628062"></p>
<p>可以看到，在查询后的一段时间内，我设置的是10秒，逻辑过期时间由845毫秒改为069毫秒，实现了缓存重建</p>
<h2 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h2><p><strong>泛型。函数式编程，lambda表达式，这块上强度了，先copy，有时间再看</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h1><h2 id="全局唯一ID："><a href="#全局唯一ID：" class="headerlink" title="全局唯一ID："></a>全局唯一ID：</h2><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li><strong>id的规律性太明显</strong></li>
<li><strong>受单表数据量的限制</strong></li>
</ul>
<p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p>
<p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p>
<p><strong>全局ID生成器</strong>：是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p>
<ul>
<li>唯一性</li>
<li>递增性</li>
<li>安全性</li>
<li>高可用</li>
<li>高性能</li>
</ul>
<p>为了增加ID的安全性，我们不可以直接使用Redis自增的数值，拼接其他一些信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412035633407.png" alt="image-20240412035633407"></p>
<p>ID的组成部分：符号位：1bit，永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>
<h2 id="Redis实现全局唯一ID"><a href="#Redis实现全局唯一ID" class="headerlink" title="Redis实现全局唯一ID"></a>Redis实现全局唯一ID</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程测试"><a href="#多线程测试" class="headerlink" title="多线程测试"></a><strong>多线程测试</strong></h2><p><strong>：给300个线程，每个线程生成100个ID，一共三万个ID，在多线程的情况下，如何等全部线程执行完了再去查询方法的执行时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程下测试时间的解释：</p>
<blockquote>
<p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p>
<p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p>
<p>CountDownLatch 中有两个最重要的方法</p>
<p>1、countDown</p>
<p>2、await</p>
<p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p>
</blockquote>
<p><strong>添加优惠券</strong></p>
<p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>
<p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p>
<p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p>
<p>**新增普通卷代码：  **VoucherController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新增秒杀卷代码：</strong></p>
<p><strong>VoucherController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VoucherServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在postman或者apiair接口传入以下body</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;shopId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;100元代金券&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subTitle&quot;</span><span class="punctuation">:</span><span class="string">&quot;周一至周五可用&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span><span class="string">&quot;全场通用\\n无需预约\\n可无限叠加&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;payValue&quot;</span><span class="punctuation">:</span><span class="number">8000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;actualValue&quot;</span><span class="punctuation">:</span><span class="number">10000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;beginTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2022-01-01T00:00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;endTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2022-10-31T23:59:59&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="实现下单秒杀"><a href="#实现下单秒杀" class="headerlink" title="实现下单秒杀"></a>实现下单秒杀</h2><p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p>下单核心逻辑分析：</p>
<p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p>
<p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回<strong>订单id</strong>，如果有一个条件不满足则直接结束。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412061530933.png" alt="image-20240412061530933"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckikkVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.判断秒杀是否结束</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.扣减库存,使用mybatisplus的链式查找工具</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService</span><br><span class="line">                .update().setSql(<span class="string">&quot;stock = stock -1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//订单ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">//代金券ID</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="comment">//7.返回订单ID</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h2><p>模拟100个线程同时抢券1分钟</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412144726095.png" alt="image-20240412144726095" style="zoom:50%;">

<p>数据库中卖出了109条记录</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412144826175.png" alt="image-20240412144826175"></p>
<p>秒杀券库存为-9</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412144914188.png" alt="image-20240412144914188"></p>
<p><strong>分析原因：</strong></p>
<p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p>
<p>典型的多线程安全问题：</p>
<p> 针对这一问题，我们就是要加锁，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412145805456.png" alt="image-20240412145805456"></p>
<p><strong>悲观锁</strong>：对数据串行化执行，synchroniedz，lock都是悲观锁，直接在我们的方法上加注解@Synchronized就行</p>
<p><strong>乐观锁：</strong>会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412150751030.png" alt="image-20240412150751030"></p>
<p>可以用stock来代替version，只需要在后面的查询条件里加上，and stock &#x3D; stock就行</p>
<p>修改之后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.扣减库存,使用mybatisplus的链式查找工具</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService</span><br><span class="line">        .update().setSql(<span class="string">&quot;stock = stock -1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update();</span><br><span class="line"><span class="keyword">if</span>(!success)&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mybatisPlus中的语句，等效于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update seckill_tab set stock = stock - 1 where voucher_id = #&#123;vocherID&#125; and stock = #&#123;stock&#125;</span><br></pre></td></tr></table></figure>

<p><strong>来来来，上1秒200个线程的压力测试</strong>，<strong>我32G内存要吃满了</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412153402542.png" alt="image-20240412153402542" style="zoom:50%;">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412153536712.png" alt="image-20240412153536712" style="zoom: 50%;">

<p>嗯？怎么结果只有23条？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412153715841.png" alt="image-20240412153715841"></p>
<p>一看库存，200人1秒抢，是不会库存超卖了，但是没卖完呐，这也太安全了吧</p>
<p>问题：不一定要相等，只要有票，就接着卖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.扣减库存,使用mybatisplus的链式查找工具</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService</span><br><span class="line">        .update().setSql(<span class="string">&quot;stock = stock -1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>).update();</span><br><span class="line"><span class="keyword">if</span>(!success)&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412155014160.png" alt="image-20240412155014160"></p>
<p>可以了，卖的很干净</p>
<p><strong>知识小扩展：</strong></p>
<p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p>
<p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p>
<p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p>
<p>所以利用这么一个类，LongAdder来进行优化</p>
<p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412155113542.png" alt="image-20240412155113542"></p>
<h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><p>要求：修改秒杀业务，要求同一个优惠券，一个用户，只能下一单</p>
<p>具体的操作逻辑：在扣减库存前，判断订单人的ID和优惠券ID相等的个数，如果个数&gt;1，则失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一人一单</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="comment">//select count(*) from xxx where user_id = #&#123;userId&#125; and voucher_id = #&#123;voucherId&#125;;</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line"><span class="keyword">if</span>(count &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412161837535.png" alt="image-20240412161837535" style="zoom: 80%;">

<p><strong>测试：200个线程，同一用户压力测试走起</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412162226034.png" alt="image-20240412162226034"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412162241869.png" alt="image-20240412162241869"></p>
<p><strong>结果失败：还是有三个线程同一ID的用户，抢购了三张用户券</strong></p>
<p>分析：还是线程安全问题，对于我们的代码，多个线程执行的时候，查出的数据都是为0 ，可以插入，插入需要时间，在这个时间内进入的线程，还是会执行插入</p>
<p> <strong>解决问题：加锁！！！</strong></p>
<p>初步代码：把一人一单的逻辑代码都提交到一个方法中去，然后给这个方法加锁</p>
<p>不管哪一个线程（例如线程A），运行到这个方法时，都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A，没有的话，锁定调用者，然后直接运行。</p>
<p><strong>但是！</strong>（我这里看不懂了）就用老师的吧</p>
<p><code>事物+多线程+锁，处理的方法</code></p>
<ul>
<li><p>但是这样加锁，锁的细粒度太粗了，在使用锁的过程中，控制锁粒度是一个非常重要的事情，因为<code>如果锁的粒度太大，会导致每个线程进来都会被锁住</code>，现在的情况就是所有用户都公用这一把锁，串行执行，效率很低，我们现在要完成的业务是<code>一人一单</code>，所以这个锁，应该只加在单个用户上，用户标识可以用<code>userId</code></p>
</li>
<li><p>由于toString的源码是new String，所以如果我们只用<code>userId.toString()</code>拿到的也不是同一个用户，需要使用<code>intern()</code>，如果字符串常量池中已经包含了一个等于这个string对象的字符串（由equals（object）方法确定），那么将返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。</p>
</li>
<li><p>（<code>其实以上就可以用了，但是存在事物问题</code>）</p>
</li>
<li><p>但是以上代码还是存在问题，问题的原因在于当前方法被Spring的事务控制，如果你在内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放了，这样也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题</p>
</li>
<li><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务，这里可以使用<code>AopContext.currentProxy()</code>来获取当前对象的代理对象，然后再用代理对象调用方法，记得要去<code>IVoucherOrderService</code>中创建<code>createVoucherOrder</code>方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>同时在启动类上加上<code>@EnableAspectJAutoProxy(exposeProxy = true)</code>注解</p>
</li>
<li><p>引入aspectjweaver依赖</p>
</li>
<li><p>重启服务器，再次使用Jmeter测试，200个线程并发，但是只能抢到一张优惠券，目的达成</p>
</li>
</ul>
<h2 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h2><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在<code>集群模式</code>下就不行了</p>
<p><strong>1.复制服务，将服务启动两份，搭建集群</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412212621591.png" alt="image-20240412212621591"></p>
<p>2.然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>
<blockquote>
<p>修改配置文件的时候，一定把所有的nginx关闭，因为我手贱多点了几下，启动了太多nginx服务器了，所以一直配置不成功，因为一直有以前的nginx启动</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412213115309.png" alt="image-20240412213115309" style="zoom:67%;">

<p><strong>有关锁失效原因分析</strong></p>
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412213230593.png" alt="image-20240412213230593" style="zoom:67%;">

<p>集群模式下，有多个jvm的存在，每个jvm内都有自己的锁，导致每一个锁都可以有一个线程获取，于是就出现了并行运行</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p><code>分布式锁</code>：满足分布式系统或者集群系统模式下多进程可见并且互斥的锁</p>
<p><code>核心思想</code>：让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412214026155.png" alt="image-20240412214026155" style="zoom:50%;">

<ul>
<li><p>那么分布式锁他应该满足一些什么样的条件呢？</p>
</li>
<li><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p>
</li>
<li><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p>
</li>
<li><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p>
</li>
<li><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p>
</li>
<li><p>安全性：安全也是程序中必不可少的一环</p>
</li>
</ul>
<p>常见的分布式锁有三种</p>
<ul>
<li><code>Mysql</code>：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</li>
<li><code>Redis</code>：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</li>
<li>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/07/Java/Redis/BaiduNetdiskDownload/Redis入门到实战教程/02-实战篇/讲义/Redis实战篇.assets/1653382219377.png" alt="1653382219377"></p>
<h2 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h2><p> 我们虽然有多台服务器集群，但是我们都是在同一个Redis中获取锁，所以可以加锁</p>
<p>自定义锁的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutSec 持有锁的超时时间。过期自动释放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true代表成功，false代表失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在工具类中实现接口，定义锁的一般方法</p>
<p>底层是Redis中的set NX互斥和set EX设置超时时间方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁被误删的情况"><a href="#分布式锁被误删的情况" class="headerlink" title="分布式锁被误删的情况"></a>分布式锁被误删的情况</h2><p>逻辑说明：</p>
<p>持有锁的线程在锁的<code>内部出现了阻塞，导致他的锁自动释放</code>，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p>
<p>解决方案：<strong>解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除</strong>，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653385920025.png" alt=" "></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取线程标示</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span>ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">       <span class="comment">// 获取锁</span></span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">               .setIfAbsent(KEY_PREFIX + name, threadId , timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//获取线程标识</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span>ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">       <span class="comment">//获取锁中标识</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">       <span class="comment">//判断是否一致</span></span><br><span class="line">       <span class="keyword">if</span>(threadId.equals(id))&#123;</span><br><span class="line">           <span class="comment">//通过del删除锁</span></span><br><span class="line">           stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁的原子性的问题"><a href="#分布式锁的原子性的问题" class="headerlink" title="分布式锁的原子性的问题"></a>分布式锁的原子性的问题</h2><p><strong>更为极端的误删逻辑说明</strong>：</p>
<p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653387764938.png" alt="1653387764938" style="zoom:67%;">

<p>也就是代码中的，判断和删除，两行代码，执行就是会有时间，哪怕几微妙，几纳秒</p>
<p>就在这时，线程阻塞了，JVM中full gc了，又误删了</p>
<h2 id="Lua脚本解决多条命令的原子性问题"><a href="#Lua脚本解决多条命令的原子性问题" class="headerlink" title="Lua脚本解决多条命令的原子性问题"></a>Lua脚本解决多条命令的原子性问题</h2><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了。</a></p>
<blockquote>
<p><strong>Lua脚本在Redis中是原子性执行的，即使是由多个命令组成的脚本，Redis会将其作为一个整体进行执行，不会被其他客户端的操作打断，从而确保了操作的原子性。</strong></p>
</blockquote>
<p>这里重点介绍Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>

<p>例如，我们要执行set name jack，则脚本是这样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>

<p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：<code>EVAL</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240413024602579.png" alt="image-20240413024602579"></p>
<p>释放锁的业务流程是这样的</p>
<p>​	1、获取锁中的线程标示</p>
<p>​	2、判断是否与指定的标示（当前线程标示）一致</p>
<p>​	3、如果一致则释放锁（删除）</p>
<p>​	4、如果不一致则什么都不做</p>
<p>如果用Lua脚本来表示则是这样的：</p>
<p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h2 id="利用Java调用lua脚本"><a href="#利用Java调用lua脚本" class="headerlink" title="利用Java调用lua脚本"></a>利用Java调用lua脚本</h2><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240413040136593.png" alt="image-20240413040136593" style="zoom: 80%;">

<p>初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化释放锁的脚本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;  <span class="comment">//静态代码块，在类加载的时候执行，用于初始化</span></span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));<span class="comment">//加载resource下的资源</span></span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);<span class="comment">//配置返回值</span></span><br></pre></td></tr></table></figure>

<p>调用execute方法去删除锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lua脚本 实现锁的删除</span></span><br><span class="line"><span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span>ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">stringRedisTemplate.execute(UNLOCK_SCRIPT,  <span class="comment">//lua脚本</span></span><br><span class="line">        Collections.singletonList(KEY_PREFIX + name),<span class="comment">//key转为集合</span></span><br><span class="line">        threadId <span class="comment">//线程标识</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>基于Redis实现分布式锁的实现思路</p>
<ol>
<li><strong>选择合适的锁键（Lock Key）</strong>：<ul>
<li>锁键是用于标识和获取锁的唯一标识符。它应该是具有唯一性的，以防止不同的应用程序或线程之间发生冲突。通常，锁键可以是一个字符串，可以包含命名空间、资源名称、唯一标识符等信息。</li>
</ul>
</li>
<li><strong>获取锁</strong>：<ul>
<li>通过在 Redis 中设置一个键值对来获取锁。键表示锁键，值表示锁的持有者标识符或者一个随机生成的唯一标识符。</li>
<li>可以使用 Redis 的 SETNX 命令（SET if Not eXists）来尝试设置锁，如果键不存在则设置成功，表示获取锁成功。</li>
</ul>
</li>
<li><strong>设置锁的超时时间</strong>（可选）：<ul>
<li>可以为锁设置一个超时时间，防止锁被永久持有。可以使用 Redis 的 SETEX 或者 EXPIRE 命令来设置键的过期时间。</li>
</ul>
</li>
<li><strong>释放锁</strong>：<ul>
<li>当持有锁的线程完成了工作，或者锁超时时，需要将锁释放。可以使用 DEL 命令来删除键，释放锁。</li>
</ul>
</li>
</ol>
<p>在实现分布式锁时，还需要考虑以下几点：</p>
<ul>
<li><strong>锁的互斥性</strong>：确保同一时刻只有一个线程或者进程能够持有锁。</li>
<li><strong>锁的可重入性</strong>：允许同一线程或者进程多次获取同一个锁。</li>
<li><strong>锁的可靠性</strong>：确保在各种异常情况下，锁都能够正确地释放，避免死锁或者锁失效。</li>
<li><strong>锁的性能</strong>：尽量减小锁操作对性能的影响，避免锁竞争和频繁的锁释放操作。</li>
</ul>
<h1 id="分布式锁redission"><a href="#分布式锁redission" class="headerlink" title="分布式锁redission"></a>分布式锁redission</h1><p>基于setnx实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240413045006147.png" alt="image-20240413045006147"></p>
<p>那么什么是Redission呢</p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p>Redission提供了分布式锁的多种多样的功能</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653546736063.png" alt="1653546736063"></p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.28.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义配置类，配置Redis地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.239.129:6379&quot;</span>)</span><br><span class="line">                .setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后直接注入对象，调用他的getClock和unlock方法即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁-redisson可重入锁的原理"><a href="#分布式锁-redisson可重入锁的原理" class="headerlink" title="分布式锁-redisson可重入锁的原理"></a>分布式锁-redisson可重入锁的原理</h2><p> 可重入锁：以前的锁是不可冲重入的，所以当一个线程，里去调用多把锁的时候，就会出现第一把锁获取成功，其他锁获取失败的情况</p>
<p>为了解决锁的可重入性质。将以前的key值为lock，value属性只有线程自己的ID，改为用hashmap存储，存储当先线程的ID和线程获取锁的次数</p>
<p>调用锁的时候，判断是不是自己，统计数+1，释放的时候，判断是不是自己，统计数-1，知道统计数为0，再释放锁</p>
<p>具体的流程如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240413182704225.png" alt="image-20240413182704225"></p>
<p>为了保证原子性，就是执行获取锁和删除锁的过程是一起的，不会被其他线程阻挡</p>
<p>使用lua脚本实现</p>
<p><strong>获取锁的逻辑</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"><span class="comment">-- 锁不存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 获取锁并添加线程标识，state设为1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="comment">-- 设置锁有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁存在，判断threadId是否为自己</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 锁存在，重入次数 +1，这里用的是hash结构的incrby增长</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, thread, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">-- 设置锁的有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里，说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure>

<p><strong>释放锁的逻辑</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="comment">-- 如果锁不是自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁是自己的，锁计数-1，还是用hincrby，不过自增长的值为-1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">-- 判断重入次数为多少</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 大于0，重置有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 否则直接释放锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁redisson重试和看门狗机制"><a href="#分布式锁redisson重试和看门狗机制" class="headerlink" title="分布式锁redisson重试和看门狗机制"></a>分布式锁redisson重试和看门狗机制</h2><ol>
<li><strong>重试机制</strong>：<ul>
<li>在使用 Redisson 实现分布式锁时，为了应对网络异常、Redis 服务器故障等情况，通常会配置重试机制。重试机制可以在获取锁失败后自动进行多次重试，直到获取锁成功或达到最大重试次数为止。</li>
<li>Redisson 的重试机制是通过循环调用 Redis 的 SETNX（SET if Not eXists）命令来实现的。当某个节点在获取锁时失败后，会在指定的时间间隔内进行重试，直到获取锁成功或者超过最大重试次数。</li>
</ul>
</li>
<li><strong>看门狗机制</strong>：<ul>
<li>看门狗机制是用于防止锁持有者在执行业务逻辑时出现异常<code>导致锁没有被释放而造成死锁</code>的情况。看门狗机制会在获取锁成功后启动一个定时任务，定时更新锁的过期时间。如果锁持有者因为异常或其他原因未能及时释放锁，锁的过期时间会被更新，确保锁在一定时间内仍然有效，避免死锁情况的发生。</li>
<li>在 Redisson 中，看门狗机制是通过 Redis 的 PEXPIRE（设置过期时间，带毫秒单位）命令实现的。当获取锁成功后，会启动一个定时任务定时更新锁的过期时间，保持锁的有效性。</li>
</ul>
</li>
</ol>
<p>综上所述，重试机制和看门狗机制是 Redisson 保证分布式锁可靠性和稳定性的重要机制。重试机制用于处理获取锁失败的情况，而看门狗机制用于防止锁的持有者出现异常导致锁未被释放而造成死锁的情况。这两种机制结合起来，可以有效地确保分布式锁的正确使用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240413224056964.png" alt="image-20240413224056964"></p>
<p><strong>Redisson分布式锁的原理</strong></p>
<p><strong>可重入：利用hash结构记录线程ID和重入次数</strong></p>
<p><strong>可重试：利用信号量和PubSUb实现等待，唤醒，获取锁失败的重试机制</strong></p>
<p><strong>超时续约：利用看门狗，每隔一段时间（释放时间的1&#x2F;3），重置超时时间</strong></p>
<h2 id="Redisson主从一致性问题–multiLock"><a href="#Redisson主从一致性问题–multiLock" class="headerlink" title="Redisson主从一致性问题–multiLock"></a>Redisson主从一致性问题–multiLock</h2><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p>
<p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653554055048.png" alt="1653554055048"></p>
<p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p>
<p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240414004700400.png" alt="image-20240414004700400"></p>
<h2 id="本章小结："><a href="#本章小结：" class="headerlink" title="本章小结："></a>本章小结：</h2><ol>
<li>不可重入Redis分布式锁<ul>
<li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li>
<li>缺陷：不可重入、无法重试、锁超时失效</li>
</ul>
</li>
<li>可重入Redis分布式锁<ul>
<li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li>
<li>缺陷：Redis宕机引起锁失效问题</li>
</ul>
</li>
<li>Redisson的multiLock<ul>
<li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li>
</ul>
</li>
</ol>
<h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><p><strong>测试：在测试类中，将数据库中的所有用户，分发令牌的token写入Redis中，并且把token写入文件里</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> IUserService userService;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tokenWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">       <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;tokens.txt&quot;</span>));</span><br><span class="line">       List&lt;User&gt; list = userService.list();</span><br><span class="line">       <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">           <span class="comment">//6.随机生成token，作为登陆令牌</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">           <span class="comment">//7.将user转为Hash存储。调用工具类</span></span><br><span class="line">           <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">           Map&lt;String, Object&gt; usermap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                   CopyOptions.create()</span><br><span class="line">                           .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                           .setFieldValueEditor((Name, Value) -&gt; Value.toString())</span><br><span class="line">           );</span><br><span class="line">           <span class="comment">//8.存储到Redis中，并且设置token有效期</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">           stringRedisTemplate.opsForHash().putAll(tokenKey, usermap);</span><br><span class="line">           <span class="comment">//stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">           writer.write(token);</span><br><span class="line">           writer.newLine();</span><br><span class="line">       &#125;</span><br><span class="line">       writer.close();</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;测试方法用时&quot;</span> + (end-start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在jmeter中并发测试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415014955568.png" alt="image-20240415014955568"></p>
<p>断言就是我们判断返回值Jason中的success，如果等于true，判断成功，其他判断失败</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415015105647.png" alt="image-20240415015105647"></p>
<p>并发1000次，我发现，我们的自己定义的锁，平均相应3222ms，太慢了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415015229828.png" alt="image-20240415015229828"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415015823187.png" alt="image-20240415015823187"></p>
<p><strong>先尝试用redisson的锁</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415022237053.png" alt="image-20240415022237053"></p>
<p>平均值由3222ms提升到了2107ms</p>
<p>但还是太慢，还得优化</p>
<h2 id="异步秒杀思路"><a href="#异步秒杀思路" class="headerlink" title="异步秒杀思路"></a>异步秒杀思路</h2><p>我们来回顾一下下单流程</p>
<p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p>
<p>1、查询优惠卷</p>
<p>2、判断秒杀库存是否足够</p>
<p>3、查询订单</p>
<p>4、校验是否是一人一单</p>
<p>5、扣减库存</p>
<p>6、创建订单</p>
<p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415090059038.png" alt="image-20240415090059038"></p>
<p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p>
<p><code>第一个难点</code><strong>是我们怎么在redis中去快速校验一人一单，还有库存判断</strong></p>
<p><strong><code>第二个难点</code>是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415091025381.png" alt="image-20240415091025381"></p>
<p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p>
<p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415091234973.png" alt="image-20240415091234973"></p>
<p>需求：</p>
<ul>
<li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p>
</li>
<li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p>
</li>
<li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p>
</li>
<li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p>
</li>
</ul>
<p>VoucherServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整lua表达式</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p>
<h2 id="基于阻塞队列实现秒杀优化"><a href="#基于阻塞队列实现秒杀优化" class="headerlink" title="基于阻塞队列实现秒杀优化"></a>基于阻塞队列实现秒杀优化</h2><p>没能实现数据库的事物，一加事物就报错，不知道为什么</p>
<p>一行行敲的代码，不懂的全写在注释里面了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化释放锁的脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;  <span class="comment">//静态代码块，在类加载的时候执行，用于初始化</span></span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));<span class="comment">//加载resource下的资源</span></span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);<span class="comment">//配置返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span>  <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//异步处理线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于线程池处理的任务</span></span><br><span class="line">    <span class="comment">// 当初始化完毕后，就会去从阻塞对列中去拿信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 2.创建锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">        <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">            log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">            createVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            redisLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private IVoucherOrderService proxy;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckikkVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1.执行lua脚本</span></span><br><span class="line">        <span class="comment">//使用lua脚本 实现redis中判断用户是否下单</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,  <span class="comment">//lua脚本</span></span><br><span class="line">                Collections.emptyList(),<span class="comment">//keys的集合，没有传空</span></span><br><span class="line">                voucherId.toString(), userId.toString()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//不为0，代表没有资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(result == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> :<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 为0，代表有购买资格，把下单信息保存到阻塞队列中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回订单ID的ID，全局ID生成器，生成的是订单号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//订单ID</span></span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//用户ID</span></span><br><span class="line">        <span class="comment">//Long userId = UserHolder.getUser().getId();</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">//代金券ID</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">//放进阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="comment">//proxy = (IVoucherOrderService) AopContext.currentProxy();</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span>&#123;</span><br><span class="line">        <span class="comment">//一人一单</span></span><br><span class="line">        <span class="comment">//Long userId = UserHolder.getUser().getId();</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">//select count(*) from xxx where user_id = #&#123;userId&#125; and voucher_id = #&#123;voucherId&#125;;</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// Result.fail(&quot;用户已经购买过一次了&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.扣减库存,使用mybatisplus的链式查找工具</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService</span><br><span class="line">                .update().setSql(<span class="string">&quot;stock = stock -1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId())</span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// Result.fail(&quot;库存不足！&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质就是：创建优惠券的时候，将优惠券的信息存入redis中，<code>我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功</code>，将要操作数据库的操作提取出来，放入<code>阻塞队列</code>，后慢慢执行，将其他操作，在redis中执行，秒杀库存的判断，使用lua脚本，lua脚本执行是单线程的，确保操作是原子性的，不会有并发问题。从而达到优化的目的。</p>
<p><strong>来，上压力测试</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415164508157.png" alt="image-20240415164508157"></p>
<p>1000个用户并发抢200个，优化到了平均13ms每秒</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417004723644.png" alt="image-20240417004723644"></p>
<p>第二次压力测试。74ms</p>
<p>秒杀业务的优化思路是什么？</p>
<ul>
<li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li>
<li>再将下单业务放入阻塞队列，利用独立线程异步下单</li>
<li>基于阻塞队列的异步秒杀存在哪些问题？<ul>
<li>阻塞队列基于虚拟机JVM，内存限制问题</li>
<li>数据安全问题</li>
</ul>
</li>
</ul>
<p>快把消息队列端上来吧</p>
<h1 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h1><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为<code>消息代理</code>（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415170000036.png" alt="image-20240415170000036"></p>
<p>消息队列就类比于<code>快递柜</code>，生产者把快递放在快递柜子，快递柜子作为消息队列，通知我们去拿快递，相当于异步处理，解除了耦合，大大提高了效率</p>
<p>这里我们可以使用一些现成的mq，<strong>比如kafka，rabbitmq等等</strong>，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p>
<p>Redis提供了三种不同的方式来实现消息队列：</p>
<p>list结构：</p>
<p>PubSub:</p>
<p>Stream:比较完善的消息队列模型 </p>
<h2 id="List实现消息队列"><a href="#List实现消息队列" class="headerlink" title="List实现消息队列"></a>List实现消息队列</h2><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用<code>BRPOP或者BLPOP来实现阻塞效果。</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653575176451.png" alt="1653575176451"></p>
<p>基于List的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
<h2 id="基于PubSub消息队列"><a href="#基于PubSub消息队列" class="headerlink" title="基于PubSub消息队列"></a>基于PubSub消息队列</h2><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653575506373.png" alt="1653575506373"></p>
<p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h2 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h2><p>（没听懂，就跟着敲了）</p>
<p>需求：</p>
<ul>
<li>创建一个Stream类型的消息队列，名为stream.orders</li>
<li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li>
<li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li>
</ul>
<p>步骤一：在Linux中Redis创建一个Stream类型的消息队列，名为stream.orders</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE stream.orders g1 0 MKSTREAM</span><br></pre></td></tr></table></figure>

<p>步骤二：修改Lua脚本，新增orderId参数，并将订单信息加入到消息队列中</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>步骤三：修改秒杀逻辑（这stream真心看不懂啊）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Redis消息队列--基于Stream的消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                            StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 解析数据</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                    Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 3.创建订单</span></span><br><span class="line">                    createVoucherOrder(voucherOrder);</span><br><span class="line">                    <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                    <span class="comment">//处理异常消息</span></span><br><span class="line">                    handlePendingList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                        Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                        StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception s)&#123;</span><br><span class="line">                    s.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415225523723.png" alt="image-20240415225523723"></p>
<p>压力一测试，从阻塞队列的13ms，到stream消息队列的203毫秒，真服了 ，反向优化是吧，而且我代码还看不懂，去学其他的消息队列吧MQ吧</p>
<h2 id="RabbitMQ消息队列实现"><a href="#RabbitMQ消息队列实现" class="headerlink" title="RabbitMQ消息队列实现"></a>RabbitMQ消息队列实现</h2><p><code>花了一天去学习了RabbitMQ，只是浅浅了解了安装和基础的使用方法</code></p>
<p><code>接下来，用RabbitMQ实现消息队列</code></p>
<p><code>我只谈代码修改的部分吧</code></p>
<p><code>详细的RabbitMQ我还记了一篇RabbitMQ笔记</code></p>
<p>把以前放入阻塞队列的消息，放入消息队列RabbitMQ中</p>
<p>引入依赖，注入RabbitTemplate对象</p>
<p>其中，convertAndSend的传入的参数为，交换机，关键字，和对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="comment">/*.......*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//放入消息队列RabbitMQ</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;voucherOrder.topic&quot;</span>,<span class="string">&quot;secKill.success&quot;</span>,voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AmqpException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，用户ID：&#123;&#125;&quot;</span>,voucherOrder.getUserId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放进阻塞队列</span></span><br><span class="line">        <span class="comment">//orderTasks.add(voucherOrder);</span></span><br></pre></td></tr></table></figure>



<p>新建一个Listener包，定义MQListener类，用于监听消息</p>
<p>注入之前的service层对象，直接调用其方法即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> VoucherOrderServiceImpl voucherOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;hello.queue1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listensSimpleQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者收到了hello.queue1的消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;voucherOrder.queue&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;voucherOrder.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = &quot;secKill.success&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">voucherOrderListener</span><span class="params">(VoucherOrder voucherOrder)</span>&#123;</span><br><span class="line">        <span class="comment">//TODO 消费者拿到消息队列的消息，的处理方法</span></span><br><span class="line">        <span class="comment">//voucherOrderService.handleVoucherOrder(voucherOrder);</span></span><br><span class="line">        voucherOrderService.createVoucherOrder(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;voucherOrder.queue&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;voucherOrder.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">        key = &quot;secKill.success&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br></pre></td></tr></table></figure>

<p>使用注解嵌套注解的方式，来实现</p>
<p>具体解释如下：</p>
<ol>
<li><code>@RabbitListener</code>: 这是一个监听器注解，用于声明一个方法作为 RabbitMQ 的消息消费者。当 RabbitMQ 中有消息到达时，被注解的方法将被调用。</li>
<li><code>bindings</code>: 这是 <code>@RabbitListener</code> 注解的一个属性，用于指定<strong>队列和交换机之间的绑定关系</strong>。在这里，通过 <code>@QueueBinding</code> 注解指定了队列与交换机之间的绑定关系。</li>
<li><code>@Queue</code>: 在 <code>@QueueBinding</code> 注解中，<code>@Queue</code> 用于声明一个队列，并设置队列的属性。在这里，使用了 <code>name</code> 属性指定了队列的名称为 “voucherOrder.queue”。</li>
<li><code>@Exchange</code>: 在 <code>@QueueBinding</code> 注解中，<code>@Exchange</code> 用于声明一个交换机，并设置交换机的属性。在这里，使用了 <code>name</code> 属性指定了交换机的名称为 “voucherOrder.topic”，<code>type</code> 属性指定了交换机的类型为 “topic”。</li>
<li><code>key</code>: 在 <code>@QueueBinding</code> 注解中，<code>key</code> 属性<strong>用于指定路由键</strong>，表示消息从交换机发送到队列时所需匹配的路由规则。在这里，设置了 “secKill.success” 作为路由键。</li>
</ol>
<p>综上所述，这段代码的作用是声明了一个 RabbitMQ 的消息监听器，监听名为 “voucherOrder.topic” 的交换机上的 “secKill.success” 路由键对应的队列 “voucherOrder.queue”，当有消息通过该路由键到达时，会触发被注解的方法进行消费。</p>
<p>来，上压力测试，好快啊，平均26ms</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417155424199.png" alt="image-20240417155424199"></p>
<p>来三轮求取平均值 82ms</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417160106573.png" alt="image-20240417160106573"></p>
<p>第三轮68ms</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417160716270.png" alt="image-20240417160716270"></p>
<p>好像用了lua脚本后，就确保了一人一单不会被抢了，加Redisson分布式锁还有没有用了？</p>
<p>加锁，也是给后续写入数据库的操作加锁，感觉会没用，试试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417161256215.png" alt="image-20240417161256215"></p>
<p>果然，平均只有1s了</p>
<h1 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h1><h2 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a>发布探店笔记</h2><p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p>
<p>一共两个接口 ，上传 和发布</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418093502146.png" alt="image-20240418093502146"></p>
<p>上传接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 生成新文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        blog.setUpdateTime(user.getId());</span><br><span class="line">        <span class="comment">//保存探店博文</span></span><br><span class="line">        blogService.saveBlog(blog);</span><br><span class="line">        <span class="comment">//返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="达人探店点赞功能"><a href="#达人探店点赞功能" class="headerlink" title="达人探店点赞功能"></a>达人探店点赞功能</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418110635495.png" alt="image-20240418110635495"></p>
<p>完善点赞功能</p>
<p>需求：</p>
<ul>
<li>同一个用户只能点赞一次，再次点击则取消点赞</li>
<li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li>
</ul>
<p>实现步骤：</p>
<ul>
<li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li>
<li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li>
<li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
<li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
</ul>
<p>思路就是：用一个set集合去存储已经点赞的用户的列表集合</p>
<p>我们先去Redis中查询，</p>
<p>查询不到，数据库点赞++，保存用户到Redis说明已经点过赞</p>
<p>查询到，数据库点赞–，删除Redis中set保存的用户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户，从线程池中</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">        <span class="comment">//isMember判断是否是当前set的成员</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">        <span class="keyword">if</span> (BooleanUtil.isFalse(isMember)) &#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">            <span class="comment">//3.1 数据库点赞数+1</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//3.2 保存用户到Redis的set集合</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForSet().add(key, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">            <span class="comment">//4.1 数据库点赞数-1</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//4.2 把用户从Redis的set集合移除</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForSet().remove(key, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryHotBlog</span><span class="params">(Integer current)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据用户查询</span></span><br><span class="line">        Page&lt;Blog&gt; page = query()</span><br><span class="line">                .orderByDesc(<span class="string">&quot;liked&quot;</span>)</span><br><span class="line">                .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">        <span class="comment">// 获取当前页数据</span></span><br><span class="line">        List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">        <span class="comment">// 查询用户</span></span><br><span class="line">        records.forEach(blog -&gt;&#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> blog.getUserId();</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">            blog.setName(user.getNickName());</span><br><span class="line">            blog.setIcon(user.getIcon());</span><br><span class="line">            <span class="built_in">this</span>.isBlogLiked(blog);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="点赞排行傍"><a href="#点赞排行傍" class="headerlink" title="点赞排行傍"></a>点赞排行傍</h2><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p>
<p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的<code>sortedSet</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418151814526.png" alt="image-20240418151814526"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/07/Java/Redis/Users\A\AppData\Roaming\Typora\typora-user-images\image-20240418151858340.png" alt="image-20240418151858340"></p>
<p><strong>思路：使用zset代替set集合，按照保存时间的毫秒值，获取排名前五的用户</strong></p>
<p><strong>做一些转换，封装到DTO中即可返回</strong></p>
<p>controller层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likesBlog</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.likesBlog(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户，从线程池中</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">        <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">            <span class="comment">//3.1 数据库点赞数+1</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//3.2 保存用户到Redis的set集合、Zset集合。zadd key value score</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().add(key, userId.toString(),System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">            <span class="comment">//4.1 数据库点赞数-1</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//4.2 把用户从Redis的set集合移除</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">likesBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">        <span class="comment">//查询top5的点赞用户  zrange key 0 4</span></span><br><span class="line">        Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//        List&lt;Long&gt; ids = new ArrayList&lt;&gt;(); // 创建一个新的列表，用于存储转换后的 Long 类型值</span></span><br><span class="line"><span class="comment">//        for (String str : top5) &#123;</span></span><br><span class="line"><span class="comment">//            Long i = Long.valueOf(str); // 将字符串转换为 Long 类型</span></span><br><span class="line"><span class="comment">//            ids.add(i); // 将转换后的 Long 类型值添加到新的列表中</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(top5 == <span class="literal">null</span> || top5.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stream流实现列表字符串类型转为long类型</span></span><br><span class="line">        List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).toList();</span><br><span class="line">        List&lt;User&gt; users = userService.listByIds(ids);</span><br><span class="line">        List&lt;UserDTO&gt; userDTOS = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(User u : users)&#123;</span><br><span class="line">            <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(u, UserDTO.class);</span><br><span class="line">            userDTOS.add(userDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stream流，将List&lt;User&gt; users 复制转为 List&lt;UserDTO&gt; userDTOS</span></span><br><span class="line"><span class="comment">//        List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids)</span></span><br><span class="line"><span class="comment">//                .stream()</span></span><br><span class="line"><span class="comment">//                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span></span><br><span class="line"><span class="comment">//                .collect(Collectors.toList());</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有好多用流的处理方法，我流使用不习惯，用传统for集合遍历也行</p>
<h1 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h1><h2 id="好有关注和取关"><a href="#好有关注和取关" class="headerlink" title="好有关注和取关"></a>好有关注和取关</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418153619094.png" alt="image-20240418153619094"></p>
<p>基于该表数据结构，实现两个接口</p>
<ul>
<li>关注和取关接口</li>
<li>判断关注的接口</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418184922624.png" alt="image-20240418184922624"></p>
<p>关注是User之间的关系，是博主和粉丝的关系，<strong>是多对多的关系</strong>，数据库中有一张表，tb_follow表示</p>
<p>思路：</p>
<p>尝试关注思路：判断是关注还是取关，关注的话就定义对象，存到表中，取关就删除表中字段</p>
<p>是否关注用户：查询，符合就行</p>
<p><strong>controller层</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">IFollowService followService;</span><br><span class="line"><span class="comment">//关注</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(followUserId, isFollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消关注</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.isFollow(followUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>service层</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> BlogMapper blogMapper;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">//判断关注还是取关</span></span><br><span class="line">       <span class="keyword">if</span>(isFollow)&#123;</span><br><span class="line">           <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">           follow.setUserId(userId);</span><br><span class="line">           follow.setFollowUserId(followUserId);</span><br><span class="line">           save(follow);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">               new QueryWrapper&lt;Follow&gt;()：创建一个 Follow 实体类的查询条件包装器对象。</span></span><br><span class="line"><span class="comment">               eq(&quot;user_id&quot;, userId)：指定查询条件，表示要查询 Follow 表中 user_id 列等于 userId 的记录。</span></span><br><span class="line"><span class="comment">               eq(&quot;follow_user_id&quot;, followUserId)：进一步指定查询条件，表示要查询 Follow 表中 follow_user_id 列等于 followUserId 的记录。</span></span><br><span class="line"><span class="comment">               remove()：执行删除操作，删除符合上述查询条件的数据。</span></span><br><span class="line"><span class="comment">               总之，这行代码的作用是删除表中 user_id 等于 userId 且 follow_user_id 等于 followUserId 的记录。*/</span></span><br><span class="line">           <span class="comment">//remove(new QueryWrapper&lt;Follow&gt;().eq(&quot;user_id&quot;,userId).eq(&quot;follow_user_id&quot;,followUserId));</span></span><br><span class="line">           <span class="comment">//不熟悉还是写SQL吧</span></span><br><span class="line">           <span class="comment">//delete from tb_follow where user_id = #&#123;userId&#125; and follow_user_id = #&#123;followUserId&#125;</span></span><br><span class="line">           blogMapper.deleteFollow(userId,followUserId);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">       <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h2><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p>
<p>1、去查询用户的详情</p>
<p>2、去查询用户的笔记</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418190839157.png" alt="image-20240418190839157"></p>
<p><strong>1.查询用户详情</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.查询用户笔记</strong></p>
<ol>
<li><code>blogService.page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE))</code>：<ul>
<li><code>blogService</code> 是一个博客服务对象，通过该对象调用 <code>page</code> 方法来查询博客信息。</li>
<li><code>page</code> 方法接受一个 <code>Page</code> 对象作为参数，用于指定查询的分页信息。</li>
<li><code>new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE)</code> 创建了一个分页对象，其中 <code>current</code> 表示当前页数，<code>SystemConstants.MAX_PAGE_SIZE</code> 表示每页的记录数。</li>
<li>通过传入当前页数和每页记录数，实现了分页查询。</li>
</ul>
</li>
<li><code>List&lt;Blog&gt; records = page.getRecords();</code>：<ul>
<li><code>page.getRecords()</code> 方法用于获取当前页的记录列表。</li>
<li>将获取到的记录列表赋值给 <code>List&lt;Blog&gt; records</code>，以便后续返回给前端。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogByUserId</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;id&quot;)</span> Long id,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;,defaultValue = &quot;1&quot;)</span> Integer current)</span>&#123;</span><br><span class="line">    <span class="comment">//根据用户分页查询，current当前页数，M每页最大页数</span></span><br><span class="line">    Page&lt;Blog&gt; objectPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE);</span><br><span class="line">    Page&lt;Blog&gt; page = blogService.page(objectPage);</span><br><span class="line">    <span class="comment">//获取当前页的数据</span></span><br><span class="line">    List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共同关注的实现"><a href="#共同关注的实现" class="headerlink" title="共同关注的实现"></a><strong>共同关注的实现</strong></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418220145437.png" alt="image-20240418220145437"></p>
<p>思路：在关注的时候，放入数据库的同时，指定key把<code>当前ID的关注列表</code>以set的形式放入缓存中，</p>
<p>取消关注的时候，删除数据库的时候，删除缓存	</p>
<p>最后在用set的求交集的api，就可以查找到共同关注</p>
<p>注意查到的的数据为String，转化为Long类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">        <span class="comment">//判断关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span>(isFollow)&#123;</span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserId);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ifSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">            <span class="keyword">if</span>(ifSuccess)&#123;</span><br><span class="line">                stringRedisTemplate.opsForSet().add(key,followUserId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">/* new QueryWrapper&lt;Follow&gt;()：创建一个 Follow 实体类的查询条件包装器对象。</span></span><br><span class="line"><span class="comment">                eq(&quot;user_id&quot;, userId)：指定查询条件，表示要查询 Follow 表中 user_id 列等于 userId 的记录。</span></span><br><span class="line"><span class="comment">                eq(&quot;follow_user_id&quot;, followUserId)：进一步指定查询条件，表示要查询 Follow 表中 follow_user_id 列等于 followUserId 的记录。</span></span><br><span class="line"><span class="comment">                remove()：执行删除操作，删除符合上述查询条件的数据。</span></span><br><span class="line"><span class="comment">                总之，这行代码的作用是删除表中 user_id 等于 userId 且 follow_user_id 等于 followUserId 的记录。*/</span></span><br><span class="line">            <span class="comment">//remove(new QueryWrapper&lt;Follow&gt;().eq(&quot;user_id&quot;,userId).eq(&quot;follow_user_id&quot;,followUserId));</span></span><br><span class="line">            <span class="comment">//不熟悉还是写SQL吧</span></span><br><span class="line">            <span class="comment">//delete from tb_follow where user_id = #&#123;userId&#125; and follow_user_id = #&#123;followUserId&#125;</span></span><br><span class="line">            blogMapper.deleteFollow(userId,followUserId);</span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key,followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">        Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key1, key2);</span><br><span class="line">        <span class="keyword">if</span>(intersect == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析ID,Stream流处理</span></span><br><span class="line">        List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).toList();</span><br><span class="line">        List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids).stream()</span><br><span class="line">                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">                .toList();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="关注推送Feed流"><a href="#关注推送Feed流" class="headerlink" title="关注推送Feed流"></a>关注推送Feed流</h2><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流</p>
<p>关注推送也叫做<code>Feed流</code>，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>
<p>对于<code>新型的Feed流</code>的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>
<p>Feed流产品有两种常见模式：<br><code>Timeline</code>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如<strong>朋友圈</strong></p>
<ul>
<li>优点：信息全面，不会有缺失。并且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
<p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p>
<ul>
<li><p>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</p>
</li>
<li><p>缺点：如果算法不精准，可能起到反作用</p>
</li>
<li><p>该模式的实现方案有三种：</p>
</li>
</ul>
<p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p>
<p>，因此采用Timeline的模式。该模式的实现方案有三种：</p>
<ul>
<li>拉模式</li>
<li>推模式</li>
<li>推拉结合</li>
</ul>
<p><strong>拉模式</strong>：也叫是，<code>读扩散</code></p>
<p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p>
<p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>
<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653809450816.png" alt="1653809450816"></p>
<p><strong>推模式</strong>：也叫做<code>写扩散。</code></p>
<p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653809875208.png" alt="1653809875208"></p>
<p><strong>推拉结合模式</strong>：也叫做<code>读写混合</code>，兼具推和拉两种模式的优点。</p>
<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个<code>普通的人，那么我们采用写扩散的方式</code>，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，<code>如果是大V，那么他是直接将数据先写入到一份到发件箱里边去</code>，然后再直接写一份到<code>活跃粉丝</code>收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653812346852.png" alt="1653812346852"></p>
<p><strong>大V：发件箱+活跃粉丝收件箱</strong></p>
<p><strong>普通人：收件箱</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418221503956.png" alt="image-20240418221503956"></p>
<h2 id="推送到粉丝邮件箱"><a href="#推送到粉丝邮件箱" class="headerlink" title="推送到粉丝邮件箱"></a>推送到粉丝邮件箱</h2><p>需求：</p>
<ul>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li>
<li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li>
<li>查询收件箱数据时，可以实现分页查询</li>
</ul>
<p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p>
<p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p>
<p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p>
<p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653813047671.png" alt="1653813047671"></p>
<p>Feed流的滚动分页</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653813462834.png" alt="1653813462834"></p>
<p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p>
<h2 id="好友关注：实现分页查询收邮箱"><a href="#好友关注：实现分页查询收邮箱" class="headerlink" title="好友关注：实现分页查询收邮箱"></a><strong>好友关注：实现分页查询收邮箱</strong></h2><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p>
<p>具体操作如下：</p>
<p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p>
<p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p>
<p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p>
<p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240419010208450.png" alt="image-20240419010208450"></p>
<p>controller层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service层</p>
<p>思路：使用zset中的方法，</p>
<ul>
<li><code>tringRedisTemplate.opsForZSet()</code>：通过 RedisTemplate 获取操作有序集合的接口。</li>
<li><code>reverseRangeByScoreWithScores()</code>：这是有序集合操作的一个方法，用于按照分数范围反向获取指定数量的成员和分数。</li>
<li><code>key</code>：指定要查询的有序集合的键。</li>
<li><code>0</code>：指定分数的最小值，这里为 0。</li>
<li><code>max</code>：指定分数的最大值，具体数值由变量 <code>max</code> 决定。</li>
<li><code>offset</code>：指定结果集的偏移量，即从符合条件的结果中的第几个开始取值。</li>
<li><code>2</code>：指定要返回的成员数量。</li>
</ul>
<p>该方法返回一个包含成员及其分数的 <code>TypedTuple</code> 集合，其中每个 <code>TypedTuple</code> 对象包含了一个成员和对应的分数。从有序集合中按照分数范围查询指定数量的成员，并按照分数从高到低进行排序，然后返回成员及其分数的集合。</p>
<p><code>难点：在于偏移量的处理</code></p>
<p>让我回想起刷leecode的那些夜晚</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">       <span class="comment">//1.获取当前用户的收件箱</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + userId;</span><br><span class="line">       Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">               .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">       <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.ok();</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">       <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">       <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">           <span class="comment">// 4.1.获取id</span></span><br><span class="line">           ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">           <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">           <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">           <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">               os++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               minTime = time;</span><br><span class="line">               os = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       os = minTime == max ? os : os + offset;</span><br><span class="line">       <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">       List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">           <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">           queryBlogUser(blog);</span><br><span class="line">           <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">           isBlogLiked(blog);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 6.封装并返回</span></span><br><span class="line">       <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">       r.setList(blogs);</span><br><span class="line">       r.setOffset(os);</span><br><span class="line">       r.setMinTime(minTime);</span><br><span class="line">       <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h1><h2 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240419153837484.png" alt="image-20240419153837484"></p>
<p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">        <span class="comment">//Stream流实现分组</span></span><br><span class="line">        Map&lt;Long, List&lt;Shop&gt;&gt; shopList = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">        <span class="comment">//一般的分组</span></span><br><span class="line"><span class="comment">//        Map&lt;Long, List&lt;Shop&gt;&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        for (Shop shop : list) &#123;</span></span><br><span class="line"><span class="comment">//            Long id = shop.getId();</span></span><br><span class="line"><span class="comment">//            if (!map.containsKey(id)) &#123;</span></span><br><span class="line"><span class="comment">//                map.put(id, new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            map.get(id).add(shop);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : shopList.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">            <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">            List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">            List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">            <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">            <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">                <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">                locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                        shop.getId().toString(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">                ));</span><br><span class="line">            &#125;</span><br><span class="line">            stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>存入后的数据</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240419154000164.png" alt="image-20240419154000164"></p>
<p><strong>难点：</strong>不是每次都与Redis链接，去插入数据，而是把数据封装成List&lt;RedisGeoCommands.GeoLocation<String>&gt;集合，一次插入，减小与Redis链接的次数，提升效率</String></p>
<p>分页查询：</p>
<h2 id="附近商户的实现功能"><a href="#附近商户的实现功能" class="headerlink" title="附近商户的实现功能"></a>附近商户的实现功能</h2><p><strong>controller层</strong></p>
<p>ShopController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShopServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">       <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">       <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">           Page&lt;Shop&gt; page = query()</span><br><span class="line">                   .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                   .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">           <span class="comment">// 返回数据</span></span><br><span class="line">           <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.计算分页参数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">       <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">       GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo()</span><br><span class="line">               <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">               .search(</span><br><span class="line">                       key,</span><br><span class="line">                       GeoReference.fromCoordinate(x, y),</span><br><span class="line">                       <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">                       RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">               );</span><br><span class="line">       <span class="comment">// 4.解析出id</span></span><br><span class="line">       <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">       <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">           <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">           <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">       List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">       Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">       list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">           <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">           ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">           <span class="comment">// 4.3.获取距离</span></span><br><span class="line">           <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">           distanceMap.put(shopIdStr, distance);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">       List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">       <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">           shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 6.返回</span></span><br><span class="line">       <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通过 opsForGeo() 方法获取了 Redis 的 Geo 操作对象。</span><br><span class="line">调用 search() 方法执行地理位置的搜索操作。</span><br><span class="line">search() 方法接收了一系列参数：</span><br><span class="line">key：指定了要搜索的 GeoKey（地理位置的键）。</span><br><span class="line">GeoReference.fromCoordinate(x, y)：指定了搜索的中心坐标，其中 x 和 y 分别表示了经度和纬度。</span><br><span class="line">new Distance(5000)：指定了搜索的半径范围，这里设置为 5000 米。</span><br><span class="line">RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)：这是可选的参数，用于配置搜索的行为。includeDistance() 表示在搜索结果中包含距离信息，limit(end) 表示限制搜索结果的数量为 end。</span><br></pre></td></tr></table></figure>



<h2 id="用户签到BitMap"><a href="#用户签到BitMap" class="headerlink" title="用户签到BitMap"></a>用户签到BitMap</h2><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653823145495.png" alt="1653823145495"></p>
<p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p>
<p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p>
<p>我们可以采用类似这样的方案来实现我们的签到需求。</p>
<p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p>
<p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p>
<p>Redis中是利用string类型数据结构实现<code>BitMap</code>，因此最大上限是512M，转换为bit则是 2^32个bit位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653824498278.png" alt="1653824498278"></p>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT ：获取指定位置（offset）的bit值</li>
<li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li>
<li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p>
<p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p>
<p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p>
<p><strong>代码</strong></p>
<p>UserController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户签到-签到统计"><a href="#用户签到-签到统计" class="headerlink" title="用户签到-签到统计"></a>用户签到-签到统计</h2><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/07/Java/Redis/BaiduNetdiskDownload/Redis入门到实战教程/02-实战篇/讲义/Redis实战篇.assets/1653834455899.png" alt="1653834455899"></p>
<p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p>
<p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p>
<p>  BITFIELD key GET u[dayOfMonth] 0</p>
<p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p>
<p><strong>问题3：如何从后向前遍历每个bit位？</strong></p>
<p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/07/Java/Redis/BaiduNetdiskDownload/Redis入门到实战教程/02-实战篇/讲义/Redis实战篇.assets/1653835784444.png" alt="1653835784444"></p>
<p>代码</p>
<p><strong>UserController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="额外加餐"><a href="#额外加餐" class="headerlink" title="额外加餐"></a>额外加餐</h2><p>-关于使用bitmap来解决缓存穿透的方案</p>
<p>回顾<strong>缓存穿透</strong>：</p>
<p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p>
<p>解决方案：</p>
<ul>
<li><p>判断id&lt;0</p>
</li>
<li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p>
</li>
</ul>
<p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p>
<p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p>
<p>所以我们如何解决呢？</p>
<p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653836416586.png" alt="1653836416586"></p>
<p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p>
<p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p>
<p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p>
<p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p>
<p>id % bitmap.size  &#x3D; 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653836578970.png" alt="1653836578970"></p>
<h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><p><strong>UV统计-HyperLogLog</strong></p>
<p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p>
<p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p>
<p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PFADD key element [element...]</span><br><span class="line">summary: Adds the specified elements to the specified HyperLogLog</span><br><span class="line"></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line">Return the approximated cardinality of the <span class="built_in">set</span>(s) observed by the HyperLogLog at key(s).</span><br><span class="line"></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br><span class="line">lnternal commands <span class="keyword">for</span> debugging HyperLogLog values</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHyperLogLog</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] users = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        j = i % <span class="number">1000</span>;</span><br><span class="line">        users[j] = <span class="string">&quot;user_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">999</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForHyperLogLog().add(<span class="string">&quot;HLL&quot;</span>, users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class="string">&quot;HLL&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240420010114009.png" alt="image-20240420010114009"></p>
<p>1000000存入997593，误差率约为0.2%</p>
<h1 id="实战篇结束，完结撒花"><a href="#实战篇结束，完结撒花" class="headerlink" title="实战篇结束，完结撒花"></a>实战篇结束，完结撒花</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.mfyuan.top">方圆</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.mfyuan.top/2024/04/07/Java/Redis/">http://www.mfyuan.top/2024/04/07/Java/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.mfyuan.top" target="_blank">方圆的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_26.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/07/Java/Docker/" title="Docker"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_17.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/05/Java/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Java基础篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_25.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基础篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/24/Interviews/Redis/" title="Redis面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_13.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-24</div><div class="title">Redis面试题</div></div></a></div><div><a href="/2024/04/07/Java/Docker/" title="Docker"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_17.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-07</div><div class="title">Docker</div></div></a></div><div><a href="/2024/05/07/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="java8新特性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_9.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-07</div><div class="title">java8新特性</div></div></a></div><div><a href="/2024/04/15/Java/RabbitMQ/" title="RabbitMq"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_15.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-15</div><div class="title">RabbitMq</div></div></a></div><div><a href="/2024/03/25/Java/JavaWeb/" title="JavaWeb笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_10.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-25</div><div class="title">JavaWeb笔记</div></div></a></div><div><a href="/2024/04/04/Java/java%E9%9B%86%E5%90%88/" title="Java集合常用方法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_4.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-04</div><div class="title">Java集合常用方法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">方圆</div><div class="author-info__description">总要在互联网上留下点记忆吧</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fyfyfy233"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fyfyfy233" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://image.mfyuan.top/img/QQ.jpg" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #24292e;"></i></a><a class="social-icon" href="https://image.mfyuan.top/img/WeChat.png" target="_blank" title="微信"><i class="fab fa-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/232780690" target="_blank" title="bilibili"><i class="fab fa-bilibili" style="color: #24292e;"></i></a><a class="social-icon" href="https://leetcode.cn/u/yin-ni-er-qi-de-yi-hong-xi-bei" target="_blank" title="leecode"><i class="fab fa-leanpub" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%90%86%E8%AE%BARedis"><span class="toc-number">1.</span> <span class="toc-text">理论Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E8%AF%86Redis"><span class="toc-number">2.</span> <span class="toc-text">初识Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Nosql%EF%BC%9A%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.</span> <span class="toc-text">Nosql：非关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96"><span class="toc-number">2.1.1.</span> <span class="toc-text">结构化与非结构化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%92%8C%E9%9D%9E%E5%85%B3%E8%81%94"><span class="toc-number">2.1.2.</span> <span class="toc-text">关联和非关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.3.</span> <span class="toc-text">查询方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9"><span class="toc-number">2.1.4.</span> <span class="toc-text">事物</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Redis"><span class="toc-number">3.</span> <span class="toc-text">认识Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Redis"><span class="toc-number">4.</span> <span class="toc-text">安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linux%E4%B8%8B%E5%AE%89%E8%A3%85"><span class="toc-number">4.1.</span> <span class="toc-text">1.Linux下安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%AE%89%E8%A3%85Redis"><span class="toc-number">4.2.</span> <span class="toc-text">1.3.安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E4%BE%9D%E8%B5%96%E5%BA%93"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.3.1.依赖库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E4%B8%8A%E4%BC%A0%E5%AE%89%E8%A3%85%E5%8C%85%E5%B9%B6%E8%A7%A3%E5%8E%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">1.3.2.上传安装包并解压</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E5%90%AF%E5%8A%A8"><span class="toc-number">4.2.3.</span> <span class="toc-text">1.3.3.启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">1.3.4.默认启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-5-%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8"><span class="toc-number">4.2.5.</span> <span class="toc-text">1.3.5.指定配置启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-6-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF"><span class="toc-number">4.2.6.</span> <span class="toc-text">1.3.6.开机自启</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Docker%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85"><span class="toc-number">4.3.</span> <span class="toc-text">2.Docker镜像安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">安装遇到的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">Redis常见命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.</span> <span class="toc-text">Redis通用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">String类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#key%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.</span> <span class="toc-text">key结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">Hash类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">List类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E7%BB%93%E6%9E%84"><span class="toc-number">5.6.</span> <span class="toc-text">Set结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SortedSet%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.7.</span> <span class="toc-text">SortedSet类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">6.</span> <span class="toc-text">Redis的Java客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Jedis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">6.1.</span> <span class="toc-text">Jedis客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jedis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">6.2.</span> <span class="toc-text">Jedis连接池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringDataRedis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">6.3.</span> <span class="toc-text">SpringDataRedis客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">6.4.</span> <span class="toc-text">自定义序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringRedisTemplate"><span class="toc-number">6.5.</span> <span class="toc-text">StringRedisTemplate</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%AF%87Redis"><span class="toc-number">7.</span> <span class="toc-text">实战篇Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6"><span class="toc-number">7.1.</span> <span class="toc-text">导入项目框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86"><span class="toc-number">8.</span> <span class="toc-text">1.短信登陆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Esession%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">基于session的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8BThreadLocal"><span class="toc-number">8.2.</span> <span class="toc-text">线程ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.1.</span> <span class="toc-text">Tomcat运行原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session%E5%85%B1%E4%BA%AB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.3.</span> <span class="toc-text">session共享的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">8.4.</span> <span class="toc-text">Redis的实现思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%95%86%E5%93%81%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">9.</span> <span class="toc-text">2.商品查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%95%86%E5%93%81%E7%BC%93%E5%AD%98"><span class="toc-number">9.1.</span> <span class="toc-text">添加商品缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E7%BB%99%E5%BA%97%E9%93%BA%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E7%BC%93%E5%AD%98"><span class="toc-number">9.2.</span> <span class="toc-text">练习：给店铺类型查询业务添加缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">9.3.</span> <span class="toc-text">Redis缓存更新策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%95%86%E9%93%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="toc-number">9.4.</span> <span class="toc-text">实现商铺缓存与数据库缓存双写一致</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">9.5.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98"><span class="toc-number">9.6.</span> <span class="toc-text">编码解决缓存穿透问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">9.7.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">9.8.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">9.9.</span> <span class="toc-text">用互斥锁解决缓存击穿问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">9.10.</span> <span class="toc-text">用逻辑过期解决缓存击穿问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85Redis%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">9.11.</span> <span class="toc-text">封装Redis工具类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-number">10.</span> <span class="toc-text">优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%EF%BC%9A"><span class="toc-number">10.1.</span> <span class="toc-text">全局唯一ID：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">10.2.</span> <span class="toc-text">Redis实现全局唯一ID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">10.3.</span> <span class="toc-text">多线程测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8B%E5%8D%95%E7%A7%92%E6%9D%80"><span class="toc-number">10.4.</span> <span class="toc-text">实现下单秒杀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">10.5.</span> <span class="toc-text">库存超卖问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">10.6.</span> <span class="toc-text">一人一单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">10.7.</span> <span class="toc-text">集群环境下的并发问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">11.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">11.1.</span> <span class="toc-text">基于Redis的分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A2%AB%E8%AF%AF%E5%88%A0%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">11.2.</span> <span class="toc-text">分布式锁被误删的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">11.3.</span> <span class="toc-text">分布式锁的原子性的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua%E8%84%9A%E6%9C%AC%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">11.4.</span> <span class="toc-text">Lua脚本解决多条命令的原子性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Java%E8%B0%83%E7%94%A8lua%E8%84%9A%E6%9C%AC"><span class="toc-number">11.5.</span> <span class="toc-text">利用Java调用lua脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">11.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redission"><span class="toc-number">12.</span> <span class="toc-text">分布式锁redission</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">12.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.2.</span> <span class="toc-text">分布式锁-redisson可重入锁的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redisson%E9%87%8D%E8%AF%95%E5%92%8C%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6"><span class="toc-number">12.3.</span> <span class="toc-text">分布式锁redisson重试和看门狗机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redisson%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E2%80%93multiLock"><span class="toc-number">12.4.</span> <span class="toc-text">Redisson主从一致性问题–multiLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-number">12.5.</span> <span class="toc-text">本章小结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">12.6.</span> <span class="toc-text">秒杀优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80%E6%80%9D%E8%B7%AF"><span class="toc-number">12.7.</span> <span class="toc-text">异步秒杀思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">12.8.</span> <span class="toc-text">基于阻塞队列实现秒杀优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">13.</span> <span class="toc-text">Redis消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">13.1.</span> <span class="toc-text">List实现消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EPubSub%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">13.2.</span> <span class="toc-text">基于PubSub消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">13.3.</span> <span class="toc-text">基于Stream的消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.4.</span> <span class="toc-text">RabbitMQ消息队列实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97"><span class="toc-number">14.</span> <span class="toc-text">达人探店</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E6%8E%A2%E5%BA%97%E7%AC%94%E8%AE%B0"><span class="toc-number">14.1.</span> <span class="toc-text">发布探店笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD"><span class="toc-number">14.2.</span> <span class="toc-text">达人探店点赞功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E%E6%8E%92%E8%A1%8C%E5%82%8D"><span class="toc-number">14.3.</span> <span class="toc-text">点赞排行傍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8"><span class="toc-number">15.</span> <span class="toc-text">好友关注</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%BD%E6%9C%89%E5%85%B3%E6%B3%A8%E5%92%8C%E5%8F%96%E5%85%B3"><span class="toc-number">15.1.</span> <span class="toc-text">好有关注和取关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-number">15.2.</span> <span class="toc-text">共同关注</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.3.</span> <span class="toc-text">共同关注的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81Feed%E6%B5%81"><span class="toc-number">15.4.</span> <span class="toc-text">关注推送Feed流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E5%88%B0%E7%B2%89%E4%B8%9D%E9%82%AE%E4%BB%B6%E7%AE%B1"><span class="toc-number">15.5.</span> <span class="toc-text">推送到粉丝邮件箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E6%94%B6%E9%82%AE%E7%AE%B1"><span class="toc-number">15.6.</span> <span class="toc-text">好友关注：实现分页查询收邮箱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7"><span class="toc-number">16.</span> <span class="toc-text">附近商户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">16.1.</span> <span class="toc-text">GEO数据结构的基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">16.2.</span> <span class="toc-text">附近商户的实现功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0BitMap"><span class="toc-number">16.3.</span> <span class="toc-text">用户签到BitMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0-%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">16.4.</span> <span class="toc-text">用户签到-签到统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E5%8A%A0%E9%A4%90"><span class="toc-number">16.5.</span> <span class="toc-text">额外加餐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">16.6.</span> <span class="toc-text">UV统计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%AF%87%E7%BB%93%E6%9D%9F%EF%BC%8C%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1"><span class="toc-number">17.</span> <span class="toc-text">实战篇结束，完结撒花</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/07/Written%20Examination/wangyi/" title="网易面经"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_10.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网易面经"/></a><div class="content"><a class="title" href="/2024/06/07/Written%20Examination/wangyi/" title="网易面经">网易面经</a><time datetime="2024-06-07T02:10:42.000Z" title="发表于 2024-06-07 10:10:42">2024-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/04/Written%20Examination/xiecheng/" title="携程笔试&amp;面经"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_3.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="携程笔试&amp;面经"/></a><div class="content"><a class="title" href="/2024/06/04/Written%20Examination/xiecheng/" title="携程笔试&amp;面经">携程笔试&amp;面经</a><time datetime="2024-06-04T15:03:30.000Z" title="发表于 2024-06-04 23:03:30">2024-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/24/Written%20Examination/meituan/" title="美团笔试&amp;面经"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_5.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="美团笔试&amp;面经"/></a><div class="content"><a class="title" href="/2024/05/24/Written%20Examination/meituan/" title="美团笔试&amp;面经">美团笔试&amp;面经</a><time datetime="2024-05-24T13:21:47.000Z" title="发表于 2024-05-24 21:21:47">2024-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/24/Interviews/JavaSE/" title="java基础面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_10.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础面试题"/></a><div class="content"><a class="title" href="/2024/05/24/Interviews/JavaSE/" title="java基础面试题">java基础面试题</a><time datetime="2024-05-24T04:36:06.000Z" title="发表于 2024-05-24 12:36:06">2024-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/24/Interviews/Mybatis/" title="Mybatis面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_30.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis面试题"/></a><div class="content"><a class="title" href="/2024/05/24/Interviews/Mybatis/" title="Mybatis面试题">Mybatis面试题</a><time datetime="2024-05-24T04:34:33.000Z" title="发表于 2024-05-24 12:34:33">2024-05-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_26.webp')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 方圆</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://www.mfyuan.top/categories/java/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 小方の编程笔记 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.mfyuan.top/categories/project/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 小方の项目学习 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.mfyuan.top/categories/力扣/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 小方の刷题笔记 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.mfyuan.top/categories/生活/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 小方の生活趣事 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.mfyuan.top/categories/笔试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 公司の笔试&面经 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://www.mfyuan.top/categories/面试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 小方の面试总结 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://www.mfyuan.top/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #F5F5DC;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/07/Java/Redis/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_26.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-07</span><a class="blog-slider__title" href="2024/04/07/Java/Redis/" alt="">Redis</a><div class="blog-slider__text">自己在学习Redis知识时候记得一些笔记， 它用Redis实现了短信登录，缓存查询，优惠券秒杀，附近商户，UV统计，用户签到，好友关注，达人探店等功能</div><a class="blog-slider__button" href="2024/04/07/Java/Redis/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/03/25/Java/JavaWeb/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_10.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-25</span><a class="blog-slider__title" href="2024/03/25/Java/JavaWeb/" alt="">JavaWeb笔记</a><div class="blog-slider__text">自己在学习web知识时候记得一些笔记， 它打通了从前端 =&gt; MySQL =&gt; Java Web =&gt; SSM =&gt; Spring Boot =&gt; Maven 这一套技术栈</div><a class="blog-slider__button" href="2024/03/25/Java/JavaWeb/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/20/Interviews/baguwen/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_1.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-20</span><a class="blog-slider__title" href="2024/04/20/Interviews/baguwen/" alt="">面试总结</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/04/20/Interviews/baguwen/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/04/Java/java集合/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/Saved%20Pictures/default_cover_4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-04</span><a class="blog-slider__title" href="2024/04/04/Java/java集合/" alt="">Java集合常用方法</a><div class="blog-slider__text">总结的Java集合常用方法，刷题前看看</div><a class="blog-slider__button" href="2024/04/04/Java/java集合/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/03/26/life/taiziwan/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/img_taiziwan_cover.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-26</span><a class="blog-slider__title" href="2024/03/26/life/taiziwan/" alt="">太子湾+法喜寺游记</a><div class="blog-slider__text">一篇流水账</div><a class="blog-slider__button" href="2024/03/26/life/taiziwan/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>