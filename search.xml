<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>太子湾+法喜寺游记</title>
      <link href="/2024/03/26/taiziwan/"/>
      <url>/2024/03/26/taiziwan/</url>
      
        <content type="html"><![CDATA[<p>游记怎么写？就当写流水账吧</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_0060.JPG" alt="image-1"></p><h1 id="太子湾郁金香-法喜寺五百年玉兰花"><a href="#太子湾郁金香-法喜寺五百年玉兰花" class="headerlink" title="太子湾郁金香&amp;&amp;法喜寺五百年玉兰花"></a>太子湾郁金香&amp;&amp;法喜寺五百年玉兰花</h1><p><strong>“三月春花渐次醒”</strong></p><p>睡到自然醒骑车出发</p><p>我骑车，室友坐地铁去</p><p>太子湾在西湖旁边，离学校30公里吧，正常我一个一个半小时骑到</p><p>在杭州求学第六年了，之江东路，不知道骑了多少次了，西湖也去过太多次了</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_120917.jpg"><p>路上遇到一个骑行的小姐姐，太狠了，一路35+，我跟了七八公里，一个上坡跟不住了，女骑恐怖如斯</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_130552.jpg" alt="image-3" style="zoom: 200%;"><h2 id="太子湾门口"><a href="#太子湾门口" class="headerlink" title="太子湾门口"></a>太子湾门口</h2><p>以前的太子湾是不要预约的，现在要预约了，但是免费，门口也不差，人工看二维码我真的是绷不住了</p><p>南山路，路两边不知道什么时候围了栏杆，以往周末堵得水泄不通的南山路，现在好像不让私家车进来了，也就只有公交车了，不堵了，很好</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_130952.jpg" alt="image-4"></p><p>樱花还没开，人很多，两边很突兀，就地上一点郁金香展示着春天的色彩</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_1032.JPG" alt="image-5"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_1036.JPG" alt="image-6"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_1049.JPG" alt="image-7"></p><p>不多说了，上图</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_1057.JPG" alt="image-8"></p><p>这张红白分明的，真的拍的很好</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_1069.JPG" alt="image-9"></p><p>人是真的多，多到走不动道</p><p>但花也是真好看</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_1083.JPG" alt="image-10"></p><p>小河边拍花，一个小姐姐闯进我的镜头</p><p>突然发现，小桥，流水，小姐姐，还蛮和谐的</p><p>拍了好几张，留下一张侧脸，我觉得这张，嗯，刚刚好</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_1097.JPG" alt="image-11"></p><p>郁金香下的城堡</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_2836.JPG" alt="image-12"></p><p>粉色郁金香</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_2953.JPG" alt="image-13"></p><p>拉近拍近景，郁金香下还有蜜蜂在吸取花蜜</p><p>此时室友已经快到法喜寺了</p><p>我该去与之汇合</p><p>太子湾我来过很多次了，印象最深的是，19年那会儿，我也是，在这儿见到了杭州最美的春天，樱花和郁金香一起开放，樱花树下就是郁金香，各种颜色的，今年来的太早啦，如果等一两周后，樱花盛开，那将别是一番风采</p><h2 id="法喜寺"><a href="#法喜寺" class="headerlink" title="法喜寺"></a>法喜寺</h2><p>骑车从太子湾去法喜寺，从杨公堤上去，一路上还是堵堵堵堵</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_1107.JPG" alt="image-14"></p><p>来杭州这么多年了，灵隐寺去过不少次，法喜寺还是第一次去</p><p>门票10元</p><p><strong>上天竺法喜讲寺</strong></p><p>都说是求姻缘的好地方</p><p>我可要好好上个香，看看到底能不能在今年实现了哈哈哈（开玩笑</p><p>（我可是来看五百年的玉兰花的）</p><p>求还得求</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240317_014700.jpg" alt="image-15"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/wx_camera_1710571294492.jpg" alt="image-16"></p><p>你别说这寺庙看起来还蛮宏伟的</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/wx_camera_1710571653012.jpg" alt="image-17"></p><p>法喜寺的网红拍照打卡点，得用长焦拍，我随便一拍一点意境都没有了</p><p>可惜相机没有长焦，不过我用手机的10倍长焦拍到了好看的小姐姐</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_144851.jpg" alt="image-18"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_144848.jpg" alt="image-19"></p><p>此刻，景已经不重要了，人好看就成功了</p><p>哦忘了，我们的正事是来看五百年的玉兰花的</p><p>转了一圈都没找到，终于下楼拐进一个小巷子看到了</p><p>传说中的五百岁的玉兰花</p><p><strong>“花开花落五百次，只为遇见你”</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_150955.jpg" alt="image-20"></p><p>人太多辣，全部都是人，慕名而来的人</p><p>看到了就是值得的</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_0025.JPG" alt="image-21"></p><p>从这个角度拍，避开人群，背景刚好是寺庙的黄墙上，很不错</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_0015.JPG" alt="image-22"></p><p>嗯，55毫米的焦段刚好拍到 <strong>五观堂</strong> 和 灯笼上的字<strong>一心念佛世界和平</strong></p><p>可惜，还是来迟了些，这边的玉兰花，可能是因为阳光照射的过多了，都快凋谢了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_0014.JPG" alt="image-23"></p><p>此刻我真想唱</p><p>“我真的还想再活五百年~”</p><p>看完玉兰花四处闲逛之际</p><p>来到了寺庙深处，食堂的后面</p><p>遇到了我觉得今天最好的拍照点，可能也是运气好，阳光洒落刚刚好落在食堂黄墙的后面</p><p>还没人，真的是绝佳的拍照地点</p><p>我赶紧让家豪先上，机不可失时不再来，一会儿太阳就落山了，就没这么好的景色了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/DSC_0046.JPG" alt="image-24"></p><p>快门按下，随手一拍就是大片，拍出了男明星的感觉</p><p>有一说一</p><p>这张真的不错</p><p>把我室友拍的很帅</p><p>当然，怎么能少的了我</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240317_014446.jpg" alt="image-25"></p><p>嘿还行吧，我挺喜欢这张的</p><p>发给朋友看</p><p>朋友说我拿掉眼睛更好看，真的么？我觉得都还行</p><p>为了等着吃法喜寺的斋饭，要到四点半</p><p>我们就去逛纪念品店</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_161748.jpg" alt="image-26"></p><p>在一把串手串中，我一看就相中了，那款猫爪的手串</p><p>太可爱了</p><p>虽然店员说，图中[2.4]经典款卖的最火</p><p>但我还是觉得猫爪好看哦</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_162941.jpg" alt="image-27"></p><p>-68，不过值了</p><p>（后面才知道朋友说这是拿火烤的，抖音一看只要30块）</p><p>（瓦不管，瓦我开过光！）</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240317_192214.jpg" alt="image-28"></p><p>对比一下我们仨的，还是我的好看</p><p>四点半了，去吃法喜寺斋饭了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_163636.jpg" alt="image-29"></p><p>开始好奇只要五块钱的斋饭是什么</p><p>后来知道了，就这啊</p><p>白水煮菜豆皮加大米饭</p><p>我好奇了，偶尔吃就算了</p><p>和尚天天吃这个怎么受得了的，营养肯定跟不上啊</p><p>室友说：船上袈裟是上班，脱下袈裟是生活</p><p>我懂了</p><p>吃完回家啦</p><h2 id="闻涛路樱花"><a href="#闻涛路樱花" class="headerlink" title="闻涛路樱花"></a>闻涛路樱花</h2><p>和室友告别，继续前行，通过梅灵南路的隧道，下到之江路，过钱塘江大桥</p><p>我想要去闻涛路看看樱花</p><p>我记得有一年来过</p><p>江畔两岸一路的樱花，特别美，但去之前我就可能有预感了，太子湾的樱花都还没有开，那么闻涛路的应该也没开吧</p><p>果然不出我所料</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_180616.jpg" alt="image-30"></p><p>可能要等两周吧才能开咯 ，那就下周再来</p><p>不过江边骑行还是不错的</p><p>闻涛路，有专门的骑行道，比一般的江堤的路要宽不少</p><p>骑着骑着天就黑了</p><p>夜晚的复兴大桥</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_183723.jpg" alt="image-31"></p><p>手机渣渣画质只能拍成这样了</p><p>还有半小时，准备去看林俊杰的演唱会</p><p>什么？你问我怎么抢到票的？</p><p>那当然是，根本抢不到好吧</p><p>只能去外场听</p><p>喜欢听林俊杰，周杰伦，许嵩的歌</p><h2 id="林俊杰演唱会"><a href="#林俊杰演唱会" class="headerlink" title="林俊杰演唱会"></a>林俊杰演唱会</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_190703.jpg" alt="image-32"></p><p>呼呼呼，人是真的多</p><p>大莲花也是真的好看啊</p><p>变色，五颜六色的</p><p>外场的人也好多啊</p><p>看来抢不到票的人，还是真的多啊</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/IMG_20240316_190927.jpg" alt="image-33"></p><p>稳啦，找到位置了，席地而坐大家，都是JJ的粉丝</p><p>我看还有人拿着票，我去一问，才是旁边买的仿制的票奥</p><p>真粉丝啊，留个仿制的当个纪念</p><p>等了好久</p><p>林俊杰的第一首是，记得</p><p><strong>谁还记得是谁先说，永远的爱我~</strong></p><p>但是大莲花太大啦，声音很嘈杂，听得不是很清楚，我也是第一次听外场</p><p>体验极差，不如回去看饭拍的视频（写这篇文档的时候，其实边学习，边听了两遍饭拍了都）</p><p>外场大家在唱，虽然听不清，但是氛围还是有的</p><p>林俊杰的《关键词》真的太好听啦</p><p>后面听到快结束《她说》的时候，保安开始清场了，因为要保证散场</p><p>我就回去了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/taiziwan/Screenshot_2024-03-16-22-56-15-866_com.mi.health.jpg" alt="image-34"></p><p>充实的一天</p><p>充实的一篇流水账</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 太子湾 </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot 原理篇</title>
      <link href="/2024/03/26/springboot/"/>
      <url>/2024/03/26/springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpingBoot原理"><a href="#SpingBoot原理" class="headerlink" title="SpingBoot原理"></a>SpingBoot原理</h1><p>在前面十多天的课程当中，我们学习的都是web开发的技术使用，都是面向应用层面的，我们学会了怎么样去用。而我们今天所要学习的是web后端开发的最后一个篇章springboot原理篇，主要偏向于底层原理。</p><p>我们今天的课程安排包括这么三个部分：</p><ol><li>配置优先级：Springboot项目当中属性配置的常见方式以及配置的优先级</li><li>Bean的管理</li><li>剖析Springboot的底层原理</li></ol><h2 id="1-配置优先级"><a href="#1-配置优先级" class="headerlink" title="1. 配置优先级"></a>1. 配置优先级</h2><p>在我们前面的课程当中，我们已经讲解了SpringBoot项目当中支持的三类配置文件：</p><ul><li>application.properties</li><li>application.yml</li><li>application.yaml</li></ul><p>在SpringBoot项目当中，我们要想配置一个属性，可以通过这三种方式当中的任意一种来配置都可以，那么如果项目中同时存在这三种配置文件，且都配置了同一个属性，如：Tomcat端口号，到底哪一份配置文件生效呢？</p><ul><li>application.properties</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure><ul><li>application.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">8082</span></span><br></pre></td></tr></table></figure><ul><li>application.yaml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">8082</span></span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/yourname.png" alt="image-7832738"></p><p>我们启动SpringBoot程序，测试下三个配置文件中哪个Tomcat端口号生效：</p><ul><li>properties、yaml、yml三种配置文件同时存在</li></ul><p><img src="/2024/03/26/springboot/image-20230113144757856.png" alt="image-20230113144757856"></p><blockquote><p>properties、yaml、yml三种配置文件，优先级最高的是properties</p></blockquote><ul><li>yaml、yml两种配置文件同时存在</li></ul><p><img src="/2024/03/26/springboot/image-20230113145158771.png" alt="image-20230113145158771"></p><blockquote><p>配置文件优先级排名（从高到低）：</p><ol><li>properties配置文件</li><li>yml配置文件</li><li>yaml配置文件</li></ol></blockquote><p>注意事项：虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置。（yml是主流）</p><p>在SpringBoot项目当中除了以上3种配置文件外，SpringBoot为了增强程序的扩展性，除了支持配置文件的配置方式以外，还支持另外两种常见的配置方式：</p><ol><li><p>Java系统属性配置 （格式： -Dkey&#x3D;value）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dserver.port=9000</span><br></pre></td></tr></table></figure></li><li><p>命令行参数 （格式：–key&#x3D;value）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--server.port=10010</span><br></pre></td></tr></table></figure></li></ol><p>那在idea当中运行程序时，如何来指定Java系统属性和命令行参数呢？</p><ul><li>编辑启动程序的配置信息</li></ul><p><img src="/2024/03/26/springboot/image-20230113162746634.png" alt="image-20230113162746634"></p><p><img src="/2024/03/26/springboot/image-20230113162639630.png" alt="image-20230113162639630"></p><p>重启服务，同时配置Tomcat端口(三种配置文件、系统属性、命令行参数)，测试哪个Tomcat端口号生效：</p><p><img src="/2024/03/26/springboot/image-20230113165006550.png" alt="image-20230113165006550"></p><p>删除命令行参数配置，重启SpringBoot服务：</p><p><img src="/2024/03/26/springboot/image-20230113170841253.png" alt="image-20230113170841253"></p><blockquote><p>优先级： 命令行参数 &gt;  系统属性参数 &gt; properties参数 &gt; yml参数 &gt; yaml参数</p></blockquote><p>思考：如果项目已经打包上线了，这个时候我们又如何来设置Java系统属性和命令行参数呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=9000 -jar XXXXX.jar --server.port=10010</span><br></pre></td></tr></table></figure><p>下面我们来演示下打包程序运行时指定Java系统属性和命令行参数：</p><ol><li>执行maven打包指令package，把项目打成jar文件</li><li>使用命令：java -jar 方式运行jar文件程序</li></ol><p>项目打包：</p><p><img src="/2024/03/26/springboot/image-20230113172313655.png" alt="image-20230113172313655"></p><p><img src="/2024/03/26/springboot/image-20230113172854016.png" alt="image-20230113172854016"></p><p>运行jar程序：</p><ul><li>同时设置Java系统属性和命令行参数</li></ul><p><img src="/2024/03/26/springboot/image-20230113172659269.png" alt="image-20230113172659269"></p><ul><li>仅设置Java系统属性</li></ul><p><img src="/2024/03/26/springboot/image-20230113173228232.png" alt="image-20230113173228232"></p><blockquote><p>注意事项：</p><ul><li>Springboot项目进行打包时，需要引入插件 spring-boot-maven-plugin (基于官网骨架创建项目，会自动添加该插件)</li></ul></blockquote><p>在SpringBoot项目当中，常见的属性配置方式有5种， 3种配置文件，加上2种外部属性的配置(Java系统属性、命令行参数)。通过以上的测试，我们也得出了优先级(从低到高)：</p><ul><li>application.yaml（忽略）</li><li>application.yml</li><li>application.properties</li><li>java系统属性（-Dxxx&#x3D;xxx）</li><li>命令行参数（–xxx&#x3D;xxx）</li></ul><h2 id="2-Bean管理"><a href="#2-Bean管理" class="headerlink" title="2. Bean管理"></a>2. Bean管理</h2><p>在前面的课程当中，我们已经讲过了我们可以通过Spring当中提供的注解@Component以及它的三个衍生注解（@Controller、@Service、@Repository）来声明IOC容器中的bean对象，同时我们也学习了如何为应用程序注入运行时所需要依赖的bean对象，也就是依赖注入DI。</p><p>我们今天主要学习IOC容器中Bean的其他使用细节，主要学习以下三方面：</p><ol><li>如何从IOC容器中手动的获取到bean对象</li><li>bean的作用域配置</li><li>管理第三方的bean对象</li></ol><p>接下来我们先来学习第一方面，从IOC容器中获取bean对象。</p><h3 id="2-1-获取Bean"><a href="#2-1-获取Bean" class="headerlink" title="2.1 获取Bean"></a>2.1 获取Bean</h3><p>默认情况下，SpringBoot项目在启动的时候会自动的创建IOC容器(也称为Spring容器)，并且在启动的过程当中会自动的将bean对象都创建好，存放在IOC容器当中。应用程序在运行时需要依赖什么bean对象，就直接进行依赖注入就可以了。</p><p>而在Spring容器中提供了一些方法，可以主动从IOC容器中获取到bean对象，下面介绍3种常用方式：</p><ol><li><p>根据name获取bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure></li><li><p>根据类型获取bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span></span><br></pre></td></tr></table></figure></li><li><p>根据name获取bean（带类型转换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span></span><br></pre></td></tr></table></figure></li></ol><p>思考：要从IOC容器当中来获取到bean对象，需要先拿到IOC容器对象，怎么样才能拿到IOC容器呢？</p><ul><li>想获取到IOC容器，直接将IOC容器对象注入进来就可以了</li></ul><p>控制器：DeptController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/depts&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptService deptService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeptController</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DeptController constructor ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Dept&gt; deptList = deptService.list();</span><br><span class="line">        <span class="keyword">return</span> Result.success(deptList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>  &#123;</span><br><span class="line">        deptService.delete(id);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Dept dept)</span>&#123;</span><br><span class="line">        deptService.save(dept);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务实现类：DeptServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Dept&gt; deptList = deptMapper.list();</span><br><span class="line">        <span class="keyword">return</span> deptList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        deptMapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        dept.setCreateTime(LocalDateTime.now());</span><br><span class="line">        dept.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        deptMapper.save(dept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部部门数据</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from dept&quot;)</span></span><br><span class="line">    List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除部门</span></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from dept where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增部门</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into dept(name, create_time, update_time) values (#&#123;name&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Dept dept)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext; <span class="comment">//IOC容器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取bean对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//根据bean的名称获取</span></span><br><span class="line">        <span class="type">DeptController</span> <span class="variable">bean1</span> <span class="operator">=</span> (DeptController) applicationContext.getBean(<span class="string">&quot;deptController&quot;</span>);</span><br><span class="line">        System.out.println(bean1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据bean的类型获取</span></span><br><span class="line">        <span class="type">DeptController</span> <span class="variable">bean2</span> <span class="operator">=</span> applicationContext.getBean(DeptController.class);</span><br><span class="line">        System.out.println(bean2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据bean的名称 及 类型获取</span></span><br><span class="line">        <span class="type">DeptController</span> <span class="variable">bean3</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;deptController&quot;</span>, DeptController.class);</span><br><span class="line">        System.out.println(bean3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后控制台日志：</p><p><img src="/2024/03/26/springboot/image-20230113211619818.png" alt="image-20230113211619818"></p><blockquote><p>问题：输出的bean对象地址值是一样的，说明IOC容器当中的bean对象有几个？</p><p>答案：只有一个。        （默认情况下，IOC中的bean对象是单例）</p><p>那么能不能将bean对象设置为非单例的(每次获取的bean都是一个新对象)？</p><p>可以，在下一个知识点(bean作用域)中讲解。</p></blockquote><p>注意事项：</p><ul><li>上述所说的 【Spring项目启动时，会把其中的bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。</li></ul><h3 id="2-2-Bean作用域"><a href="#2-2-Bean作用域" class="headerlink" title="2.2 Bean作用域"></a>2.2 Bean作用域</h3><p>在前面我们提到的IOC容器当中，默认bean对象是单例模式(只有一个实例对象)。那么如何设置bean对象为非单例呢？需要设置bean的作用域。</p><p>在Spring中支持五种作用域，后三种在web环境才生效：</p><table><thead><tr><th><strong>作用域</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>singleton</td><td>容器内同名称的bean只有一个实例（单例）（默认）</td></tr><tr><td>prototype</td><td>每次使用该bean时会创建新的实例（非单例）</td></tr><tr><td>request</td><td>每个请求范围内会创建新的实例（web环境中，了解）</td></tr><tr><td>session</td><td>每个会话范围内会创建新的实例（web环境中，了解）</td></tr><tr><td>application</td><td>每个应用范围内会创建新的实例（web环境中，了解）</td></tr></tbody></table><p>知道了bean的5种作用域了，我们要怎么去设置一个bean的作用域呢？</p><ul><li>可以借助Spring中的@Scope注解来进行配置作用域</li></ul><p><img src="/2024/03/26/springboot/image-20230113214244144.png" alt="image-20230113214244144"></p><p><strong>1). 测试一</strong></p><ul><li>控制器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认bean的作用域为：singleton (单例)</span></span><br><span class="line"><span class="meta">@Lazy</span> <span class="comment">//延迟加载（第一次使用bean对象时，才会创建bean对象并交给ioc容器管理）</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/depts&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptService deptService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeptController</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DeptController constructor ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext; <span class="comment">//IOC容器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean的作用域</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScope</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">DeptController</span> <span class="variable">deptController</span> <span class="operator">=</span> applicationContext.getBean(DeptController.class);</span><br><span class="line">            System.out.println(deptController);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启SpringBoot服务，运行测试方法，查看控制台打印的日志：</p><p><img src="/2024/03/26/springboot/image-20230114001348839.png" alt="image-20230114001348839"></p><blockquote><p>注意事项：</p><ul><li><p>IOC容器中的bean默认使用的作用域：singleton (单例)</p></li><li><p>默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化(延迟到第一次使用时)</p></li></ul></blockquote><p><strong>2). 测试二</strong></p><p>修改控制器DeptController代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">//bean作用域为非单例</span></span><br><span class="line"><span class="meta">@Lazy</span> <span class="comment">//延迟加载</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/depts&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptService deptService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeptController</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DeptController constructor ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启SpringBoot服务，再次执行测试方法，查看控制吧打印的日志：</p><p><img src="/2024/03/26/springboot/image-20230114001736151.png" alt="image-20230114001736151"></p><blockquote><p>注意事项：</p><ul><li>prototype的bean，每一次使用该bean的时候都会创建一个新的实例</li><li>实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性</li></ul></blockquote><h3 id="2-3-第三方Bean"><a href="#2-3-第三方Bean" class="headerlink" title="2.3 第三方Bean"></a>2.3 第三方Bean</h3><p>学习完bean的获取、bean的作用域之后，接下来我们再来学习第三方bean的配置。</p><p>之前我们所配置的bean，像controller、service，dao三层体系下编写的类，这些类都是我们在项目当中自己定义的类(自定义类)。当我们要声明这些bean，也非常简单，我们只需要在类上加上@Component以及它的这三个衍生注解（@Controller、@Service、@Repository），就可以来声明这个bean对象了。<br>但是在我们项目开发当中，还有一种情况就是这个类它不是我们自己编写的，而是我们引入的第三方依赖当中提供的。</p><p>在pom.xml文件中，引入dom4j：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Dom4j--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>dom4j就是第三方组织提供的。 dom4j中的SAXReader类就是第三方编写的。</p></blockquote><p>当我们需要使用到SAXReader对象时，直接进行依赖注入是不是就可以了呢？</p><ul><li>按照我们之前的做法，需要在SAXReader类上添加一个注解@Component（将当前类交给IOC容器管理）</li></ul><p><img src="/2024/03/26/springboot/image-20230114003903285.png" alt="image-20230114003903285"></p><blockquote><p>结论：第三方提供的类是只读的。无法在第三方类上添加@Component注解或衍生注解。</p></blockquote><p>那么我们应该怎样使用并定义第三方的bean呢？</p><ul><li>如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component 及衍生注解声明bean的，就需要用到**@Bean**注解。</li></ul><p><strong>解决方案1：在启动类上添加@Bean标识的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明第三方bean</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span></span><br><span class="line">    <span class="keyword">public</span> SAXReader <span class="title function_">saxReader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">emp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">emp</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SAXReader saxReader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三方bean的管理</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testThirdBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;1.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rootElement.element(<span class="string">&quot;name&quot;</span>).getText();</span><br><span class="line">        <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> rootElement.element(<span class="string">&quot;age&quot;</span>).getText();</span><br><span class="line"></span><br><span class="line">        System.out.println(name + <span class="string">&quot; : &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重启SpringBoot服务，执行测试方法后，控制台输出日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tom : 18</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：以上在启动类中声明第三方Bean的作法，不建议使用（项目中要保证启动类的纯粹性）</strong></p></blockquote><p><strong>解决方案2：在配置类中定义@Bean标识的方法</strong></p><ul><li>如果需要定义第三方Bean时， 通常会单独定义一个配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类  (在配置类当中对第三方bean进行集中的配置管理)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明第三方bean</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span></span><br><span class="line">          <span class="comment">//通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名</span></span><br><span class="line">    <span class="keyword">public</span> SAXReader <span class="title function_">reader</span><span class="params">(DeptService deptService)</span>&#123;</span><br><span class="line">        System.out.println(deptService);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注释掉SpringBoot启动类中创建第三方bean对象的代码，重启服务，执行测试方法，查看控制台日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tom : 18</span><br></pre></td></tr></table></figure><p>在方法上加上一个@Bean注解，Spring 容器在启动的时候，它会自动的调用这个方法，并将方法的返回值声明为Spring容器当中的Bean对象。</p><blockquote><p>注意事项 ：</p><ul><li><p>通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。</p></li><li><p>如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。</p></li></ul></blockquote><p>关于Bean大家只需要保持一个原则：</p><ul><li>如果是在项目当中我们自己定义的类，想将这些类交给IOC容器管理，我们直接使用@Component以及它的衍生注解来声明就可以。</li><li>如果这个类它不是我们自己定义的，而是引入的第三方依赖当中提供的类，而且我们还想将这个类交给IOC容器管理。此时我们就需要在配置类中定义一个方法，在方法上加上一个@Bean注解，通过这种方式来声明第三方的bean对象。</li></ul><h2 id="3-SpringBoot原理"><a href="#3-SpringBoot原理" class="headerlink" title="3. SpringBoot原理"></a>3. SpringBoot原理</h2><p>经过前面10多天课程的学习，大家也会发现基于SpringBoot进行web程序的开发是非常简单、非常高效的。</p><p>SpringBoot使我们能够集中精力地去关注业务功能的开发，而不用过多地关注框架本身的配置使用。而我们前面所讲解的都是面向应用层面的技术，接下来我们开始学习SpringBoot的原理，这部分内容偏向于底层的原理分析。</p><p>在剖析SpringBoot的原理之前，我们先来快速回顾一下我们前面所讲解的Spring家族的框架。</p><p><img src="/2024/03/26/springboot/image-20230114171304644.png" alt="image-20230114171304644"></p><p>Spring是目前世界上最流行的Java框架，它可以帮助我们更加快速、更加容易的来构建Java项目。而在Spring家族当中提供了很多优秀的框架，而所有的框架都是基于一个基础框架的SpringFramework(也就是Spring框架)。而前面我们也提到，如果我们直接基于Spring框架进行项目的开发，会比较繁琐。</p><p>这个繁琐主要体现在两个地方：</p><ol><li>在pom.xml中依赖配置比较繁琐，在项目开发时，需要自己去找到对应的依赖，还需要找到依赖它所配套的依赖以及对应版本，否则就会出现版本冲突问题。</li><li>在使用Spring框架进行项目开发时，需要在Spring的配置文件中做大量的配置，这就造成Spring框架入门难度较大，学习成本较高。</li></ol><p><img src="/2024/03/26/springboot/image-20230114170610438.png" alt="image-20230114170610438"></p><blockquote><p>基于Spring存在的问题，官方在Spring框架4.0版本之后，又推出了一个全新的框架：SpringBoot。</p><p>通过 SpringBoot来简化Spring框架的开发(是简化不是替代)。我们直接基于SpringBoot来构建Java项目，会让我们的项目开发更加简单，更加快捷。</p></blockquote><p>SpringBoot框架之所以使用起来更简单更快捷，是因为SpringBoot框架底层提供了两个非常重要的功能：一个是起步依赖，一个是自动配置。</p><p><img src="/2024/03/26/springboot/image-20230114172442018.png" alt="image-20230114172442018"></p><blockquote><p>通过SpringBoot所提供的起步依赖，就可以大大的简化pom文件当中依赖的配置，从而解决了Spring框架当中依赖配置繁琐的问题。</p><p>通过自动配置的功能就可以大大的简化框架在使用时bean的声明以及bean的配置。我们只需要引入程序开发时所需要的起步依赖，项目开发时所用到常见的配置都已经有了，我们直接使用就可以了。</p></blockquote><p>简单回顾之后，接下来我们来学习下SpringBoot的原理。其实学习SpringBoot的原理就是来解析SpringBoot当中的起步依赖与自动配置的原理。我们首先来学习SpringBoot当中起步依赖的原理。</p><h3 id="3-1-起步依赖"><a href="#3-1-起步依赖" class="headerlink" title="3.1 起步依赖"></a>3.1 起步依赖</h3><p>假如我们没有使用SpringBoot，用的是Spring框架进行web程序的开发，此时我们就需要引入web程序开发所需要的一些依赖。</p><p><img src="/2024/03/26/springboot/image-20230114173645101.png" alt="image-20230114173645101"></p><blockquote><p>spring-webmvc依赖：这是Spring框架进行web程序开发所需要的依赖</p><p>servlet-api依赖：Servlet基础依赖</p><p>jackson-databind依赖：JSON处理工具包</p><p>如果要使用AOP，还需要引入aop依赖、aspect依赖</p><p>项目中所引入的这些依赖，还需要保证版本匹配，否则就可能会出现版本冲突问题。</p></blockquote><p>如果我们使用了SpringBoot，就不需要像上面这么繁琐的引入依赖了。我们只需要引入一个依赖就可以了，那就是web开发的起步依赖：springboot-starter-web。</p><p><img src="/2024/03/26/springboot/image-20230114174805852.png" alt="image-20230114174805852"></p><p>为什么我们只需要引入一个web开发的起步依赖，web开发所需要的所有的依赖都有了呢？</p><ul><li>因为Maven的依赖传递。</li></ul><blockquote><ul><li><p>在SpringBoot给我们提供的这些起步依赖当中，已提供了当前程序开发所需要的所有的常见依赖(官网地址：<a href="https://docs.spring.io/spring-boot/docs/2.7.7/reference/htmlsingle/#using.build-systems.starters)%E3%80%82">https://docs.spring.io/spring-boot/docs/2.7.7/reference/htmlsingle/#using.build-systems.starters)。</a></p></li><li><p>比如：springboot-starter-web，这是web开发的起步依赖，在web开发的起步依赖当中，就集成了web开发中常见的依赖：json、web、webmvc、tomcat等。我们只需要引入这一个起步依赖，其他的依赖都会自动的通过Maven的依赖传递进来。</p></li></ul></blockquote><p><strong>结论：起步依赖的原理就是Maven的依赖传递。</strong></p><h3 id="3-2-自动配置"><a href="#3-2-自动配置" class="headerlink" title="3.2 自动配置"></a>3.2 自动配置</h3><p>我们讲解了SpringBoot当中起步依赖的原理，就是Maven的依赖传递。接下来我们解析下自动配置的原理，我们要分析自动配置的原理，首先要知道什么是自动配置。</p><h4 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h4><p>SpringBoot的自动配置就是当Spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。</p><blockquote><p>比如：我们要进行事务管理、要进行AOP程序的开发，此时就不需要我们再去手动的声明这些bean对象了，我们直接使用就可以从而大大的简化程序的开发，省去了繁琐的配置操作。</p></blockquote><p>下面我们打开idea，一起来看下自动配置的效果：</p><ul><li>运行SpringBoot启动类</li></ul><p><img src="/2024/03/26/springboot/image-20230114205745221.png" alt="image-20230114205745221"></p><p><img src="/2024/03/26/springboot/image-20230114213945851.png" alt="image-20230114213945851"></p><p><img src="/2024/03/26/springboot/image-20230114212750007.png" alt="image-20230114212750007"></p><p>大家会看到有两个CommonConfig，在第一个CommonConfig类中定义了一个bean对象，bean对象的名字叫reader。</p><p>在第二个CommonConfig中它的bean名字叫commonConfig，为什么还会有这样一个bean对象呢？原因是在CommonConfig配置类上添加了一个注解@Configuration，而@Configuration底层就是@Component</p><p><img src="/2024/03/26/springboot/image-20230114220159619.png" alt="image-20230114220159619"></p><blockquote><p>所以配置类最终也是SpringIOC容器当中的一个bean对象</p></blockquote><p>在IOC容器中除了我们自己定义的bean以外，还有很多配置类，这些配置类都是SpringBoot在启动的时候加载进来的配置类。这些配置类加载进来之后，它也会生成很多的bean对象。</p><p><img src="/2024/03/26/springboot/image-20230114221341811.png" alt="image-20230114221341811"></p><blockquote><p>比如：配置类GsonAutoConfiguration里面有一个bean，bean的名字叫gson，它的类型是Gson。 </p><p>com.google.gson.Gson是谷歌包中提供的用来处理JSON格式数据的。</p></blockquote><p>当我们想要使用这些配置类中生成的bean对象时，可以使用@Autowired就自动注入了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.itheima.pojo.Result;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJson</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> gson.toJson(Result.success());</span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加断点，使用debug模式运行测试类程序：</p><p><img src="/2024/03/26/springboot/image-20230114222245520.png" alt="image-20230114222245520"></p><p>问题：在当前项目中我们并没有声明谷歌提供的Gson这么一个bean对象，然后我们却可以通过@Autowired从Spring容器中注入bean对象，那么这个bean对象怎么来的？</p><p>答案：SpringBoot项目在启动时通过自动配置完成了bean对象的创建。</p><p>体验了SpringBoot的自动配置了，下面我们就来分析自动配置的原理。其实分析自动配置原理就是来解析在SpringBoot项目中，在引入依赖之后是如何将依赖jar包当中所定义的配置类以及bean加载到SpringIOC容器中的。</p><h4 id="3-2-2-常见方案"><a href="#3-2-2-常见方案" class="headerlink" title="3.2.2 常见方案"></a>3.2.2 常见方案</h4><h5 id="3-2-2-1-概述"><a href="#3-2-2-1-概述" class="headerlink" title="3.2.2.1 概述"></a>3.2.2.1 概述</h5><p>我们知道了什么是自动配置之后，接下来我们就要来剖析自动配置的原理。解析自动配置的原理就是分析在 SpringBoot项目当中，我们引入对应的依赖之后，是如何将依赖jar包当中所提供的bean以及配置类直接加载到当前项目的SpringIOC容器当中的。</p><p>接下来，我们就直接通过代码来分析自动配置原理。</p><blockquote><p>准备工作：在Idea中导入”资料\03. 自动配置原理”下的itheima-utils工程</p></blockquote><p>1、在SpringBoot项目 spring-boot-web-config2 工程中，通过坐标引入itheima-utils依赖</p><p><img src="/2024/03/26/springboot/image-20230114224107653.png" alt="image-20230114224107653"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenParser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TokenParser ... parse ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在测试类中，添加测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTokenParse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(TokenParser.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、执行测试方法</p><p><img src="/2024/03/26/springboot/image-20230114225018255.png" alt="image-20230114225018255"></p><blockquote><p>异常信息描述： 没有com.example.TokenParse类型的bean</p><p>说明：在Spring容器中没有找到com.example.TokenParse类型的bean对象</p></blockquote><p>思考：引入进来的第三方依赖当中的bean以及配置类为什么没有生效？</p><ul><li>原因在我们之前讲解IOC的时候有提到过，在类上添加@Component注解来声明bean对象时，还需要保证@Component注解能被Spring的组件扫描到。</li><li>SpringBoot项目中的@SpringBootApplication注解，具有包扫描的作用，但是它只会扫描启动类所在的当前包以及子包。 </li><li>当前包：com.itheima， 第三方依赖中提供的包：com.example（扫描不到）</li></ul><p>那么如何解决以上问题的呢？</p><ul><li>方案1：@ComponentScan 组件扫描</li><li>方案2：@Import 导入（使用@Import导入的类会被Spring加载到IOC容器中）</li></ul><h5 id="3-2-2-2-方案一"><a href="#3-2-2-2-方案一" class="headerlink" title="3.2.2.2 方案一"></a>3.2.2.2 方案一</h5><p>@ComponentScan组件扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima&quot;,&quot;com.example&quot;&#125;)</span> <span class="comment">//指定要扫描的包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新执行测试方法，控制台日志输出：</p><p><img src="/2024/03/26/springboot/image-20230114231121016.png" alt="image-20230114231121016"></p><blockquote><p>大家可以想象一下，如果采用以上这种方式来完成自动配置，那我们进行项目开发时，当需要引入大量的第三方的依赖，就需要在启动类上配置N多要扫描的包，这种方式会很繁琐。而且这种大面积的扫描性能也比较低。</p><p>缺点：</p><ol><li>使用繁琐</li><li>性能低</li></ol><p><strong>结论：SpringBoot中并没有采用以上这种方案。</strong></p></blockquote><h5 id="3-2-2-3-方案二"><a href="#3-2-2-3-方案二" class="headerlink" title="3.2.2.3 方案二"></a>3.2.2.3 方案二</h5><p>@Import导入</p><ul><li>导入形式主要有以下几种：<ol><li>导入普通类</li><li>导入配置类</li><li>导入ImportSelector接口实现类</li></ol></li></ul><p>1). 使用@Import导入普通类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(TokenParser.class)</span> <span class="comment">//导入的类会被Spring加载到IOC容器中</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重新执行测试方法，控制台日志输出：</p><p><img src="/2024/03/26/springboot/image-20230114231709392.png" alt="image-20230114231709392"></p></blockquote><p>2). 使用@Import导入配置类：</p><ul><li>配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HeaderGenerator <span class="title function_">headerGenerator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(HeaderConfig.class)</span> <span class="comment">//导入配置类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHeaderParser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(HeaderParser.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHeaderGenerator</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(HeaderGenerator.class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行测试方法：</p><p><img src="/2024/03/26/springboot/image-20230114233252259.png" alt="image-20230114233252259"></p></blockquote><p>3). 使用@Import导入ImportSelector接口实现类：</p><ul><li>ImportSelector接口实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="comment">//返回值字符串数组（数组中封装了全限定名称的类）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.example.HeaderConfig&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(MyImportSelector.class)</span> <span class="comment">//导入ImportSelector接口实现类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行测试方法：</p><p><img src="/2024/03/26/springboot/image-20230114234222946.png" alt="image-20230114234222946"></p></blockquote><p>我们使用@Import注解通过这三种方式都可以导入第三方依赖中所提供的bean或者是配置类。</p><p>思考：如果基于以上方式完成自动配置，当要引入一个第三方依赖时，是不是还要知道第三方依赖中有哪些配置类和哪些Bean对象？</p><ul><li>答案：是的。 （对程序员来讲，很不友好，而且比较繁琐）</li></ul><p>思考：当我们要使用第三方依赖，依赖中到底有哪些bean和配置类，谁最清楚？</p><ul><li>答案：第三方依赖自身最清楚。</li></ul><blockquote><p><strong>结论：我们不用自己指定要导入哪些bean对象和配置类了，让第三方依赖它自己来指定。</strong></p></blockquote><p>怎么让第三方依赖自己指定bean对象和配置类？</p><ul><li>比较常见的方案就是第三方依赖给我们提供一个注解，这个注解一般都以@EnableXxxx开头的注解，注解中封装的就是@Import注解</li></ul><p>4). 使用第三方依赖提供的 @EnableXxxxx注解</p><ul><li>第三方依赖中提供的注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span><span class="comment">//指定要导入哪些bean对象或配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHeaderConfig &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在使用时只需在启动类上加上@EnableXxxxx注解即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHeaderConfig</span>  <span class="comment">//使用第三方依赖提供的Enable开头的注解</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行测试方法：</p><p><img src="/2024/03/26/springboot/image-20230114233252259.png" alt="image-20230114233252259"></p></blockquote><p>以上四种方式都可以完成导入操作，但是第4种方式会更方便更优雅，而这种方式也是SpringBoot当中所采用的方式。</p><h4 id="3-2-3-原理分析"><a href="#3-2-3-原理分析" class="headerlink" title="3.2.3 原理分析"></a>3.2.3 原理分析</h4><h5 id="3-2-3-1-源码跟踪"><a href="#3-2-3-1-源码跟踪" class="headerlink" title="3.2.3.1 源码跟踪"></a>3.2.3.1 源码跟踪</h5><p>前面我们讲解了在项目当中引入第三方依赖之后，如何加载第三方依赖中定义好的bean对象以及配置类，从而完成自动配置操作。那下面我们通过源码跟踪的形式来剖析下SpringBoot底层到底是如何完成自动配置的。</p><blockquote><p>源码跟踪技巧：</p><p>在跟踪框架源码的时候，一定要抓住关键点，找到核心流程。一定不要从头到尾一行代码去看，一个方法的去研究，一定要找到关键流程，抓住关键点，先在宏观上对整个流程或者整个原理有一个认识，有精力再去研究其中的细节。</p></blockquote><p>要搞清楚SpringBoot的自动配置原理，要从SpringBoot启动类上使用的核心注解@SpringBootApplication开始分析：</p><p><img src="/2024/03/26/springboot/image-20230115001439110.png" alt="image-20230115001439110"></p><p>在@SpringBootApplication注解中包含了：</p><ul><li>元注解（不再解释）</li><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>我们先来看第一个注解：@SpringBootConfiguration</p><p><img src="/2024/03/26/springboot/image-20230115001950076.png" alt="image-20230115001950076"></p><blockquote><p>@SpringBootConfiguration注解上使用了@Configuration，表明SpringBoot启动类就是一个配置类。</p><p>@Indexed注解，是用来加速应用启动的（不用关心）。</p></blockquote><p>接下来再先看@ComponentScan注解：</p><p><img src="/2024/03/26/springboot/image-20230115002450993.png" alt="image-20230115002450993"></p><blockquote><p>@ComponentScan注解是用来进行组件扫描的，扫描启动类所在的包及其子包下所有被@Component及其衍生注解声明的类。</p><p>SpringBoot启动类，之所以具备扫描包功能，就是因为包含了@ComponentScan注解。</p></blockquote><p>最后我们来看看@EnableAutoConfiguration注解（自动配置核心注解）：</p><p><img src="/2024/03/26/springboot/image-20230115002743115.png" alt="image-20230115002743115"></p><blockquote><p>使用@Import注解，导入了实现ImportSelector接口的实现类。</p><p>AutoConfigurationImportSelector类是ImportSelector接口的实现类。</p><p><img src="/2024/03/26/springboot/image-20230115003242549.png" alt="image-20230115003242549"></p></blockquote><p>AutoConfigurationImportSelector类中重写了ImportSelector接口的selectImports()方法：</p><p><img src="/2024/03/26/springboot/image-20230115003348288.png" alt="image-20230115003348288"></p><blockquote><p>selectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合</p></blockquote><p><img src="/2024/03/26/springboot/image-20230115003704385.png" alt="image-20230115003704385"></p><blockquote><p>getAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合</p></blockquote><p><img src="/2024/03/26/springboot/image-20230115003903302.png" alt="image-20230115003903302"></p><blockquote><p>getCandidateConfigurations方法的功能：</p><p>获取所有基于META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports文件、META-INF&#x2F;spring.factories文件中配置类的集合</p></blockquote><p>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports文件和META-INF&#x2F;spring.factories文件这两个文件在哪里呢？</p><ul><li>通常在引入的起步依赖中，都有包含以上两个文件</li></ul><p><img src="/2024/03/26/springboot/image-20230129090835964.png" alt="image-20230129090835964"> </p><p><img src="/2024/03/26/springboot/image-20230115064329460.png" alt="image-20230115064329460"></p><p>在前面在给大家演示自动配置的时候，我们直接在测试类当中注入了一个叫gson的bean对象，进行JSON格式转换。虽然我们没有配置bean对象，但是我们是可以直接注入使用的。原因就是因为在自动配置类当中做了自动配置。到底是在哪个自动配置类当中做的自动配置呢？我们通过搜索来查询一下。</p><p>在META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports配置文件中指定了第三方依赖Gson的配置类：GsonAutoConfiguration</p><p><img src="/2024/03/26/springboot/image-20230115005159530.png" alt="image-20230115005159530"></p><p>第三方依赖中提供的GsonAutoConfiguration类：</p><p><img src="/2024/03/26/springboot/image-20230115005418900.png" alt="image-20230115005418900"></p><blockquote><p>在GsonAutoConfiguration类上，添加了注解@AutoConfiguration，通过查看源码，可以明确：GsonAutoConfiguration类是一个配置。</p><p><img src="/2024/03/26/springboot/image-20230115065247287.png" alt="image-20230115065247287"></p></blockquote><p>看到这里，大家就应该明白为什么可以完成自动配置了，原理就是在配置类中定义一个@Bean标识的方法，而Spring会自动调用配置类中使用@Bean标识的方法，并把方法的返回值注册到IOC容器中。</p><p><strong>自动配置源码小结</strong></p><p>自动配置原理源码入口就是@SpringBootApplication注解，在这个注解中封装了3个注解，分别是：</p><ul><li>@SpringBootConfiguration<ul><li>声明当前类是一个配置类</li></ul></li><li>@ComponentScan<ul><li>进行组件扫描（SpringBoot中默认扫描的是启动类所在的当前包及其子包）</li></ul></li><li>@EnableAutoConfiguration<ul><li>封装了@Import注解（Import注解中指定了一个ImportSelector接口的实现类）<ul><li>在实现类重写的selectImports()方法，读取当前项目下所有依赖jar包中META-INF&#x2F;spring.factories、META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports两个文件里面定义的配置类（配置类中定义了@Bean注解标识的方法）。</li></ul></li></ul></li></ul><p>当SpringBoot程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息(类的全限定名)封装到String类型的数组中，最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中，交给IOC容器管理。</p><blockquote><p>最后呢给大家抛出一个问题：在META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，那这些bean都会注册到Spring的IOC容器中吗？</p><p>答案：并不是。 在声明bean对象时，上面有加一个以@Conditional开头的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）</p></blockquote><h5 id="3-2-3-2-Conditional"><a href="#3-2-3-2-Conditional" class="headerlink" title="3.2.3.2 @Conditional"></a>3.2.3.2 @Conditional</h5><p>我们在跟踪SpringBoot自动配置的源码的时候，在自动配置类声明bean的时候，除了在方法上加了一个@Bean注解以外，还会经常用到一个注解，就是以Conditional开头的这一类的注解。以Conditional开头的这些注解都是条件装配的注解。下面我们就来介绍下条件装配注解。</p><p>@Conditional注解：</p><ul><li>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring的IOC容器中。</li><li>位置：方法、类</li><li>@Conditional本身是一个父注解，派生出大量的子注解：<ul><li>@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。</li><li>@ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。</li><li>@ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。</li></ul></li></ul><p>下面我们通过代码来演示下Conditional注解的使用：</p><ul><li>@ConditionalOnClass注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name=&quot;io.jsonwebtoken.Jwts&quot;)</span><span class="comment">//环境中存在指定的这个类，才会将该bean加入IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pom.xml</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--JWT令牌--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">0.9</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHeaderParser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(HeaderParser.class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行testHeaderParser()测试方法：</p><p><img src="/2024/03/26/springboot/image-20230115203748022.png" alt="image-20230115203748022"></p><p>因为io.jsonwebtoken.Jwts字节码文件在启动SpringBoot程序时已存在，所以创建HeaderParser对象并注册到IOC容器中。</p></blockquote><ul><li>@ConditionalOnMissingBean注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">//不存在该类型的bean，才会将该bean加入IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行testHeaderParser()测试方法：</p><p><img src="/2024/03/26/springboot/image-20230115211029855.png" alt="image-20230115211029855"></p><p>SpringBoot在调用@Bean标识的headerParser()前，IOC容器中是没有HeaderParser类型的bean，所以HeaderParser对象正常创建，并注册到IOC容器中。</p></blockquote><p>再次修改@ConditionalOnMissingBean注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name=&quot;deptController2&quot;)</span><span class="comment">//不存在指定名称的bean，才会将该bean加入IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行testHeaderParser()测试方法：</p><p><img src="/2024/03/26/springboot/image-20230115211351681.png" alt="image-20230115211351681"></p><p>因为在SpringBoot环境中不存在名字叫deptController2的bean对象，所以创建HeaderParser对象并注册到IOC容器中。</p></blockquote><p>再次修改@ConditionalOnMissingBean注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(HeaderConfig.class)</span><span class="comment">//不存在指定类型的bean，才会将bean加入IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHeaderParser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(HeaderParser.class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行testHeaderParser()测试方法：</p><p><img src="/2024/03/26/springboot/image-20230115211957191.png" alt="image-20230115211957191"></p><p>因为HeaderConfig类中添加@Configuration注解，而@Configuration注解中包含了@Component，所以SpringBoot启动时会创建HeaderConfig类对象，并注册到IOC容器中。</p><p>当IOC容器中有HeaderConfig类型的bean存在时，不会把创建HeaderParser对象注册到IOC容器中。而IOC容器中没有HeaderParser类型的对象时，通过getBean(HeaderParser.class)方法获取bean对象时，引发异常：NoSuchBeanDefinitionException</p></blockquote><ul><li>@ConditionalOnProperty注解（这个注解和配置文件当中配置的属性有关系）</li></ul><p>先在application.yml配置文件中添加如下的键值对：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">itheima</span></span><br></pre></td></tr></table></figure><p>在声明bean的时候就可以指定一个条件@ConditionalOnProperty</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(name =&quot;name&quot;,havingValue = &quot;itheima&quot;)</span><span class="comment">//配置文件中存在指定属性名与值，才会将bean加入IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HeaderGenerator <span class="title function_">headerGenerator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行testHeaderParser()测试方法：</p><p><img src="/2024/03/26/springboot/image-20230115220235511.png" alt="image-20230115220235511"></p></blockquote><p>修改@ConditionalOnProperty注解：  havingValue的值修改为”itheima2”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name =&quot;name&quot;,havingValue = &quot;itheima2&quot;)</span><span class="comment">//配置文件中存在指定属性名与值，才会将bean加入IOC容器</span></span><br><span class="line"><span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再次执行testHeaderParser()测试方法：</p><p><img src="/2024/03/26/springboot/image-20230115211957191.png" alt="image-20230115211957191"></p><p>因为application.yml配置文件中，不存在： name:  itheima2，所以HeaderParser对象在IOC容器中不存在</p></blockquote><p>我们再回头看看之前讲解SpringBoot源码时提到的一个配置类：GsonAutoConfiguration</p><p><img src="/2024/03/26/springboot/image-20230115222128740.png" alt="image-20230115222128740"></p><p>最后再给大家梳理一下自动配置原理：</p><p><img src="/2024/03/26/springboot/image-20230115222302753.png" alt="image-20230115222302753"></p><blockquote><p>自动配置的核心就在@SpringBootApplication注解上，SpringBootApplication这个注解底层包含了3个注解，分别是：</p><ul><li><p>@SpringBootConfiguration</p></li><li><p>@ComponentScan</p></li><li><p>@EnableAutoConfiguration</p></li></ul><p>@EnableAutoConfiguration这个注解才是自动配置的核心。</p><ul><li>它封装了一个@Import注解，Import注解里面指定了一个ImportSelector接口的实现类。</li><li>在这个实现类中，重写了ImportSelector接口中的selectImports()方法。</li><li>而selectImports()方法中会去读取两份配置文件，并将配置文件中定义的配置类做为selectImports()方法的返回值返回，返回值代表的就是需要将哪些类交给Spring的IOC容器进行管理。</li><li>那么所有自动配置类的中声明的bean都会加载到Spring的IOC容器中吗? 其实并不会，因为这些配置类中在声明bean时，通常都会添加@Conditional开头的注解，这个注解就是进行条件装配。而Spring会根据Conditional注解有选择性的进行bean的创建。</li><li>@Enable 开头的注解底层，它就封装了一个注解 import 注解，它里面指定了一个类，是 ImportSelector 接口的实现类。在实现类当中，我们需要去实现 ImportSelector  接口当中的一个方法 selectImports 这个方法。这个方法的返回值代表的就是我需要将哪些类交给 spring 的 IOC容器进行管理。</li><li>此时它会去读取两份配置文件，一份儿是 spring.factories，另外一份儿是 autoConfiguration.imports。而在  autoConfiguration.imports 这份儿文件当中，它就会去配置大量的自动配置的类。</li><li>而前面我们也提到过这些所有的自动配置类当中，所有的 bean都会加载到 spring 的 IOC 容器当中吗？其实并不会，因为这些配置类当中，在声明 bean 的时候，通常会加上这么一类@Conditional 开头的注解。这个注解就是进行条件装配。所以SpringBoot非常的智能，它会根据 @Conditional 注解来进行条件装配。只有条件成立，它才会声明这个bean，才会将这个 bean 交给 IOC 容器管理。</li></ul></blockquote><h4 id="3-2-4-案例"><a href="#3-2-4-案例" class="headerlink" title="3.2.4 案例"></a>3.2.4 案例</h4><h5 id="3-2-4-1-自定义starter分析"><a href="#3-2-4-1-自定义starter分析" class="headerlink" title="3.2.4.1 自定义starter分析"></a>3.2.4.1 自定义starter分析</h5><p>前面我们解析了SpringBoot中自动配置的原理，下面我们就通过一个自定义starter案例来加深大家对于自动配置原理的理解。首先介绍一下自定义starter的业务场景，再来分析一下具体的操作步骤。</p><p>所谓starter指的就是SpringBoot当中的起步依赖。在SpringBoot当中已经给我们提供了很多的起步依赖了，我们为什么还需要自定义 starter 起步依赖？这是因为在实际的项目开发当中，我们可能会用到很多第三方的技术，并不是所有的第三方的技术官方都给我们提供了与SpringBoot整合的starter起步依赖，但是这些技术又非常的通用，在很多项目组当中都在使用。</p><p>业务场景：</p><ul><li>我们前面案例当中所使用的阿里云OSS对象存储服务，现在阿里云的官方是没有给我们提供对应的起步依赖的，这个时候使用起来就会比较繁琐，我们需要引入对应的依赖。我们还需要在配置文件当中进行配置，还需要基于官方SDK示例来改造对应的工具类，我们在项目当中才可以进行使用。</li><li>大家想在我们当前项目当中使用了阿里云OSS，我们需要进行这么多步的操作。在别的项目组当中要想使用阿里云OSS，是不是也需要进行这么多步的操作，所以这个时候我们就可以自定义一些公共组件，在这些公共组件当中，我就可以提前把需要配置的bean都提前配置好。将来在项目当中，我要想使用这个技术，我直接将组件对应的坐标直接引入进来，就已经自动配置好了，就可以直接使用了。我们也可以把公共组件提供给别的项目组进行使用，这样就可以大大的简化我们的开发。</li></ul><p>在SpringBoot项目中，一般都会将这些公共组件封装为SpringBoot当中的starter，也就是我们所说的起步依赖。</p><p><img src="/2024/03/26/springboot/image-20230115224939131.png" alt="image-20230115224939131"></p><blockquote><p>SpringBoot官方starter命名： spring-boot-starter-xxxx</p><p>第三组织提供的starter命名：  xxxx-spring-boot-starter</p></blockquote><p><img src="/2024/03/26/springboot/image-20230115225703863.png" alt="image-20230115225703863"></p><blockquote><p>Mybatis提供了配置类，并且也提供了springboot会自动读取的配置文件。当SpringBoot项目启动时，会读取到spring.factories配置文件中的配置类并加载配置类，生成相关bean对象注册到IOC容器中。</p><p>结果：我们可以直接在SpringBoot程序中使用Mybatis自动配置的bean对象。</p></blockquote><p>在自定义一个起步依赖starter的时候，按照规范需要定义两个模块：</p><ol><li>starter模块（进行依赖管理[把程序开发所需要的依赖都定义在starter起步依赖中]）</li><li>autoconfigure模块（自动配置）</li></ol><blockquote><p>将来在项目当中进行相关功能开发时，只需要引入一个起步依赖就可以了，因为它会将autoconfigure自动配置的依赖给传递下来。</p></blockquote><p>上面我们简单介绍了自定义starter的场景，以及自定义starter时涉及到的模块之后，接下来我们就来完成一个自定义starter的案例。</p><p>需求：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类AliyunOSSUtils的自动配置。</p><p>目标：引入起步依赖引入之后，要想使用阿里云OSS，注入AliyunOSSUtils直接使用即可。</p><p>之前阿里云OSS的使用：</p><ul><li>配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置阿里云OSS参数</span></span><br><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">oss:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">https://oss-cn-shanghai.aliyuncs.com</span></span><br><span class="line">    <span class="attr">accessKeyId:</span> <span class="string">LTAI5t9MZK8iq5T2Av5GLDxX</span></span><br><span class="line">    <span class="attr">accessKeySecret:</span> <span class="string">C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc</span></span><br><span class="line">    <span class="attr">bucketName:</span> <span class="string">web-framework01</span></span><br></pre></td></tr></table></figure><ul><li>AliOSSProperties类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSProperties</span> &#123;</span><br><span class="line">    <span class="comment">//区域</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="comment">//身份ID</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId ;</span><br><span class="line">    <span class="comment">//身份密钥</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret ;</span><br><span class="line">    <span class="comment">//存储空间</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>AliOSSUtils工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//当前类对象由Spring创建和管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSUtils</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliOSSProperties aliOSSProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现上传图片到OSS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取上传的文件的输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> multipartFile.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免文件覆盖</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> multipartFile.getOriginalFilename();</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上传文件到 OSS</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(aliOSSProperties.getEndpoint(),</span><br><span class="line">                aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret());</span><br><span class="line">        ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span>aliOSSProperties.getEndpoint().split(<span class="string">&quot;//&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;//&quot;</span> + aliOSSProperties.getBucketName() + <span class="string">&quot;.&quot;</span> + aliOSSProperties.getEndpoint().split(<span class="string">&quot;//&quot;</span>)[<span class="number">1</span>] + <span class="string">&quot;/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭ossClient</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        <span class="keyword">return</span> url;<span class="comment">// 把上传到oss的路径返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在项目当中要使用阿里云OSS，就可以注入AliOSSUtils工具类来进行文件上传。但这种方式其实是比较繁琐的。</p><p>大家再思考，现在我们使用阿里云OSS，需要做这么几步，将来大家在开发其他的项目的时候，你使用阿里云OSS，这几步你要不要做？当团队中其他小伙伴也在使用阿里云OSS的时候，步骤 不也是一样的。</p><p>所以这个时候我们就可以制作一个公共组件(自定义starter)。starter定义好之后，将来要使用阿里云OSS进行文件上传，只需要将起步依赖引入进来之后，就可以直接注入AliOSSUtils使用了。</p><p>需求明确了，接下来我们再来分析一下具体的实现步骤：</p><ul><li>第1步：创建自定义starter模块（进行依赖管理）<ul><li>把阿里云OSS所有的依赖统一管理起来</li></ul></li><li>第2步：创建autoconfigure模块<ul><li>在starter中引入autoconfigure （我们使用时只需要引入starter起步依赖即可）</li></ul></li><li>第3步：在autoconfigure中完成自动配置<ol><li>定义一个自动配置类，在自动配置类中将所要配置的bean都提前配置好</li><li>定义配置文件，把自动配置类的全类名定义在配置文件中</li></ol></li></ul><p>我们分析完自定义阿里云OSS自动配置的操作步骤了，下面我们就按照分析的步骤来实现自定义starter。</p><h5 id="3-2-4-2-自定义starter实现"><a href="#3-2-4-2-自定义starter实现" class="headerlink" title="3.2.4.2 自定义starter实现"></a>3.2.4.2 自定义starter实现</h5><p>自定义starter的步骤我们刚才已经分析了，接下来我们就按照分析的步骤来完成自定义starter的开发。</p><p>首先我们先来创建两个Maven模块：</p><p>1). aliyun-oss-spring-boot-starter模块</p><p><img src="/2024/03/26/springboot/image-20230115234739988.png" alt="image-20230115234739988"></p><p><img src="/2024/03/26/springboot/image-20230115234823134.png" alt="image-20230115234823134"></p><p>创建完starter模块后，删除多余的文件，最终保留内容如下：</p><p><img src="/2024/03/26/springboot/image-20230115235429353.png" alt="image-20230115235429353"></p><p>删除pom.xml文件中多余的内容后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2). aliyun-oss-spring-boot-autoconfigure模块</p><p><img src="/2024/03/26/springboot/image-20230116000302319.png" alt="image-20230116000302319"></p><p><img src="/2024/03/26/springboot/image-20230115235921014.png" alt="image-20230115235921014"></p><p>创建完starter模块后，删除多余的文件，最终保留内容如下：</p><p><img src="/2024/03/26/springboot/image-20230116000542905.png" alt="image-20230116000542905"></p><p>删除pom.xml文件中多余的内容后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照我们之前的分析，是需要在starter模块中来引入autoconfigure这个模块的。打开starter模块中的pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入autoconfigure模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前两步已经完成了，接下来是最关键的就是第三步：</p><p>在autoconfigure模块当中来完成自动配置操作。</p><blockquote><p> 我们将之前案例中所使用的阿里云OSS部分的代码直接拷贝到autoconfigure模块下，然后进行改造就行了。</p></blockquote><p><img src="/2024/03/26/springboot/image-20230116001622679.png" alt="image-20230116001622679"></p><p>拷贝过来后，还缺失一些相关的依赖，需要把相关依赖也拷贝过来：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入web起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Lombok--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--阿里云OSS--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.15.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- no more than 2.3.3--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在大家思考下，在类上添加的@Component注解还有用吗？</p><p><img src="/2024/03/26/springboot/image-20230116002417105.png" alt="image-20230116002417105"></p><p><img src="/2024/03/26/springboot/image-20230116002442736.png" alt="image-20230116002442736"></p><p>答案：没用了。  在SpringBoot项目中，并不会去扫描com.aliyun.oss这个包，不扫描这个包那类上的注解也就失去了作用。</p><blockquote><p>@Component注解不需要使用了，可以从类上删除了。</p><p>删除后报红色错误，暂时不理会，后面再来处理。</p><p><img src="/2024/03/26/springboot/image-20230116002747681.png" alt="image-20230116002747681"></p><p>删除AliOSSUtils类中的@Component注解、@Autowired注解</p><p><img src="/2024/03/26/springboot/image-20230116003046768.png" alt="image-20230116003046768"></p></blockquote><p>下面我们就要定义一个自动配置类了，在自动配置类当中来声明AliOSSUtils的bean对象。</p><p><img src="/2024/03/26/springboot/image-20230116003513900.png" alt="image-20230116003513900"></p><p> AliOSSAutoConfiguration类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//当前类为Spring配置类</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AliOSSProperties.class)</span><span class="comment">//导入AliOSSProperties类，并交给SpringIOC管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建AliOSSUtils对象，并交给SpringIOC容器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AliOSSUtils <span class="title function_">aliOSSUtils</span><span class="params">(AliOSSProperties aliOSSProperties)</span>&#123;</span><br><span class="line">        <span class="type">AliOSSUtils</span> <span class="variable">aliOSSUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliOSSUtils</span>();</span><br><span class="line">        aliOSSUtils.setAliOSSProperties(aliOSSProperties);</span><br><span class="line">        <span class="keyword">return</span> aliOSSUtils;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AliOSSProperties类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*阿里云OSS相关配置*/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSProperties</span> &#123;</span><br><span class="line">    <span class="comment">//区域</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="comment">//身份ID</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId ;</span><br><span class="line">    <span class="comment">//身份密钥</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret ;</span><br><span class="line">    <span class="comment">//存储空间</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AliOSSUtils类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AliOSSProperties aliOSSProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现上传图片到OSS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取上传的文件的输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> multipartFile.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免文件覆盖</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> multipartFile.getOriginalFilename();</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上传文件到 OSS</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(aliOSSProperties.getEndpoint(),</span><br><span class="line">                aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret());</span><br><span class="line">        ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span>aliOSSProperties.getEndpoint().split(<span class="string">&quot;//&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;//&quot;</span> + aliOSSProperties.getBucketName() + <span class="string">&quot;.&quot;</span> + aliOSSProperties.getEndpoint().split(<span class="string">&quot;//&quot;</span>)[<span class="number">1</span>] + <span class="string">&quot;/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭ossClient</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        <span class="keyword">return</span> url;<span class="comment">// 把上传到oss的路径返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在aliyun-oss-spring-boot-autoconfigure模块中的resources下，新建自动配置文件：</p><ul><li><p>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.aliyun.oss.AliOSSAutoConfiguration</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2024/03/26/springboot/image-20230116004957697.png" alt="image-20230116004957697"></p><h5 id="3-2-4-3-自定义starter测试"><a href="#3-2-4-3-自定义starter测试" class="headerlink" title="3.2.4.3 自定义starter测试"></a>3.2.4.3 自定义starter测试</h5><p>阿里云OSS的starter我们刚才已经定义好了，接下来我们就来做一个测试。</p><blockquote><p>今天的课程资料当中，提供了一个自定义starter的测试工程。我们直接打开文件夹，里面有一个测试工程。测试工程就是springboot-autoconfiguration-test，我们只需要将测试工程直接导入到Idea当中即可。</p></blockquote><p><img src="/2024/03/26/springboot/image-20230116005530815.png" alt="image-20230116005530815"></p><p>测试前准备：</p><ol><li><p>在test工程中引入阿里云starter依赖</p><ul><li>通过依赖传递，会把autoconfigure依赖也引入了</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入阿里云OSS起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在test工程中的application.yml文件中，配置阿里云OSS配置参数信息（从以前的工程中拷贝即可）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置阿里云OSS参数</span></span><br><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">oss:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">https://oss-cn-shanghai.aliyuncs.com</span></span><br><span class="line">    <span class="attr">accessKeyId:</span> <span class="string">LTAI5t9MZK8iq5T2Av5GLDxX</span></span><br><span class="line">    <span class="attr">accessKeySecret:</span> <span class="string">C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc</span></span><br><span class="line">    <span class="attr">bucketName:</span> <span class="string">web-framework01</span></span><br></pre></td></tr></table></figure></li><li><p>在test工程中的UploadController类编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliOSSUtils aliOSSUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile image)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//上传文件到阿里云 OSS</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> aliOSSUtils.upload(image);</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>编写完代码后，我们启动当前的SpringBoot测试工程：</p><ul><li>随着SpringBoot项目启动，自动配置会把AliOSSUtils的bean对象装配到IOC容器中</li></ul><p><img src="/2024/03/26/springboot/image-20230116011039611.png" alt="image-20230116011039611"></p><p>用postman工具进行文件上传：</p><p><img src="/2024/03/26/springboot/image-20230116010731914.png" alt="image-20230116010731914"></p><p>通过断点可以看到自动注入AliOSSUtils的bean对象：</p><p><img src="/2024/03/26/springboot/image-20230116011501201.png" alt="image-20230116011501201"></p><h2 id="4-Web后端开发总结"><a href="#4-Web后端开发总结" class="headerlink" title="4. Web后端开发总结"></a>4. Web后端开发总结</h2><p>到此基于SpringBoot进行web后端开发的相关知识我们已经学习完毕了。下面我们一起针对这段web课程做一个总结。</p><p>我们来回顾一下关于web后端开发，我们都学习了哪些内容，以及每一块知识，具体是属于哪个框架的。</p><p>web后端开发现在基本上都是基于标准的三层架构进行开发的，在三层架构当中，Controller控制器层负责接收请求响应数据，Service业务层负责具体的业务逻辑处理，而Dao数据访问层也叫持久层，就是用来处理数据访问操作的，来完成数据库当中数据的增删改查操作。</p><p><img src="/2024/03/26/springboot/image-20230114180044897.png" alt="image-20230114180044897"></p><blockquote><p>在三层架构当中，前端发起请求首先会到达Controller(不进行逻辑处理)，然后Controller会直接调用Service 进行逻辑处理， Service再调用Dao完成数据访问操作。</p></blockquote><p>如果我们在执行具体的业务处理之前，需要去做一些通用的业务处理，比如：我们要进行统一的登录校验，我们要进行统一的字符编码等这些操作时，我们就可以借助于Javaweb当中三大组件之一的过滤器Filter或者是Spring当中提供的拦截器Interceptor来实现。</p><p><img src="/2024/03/26/springboot/image-20230114191737227.png" alt="image-20230114191737227"></p><p>而为了实现三层架构层与层之间的解耦，我们学习了Spring框架当中的第一大核心：IOC控制反转与DI依赖注入。</p><blockquote><p>所谓控制反转，指的是将对象创建的控制权由应用程序自身交给外部容器，这个容器就是我们常说的IOC容器或Spring容器。</p><p>而DI依赖注入指的是容器为程序提供运行时所需要的资源。</p></blockquote><p>除了IOC与DI我们还讲到了AOP面向切面编程，还有Spring中的事务管理、全局异常处理器，以及传递会话技术Cookie、Session以及新的会话跟踪解决方案JWT令牌，阿里云OSS对象存储服务，以及通过Mybatis持久层架构操作数据库等技术。</p><p><img src="/2024/03/26/springboot/image-20230114192921673.png" alt="image-20230114192921673"></p><p>我们在学习这些web后端开发技术的时候，我们都是基于主流的SpringBoot进行整合使用的。而SpringBoot又是用来简化开发，提高开发效率的。像过滤器、拦截器、IOC、DI、AOP、事务管理等这些技术到底是哪个框架提供的核心功能？</p><p><img src="/2024/03/26/springboot/image-20230114193609782.png" alt="image-20230114193609782"></p><blockquote><p>Filter过滤器、Cookie、 Session这些都是传统的JavaWeb提供的技术。</p><p>JWT令牌、阿里云OSS对象存储服务，是现在企业项目中常见的一些解决方案。</p><p>IOC控制反转、DI依赖注入、AOP面向切面编程、事务管理、全局异常处理、拦截器等，这些技术都是 Spring Framework框架当中提供的核心功能。</p><p>Mybatis就是一个持久层的框架，是用来操作数据库的。</p></blockquote><p>在Spring框架的生态中，对web程序开发提供了很好的支持，如：全局异常处理器、拦截器这些都是Spring框架中web开发模块所提供的功能，而Spring框架的web开发模块，我们也称为：SpringMVC</p><p><img src="/2024/03/26/springboot/image-20230114195143418.png" alt="image-20230114195143418"></p><blockquote><p>SpringMVC不是一个单独的框架，它是Spring框架的一部分，是Spring框架中的web开发模块，是用来简化原始的Servlet程序开发的。</p></blockquote><p>外界俗称的SSM，就是由：SpringMVC、Spring Framework、Mybatis三块组成。</p><p>基于传统的SSM框架进行整合开发项目会比较繁琐，而且效率也比较低，所以在现在的企业项目开发当中，基本上都是直接基于SpringBoot整合SSM进行项目开发的。</p><p>到此我们web后端开发的内容就已经全部讲解结束了。</p>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合常用方法</title>
      <link href="/2024/03/26/javaCollection/"/>
      <url>/2024/03/26/javaCollection/</url>
      
        <content type="html"><![CDATA[<h2 id="java-数组，集合，字符串中常用的方法"><a href="#java-数组，集合，字符串中常用的方法" class="headerlink" title="java 数组，集合，字符串中常用的方法"></a>java 数组，集合，字符串中常用的方法</h2><h4 id="数组Arrays-类"><a href="#数组Arrays-类" class="headerlink" title="数组Arrays 类"></a>数组Arrays 类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">Arrays.toString() <span class="comment">//输出数组的内容</span></span><br><span class="line"></span><br><span class="line">Arrays.sort()<span class="comment">//快速排序</span></span><br><span class="line"></span><br><span class="line">Arrays.equals()<span class="comment">//逐个比较数组元素是否相等</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch( c数组,key定值)   <span class="comment">//在数组中寻找定值，返回此值的下标</span></span><br><span class="line"></span><br><span class="line">Arrays.copyOf() <span class="comment">//拷贝数组</span></span><br><span class="line"></span><br><span class="line">Arrays.copyOfRange(arr,from A，to B)  <span class="comment">//拷贝AB 之间的数组的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符串String类"><a href="#字符串String类" class="headerlink" title="字符串String类"></a>字符串String类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">()</span>;<span class="comment">//提取字符串中指定位置的值</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">toCharArray</span><span class="params">()</span>;<span class="comment">//将字符串转变为字符数组</span></span><br><span class="line">String <span class="title function_">trim</span><span class="params">()</span>; <span class="comment">//返回字符串，忽略前导空白和尾部空白</span></span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span>;</span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmptyt</span><span class="params">()</span>;<span class="comment">//判断是否为空字符串</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String s)</span>; <span class="comment">//忽略大小比较字符串的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String s)</span>; <span class="comment">//比较两个字符串的大小，相等0，不相等-1</span></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>; <span class="comment">//返回新字符串，从指定位置开始截取到最有一个位置</span></span><br><span class="line">String <span class="title function_">subString</span><span class="params">(<span class="type">int</span> begin ,<span class="type">int</span> end)</span>;<span class="comment">//截取左闭右开的字符串</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String str)</span>;<span class="comment">// str.contains(str1);str中是否包含str1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span> <span class="comment">//返回字符串在此字符串中第一次出现的索引，没有返回-1</span></span><br><span class="line">    indexOf(String str,<span class="type">int</span> index);<span class="comment">//index之后开始索引查找</span></span><br><span class="line">String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar,newChar)</span>;<span class="comment">//替换字符串</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String str)</span>;<span class="comment">//匹配是否符合正则表达式</span></span><br><span class="line">String [] split(<span class="string">&quot;字符&quot;</span>);<span class="comment">//根据给定的正则表达式拆分字符串，形成一个新的String数组</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer</span><br><span class="line">线程安全： StringBuffer 是线程安全的，因此适用于多线程环境，可以确保在并发操作时不会出现数据不一致的问题。</span><br><span class="line">同步方法： StringBuffer 的方法都是同步的，这会带来一些性能上的损失。因此，当需要在线程安全的环境中进行字符串操作时，使用 StringBuffer 是合适的选择。</span><br><span class="line"></span><br><span class="line">StringBuilder JDK1<span class="number">.5</span>版本之后引入的</span><br><span class="line">非线程安全： StringBuilder 不是线程安全的，因此在单线程环境中使用更为高效。</span><br><span class="line"></span><br><span class="line">性能优势： 由于不需要考虑线程安全性，StringBuilder 在性能上通常比 StringBuffer 更优秀。在单线程环境中进行大量字符串操作时，使用 StringBuilder 可以提高效率。</span><br><span class="line"></span><br><span class="line">选择场景：</span><br><span class="line">多线程环境： 如果在多线程环境中需要进行字符串操作，选择 StringBuffer。</span><br><span class="line">单线程环境： 如果在单线程环境中进行字符串操作，选择 StringBuilder 可以获得更好的性能。</span><br></pre></td></tr></table></figure><h4 id="StringBuilder的常用方法"><a href="#StringBuilder的常用方法" class="headerlink" title="StringBuilder的常用方法"></a>StringBuilder的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">                                      (<span class="type">int</span> capacity);</span><br><span class="line">  (空参构造器)<span class="comment">//默认初始为16个字符</span></span><br><span class="line">str.append(String str);<span class="comment">//添加各种数据</span></span><br><span class="line">str.delete(<span class="type">int</span> start,<span class="type">int</span> end);<span class="comment">//删除指定位置的内容</span></span><br><span class="line">deletecharAt(<span class="type">int</span> index);<span class="comment">//删除指定索引位置上的元素</span></span><br><span class="line">str.replace(<span class="type">int</span> start,<span class="type">int</span> end,String str);<span class="comment">//指定位置替换</span></span><br><span class="line">str.insert(<span class="type">int</span> start,String s);<span class="comment">//指定位置插入</span></span><br><span class="line">str.reverse();<span class="comment">//当前字符翻转</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span> <span class="comment">//str在字符串中首次出现的位置</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> ch)</span> <span class="comment">//将指定位置的字符换为新的</span></span><br></pre></td></tr></table></figure><h4 id="集合框架：collection接口继承树"><a href="#集合框架：collection接口继承树" class="headerlink" title="集合框架：collection接口继承树"></a>集合框架：collection接口继承树</h4><p>集合框架：</p><p>Collection接口：单列集合，用来存储一个一个的对象</p><p>list接口：存储有序的，可以重复的数据 –&gt;”动态数组”</p><p>​ArrayList: list的主要实现类，线程不安全。底层使用object[]数组存储</p><p>​LinkedList:底层使用双向链表存储。对于频繁的插入和删除操作，效率高</p><p>​Vector：古老实现类，线程安全，效率低</p><p>set接口：无序的，不可重复的数据  –&gt;高中数学中的集合</p><p>​       </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      无序性，不等于随机性，存储数据根据数据计算哈希值，根据哈希值存储</span><br><span class="line"></span><br><span class="line">​不可重复性：靠存储的元素类型是否重写hashcode()和equals()方法实现的，比较过程：存储元素会使用hash()算法生成一个int类型的hashcode散列值，然后与以存储的元素的hashcode比较，如果不一致则是新的对象，如果一致的话，再调用equals()方法，比较两个对象的内容是否相等，这样就确保了存储的唯一性。</span><br></pre></td></tr></table></figure><p>​HashSet：set接口的主要实现类，线程不安全，可以存储null值，底层使用哈希表</p><p>​LinkedHashSet：HashSet的子类，可以按照添加的顺序遍历，底层使用哈希表和链表，频繁遍历效率高</p><p>​TreeSet：底层二叉树红黑树，可以按照添加的对象的指定属性，排序，所以只能添加同类的对象 </p><pre><code>        TreeSet底层数据结构采用二叉树来实现，元素唯一且已经排好序；唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性。根据构造方法不同，分为自然排序（无参构造）和比较器排序（有参构造），自然排序要求元素必须实现Compareable接口，并重写里面的compareTo()方法，元素通过比较返回的int值来判断排序序列，返回0说明两个对象相同，不需要存储；比较器排需要在TreeSet初始化是时候传入一个实现Comparator接口的比较器对象，或者采用匿名内部类的方式new一个Comparator对象，重写里面的compare()方法；</code></pre><p><img src="/2024/03/26/javaCollection/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240109193220620.png" alt="image-20240109193220620"></p><p>Map接口：双列集合，用来存储一对（key,value）的数据  ，底层数组+链表+红黑树</p><p>​HashMap：主要实现类。线程不安全，效率高，可以存储null，</p><p>​LinkedHashMap：底层链表，保证在遍历元素时候，可以按照添加的顺序遍历，频繁的遍历效率高</p><p>​WeakHashMap： </p><p>​Hashtable：古老实现类。线程安全，效率低，不能存储null</p><pre><code>               properties:常用来处理配置文件，key-value都是String类型的</code></pre><p>​TreeMap：底层红黑树，保证添加的key进行排序（key必须是同一类对象）实现排序遍历</p><img src="/2024/03/26/javaCollection/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240109152948047.png" alt="image-20240109152948047" style="zoom: 50%;"><p>map中的key：无序的，不可重复的，使用set存储所有的key</p><p>​               value：无序的，可重复的</p><p><strong>map的底层实现原理：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JDK8之后map底层是  数组+链表+红黑树</span><br><span class="line">当首次执行执行插入操作map.put(key,value)后，底层创建一个长度为16的数组</span><br><span class="line">key相当于set不可重复，调用key1类所在的hashcode()计算哈希值，不一样，根据hash值计算出存储在数组中的位置，</span><br><span class="line">若存放位置为空的话，则添加成功</span><br><span class="line">若存放位置的数据不为空，(说明此位置已经有一个或者多个数据了，以链表的形式存在)，比较key1和已有元素的hash值，如果都不相同，则添加成功，</span><br><span class="line">如果相同，则继续比较key1类所在的equals()方法，判断是否为相同的元素，</span><br><span class="line">如果不相同，则直接添加</span><br><span class="line">如果相同，则使用新的的value值，替换之前的value值</span><br><span class="line"></span><br><span class="line">当使用hashcode()计算出的数组的一个索引位置上的元素以链表的形式存在的结构个数&gt;8，并且当前数组的长度大于16的时候，此时将此索引位置上所有的数据改为使用红黑树存储，为了提高查找的效率</span><br><span class="line"></span><br><span class="line">再不断的添加数据的过程中，会涉及到底层数组扩容的问题</span><br><span class="line"></span><br><span class="line">HashMap 的底层数组在什么时候扩容，是由负载因子（Load Factor）和阈值（Threshold）决定的。负载因子是一个表示哈希表满程度的值，而阈值则是根据负载因子和数组长度计算得出的阈值。当哈希表中的元素个数超过阈值时，数组会进行扩容操作。默认扩容为原来的2倍</span><br><span class="line"></span><br><span class="line">具体来说，扩容的触发条件是：元素个数超过阈值。而阈值的计算方式为：threshold=capacity×loadFactor</span><br><span class="line">其中：</span><br><span class="line">capacity 是哈希表数组的容量（数组的长度）。</span><br><span class="line">loadFactor 是负载因子，默认为 0.75。</span><br><span class="line">当哈希表中的元素个数达到阈值时，就会触发数组的扩容。扩容的具体过程包括：</span><br><span class="line"></span><br><span class="line">创建新数组： 创建一个新的数组，其容量是原数组的两倍。</span><br><span class="line">重新哈希： 将原数组中的所有元素重新计算哈希码，并放入新数组中。由于数组容量变化，哈希码的计算可能会得到不同的索引位置。</span><br><span class="line">替换原数组： 将新数组替换为原数组。</span><br></pre></td></tr></table></figure><img src="/2024/03/26/javaCollection/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240109213415336.png" alt="image-20240109213415336" style="zoom:50%;"><p><strong>map的主要方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>:</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> <span class="comment">//查询map中是否包含指定的key，如果包含则返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span><span class="comment">//查询map中是否包含指定的value，如果包含返回true</span></span><br><span class="line"></span><br><span class="line">Object <span class="title function_">get</span><span class="params">(Object key)</span><span class="comment">//返回指定可以对应的value。如果map中不包含key则返回null</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">//顾名思义，空返回true</span></span><br><span class="line">Object <span class="title function_">put</span><span class="params">(key,value)</span>;<span class="comment">//添加一个键值对，如果已经有则覆盖原有的键值对</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">()</span>;<span class="comment">//将指定map的键值复制到对应的map中去</span></span><br><span class="line">Object <span class="title function_">remove</span><span class="params">(key)</span>;<span class="comment">//删除指定key对应的键值对，返回相关联的value，若key不存在，则返回null</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;<span class="comment">//返回map中键值对的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getOrDefault</span><span class="params">(key, defaultValue)</span><span class="comment">//获取指定key对应对value,如果找不到key，则返回设置的默认值</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//原视图操作法</span></span><br><span class="line">Set <span class="title function_">entrySet</span><span class="params">()</span><span class="comment">//返回map中包含的所有key-value对应的set集合</span></span><br><span class="line">Set <span class="title function_">keySet</span><span class="params">()</span><span class="comment">//返回map中所有的key组成的set集合</span></span><br><span class="line">Collection <span class="title function_">values</span><span class="params">()</span>;<span class="comment">//返回map里所有的value组成的Collection</span></span><br></pre></td></tr></table></figure><h4 id="HashMap中按照key和value排序的两种方法"><a href="#HashMap中按照key和value排序的两种方法" class="headerlink" title="HashMap中按照key和value排序的两种方法"></a>HashMap中按照key和value排序的两种方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.对key值进行排序</span></span><br><span class="line"><span class="comment">HashMap的存储是没有顺序的，而是按照key值的hashcode()实现的，</span></span><br><span class="line"><span class="comment">所以对key值排序，首先要得到HashMap中的所有key组成的集合，使用keyset()方法，并且转换为数组，这样才能用Arrays.sort()进行排序，*/</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keyset();</span><br><span class="line">Object[] arr = set.toArray();</span><br><span class="line"><span class="keyword">for</span>(Object key :arr)&#123;</span><br><span class="line">map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*2.对value值进行排序</span></span><br><span class="line"><span class="comment">对value进行排序，首先要得到HashMap中的包含映射关系的视图entrySet</span></span><br><span class="line"><span class="comment">将entrySet转为List，然后重写比较器即可，</span></span><br><span class="line"><span class="comment">可以使用List.sort(comparator);</span></span><br><span class="line"><span class="comment">Collections.sort(comparator);*/</span></span><br><span class="line"></span><br><span class="line">List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(map.entrySet()); <span class="comment">//转换为list</span></span><br><span class="line"><span class="comment">//Map.Entry表示java中操作键值对的接口，Map 接口的实现类（如 HashMap）的 entrySet() 方法返回一个包含 Map.Entry 对象的集合，这样可以遍历并操作键值对。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//List&lt;Map.Entry&lt;String, Integer&gt;&gt; entryList 表示一个包含键值对的列表，其中键是 String 类型，值是 Integer 类型。这个列表被用来对键值对进行排序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用list排序;</span></span><br><span class="line">       list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Collections.sort()进行排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2024/03/26/javaCollection/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240105161818539.png" alt="image-20240105161818539" style="zoom:50%;"><img src="/2024/03/26/javaCollection/Users\fangyuan\Documents\Tencent Files\2834980241\Image\C2C\W%RTEWRGP6%Z~TZQS3P{M22.png" alt="W%RTEWRGP6%Z~TZQS3P{M22" style="zoom:50%;"><h4 id="集合和数组"><a href="#集合和数组" class="headerlink" title="集合和数组"></a>集合和数组</h4><p>长度区别：数组固定，集合长度可变</p><p>内容区别：数组可以是基本的数据类型，也可以是引用的数据类型</p><p>​集合只能是引用类型</p><p>元素内容：数组只能存储同一种类型</p><p>​集合可以存储不同类型的（一般也是同一种类型的）</p><h4 id="collection集合的方法："><a href="#collection集合的方法：" class="headerlink" title="collection集合的方法："></a>collection集合的方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;<span class="comment">//在集合末尾添加元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;<span class="comment">//删除与o值相等的元素，并且返回</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;<span class="comment">//清除完集合中的所有元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(O o)</span>;<span class="comment">//判断集合中是否包含元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;<span class="comment">//判断集合是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;<span class="comment">//返回集合中的元素个数</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection c)</span>;<span class="comment">//将c中的所有元素添加到另一个集</span></span><br><span class="line">Object[] toArray();<span class="comment">//返回包含本集合中所有元素的数组，集合--&gt;数组</span></span><br><span class="line">Iterator <span class="title function_">iterator</span><span class="params">()</span>;<span class="comment">//迭代器，集合的专用遍历方式</span></span><br><span class="line">iterator.next(),iterator.hasnext()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">collection和collections的区别</span><br><span class="line">collection是所有集合的接口，list，set，map</span><br><span class="line">collections是操作集合的工具类;</span><br><span class="line"></span><br><span class="line">collections的常用方法,都是静态方法，<span class="keyword">static</span>，直接调用它</span><br><span class="line">Collections.reverse(list); <span class="comment">//反转集合中的元素</span></span><br><span class="line">shuffle(list);<span class="comment">//对集合的元素进行随机排序</span></span><br><span class="line">sort();<span class="comment">//升序排序</span></span><br><span class="line">sort(list,comparator);<span class="comment">//指定comparator的产生顺序对集合list排序</span></span><br><span class="line">swap(list,<span class="type">int</span> i,<span class="type">int</span> j);<span class="comment">//指定集合中的i,j 处的元素进行交换</span></span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">frequency(Collection，Object o);<span class="comment">//集合中指定元素出现的个数</span></span><br><span class="line">copy(list dest,list,src);<span class="comment">//将 src的内容复制到desc中</span></span><br><span class="line">replaceAll(list，old，<span class="keyword">new</span>);<span class="comment">//将list中的所有旧值改为新的值</span></span><br><span class="line">Collections提供了多个synchronizedXxx()方法，解决ArrayList，Hashmap等线程安全的问题 </span><br></pre></td></tr></table></figure><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p><img src="/2024/03/26/javaCollection/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240106164926820.png" alt="image-20240106164926820"></p><p>总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">增：add(Object)</span><br><span class="line"></span><br><span class="line">删：remove(<span class="type">int</span> index)/remove(Object obj)</span><br><span class="line"></span><br><span class="line">改：set(<span class="type">int</span> index,Object o)</span><br><span class="line"></span><br><span class="line">查：get(<span class="type">int</span> index)</span><br><span class="line"></span><br><span class="line">长度：size()</span><br><span class="line"></span><br><span class="line">遍历：foreach 迭代器Iterator()</span><br><span class="line"></span><br><span class="line">集合--&gt;数组：toArray()</span><br><span class="line">数组--&gt;集合：Arrays.asList();</span><br></pre></td></tr></table></figure><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>java与C、C++的异同</p><p>1.相同，java和C++都是面向对象的语言，封装，继承，多态</p><p>封装：就是将对象的属性和状态封装在一个类中，并且提供公共的public来get，set此属性的值。好处是，高内聚，低耦合，隐藏对象内部的复杂性，只对外公开简单的接口，供外界调用</p><p>继承：extends，子类可以继承父类的属性和方法，不修改父类的情况下添加自己的新成员方法，子类成员通过super关键字调用父类的构造方法和成员。</p><p>多态性质：同一操作对不同的对象，有不同的解释，就是多态性（父类的引用指向子类的对象）</p><p>通过方法重写override或者方法重载</p><p>2.不同之处：</p><p>java是解释性的语言，运行过程为：java编译后生成字节码文件，然后在java虚拟机JVM中解释运行，</p><p>C++编译型语言，编译后直接生成二进制的字节码文件，所以C++运行速度快，但是java可以移植</p><p>java中没有指针，提供了数组和集合这样的类和方法去操作，使得程序更加安全</p><p>java中没法实现多重继承，只能实现多个接口来达到与C++中多重继承的作用</p><p>C++中，经常需要去malloc去分配和释放内存，java中有垃圾回收机制，会自动释放内存</p><p>C++支持运算符的重载，java不支持</p><p>C++更接近底层，允许更多的底层控制，java隐藏了更多的底层细节，提供了丰富的库和内置功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">集合collection中存储的如果是自定义的对象，需要重写哪儿些方法</span><br><span class="line">list：equals()方法判断对象的属性是否相等</span><br><span class="line">hashset：重写equals()和hashcode()方法，为什么要重写hashcode，这与hashset的比较过程是有关系的，存储对象会采用hash算法生成一个int类型的哈希值，如果hash值不一样判断不是相同的元素，再存储，如果hash值一样，就调用equals 方法判断，所以不去重写的话，会调用父类的hash算法，这样相同的元素就会被判断为不同的hash值，就违背了set表不能有重复元素的定义</span><br><span class="line">treeset：底层二叉树，元素唯一且已经排好序，因为需要排序，所以就需要在compare方法里定义比较对象的属性，进行排序。重写compareTo()，compare()</span><br></pre></td></tr></table></figure><p><strong>线程安全和线程不安全</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程安全就是：多线程访问时候，提供一种加锁的机制，当其中一个线程访问的时候，其他的线程不能进行访问，从而达到保护数据的目的，对java中的synchronized关键字</span><br><span class="line">线程不安全：不加锁，有可能出现多个线程先后更爱数据得到的是错误数据</span><br><span class="line">例如：1000张票，A和B同时买票，如果线程不安全，会出现同时执行1000-1 的操作，导致最后剩下999张票，而不是998张</span><br></pre></td></tr></table></figure><p>例题：理解hashset的底层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        hashSet.add(p1);</span><br><span class="line">        hashSet.add(p2);</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        p1.age = <span class="number">3</span>;</span><br><span class="line">        hashSet.remove(p1);</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>,<span class="number">1</span>));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person类重写了hashcode和equals方法</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">1</span>&#125;, Person&#123;name=<span class="string">&#x27;B&#x27;</span>, age=<span class="number">2</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">3</span>&#125;, Person&#123;name=<span class="string">&#x27;B&#x27;</span>, age=<span class="number">2</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">3</span>&#125;, Person&#123;name=<span class="string">&#x27;B&#x27;</span>, age=<span class="number">2</span>&#125;, Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">3</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">3</span>&#125;, Person&#123;name=<span class="string">&#x27;B&#x27;</span>, age=<span class="number">2</span>&#125;, Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">1</span>&#125;, Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">3</span>&#125;]</span><br><span class="line">    </span><br><span class="line">解析：先往set添加了两个元素，所以输出两个</span><br><span class="line">   <span class="comment">// 修改了p1的age，移除了p1，在set中remove，还是要先计算hash值，因为修改了p1=Person(&quot;A&quot;, 3)，所以哈希值变了，但是原来在底层的还是Person(&quot;A&quot;, 1)，所以remove找不到，没有删除，输出仍为两个，再添加Person(&quot;A&quot;,3)，重新计算hash值，可以添加成功，最后添加new Person(&quot;A&quot;,1)，与之前的hash值相等，所以再调用equals判断是否为同一个对象，很明显不是同一个对象，所以也可以添加成功</span></span><br><span class="line">    <span class="comment">//总结：尽量不要再set中修改属性，很麻烦，直接删了重新添加</span></span><br></pre></td></tr></table></figure><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">push(value)<span class="comment">//将给定的值，压入栈的顶端，入站</span></span><br><span class="line">pop()<span class="comment">//删除并且返回栈顶的值，出栈</span></span><br><span class="line">peek()<span class="comment">//返回栈顶的值，但并不删除</span></span><br><span class="line">isEmpty()<span class="comment">//</span></span><br><span class="line">size()<span class="comment">//长度</span></span><br><span class="line">search(Object o)<span class="comment">//返回对象在栈中的位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，</span></span><br><span class="line"><span class="comment">//LinkedList实现了Queue接口，因此我们可以把LinkedList当成Queue队列来用</span></span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//add()和remove()，方法在失败的时候会抛出异常（不推荐使用）</span></span><br><span class="line"></span><br><span class="line">add(E e)：将元素 e 插入到队列末尾，如果插入成功，则返回 <span class="literal">true</span>；如果插入失败（即队列已满），则会抛出异常；</span><br><span class="line"></span><br><span class="line">remove()：移除队首元素，若移除成功，则返回 <span class="literal">true</span>；如果移除失败（队列为空），则会抛出异常；</span><br><span class="line"></span><br><span class="line">remove(Object o)：移除指定的元素，若移除成功，则返回 <span class="literal">true</span>；如果移除失败（队列为空），则会抛出异常</span><br><span class="line"></span><br><span class="line">offer(E e)：将元素 e 插入到队列末尾，如果插入成功，则返回 <span class="literal">true</span>；如果插入失败（即队列已满），则返回 <span class="literal">false</span>；</span><br><span class="line"></span><br><span class="line">poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回 <span class="literal">null</span>；</span><br><span class="line"></span><br><span class="line">peek()：获取队首元素，若成功，则返回队首元素；否则返回 <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">isEmpty</span><span class="params">()</span>：队列是否为空</span><br><span class="line"></span><br><span class="line">size()：队列长度</span><br><span class="line"></span><br><span class="line">对于非阻塞队列，一般情况下建议使用 offer、poll 和 peek 三个方法，不建议使用 add 和 remove 方法。因为使用 offer、poll 和 peek 三个方法可以通过返回值判断操作成功与否，而使用 add 和 remove 方法却不能达到这样的效果。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/26/hello-world/"/>
      <url>/2024/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line"><span class="built_in">date</span>:</span><br><span class="line">updated:</span><br><span class="line"><span class="built_in">type</span>:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello </tag>
            
            <tag> World </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaweb笔记</title>
      <link href="/2024/03/25/JavaWeb/"/>
      <url>/2024/03/25/JavaWeb/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb开发"><a href="#JavaWeb开发" class="headerlink" title="JavaWeb开发"></a>JavaWeb开发</h1><p>自己在学习web知识时候记得一些笔记，有三万字</p><ol><li>它打通了从前端 &#x3D;&gt; MySQL &#x3D;&gt; Java Web &#x3D;&gt; SSM &#x3D;&gt; Spring Boot &#x3D;&gt; Maven 这一套技术栈</li><li>它包含了像 Postman、MySQL 图形界面等开发工具的使用</li><li>它包含了像登录校验（JWT）、文件上传等常见业务的实践</li><li>它包含了 AOP 应用、SpringBoot 原理、Maven 高级等进阶知识</li></ol><p>但是图片显示不出来了</p><h3 id="初识web前端"><a href="#初识web前端" class="headerlink" title="初识web前端"></a>初识web前端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">用户在浏览器页面输入网址，是如何得到响应的页面数据的？</span><br><span class="line">1.浏览器根据请求的URL网址，查看缓存，如果资源未缓存，则</span><br><span class="line">2.交给DNS域名解析，转换为服务器的ip地址，向服务器发起请求</span><br><span class="line">3.建立tcp连接：三次握手：</span><br><span class="line">第一次握手：客户端向服务端发送数据包，选择一个起始序列号ISN，表示想建立连接</span><br><span class="line">第二次握手：服务端收到客户端的请求后，确认客户端请求发送带确认标记的数据包，也包括服务端的ISN</span><br><span class="line">第三次握手：客户端收到数据包后，明确了从客户端到服务器之间的数据传输的正常的，都确认了对方的ISN</span><br><span class="line">三次握手的目的是：确保双方能够接受和发送数据，同步双方的初始序列号ISN，这样就建立了可靠的链接，可以惊进行后续的通信</span><br><span class="line">在握手的过程中，如果某个阶段数据包丢失或者延迟，tcp协议会等待一段时间后，重新发送和接收数据，直到建立连接或者放弃链接，</span><br><span class="line">4.HTTP请求响应：握手建立连接成功后，客户端发起HTTP请求：包含要访问的信息</span><br><span class="line">5.服务器处理请求：服务器收到HTTP请求后，根据请求的资源和参数执行相应的处理，会涉及到数据库的查询和业务逻辑的处理</span><br><span class="line">6.服务器返回HTTP响应：根据HTTP响应协议，返回包括状态码，响应头，响应体等等</span><br><span class="line">7.浏览器接受响应：接收到后，开始处理，解析HTML文件，解析CSS，构建DOM树，布局和绘制，js代码的执行，最终呈现页面等等（涉及到前端的知识）</span><br><span class="line">HTML：负责网页的结构（页面和元素）</span><br><span class="line">CSS：负责网页的表现（页面元素的外观，位置，颜色大小等）</span><br><span class="line">JS：负责网页的行为（交互，动态，逻辑效果等等）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTML：HyperText Markup Language超文本标记语言，除了文本，还能定义图片，音频，视频等内容</p><p>CSS：Cascading Style Sheet 层叠样式表，用于控制页面的样式</p><p>JavaScript：跨平台的面向对象的语言，用于网页的交互，不需要编译运行，直接用于浏览器的解释就可以</p><p>JSON对象：JavaScript Object Notation，JS对象标记法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">“key” <span class="punctuation">:</span>value<span class="punctuation">,</span></span><br><span class="line">“key”<span class="punctuation">:</span>value<span class="punctuation">,</span></span><br><span class="line">“key”<span class="punctuation">:</span>value</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>BOM对象：Browser Object model 浏览器对象模型，将js的各个组成部分分装成对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对象名称描述</span><br><span class="line">Window浏览器窗口对象</span><br><span class="line">Navigator浏览器对象</span><br><span class="line">Screen屏幕对象</span><br><span class="line">History历史记录对象</span><br><span class="line">Locationd地址栏对象</span><br></pre></td></tr></table></figure><h3 id="Vue概述"><a href="#Vue概述" class="headerlink" title="Vue概述"></a>Vue概述</h3><p>Vue是一套前端框架，免除原生js中的DOM操作，简化书写</p><p>基于MVVM的思想：Model-View-ViewModel</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model：数据模型，特指前端中通过请求从后端获取数据</span><br><span class="line">view：视图，用于展示数据的页面，可以理解成用html+css搭建的页面，但是没有数据</span><br><span class="line">viewmodel：将数据绑定到视图上，负责将数据model通过js的DOM技术，将数据展示到视图上view上</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue的快速入门</span><br><span class="line">1.新建HTML页面，引入Vue.js文件</span><br><span class="line">2.在JS代码区域，创建Vue对象，定义数据模型</span><br><span class="line">在创建vue对象时，有几个常用的属性：</span><br><span class="line">- el:  用来指定哪儿些标签受 Vue 管理。 该属性取值 `#app` 中的 `app` 需要是受管理的标签的id属性值</span><br><span class="line">- data: 用来定义数据模型</span><br><span class="line">- methods: 用来定义函数。这个我们在后面就会用到</span><br><span class="line">3.编写视图</span><br><span class="line">差值表达式：&#123;&#123;表达式&#125;&#125;。</span><br><span class="line">Vue常用指令：</span><br><span class="line">Html中带有V-前缀 的特殊属性</span><br></pre></td></tr></table></figure><h4 id="Vue生命周期："><a href="#Vue生命周期：" class="headerlink" title="Vue生命周期："></a>Vue生命周期：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">指的是：Vue对象从创建到销毁的全过程，Vue的生命周期包括8个阶段，每触发一个生命周期，就会自动执行一个生命周期的方法</span><br><span class="line">状态阶段周期</span><br><span class="line">beforeCreate创建前</span><br><span class="line">created创建后</span><br><span class="line">beforeMount挂载前</span><br><span class="line">mounted挂载完成</span><br><span class="line">beforeUpdate更新前</span><br><span class="line">updated更新后</span><br><span class="line">beforeDestroy销毁前</span><br><span class="line">destroyed销毁后</span><br></pre></td></tr></table></figure><h4 id="Ajax："><a href="#Ajax：" class="headerlink" title="Ajax："></a>Ajax：</h4><p>（Asynchronous JavaScript and XML）</p><p>是一种用于在不重新加载整个页面的情况下，通过后台与服务器进行异步通信的技术</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">概念：异步的js和xml</span><br><span class="line">作用：通过Ajax可以给服务端发送请求，并获取服务器相应的数据</span><br><span class="line">异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并且更新部分网页的数据</span><br><span class="line"></span><br><span class="line">同步：在服务器请求的过程中，浏览器页面不能做其他的操作，只能等待响应结束</span><br><span class="line"></span><br><span class="line">Ajax 的核心是通过 XMLHttpRequest 对象进行数据的异步传输。该对象提供了在后台与服务器交互的方法和属性。通过 open() 方法指定请求的类型、URL 和是否异步，然后使用 send() 方法发送请求。</span><br></pre></td></tr></table></figure><h4 id="Axios："><a href="#Axios：" class="headerlink" title="Axios："></a>Axios：</h4><p>对原生Ajax的封装，简化书写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Axios 是一个基于 Promise 的 HTTP 客户端，用于在浏览器和 Node.js 环境中发送 HTTP 请求。它是一个流行的 JavaScript 库，简化了对后端 API 的数据请求和响应处理。Axios 支持浏览器环境和Node.js环境，因此可以在前端和后端同时使用。</span><br></pre></td></tr></table></figure><h4 id="YApi"><a href="#YApi" class="headerlink" title="YApi:"></a>YApi:</h4><p>接口文档管理平台</p><h4 id="Vue组件库"><a href="#Vue组件库" class="headerlink" title="Vue组件库"></a>Vue组件库</h4><p>Vue组件库Element</p><p>Element：饿了么开发，基于Vue2.0的桌面组件库</p><p>组件：超链接，按钮，图片，表格表单等</p><h4 id="Nginx服务器"><a href="#Nginx服务器" class="headerlink" title="Nginx服务器"></a>Nginx服务器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Nginx是一个高性能、可靠性强的开源Web服务器软件，也可以用作反向代理服务器、负载均衡器和 HTTP缓存。</span><br><span class="line">特点:轻量级的web服务器，占用内存少，并发能力强</span><br><span class="line"></span><br><span class="line">正向代理：例如：我们直接用国内的服务器访问国外的服务器很慢，或者无法访问，需要在本地搭建一个服务器来帮助我们去访问，这种就是正向代理，浏览器中配置代理服务器</span><br><span class="line"></span><br><span class="line">反向代理：比如我们访问淘宝时候，淘宝内部肯定不止一个服务器，那我们访问的时候，是不是要在服务器中频繁登陆？</span><br><span class="line">搭建过渡服务器，只登录一次，但是访问所有，这就是反向代理，我们只需要把请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器，隐藏了正式服务器的地址。</span><br><span class="line"></span><br><span class="line">作用：隐藏真实服务器： 反向代理服务器隐藏了真实的目标服务器，客户端无法直接访问目标服务器。这提高了服务器的安全性，因为客户端无法得知实际处理请求的服务器的信息。</span><br><span class="line"></span><br><span class="line">负载均衡： 反向代理服务器可以分发客户端的请求到多个目标服务器，以实现负载均衡。这有助于分担服务器的负载，提高整体系统的性能和可用性。</span><br><span class="line"></span><br><span class="line">安全性： 反向代理可以作为一个额外的安全层，过滤恶意请求、拦截攻击，提供安全性功能如SSL终止和Web应用防火墙（WAF）。</span><br><span class="line"></span><br><span class="line">SSL终止： 反向代理可以终止（解密）客户端发来的SSL/TLS加密连接，将请求以明文形式发送到目标服务器，然后将目标服务器的响应重新加密后返回给客户端。这有助于减轻目标服务器的负担。</span><br><span class="line"></span><br><span class="line">缓存： 反向代理服务器可以缓存静态内容，提高访问速度，减轻目标服务器的负载。它可以缓存响应并将相同的响应直接返回给多个客户端，而无需重新请求目标服务器。</span><br><span class="line"></span><br><span class="line">压缩： 反向代理服务器可以对传输到客户端的响应进行压缩，减小传输数据的大小，提高页面加载速度。</span><br><span class="line"></span><br><span class="line">静态资源服务： 反向代理可以专门处理静态资源的请求，如图片、CSS和JavaScript文件，提供更高效的静态资源服务。</span><br><span class="line"></span><br><span class="line">故障转移： 如果目标服务器出现故障，反向代理可以将请求转发到备用服务器，提高系统的可用性。</span><br></pre></td></tr></table></figure><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240129212602769.png" alt="image-20240129212602769" style="zoom: 80%;"><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><p>一款基于JAVA平台的项目管理和整合工具，将项目开发和管理过程，抽象成一个项目对象模型POM，只需要做一些简单的配置，</p><p>Maven就可以自动完成项目的编译，测试，打包，部署</p><p>pom.xml（配置文件）  –&gt;   <strong>POM （项目对象）–&gt;  依赖管理</strong>  –&gt;本地仓库–&gt;私服–&gt;中央仓库</p><p>​                                                 构建生命周期阶段</p><p>​                                                通过一些插件–&gt;生成jar包，源代码，帮助文档，XML等</p><p><strong>Maven作用：</strong></p><p>项目构建：提供方便的，跨平台的自动化构建方式</p><p>依赖管理：管理项目依赖的资源（jar包），避免资源间的版本冲突</p><p>统一开发结构：提供标准的，统一的项目结构</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自己组织的话：基于java的项目构建和管理的工具，主要作用有仨：1.依赖管理：传统手动导入的话很麻烦，还会有jar包之间的冲突（比如要升级一个版本，其他相关的jar包版本都要升级）使用Maven管理的话，直接在pom.xml文件中用修改dependence中的即可，2.统一开发的结构：比如就是我们开发工具是常用的是IDAE，当然也有其他的工具，eclipse等，提供这种统一的开发结构就能让项目在不同的平台哦也能运行 3、项目构建：提供项目周期中的各种插件：包括项目的清理(clean)，编译(compiler),打包(jar)等等</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建Maven工程：配置Maven环境：使用本地安装的Maven，修改配置文件以及本地仓库</span><br></pre></td></tr></table></figure><p>Maven基本概念：仓库，坐标</p><p>仓库：用于存储资源，包含各种jar包</p><p>本地（个人开发者）—局域网—&gt;私服（企业服务器）–&gt;中央仓库（Maven团队）</p><p>本地仓库：</p><p>远程仓库： 私服，中央仓库</p><p>坐标：Maven中坐标用于描述仓库资源的位置</p><p>坐标组成：</p><p>groupID：项目组织</p><p>artifactID：项目名称</p><p>version：版本号</p><p>packageing：打包方式</p><p>坐标作用：找到资源的位置，通过标识将资源的识别与下载交给机器</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>...<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>...<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依赖传递：</p><p>直接依赖：在当前项目中通过依赖配置建立依赖关系</p><p>间接依赖：通过依赖的依赖，间接依赖其他资源</p><p>依赖传递的冲突问题：路径优先，层级越深，优先度越低</p><p>可选依赖：对外隐藏 optional</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;<span class="name">optional</span>&gt;</span></span><br></pre></td></tr></table></figure><p>排除依赖 exclusion</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span> junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&lt;artifactidjunit&lt;/artifactId</span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core&lt;/artifactId</span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依赖范围：主程序，测试程序，参与打包</p><p>依赖的jar默认情况下是可以在任何地方使用的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span> compile <span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">compile <span class="comment">&lt;!--默认全局--&gt;</span></span><br><span class="line">test</span><br><span class="line">provided<span class="comment">&lt;!--主代码和测试--&gt;</span></span><br><span class="line">runtime <span class="comment">&lt;!--打包--&gt;</span></span><br></pre></td></tr></table></figure><p>依赖范围的传递性：</p><p>项目构建生命周期：</p><ul><li><p>clean</p></li><li><p>default：主要生命周期，用于构建应用程序</p></li><li><p>site：</p></li></ul><p>插件：插件与生命周期的阶段绑定，执行到对应生命周期时，执行对应插件的功能</p><h2 id="web分析"><a href="#web分析" class="headerlink" title="web分析"></a>web分析</h2><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230906144736342.png" alt="image-20230906144736342"></p><p>浏览器：</p><ul><li><p>输入网址：<code>http://192.168.100.11:8080/hello</code></p><ul><li><p>通过IP地址192.168.100.11定位到网络上的一台计算机</p><blockquote><p>我们之前在浏览器中输入的localhost，就是127.0.0.1（本机）</p></blockquote></li><li><p>通过端口号8080找到计算机上运行的程序</p><blockquote><p><code>localhost:8080</code>  , 意思是在本地计算机中找到正在运行的8080端口的程序</p></blockquote></li><li><p>&#x2F;hello是请求资源位置</p><ul><li>资源：对计算机而言资源就是数据<ul><li>web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据）</li></ul></li></ul><blockquote><p><code>localhost:8080/hello</code> ，意思是向本地计算机中的8080端口程序，获取资源位置是&#x2F;hello的数据</p><ul><li>8080端口程序，在服务器找&#x2F;hello位置的资源数据，发给浏览器</li></ul></blockquote></li></ul></li></ul><p>服务器：（可以理解为ServerSocket）</p><ul><li>接收到浏览器发送的信息（如：&#x2F;hello）</li><li>在服务器上找到&#x2F;hello的资源</li><li>把资源发送给浏览器</li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP：Hyper Text Transfer Protocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。</p><p>http协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照固定的格式进行数据传输</p><p>特点：</p><ul><li><blockquote><p>是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全</p></blockquote></li><li><p><strong>基于请求-响应模型:</strong>   一次请求对应一次响应（先请求后响应）</p><blockquote><p>请求和响应是一一对应关系，没有请求，就没有响应</p></blockquote></li><li><p><strong>HTTP协议是无状态协议:</strong>  对于数据没有记忆能力。每次请求-响应都是独立的</p></li></ul><p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。</p><ul><li>缺点:  多次请求间不能共享数据</li><li>优点:  速度快</li></ul><h2 id="HTTP-请求协议："><a href="#HTTP-请求协议：" class="headerlink" title="HTTP-请求协议："></a>HTTP-请求协议：</h2><p>浏览器和服务器是按照HTTP协议进行数据通信的。</p><p>HTTP协议又分为：请求协议和响应协议</p><ul><li>请求协议：浏览器将数据以请求格式发送到服务器<ul><li>包括：<strong>请求行</strong>、<strong>请求头</strong> 、<strong>请求体</strong></li></ul></li><li>响应协议：服务器将数据以响应格式返回给浏览器<ul><li>包括：<strong>响应行</strong> 、<strong>响应头</strong> 、<strong>响应体</strong></li></ul></li></ul><table><thead><tr><th align="center">请求方式</th><th align="left">请求说明</th></tr></thead><tbody><tr><td align="center"><strong>GET</strong></td><td align="left">获取资源。<br>向特定的资源发出请求。例：<a href="http://www.baidu.com/s?wd=itheima">http://www.baidu.com/s?wd=itheima</a></td></tr><tr><td align="center"><strong>POST</strong></td><td align="left">传输实体主体。<br>向指定资源提交数据进行处理请求（例：上传文件），数据被包含在请求体中。</td></tr></tbody></table><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230906151225973.png" alt="image-20230906151225973"></p><p>GET请求和POST请求的区别：</p><table><thead><tr><th align="left">区别方式</th><th>GET请求</th><th>POST请求</th></tr></thead><tbody><tr><td align="left">请求参数</td><td>请求参数在请求行中。<br>例：&#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1</td><td>请求参数在请求体中</td></tr><tr><td align="left">请求参数长度</td><td>请求参数长度有限制(浏览器不同限制也不同)</td><td>请求参数长度没有限制</td></tr><tr><td align="left">安全性</td><td>安全性低。原因：请求参数暴露在浏览器地址栏中。</td><td>安全性相对高</td></tr></tbody></table><h2 id="HTTP-响应协议"><a href="#HTTP-响应协议" class="headerlink" title="HTTP-响应协议"></a>HTTP-响应协议</h2><p>格式：与HTTP的请求一样，HTTP响应的数据也分为3部分：<strong>响应行</strong>、<strong>响应头</strong> 、<strong>响应体</strong> </p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230906152641833.png" alt="image-20230906152641833"></p><ul><li><p>响应行(以上图中红色部分)：响应数据的第一行。响应行由<code>协议及版本</code>、<code>响应状态码</code>、<code>状态码描述</code>组成</p><ul><li>协议&#x2F;版本：HTTP&#x2F;1.1</li><li>响应状态码：200</li><li>状态码描述：OK</li></ul></li><li><p>响应头(以上图中黄色部分)：响应数据的第二行开始。格式为key：value形式</p></li></ul><p>响应体(以上图中绿色部分)： 响应数据的最后一部分。存储响应的数据</p><ul><li>响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束）</li></ul><p>响应状态码</p><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong> — 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略</td></tr><tr><td>2xx</td><td><strong>成功</strong> — 表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong> — 重定向到其它地方，让客户端再发起一个请求以完成整个处理</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong> — 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong> — 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><h2 id="HTTP-协议解析-Tomcat"><a href="#HTTP-协议解析-Tomcat" class="headerlink" title="HTTP-协议解析-Tomcat"></a>HTTP-协议解析-Tomcat</h2><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。</p><p>服务器只是一台设备，必须安装服务器软件才能提供相应的服务。</p><p><strong>服务器软件</strong></p><p>服务器软件：基于ServerSocket编写的程序</p><ul><li>服务器软件本质是一个运行在服务器设备上的应用程序</li><li>能够接收客户端请求，并根据请求给客户端响应数据</li></ul><p>![1530625192392](D:\百度云下载\Javaweb资料\day04-Maven-SpringBootWeb入门\讲义\02. SpringBootWeb入门\assets\1530625192392.png)</p><h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷。主要功能是”提供网上信息浏览服务”。</p><p>Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><p><strong>Web服务器软件使用步骤</strong></p><ul><li>准备静态资源</li><li>下载安装Web服务器软件</li><li>将静态资源部署到Web服务器上</li><li>启动Web服务器使用浏览器访问对应的资源</li></ul><h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring 是一款轻量级的java开发框架，一般指的是spring framework,他是很多模块的集合，包括springboot快速启动，springcloud微服务，spring Data数据库等spring全家桶</span><br><span class="line"></span><br><span class="line">springboot就是帮助我们快速的构建应用程序，简化开发，提高效率</span><br></pre></td></tr></table></figure><h2 id="springboot入门程序解析"><a href="#springboot入门程序解析" class="headerlink" title="springboot入门程序解析"></a>springboot入门程序解析</h2><p>起步依赖：创建好springboot工程就会导入的依赖，含有starter的</p><h2 id="SpringBootWeb的请求响应"><a href="#SpringBootWeb的请求响应" class="headerlink" title="SpringBootWeb的请求响应"></a>SpringBootWeb的请求响应</h2><p>快速入门程序：</p><p>基于springboot开发一个web应用，浏览器发起&#x2F;hello请求时候，给浏览器返回字符串helloworld，</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230907090532641.png" alt="image-20230907090532641"></p><p>我们在浏览器发起请求，请求了后端web服务器（内置的Tomcat），请求会被部署在Tomcat的Controller接收，然后Controller再给浏览器一个响应helloworld</p><p>其实呢，在Tomcat这类web服务器中，是不识别我们自己定义的Controller类的， </p><p>Tomcat是一个servlet容器，支持servlet规范的，所以在Tomcat中是可以识别servlet程序的</p><p>那我们所编写的XxxController 是如何处理请求的，又与Servlet之间有什么联系呢？</p><p>其实呢，在SpringBoot进行web程序开发时，它内置了一个核心的Servlet程序 DispatcherServlet，称之为 核心控制器。 DispatcherServlet 负责接收页面发送的请求，然后根据执行的规则，将请求再转发给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由DispatcherServlet给浏览器响应数据</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>是一种Java编程模型，用于在Web服务器上处理HTTP请求和响应。Servlet充当了Web应用程序的控制器，允许开发者以Java编写服务器端逻辑，以响应客户端的HTTP请求。</p><h2 id="请求：Postman"><a href="#请求：Postman" class="headerlink" title="请求：Postman"></a>请求：Postman</h2><p>Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。</p><p>可以模拟浏览器向后端服务器发起任何形式(如:get、post)的HTTP请求</p><p>使用Postman还可以在发起请求时，携带一些请求参数、请求头等信息</p><h3 id="简单参数"><a href="#简单参数" class="headerlink" title="简单参数"></a>简单参数</h3><p>在向服务器发起请求时，向服务器传递一些普通的请求数据</p><p>后端程序中，两种方式接受传递过来的普通数据</p><p>1.原始方式：通过servlet中提供的API：</p><p>2.springboot方式：对原始的API进行了封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="comment">//是spring框架中的注解，告诉spring该类是一个控制器，用于处理HPPT的请求和响应</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="comment">//用于将HTTP请求映射到控制器的方法，在这里指定了路径</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name,Integer age)</span>&#123;</span><br><span class="line">        System.out.println(name +<span class="string">&quot;:&quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的作用：用来为代码提供元数据信息的特殊标注，以便在编译，运行，框架扫描，执行特定的操作</p><p>在Java中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编译时注解：作用于编译器，在代码编译时执行特定的操作，例如重写override，就会确保子类正确的覆盖父类的方法</span><br><span class="line"></span><br><span class="line">运行时注解：在运行中执行特定的操作，例如：使用反射机制，获取类的信息，或者配置应用程序</span><br></pre></td></tr></table></figure><p>在springboot中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.依赖注入：@Autowired自动装配bean，当一个类上使用 `@Autowired` 注解时，Spring容器会自动查找并注入满足依赖关系的Bean。减少了手动配置的需求</span><br><span class="line"></span><br><span class="line">2.请求映射：用注解来定义web请求的映射规则，@RequestMapping，@GetMapping用于定义HTTP请求的处理方法</span><br><span class="line"></span><br><span class="line">3.配置管理：例如 @Configuration 用于定义配置类，@Value 用于获取配置属性的值。</span><br><span class="line"></span><br><span class="line">4.AOP（面向切面编程）：Spring Boot支持AOP，可以使用注解如 @Aspect 和 @Around 来实现切面编程。</span><br></pre></td></tr></table></figure><h3 id="RequestParam注解："><a href="#RequestParam注解：" class="headerlink" title="@RequestParam注解："></a>@RequestParam注解：</h3><p>对于简单参数来讲</p><p>请求参数名和controller方法中的形参名不一致时，无法接收到请求数据</p><p>那么如果我们开发中，遇到了这种请求参数名和controller方法中的形参名不相同，怎么办？</p><p>解决方案：可以使用Spring提供的@RequestParam注解完成映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span></span><br><span class="line">    <span class="comment">// 请求参数名：name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//springboot方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username , Integer age )</span>&#123;</span><br><span class="line">        System.out.println(username+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体参数</p><p>简单实体对象：将请求参数封装为一个对象，请求参数名称和实体类的属性名称相同</p><p>复杂实体对象：</p><p>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数。*</p><h3 id="数组和集合参数"><a href="#数组和集合参数" class="headerlink" title="数组和集合参数"></a>数组和集合参数</h3><p>数组：直接使用数组封装</p><p>集合：通过@RequestParam注解绑定参数关系@RequestParam List<String> list</String></p><h3 id="日期参数"><a href="#日期参数" class="headerlink" title="日期参数"></a>日期参数</h3><p>使用注解@DateTimeFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”)注解指明其具体格式完成</p><h3 id="JSON参数：最常见的前后端数据交互方式"><a href="#JSON参数：最常见的前后端数据交互方式" class="headerlink" title="JSON参数：最常见的前后端数据交互方式"></a>JSON参数：最常见的前后端数据交互方式</h3><p>需要使用@Requestbody标识</p><h3 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h3><p>直接在请求的url中传递参数，例如<a href="http://localhost:8080/user/1name">http://localhost:8080/user/1name</a> </p><p>@pathParam</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//路径参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathParam2</span><span class="params">(<span class="meta">@PathVariable</span> Integer id, <span class="meta">@PathVariable</span> String name)</span>&#123;</span><br><span class="line">        System.out.println(id+ <span class="string">&quot; : &quot;</span> +name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@PathVariable注解</p><p>作用：从url中提取并且映射到方法参数中的<strong>占位符</strong>（路径变量）的值</p><p>过程：当一个请求到达spring控制器controller时，spring会解析请求的url，并将其中的路径变量与使用注解的参数方法匹配，匹配成功后，将路径变量的值映射到方法参数中，供方法使用</p><p>@Requestbody注解</p><p>作用：用于将HTTP请求的具体内容（通常为JSON或者xml的数据）映射到JAVA对象上</p><p>过程：当一个HTTP POST请求到达Spring控制器方法时，Spring会从请求体中提取数据，然后使用 <code>@RequestBody</code> 注解的方法参数的类型来进行反序列化，将请求体中的数据映射为Java对象。</p><p>@RequestParam注解</p><p>作用：用于从HTTP请求中获取参数的值，并且将其绑定到方法参数上，供方法使用</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230908140427712.png" alt="image-20230908140427712"></p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>请求响应模式：有请求就有响应</p><p>Controller程序除了接受请求外，还能进行响应，通过@ResponseBody响应，而@ResponseBody又是集成在@ResController中</p><p>@RestController &#x3D; @Controller + @ResponseBody </p><p>@ResponseBody注解</p><ul><li>类型：方法注解、类注解</li><li>位置：书写在Controller方法上或类上</li><li>作用：将方法返回值直接响应给浏览器<ul><li>如果返回值类型是实体对象&#x2F;集合，将会转换为JSON格式后在响应给浏览器</li></ul></li></ul><h3 id="分层解耦合"><a href="#分层解耦合" class="headerlink" title="分层解耦合"></a>分层解耦合</h3><p>三层架构：开发程序时候尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。</p><blockquote><p>单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。</p><p>这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。</p></blockquote><p>基于三层架构的执行流程：</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day05-SpringBootWeb请求响应\讲义\assets\image-20221204194207812.png" alt="image-20221204194207812"></p><p>前端发起请求，由Controller层接受（Controller 响应数据给前端）</p><p>Controller层，调用Service层来进行逻辑处理，把处理结果返回给Controller层</p><p>Service层：在逻辑处理的过程中调用Dao层（逻辑处理的过程中需要数据从Dao层中获取）</p><p>Dao层操作文件中的数据（Dao层中拿到的数据会返回给Service层）</p><p>由于数据访问的对象，可能是文件，数据库，别人接口获取到的数据，</p><p>所以要先定义一个Dao的接口，再用不同的类去实现这个接口，重写接口中的方法</p><p>（这里本质上就是接口多态的实现，传入一个接口类型的实现类对象，根据不同实现类对象调用不同实现类里重写的方法）</p><h3 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h3><p>内聚：软件中各个模块内部的功能联系</p><p>耦合：衡量软件中各层、模块之间的依赖，关联程度</p><h5 id="软件设计原则：高内聚低耦合"><a href="#软件设计原则：高内聚低耦合" class="headerlink" title="软件设计原则：高内聚低耦合"></a>软件设计原则：高内聚低耦合</h5><p>高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 “高内聚”。</p><p>低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。</p><p>需要用到spring的核心概念</p><h5 id="控制反转：IOC，"><a href="#控制反转：IOC，" class="headerlink" title="控制反转：IOC，"></a>控制反转：IOC，</h5><p>对象的创建控制权由程序自身，转移到外部容器</p><p>@Component &#x2F;&#x2F;将当前对象交给IOC容器管理，成为IOC容器的bean</p><h5 id="依赖注入：DI，"><a href="#依赖注入：DI，" class="headerlink" title="依赖注入：DI，"></a>依赖注入：DI，</h5><p>容器为应用程序提供运行时，所依赖的资源，称依赖注入</p><p>@Autowired&#x2F;&#x2F;运行时从IOC容器中获取该类型的对象，并且赋值给变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将当前对象交给IOC容器管理,成为IOC容器的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceA</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpDao empDao ;</span><br></pre></td></tr></table></figure><h5 id="IOC-详解"><a href="#IOC-详解" class="headerlink" title="IOC 详解"></a>IOC 详解</h5><p>bean对象的声明：Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解：</p><ul><li>@Controller    （标注在控制层类上）</li><li>@Service          （标注在业务层类上）</li><li>@Repository    （标注在数据访问层类上）</li></ul><table><thead><tr><th align="left">注解</th><th>说明</th><th>位置</th></tr></thead><tbody><tr><td align="left">@Controller</td><td>@Component的衍生注解</td><td>标注在控制器类上</td></tr><tr><td align="left">@Service</td><td>@Component的衍生注解</td><td>标注在业务类上</td></tr><tr><td align="left">@Repository</td><td>@Component的衍生注解</td><td>标注在数据访问类上（由于与mybatis整合，用的少）</td></tr><tr><td align="left">@Component</td><td>声明bean的基础注解</td><td>不属于以上三类时，用此注解</td></tr></tbody></table><h5 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h5><p>bean对象要生效，还需要被组件扫描</p><p>需要被组件@ComponentScan扫描，被集成在@SpringbootApplication中，默认扫描范围是SpringBoot启动类所在的包及其子包</p><h5 id="依赖注入详解DI："><a href="#依赖注入详解DI：" class="headerlink" title="依赖注入详解DI："></a>依赖注入详解DI：</h5><p>使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：自动装配。</p><p>@Autowired注解，默认是按照<strong>类型</strong>进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）</p><p>举例：在Controller运行的时候，就要到IOC容器当中去查找service类型的对象，而我们的IOC容器中刚好有service对象，所以，就找到这个类型的对象完成注入操作</p><p>IOC容器里，存在多个相同类型的bean对象，会报错，需要添加注解指明当前生效的bean类</p><ul><li><p>@Primary：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。</p></li><li><p>@Qualifier：指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。</p></li><li><p>@Resource：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。</p></li></ul><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230911160941781.png" alt="image-20230911160941781"></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>概述：持久化，把数据保存到可掉电式存储设备中供以后使用</p><p>数据库： database  DB：文件系统，保存了一系列数据</p><p>DBMS：数据库管理系统：操作和管理数据库的大型软件</p><p>关系型数据库：行列形式存储</p><p>非关系型：数据以对象的形式存储在数据库中</p><p>键值型数据库：key-value形式</p><p>搜索引擎数据库：倒排索引</p><p>针对于数据库来说，主要包括三个阶段：</p><ol><li>数据库设计阶段<ul><li>参照页面原型以及需求文档设计数据库表结构</li></ul></li><li>数据库操作阶段<ul><li>根据业务功能的实现，编写SQL语句对数据表中的数据进行增删改查操作</li></ul></li><li>数据库优化阶段<ul><li>通过数据库的优化来提高数据库的访问性能。优化手段：索引、SQL优化、分库分表等</li></ul></li></ol><h2 id="SQL："><a href="#SQL：" class="headerlink" title="SQL："></a>SQL：</h2><p>结构化查询语言 structured Query Language</p><ol><li>SQL的分类</li></ol><p>DDL：数据定义语言 ，CREATE \ ALTER \ DROP \ RENAME \ TRUNCATE</p><p>DML：数据操作语言 INSERT \ DELETE \ UPDATE \ SELECT \ </p><p>DCL：数据控制语言 COMMIT \ ROLLBACK \ SAVEPOINT \ GRANT \ REVOKE</p><p><strong>链接：localhost 端口：3306 用户名：user  密码：123456</strong></p><h4 id="表操作："><a href="#表操作：" class="headerlink" title="表操作："></a>表操作：</h4><p>案例：创建一个表 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table  表名(</span><br><span class="line">字段1  字段1类型 [约束]  [comment  字段1注释 ],</span><br><span class="line">字段2  字段2类型 [约束]  [comment  字段2注释 ],</span><br><span class="line">......</span><br><span class="line">字段n  字段n类型 [约束]  [comment  字段n注释 ] </span><br><span class="line">) [ comment  表注释 ] ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user (</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;ID,唯一标识&#x27;</span>,   # id是一行数据的唯一标识（不能重复）</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day06-MySQL\讲义\assets\image-20220829143005524.png" alt="image-20220829143005524"></p><h4 id="约束："><a href="#约束：" class="headerlink" title="约束："></a>约束：</h4><table><thead><tr><th><strong>约束</strong></th><th><strong>描述</strong></th><th><strong>关键字</strong></th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段值不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证字段的所有数据都是唯一、不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段值，则采用默认值</td><td>default</td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接，保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;ID,唯一标识&#x27;</span>, #主键自动增长</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;男&#x27;</span> comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>数据类型：数值类型，字符串类型，日期和时间类型</p><p>数值类型</p><p> <img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230912140829164.png" alt="image-20230912140829164"></p><p>字符串类型</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230912142339315.png" alt="image-20230912142339315"></p><p>日期时间类型</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230912144451625.png" alt="image-20230912144451625"></p><h5 id="设计表流程"><a href="#设计表流程" class="headerlink" title="设计表流程"></a>设计表流程</h5><p>通过上面的案例，我们明白了，设计一张表，基本的流程如下：</p><ol><li><p>阅读页面原型及需求文档</p></li><li><p>基于页面原则和需求文档，确定原型字段(类型、长度限制、约束)</p></li><li><p>再增加表设计所需要的业务基础字段(id主键、插入时间、修改时间)</p></li></ol><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day06-MySQL\讲义\assets\image-20221205232253088.png" alt="image-20221205232253088"></p><blockquote><p>说明：</p><ul><li><p>create_time：记录的是当前这条数据插入的时间。 </p></li><li><p>update_time：记录当前这条数据最后更新的时间。</p></li></ul></blockquote><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230913095855893.png" alt="image-20230913095855893"></p><p>或者直接用图形化界面操作完成</p><h4 id="数据库操作：DML"><a href="#数据库操作：DML" class="headerlink" title="数据库操作：DML"></a>数据库操作：DML</h4><p>增加：insert </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段名<span class="number">1</span>, 字段名<span class="number">2</span>) <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>案例1：向tb_emp表的username、name、gender字段插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 因为设计表时create_time, update_time两个字段不能为NULL，所以也做为要插入的字段</span><br><span class="line">insert into tb_emp(username, name, gender, create_time, update_time)</span><br><span class="line">values (&#x27;wuji&#x27;, &#x27;张无忌&#x27;, 1, now(), now());</span><br></pre></td></tr></table></figure><p>案例2：向tb_emp表的所有字段插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_emp(id, username, password, name, gender, image, job, entrydate, create_time, update_time)</span><br><span class="line">values (null, &#x27;zhirou&#x27;, &#x27;123&#x27;, &#x27;周芷若&#x27;, 2, &#x27;1.jpg&#x27;, 1, &#x27;2010-01-01&#x27;, now(), now());</span><br></pre></td></tr></table></figure><p>案例3：批量向tb_emp表的username、name、gender字段插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_emp(username, name, gender, create_time, update_time)</span><br><span class="line">values (&#x27;weifuwang&#x27;, &#x27;韦一笑&#x27;, 1, now(), now()),</span><br><span class="line">       (&#x27;fengzi&#x27;, &#x27;张三疯&#x27;, 1, now(), now());</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>修改：update</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span> , 字段名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span> , .... [<span class="keyword">where</span> 条件] ;</span><br></pre></td></tr></table></figure><p>删除：delete</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名  [<span class="keyword">where</span>  条件] ;</span><br></pre></td></tr></table></figure><h4 id="数据库操作：DQL"><a href="#数据库操作：DQL" class="headerlink" title="数据库操作：DQL"></a>数据库操作：DQL</h4><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select...from(<span class="keyword">join</span> <span class="keyword">on</span>)...where...group by...having...order by...limit...</span><br></pre></td></tr></table></figure><p>sql语句的底层执行过程</p><p>在SQL语句中，执行顺序通常遵循以下规则：</p><p>FROM子句：首先执行FROM子句，以确定要查询的表和列。</p><p> FROM…(LEFT&#x2F;RIGHT)JOIN…ON 多表的链接条件</p><p>WHERE子句：如果存在WHERE子句，则会先执行WHERE子句，以过滤出符合条件的行。</p><p>GROUP BY子句：如果存在GROUP BY子句，则会先执行GROUP BY子句，以将结果按照指定的列进行分组。</p><p>HAVING子句：如果存在HAVING子句，则会先执行HAVING子句，以过滤出满足聚合函数条件的组。</p><p>ORDER BY 。。。</p><p>LIMIT。。。</p><p>SELECT子句：最后执行SELECT子句，以选择需要返回的列。</p><p>具体见数据库学习笔记</p><p>where having</p><p><strong>where与having区别（面试题）</strong></p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时指定</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段名    数据类型,</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">constraint</span>]   [外键名称]  <span class="keyword">foreign</span>  key (外键字段名)   <span class="keyword">references</span>   主表 (主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建完表后，添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>  表名  <span class="keyword">add</span> <span class="keyword">constraint</span>  外键名称  <span class="keyword">foreign</span> key(外键字段名) <span class="keyword">references</span> 主表(主表列名);</span><br></pre></td></tr></table></figure><p>多表设计</p><p>一对多</p><p>一对一</p><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><p>多对多的关系在开发中属于也比较常见的。比如：学生和老师的关系，一个学生可以有多个授课老师，一个授课老师也可以有多个学生。在比如：学生和课程的关系，一个学生可以选修多门课程，一个课程也可以供多个学生选修。</p><ul><li><p>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</p></li><li><p>实现关系：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p></li></ul><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day07-MySQL\讲义\assets\image-20221207113341028.png" alt="image-20221207113341028"></p><h4 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 表<span class="number">1</span>字段，表<span class="number">2</span>字段 <span class="keyword">from</span> 表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">where</span> 表<span class="number">1.</span>字段<span class="operator">=</span>表<span class="number">2.</span>字段</span><br><span class="line"><span class="keyword">select</span> 表<span class="number">1</span>字段，表<span class="number">2</span>字段 form 表<span class="number">1</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 链接条件 </span><br></pre></td></tr></table></figure><p>多表查询的分类：</p><p>1.等值连接  非等值连接</p><p>2.自连接  非自连接</p><p>3.内连接 外连接</p><p>1.等值连接  非等值连接的例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.salary,j.grade_level</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades j</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="keyword">BETWEEN</span> j.lowest_sal <span class="keyword">AND</span> j.highest_sal</span><br></pre></td></tr></table></figure><p>2.自连接的例子：在同一张表里</p><p>查询员工ID，员工姓名，及其管理者的ID和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.employee_id,e1.last_name,e2.employee_id,e2.last_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> employees e1,employees e2</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> e1.manager_id <span class="operator">=</span> e2.employee_id</span><br></pre></td></tr></table></figure><p>3.内连接，外连接</p><p>内连接：结果集中，不包括一个表与另一个表不匹配的行</p><p>外连接：结果集中，出了匹配的行，还查询左表或者右表中不匹配的行</p><p>外连接的分类：左外连接，右外连接，全满外连接</p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230915100030081.png" alt="image-20230915100030081" style="zoom: 200%;"><h4 id="单行函数，聚合函数"><a href="#单行函数，聚合函数" class="headerlink" title="单行函数，聚合函数"></a>单行函数，聚合函数</h4><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>单行子查询：查找出的只有一行数据，使用常规的比较符，&#x3D;，&lt;,&gt;,</p><p>多行子查询，查找出多行数据</p><p>多行比较的操作符：</p><p>​IN：等于列表中任意一个</p><p>​ANY：某一个值比较</p><p>​ALL:所有值比较</p><p>​Some：any的别名</p><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>事物：是一组操作的集合，它是一个不可分割的工作单位，事物会把所有的操作试做一个整体，一起向系统提交或者撤销操作请求操作，要么同事成功，要么同时失败。</p><p>一个业务要发送多条SQL语句给数据库执行。需要将多次访问数据库的操作视为一个整体来执行，要么所有的SQL语句全部执行成功。如果其中有一条SQL语句失败，就进行事务的回滚，所有的SQL语句全部执行失败。</p><p>使用事务控制删除部门和删除该部门下的员工的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除学工部</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_dept <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除学工部的员工</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>上述的这组SQL语句，如果如果执行成功，则提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 提交事务 (成功时执行)</span></span><br><span class="line"><span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure><ul><li>上述的这组SQL语句，如果如果执行失败，则回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 回滚事务 (出错时执行)</span></span><br><span class="line"><span class="keyword">rollback</span> ;</span><br></pre></td></tr></table></figure><h4 id="事物的四大特性"><a href="#事物的四大特性" class="headerlink" title="事物的四大特性"></a>事物的四大特性</h4><p>原子性：事物是不可分割的最小单元，要么全部成功，要么全部失败</p><p>一致性：事物完成时，必须使得所有的数据状态都保持一致</p><p>隔离性：数据库系统提供隔离机制，保证事物在不受外部并发操作影响的独立环境下运行</p><p>持久性：事物一旦回滚，它对数据库中的数据的改变是永久的</p><h4 id="索引：index："><a href="#索引：index：" class="headerlink" title="索引：index："></a>索引：index：</h4><p>帮助数据库高效获取数据的数据结构</p><p>无索引：全表扫描</p><p>有索引： 树形结构，大大减少查询时间</p><p>优点：大大提高查询效率</p><p>缺点：索引占用存储空间，同时降低，插入，删除，更新效率，要维护索引</p><p>MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。</p><p>我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。</p><p>二叉树：左边子节点比父节点小，右边子节点比父节点大</p><p>红黑树：是一种平衡二叉树</p><p>B+Tree：多路平衡搜索树</p><p><strong>创建索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create  [ unique ]  index 索引名 on  表名 (字段名,... ) ;</span><br></pre></td></tr></table></figure><p><strong>查看索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show  index  from  表名;</span><br></pre></td></tr></table></figure><p><strong>删除索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop  index  索引名  on  表名;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>主键字段，在建表时，会自动创建主键索引</li><li>添加唯一约束时，数据库实际上会添加唯一索引</li></ul><h3 id="自己做SQL时候的一些训练"><a href="#自己做SQL时候的一些训练" class="headerlink" title="自己做SQL时候的一些训练"></a>自己做SQL时候的一些训练</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id ,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">BETWEEN</span> <span class="number">6000</span> <span class="keyword">AND</span> <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span> <span class="keyword">and</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%e%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">not</span> <span class="keyword">BETWEEN</span> <span class="number">5000</span> <span class="keyword">and</span> <span class="number">12000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id <span class="keyword">FROM</span> employees</span><br><span class="line">#<span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">OR</span> department_id <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="number">20</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,commission_pct <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">like</span> <span class="string">&#x27;__a%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span> <span class="keyword">AND</span> last_name <span class="keyword">like</span> <span class="string">&#x27;%k%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> first_name <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> first_name <span class="keyword">like</span> <span class="string">&#x27;%e&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,manager_id </span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">in</span> (<span class="number">100</span>,<span class="number">101</span>,<span class="number">110</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">DESC</span>,salary <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id,</span><br><span class="line">salary<span class="operator">*</span><span class="number">12</span> newsalary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> newsalary <span class="keyword">DESC</span>,last_name <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">8008</span> <span class="keyword">AND</span> <span class="number">17000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">20</span>,<span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id,email,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">like</span> <span class="string">&#x27;%e%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> LENGTH(email) <span class="keyword">DESC</span>,department_id <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DESC</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> employee_id,department_name</span><br><span class="line"><span class="keyword">from</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t1.employee_id,t2.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees t1,departments t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.department_id <span class="operator">=</span> t2.department_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.employee_id,e.last_name,d.department_name,l.city</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">AND</span> d.location_id <span class="operator">=</span> l.location_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> job_grades</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.salary,j.grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades j</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="keyword">BETWEEN</span> j.lowest_sal <span class="keyword">AND</span> j.highest_sal</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e1.employee_id,e1.last_name,e2.employee_id,e2.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e1,employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.manager_id <span class="operator">=</span> e2.employee_id</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id,</span><br><span class="line">salary<span class="operator">*</span><span class="number">12</span> newsalary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> newsalary <span class="keyword">DESC</span>,last_name <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e1.employee_id,e1.last_name,e2.employee_id,e2.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e1,employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.manager_id <span class="operator">=</span> e2.employee_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> CONCAT(e1.last_name,<span class="string">&#x27;  worked for &#x27;</span>,e2.last_name) &quot;details&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees e1 <span class="keyword">JOIN</span> employees e2</span><br><span class="line"><span class="keyword">ON</span> e1.manager_id <span class="operator">=</span> e2.employee_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> CURDATE(),NOW()</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name ,salary,<span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">&#x27;富人&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">&#x27;中产&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">5000</span> <span class="keyword">THEN</span> <span class="string">&#x27;屌丝&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;穷人&#x27;</span> <span class="keyword">END</span> &quot;标签&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> PASSWORD(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> MD5(<span class="string">&#x27;mysql&#x27;</span>),SHA(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> VERSION(),CONNECTION_ID()</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,LENGTH(last_name)</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> last_name <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,ROUND(DATEDIFF(CURDATE(),hire_date)<span class="operator">/</span><span class="number">365</span>,<span class="number">1</span>) &quot;work_years&quot; ,DATEDIFF(CURDATE(),hire_date) </span><br><span class="line">&quot;work_days&quot; <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> work_days <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,hire_date,department_id</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> department_id <span class="keyword">IN</span> (<span class="number">80</span>,<span class="number">90</span>,<span class="number">110</span>)</span><br><span class="line"><span class="keyword">AND</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">AND</span> hire_date <span class="operator">&gt;=</span> <span class="string">&#x27;1997-01-01&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),<span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary),<span class="built_in">MAX</span>(salary),<span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,job_id,<span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id,job_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">10000</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">10000</span> <span class="keyword">AND</span> department_id <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>) </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line">#选择具有各个job_id的员工人数</span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="built_in">COUNT</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"></span><br><span class="line">#查询员工最高工资与最低工资的差距</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary)<span class="operator">-</span><span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#查询管理者手下员工的最低工资，其中最低不超过<span class="number">6000</span>，没有管理者的不再内</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> manager_id,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">where</span> manager_id <span class="keyword">is</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> salary <span class="operator">&gt;=</span> <span class="number">6000</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line">#<span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary) <span class="operator">&gt;=</span><span class="number">6000</span></span><br><span class="line"></span><br><span class="line">#查询所有部门的名字，位置，员工数量和平均工资，按平均工资排序</span><br><span class="line"><span class="keyword">SELECT</span> d.department_name,d.location_id,<span class="built_in">count</span>(employee_id),<span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> departments d <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.department_id <span class="operator">=</span> e.department_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name,location_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e2.last_name,e2.salary</span><br><span class="line"><span class="keyword">from</span> employees e1,employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e2.salary <span class="operator">&gt;</span> e1.salary</span><br><span class="line"><span class="keyword">AND</span> e1.last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">where</span> employee_id <span class="operator">=</span> <span class="number">149</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary) <span class="operator">&gt;</span> (</span><br><span class="line">                   <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line"> <span class="keyword">FROM</span> employees</span><br><span class="line"> <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(salary) <span class="keyword">ASC</span></span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id </span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&lt;=</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> e.department_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">Asc</span> ,salary <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>mybatis是一款优秀的dao持久层框架，使用Java程序操作数据库</p><p>使用mybatis操作数据库，就是在mybatis中编写查询代码，发送给数据库执行，数据库执行后，会把数据执行的查询结果，使用实体类封装起来（一行记录对应一个实体类对象）</p><p>使用实体类定义对象的属性的时候，要用包装类，因为数据库中的数据存在为空的情况，字段会返回值null，int类型的默认数值为0，包装类Integer 的默认类型为null</p><h3 id="mybatis快速入门"><a href="#mybatis快速入门" class="headerlink" title="mybatis快速入门"></a>mybatis快速入门</h3><p>1.创建springboot工程，数据表user，实体类User</p><p>2.引入mybatis的相关依赖，mybatis Framework框架，MySQL Driver配置信息</p><p>在resource中的application中里配置数据库的驱动，url，用户名，密码等</p><p>3.定义接口，@Mapper ,注解用于运行时自动生成实现类对象，交给spring的IOC容器管理</p><p>​                       @select，编写SQL语句</p><p>4，单元测试：通过依赖注入@Autowired，注入mapper接口，再调用mapper接口的list方法，输出所查询到的数据</p><h4 id="JDBC：Java-DataBase-Connectivity"><a href="#JDBC：Java-DataBase-Connectivity" class="headerlink" title="JDBC：Java DataBase Connectivity"></a>JDBC：Java DataBase Connectivity</h4><p>使用Java操作数据库的一套api，一套操作所有关系型数据库的规范，即接口。各个数据库厂商去实现这套接口</p><p>Mybatis框架，就是对原始的JDBC程序的封装。 </p><p> 原始jdbc程序的步骤：</p><p>1.注册驱动</p><p>2.获取链接对象</p><p>3.执行SQL语句，返回执行结果</p><p>4.处理执行结果</p><p>5.释放资源</p><p>缺点：</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day08-MySQL-Mybatis入门\讲义\02-Mybatis入门\assets\image-20221210153407998.png" alt="image-20221210153407998"></p><p>mybatis中对这些问题的解决</p><p>1.数据库链接的四要素，(驱动，链接，用户名，密码)，都配置在springboot的默认配置文件中，</p><p>2.查俊结果以及解析的封装，都由mybatis自动完成映射封装，我们无需关注</p><p>3.在mybatis中使用了数据库的连接池技术，从而避免了频繁的创建链接，销毁链接而带来的资源浪费</p><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><p>没有使用数据库连接池：</p><p>​客户端执行SQL语句，要先创建一个链接对象，在执行SQL，执行完后要释放，每次都要，频繁的重复销毁会比较耗费计算机的性能</p><p>数据库连接池是个容器，负责分配管理数据库的链接Connection</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day08-MySQL-Mybatis入门\讲义\02-Mybatis入门\assets\image-20221210161016314.png" alt="image-20221210161016314"></p><ul><li>程序在启动时，会在数据库连接池(容器)中，创建一定数量的Connection对象</li></ul><p>允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</p><ul><li>客户端在执行SQL时，先从连接池中获取一个Connection对象，然后在执行SQL语句，SQL语句执行完之后，释放Connection时就会把Connection对象归还给连接池（Connection对象可以复用）</li></ul><p>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</p><ul><li>客户端获取到Connection对象了，但是Connection对象并没有去访问数据库(处于空闲)，数据库连接池发现Connection对象的空闲时间 &gt; 连接池中预设的最大空闲时间，此时数据库连接池就会自动释放掉这个连接对象</li></ul><p><strong>连接池的好处：</strong></p><p>资源重用</p><p>提升系统的响应速度</p><p>避免数据库的链接泄露</p><h4 id="产品：常用的数据库连接池"><a href="#产品：常用的数据库连接池" class="headerlink" title="产品：常用的数据库连接池"></a>产品：常用的数据库连接池</h4><p>Hikari：追光者，springboot默认的连接池</p><p>Druid：德鲁伊，阿里开源的数据库连接池</p><p>修改连接池的方法：直接引入依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Druid连接池依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h3><p>是一个实用的JAVA类库，通过注解的方式自动生成，构造器，getter,setter,hashcode,toString等方法，并且可以自动化生成日志变量，简化JAVA开发，提高效率</p><table><thead><tr><th align="left"><strong>注解</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td align="left">@Getter&#x2F;@Setter</td><td>为所有的属性提供get&#x2F;set方法</td></tr><tr><td align="left">@ToString</td><td>会给类自动生成易阅读的  toString 方法</td></tr><tr><td align="left">@EqualsAndHashCode</td><td>根据类所拥有的非静态字段自动重写 equals 方法和  hashCode 方法</td></tr><tr><td align="left">@Data</td><td>提供了更综合的生成代码功能（@Getter  + @Setter + @ToString + @EqualsAndHashCode）</td></tr><tr><td align="left">@NoArgsConstructor</td><td>为实体类生成无参的构造器方法</td></tr><tr><td align="left">@AllArgsConstructor</td><td>为实体类生成除了static修饰的字段之外带有各参数的构造器方法。</td></tr></tbody></table><p>使用：</p><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在springboot的父工程中，已经集成了lombok并指定了版本号，故当前引入依赖时不需要指定version --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在实体类上添加注解</p><h2 id="Mybatis的基础操作"><a href="#Mybatis的基础操作" class="headerlink" title="Mybatis的基础操作"></a>Mybatis的基础操作</h2><h4 id="日志输入"><a href="#日志输入" class="headerlink" title="日志输入"></a>日志输入</h4><p>打开application.properties文件,配置文件，配置一下属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#指定mybatis输出日志的位置, 输出控制台</span><br><span class="line">mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><p>1.删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Mapper</span></span><br><span class="line">public interface EmpMapper &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="variable">@Delete</span>(&quot;delete from emp where id = 17&quot;)</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>public void <span class="keyword">delete</span>();</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>以上<span class="keyword">delete</span>操作的<span class="keyword">SQL</span>语句中的id值写成固定的<span class="number">17</span>，就表示只能删除id<span class="operator">=</span><span class="number">17</span>的用户数据</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="keyword">SQL</span>语句中的id值不能写成固定数值，需要变为动态的数值</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>解决方案：在<span class="keyword">delete</span>方法中添加一个参数(用户id)，将方法中的参数，传给<span class="keyword">SQL</span>语句</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="variable">@Delete</span>(&quot;delete from emp where id = #&#123;id&#125;&quot;)<span class="operator">/</span><span class="operator">/</span>使用#&#123;key&#125;方式获取方法中的参数值</span><br><span class="line">    public void <span class="keyword">delete</span>(<span class="type">Integer</span> id);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#{id} 是一个占位符，表示要传递给SQL语句的参数值。这个占位符会在实际执行时被具体的参数值替代</p><h4 id="预编译SQL"><a href="#预编译SQL" class="headerlink" title="预编译SQL"></a>预编译SQL</h4><p>优势：1.性能更高 2.更安全：防止SQL注入</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day09-Mybatis\讲义\assets\image-20221210202222206.png" alt="image-20221210202222206"></p><p>普通的SQL执行过程：解析-优化-编译-执行</p><p>预编译SQL：编译一次后将SQL语句缓存起来，后续再执行时，不会再次编译，只是输入的参数不同</p><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>原因：由于没有对用户输入内容进行充分检查，而SQL又是字符串拼接方式而成，在用户输入参数时，在参数中添加一些SQL关键字，达到改变SQL运行结果的目的，从而完成恶意攻击。</p><p>举例：一个登录管理系统中，有账户名和密码字段，而判断是否为用户登陆就是，查询用户名和密码字段是否与数据库中的匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>SQL注入：任意username ，password为 ‘ or ‘1’&#x3D;’1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>用户在页面提交数据的时候人为的添加一些特殊字符，使得sql语句的结构发生了变化，最终可以在没有用户名或者密码的情况下进行登录。</p><h4 id="参数占位符"><a href="#参数占位符" class="headerlink" title="参数占位符"></a>参数占位符</h4><p>在mybatis中提供的参数占位符有两种：${}，#{}</p><ul><li><p>#{…}</p><ul><li>执行SQL时，会将#{…}替换为?，生成预编译SQL，会自动设置参数值</li><li>使用时机：参数传递，都使用#{…}</li></ul></li><li><p>${…}</p><ul><li>拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题</li><li>使用时机：如果对表名、列表进行动态设置时使用</li></ul></li></ul><p>用like等模糊查询时，需要使用MySQL提供的字符串拼接函数：concat(‘%’ , ‘关键字’ , ‘%’)，以防止SQL注入问题</p><p>在上面我们所编写的条件查询功能中，我们需要保证接口中方法的形参名和SQL语句中的参数占位符名相同。</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20230925145458269.png" alt="image-20230925145458269"></p><h4 id="MyBatista的XML配置文件"><a href="#MyBatista的XML配置文件" class="headerlink" title="MyBatista的XML配置文件"></a>MyBatista的XML配置文件</h4><p>使用MyBatista注解的方式，主要是完成一些简单的增删改查功能</p><p>如果需要实现复杂的SQL功能，建议使用XML配置映射，将SQL语句写在XML配置文件中</p><p>在MyBatis中使用XML需要符合一定的规范</p><p>1.XML映射文件名称与Mapper接口的名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名） 一个接口对应一个相同的XML文件</p><p>2.XML映射文件的namespace属性与Mapper接口全限定名一样</p><p>3.XML映射文件中SQL语句的id与Mapper接口的方法名称一样，并且保持返回类型一致</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day09-Mybatis\讲义\assets\image-20221212153529732.png" alt="image-20221212153529732"></p><p>配置：XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day09-Mybatis\讲义\assets\image-20221212163528787.png" alt="image-20221212163528787"></p><h4 id="Mybatis动态SQL"><a href="#Mybatis动态SQL" class="headerlink" title="Mybatis动态SQL"></a>Mybatis动态SQL</h4><p> SQL语句会随着用户的输入或者外部的条件变化而变化，称为：动态SQL</p><p>动态SQL-if</p><p><if>：用于判断条件是否成立，使用test进行条件判断，如果条件为TRUE，则拼接</if></p><p><where>:<code>&lt;where&gt;</code>只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR</where></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- if做为where标签的子元素 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                 and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                 and gender = #&#123;gender&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">        order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><set>:动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）</set></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">    update emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username = #&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span> name = #&#123;name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span>gender = #&#123;gender&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;image != null&quot;</span>&gt;</span>image = #&#123;image&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>job = #&#123;job&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;entrydate != null&quot;</span>&gt;</span>entrydate = #&#123;entrydate&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptId != null&quot;</span>&gt;</span>dept_id = #&#123;deptId&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span>update_time = #&#123;updateTime&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p><foreach>:遍历操作</foreach></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--批量删除员工(1,2,3)</span></span><br><span class="line"><span class="comment">    collection:遍历的集合</span></span><br><span class="line"><span class="comment">    item:遍历出来的元素</span></span><br><span class="line"><span class="comment">    separator:分隔符</span></span><br><span class="line"><span class="comment">    open:遍历开始的SQL片段</span></span><br><span class="line"><span class="comment">    close:遍历结束后的SQL片段</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete from emp where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;sql&gt;</code>：定义可重用的SQL片段</p><p><include>&#96;：通过属性refid，指定包含的SQL片段，在原来抽取的地方进行引用</include></p><h4 id="案例的开发规范与开发流程"><a href="#案例的开发规范与开发流程" class="headerlink" title="案例的开发规范与开发流程"></a>案例的开发规范与开发流程</h4><h4 id="开发规范-REST"><a href="#开发规范-REST" class="headerlink" title="开发规范-REST"></a>开发规范-REST</h4><p>在前后端进行交互的时候，要基于当前主流的的REST风格的API进行交互</p><p>REST是一种风格，REST（Representational State Transfer），表述性状态转换，它是一种软件架构风格。</p><p>传统的url风格如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/user/getById?id=1     GET：查询id为1的用户</span><br><span class="line">http://localhost:8080/user/saveUser         POST：新增用户</span><br><span class="line">http://localhost:8080/user/updateUser       POST：修改用户</span><br><span class="line">http://localhost:8080/user/deleteUser?id=1  GET：删除id为1的用户</span><br></pre></td></tr></table></figure><p>基于REST风格的URL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/users/1  GET：查询id为1的用户</span><br><span class="line">http://localhost:8080/users    POST：新增用户</span><br><span class="line">http://localhost:8080/users    PUT：修改用户</span><br><span class="line">http://localhost:8080/users/1  DELETE：删除id为1的用户</span><br></pre></td></tr></table></figure><p>总结：通过url定位要操作的资源，通过HTTP请求方式来描述具体的操作</p><p>GET：查询  </p><p>POST：新增   </p><p>PUT：修改</p><p>DELETE：删除</p><h4 id="开发规范-统一响应流程"><a href="#开发规范-统一响应流程" class="headerlink" title="开发规范-统一响应流程"></a>开发规范-统一响应流程</h4><p>在使用前后端工程交互的时候，统一使用响应结果Result</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;<span class="comment">//响应码，1 代表成功; 0 代表失败</span></span><br><span class="line">    <span class="keyword">private</span> String msg;  <span class="comment">//响应信息 描述字符串</span></span><br><span class="line">    <span class="keyword">private</span> Object data; <span class="comment">//返回的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增删改 成功响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询 成功响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//失败响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>,msg,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发流程</p><p>查看页面原型明确需求–&gt;阅读接口文档–&gt;思路分析–&gt;接口开发–&gt;接口测试–&gt;前后端联调</p><p>基本上就是围绕接口文档做开发，要用到spring中的很多注解</p><table><thead><tr><th>10月7日</th><th></th><th>复习相关注解</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>@Pathvarible</td><td></td><td></td><td>将路径url中提取参数并映射到方法参数中</td><td></td><td></td><td></td></tr><tr><td></td><td>@RequestBody</td><td></td><td></td><td>将HTTP请求的具体内容，JSON或者XML</td><td>映射到Java对象上</td><td></td><td></td></tr><tr><td>10月8日</td><td></td><td>后端按照接口的实现流程</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>Controller控制层</td><td></td><td></td><td>@RequestMapping请求路径 @RequestController控制器 @SLf4j自动定义日志记录对象log</td><td>@Autowired依赖注入 deptService对象 @XXXMapping限定请求方式</td><td>调用deptService.函数()</td><td></td></tr><tr><td></td><td>Service逻辑处理层</td><td></td><td></td><td>Service接口：定义接口方法 Service实现类:重写+逻辑处理</td><td>@Autowired依赖注入 deptMapper对象</td><td>调用deptMapper.函数()</td><td></td></tr><tr><td></td><td>Dao数据访问层</td><td></td><td></td><td>@Mapper注解：</td><td>表示mybatis映射的接口</td><td>定义数据库操作的方法</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>10月9日</td><td></td><td>根据接口文档的实现流程</td><td></td><td></td><td>请求路径：url 请求方式：get set put 请求参数;json</td><td>@RequestMapping&#x2F;@PathVarible @GetMapping @RequestBody</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>10月10日</td><td></td><td>分页查询插件PageHelper</td><td></td><td></td><td>PageHelper.startPage()设置分页参数</td><td>将查询结果强转为Page类型</td><td>调用page方法，getTotalgetResult</td></tr><tr><td></td><td>@RequestParam</td><td></td><td></td><td>defaultvalue，如果没有，设置默认值</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>写了份表格记录一下</p><p>大体的开发流程就是</p><p>1.根据接口文档确定是什么请求，一般是请求路径和请求方式</p><p>请求路径就是&#x2F;emp&#x2F;upload等等，请求方式：POST，GET，DELETE，等等</p><p>判断是否有路径参数或者请求参数等</p><p>2.在控制层，用XXXXMapping接受路径&#x2F;emp这些，定义一个类型为Result的返回函数，去接受参数</p><p>如果请求传递的是路径参数，就用注解@PathVariable接受</p><p>如果请求参数是JSON格式的，就需要自己定一个对象，对象的私有属性包含这些，必须同名称，然后用注解</p><p>@RequestBody接受，将请求参数封装到实体类的私有属性中，再去调用</p><p>3.在控制层用@AutoWired自动注入service层的接口对象，调用service接口层中声明的方法，</p><p>定义业务实现类serviceImpl，具体实现这些方法，做一些逻辑处理，并且在类中，自动注入mybatis层的对象</p><p>4.在数据控制层就是Mybatis层，用注解@Mapper，这里主要是一些调用数据库的操作</p><p>用注解@Select,@delete等等，注解地下声明一个方法，用于接受查询返回的值</p><p>或者在resource层中定义xml配置文件，xml配置文件的位置定义要有讲究，在resource层下，要与mapper层的包名类名相同，在xml配置文件中定义动态查询语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EmpService empService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">page</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> Integer page,</span></span><br><span class="line"><span class="params">                   <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> Integer pageSize,</span></span><br><span class="line"><span class="params">                    String name,</span></span><br><span class="line"><span class="params">                    Short gender,</span></span><br><span class="line"><span class="params">                   <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate begin,</span></span><br><span class="line"><span class="params">                   <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end</span></span><br><span class="line"><span class="params">                   )</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;分页查询部门数据&quot;</span>);</span><br><span class="line">    <span class="type">PageBean</span> <span class="variable">pageBean</span> <span class="operator">=</span> empService.page(page,pageSize,name,gender,begin,end);</span><br><span class="line">    <span class="keyword">return</span> Result.success(pageBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@RequestParam(defaultValue = &quot;1&quot;) Integer page</code>：这是一个查询参数，用于指定页码，默认值是 1。<code>@RequestParam</code> 用于从请求中获取名为 <code>page</code> 的参数值。如果请求中没有 <code>page</code> 参数，它将使用默认值 1。</p><p>在 Spring MVC 中，默认情况下，如果方法参数的名称与请求中的查询参数名称匹配，Spring 将自动将请求参数值绑定到方法参数，无需显式使用 <code>@RequestParam</code> 注解。这意味着当客户端发送一个请求，其中包含名为 <code>name</code> 和 <code>gender</code> 的查询参数时，Spring 将自动将它们绑定到方法的 <code>name</code> 和 <code>gender</code> 参数上。</p><h4 id="文件上传功能"><a href="#文件上传功能" class="headerlink" title="文件上传功能"></a>文件上传功能</h4><p>1.前端程序，定义form表单</p><p>我们先来看看在前端程序中要完成哪些代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">姓名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    头像: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上传文件的原始form表单，要求表单必须具备以下三点（上传文件页面三要素）：</p><ul><li><p>表单必须有file域，用于选择要上传的文件</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>表单提交方式必须为POST</p><blockquote><p>通常上传的文件会比较大，所以需要使用 POST 提交方式</p></blockquote></li><li><p>表单的编码类型enctype必须要设置为：multipart&#x2F;form-data</p><blockquote><p>普通默认的编码格式是不适合传输大型的二进制数据的，所以在文件上传时，表单的编码格式必须设置为multipart&#x2F;form-data</p></blockquote></li></ul><p>2.后端程序</p><p>​在服务端定义一个Controller用于文件的上传，在controller中定义一个方法，来处理&#x2F;upload请求</p><p>​在定义的方法中接收提交过来的数据（形参名称和请求参数名称保持一致）不一样用@RequestParam</p><p>​spring中提供了一个API：MultipartFile  image 接收文件</p><p>MultipartFile 常见方法： </p><ul><li>String  getOriginalFilename();  &#x2F;&#x2F;获取原始文件名</li><li>void  transferTo(File dest);     &#x2F;&#x2F;将接收的文件转存到磁盘文件中</li><li>long  getSize();     &#x2F;&#x2F;获取文件的大小，单位：字节</li><li>byte[]  getBytes();    &#x2F;&#x2F;获取文件内容的字节数组</li><li>InputStream  getInputStream();    &#x2F;&#x2F;获取接收到的文件内容的输入流</li></ul><p>用image.XXX调用即可</p><p>并且使用UUID获取随机文件名称，保证每次上传时候的文件名称都是唯一的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(String username, Integer age, MultipartFile image)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;文件上传：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,username,age,image);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取原始文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建新的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extname</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));<span class="comment">//文件扩展名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString()+extname;<span class="comment">//随机名+文件扩展名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将文件存储在服务器的磁盘目录</span></span><br><span class="line">        image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/images/&quot;</span>+newFileName));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只是将上传的文件保存到本地</p><p>上传到阿里云OSS（Object Storage Service）</p><p>注册:获得阿里云的AccessKey，bucketname等信息</p><p>参照官方实例文档的SDK</p><p>在Maven项目中使用OSS的SDK，只需要pom文件中添加相应的pom依赖即可</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20231029151527018.png" alt="image-20231029151527018"></p><p>导入依赖后，修改官方参考文档，调用oss中的相关函数，实现文件的上传</p><p>使用唯一的UUID确保上传的文件名称唯一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSS;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSSClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;https://oss-cn-shanghai.aliyuncs.com&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> <span class="string">&quot;LTAI5t9MZK8iq5T2Av5GLDxX&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> <span class="string">&quot;C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> <span class="string">&quot;web-framework01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现上传图片到OSS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取上传的文件的输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> multipartFile.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免文件覆盖</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> multipartFile.getOriginalFilename();</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上传文件到 OSS</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">        ossClient.putObject(bucketName, fileName, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> endpoint.split(<span class="string">&quot;//&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;//&quot;</span> + bucketName + <span class="string">&quot;.&quot;</span> + endpoint.split(<span class="string">&quot;//&quot;</span>)[<span class="number">1</span>] + <span class="string">&quot;/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭ossClient</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        <span class="keyword">return</span> url;<span class="comment">// 把上传到oss的路径返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后返回的url就是图片的地址，例如：</p><p><a href="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/01b43569-4c97-4efe-8e0a-7631044b4ac1.jpg">https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/01b43569-4c97-4efe-8e0a-7631044b4ac1.jpg</a></p><p>用网址打开会直接显示下载，在前端的页面就会直接渲染出来</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>上述阿里云的配置信息写死在了代码中（硬编码）</p><p>缺点：在源码中重新改动，要重新编译，配置参数过于分散，不便于集中维护和管理</p><p>解决方法1：在application.properties中定义配置信息，再使用注解@Value注入</p><p>@Value 注解通常用于外部配置的属性注入，具体用法为： @Value(“${配置文件中的key}”)</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day11-SpringBootWeb案例\讲义\assets\image-20230102173905913.png" alt="image-20230102173905913"></p><h4 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h4><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day11-SpringBootWeb案例\讲义\assets\image-20230102181215809.png" alt="image-20230102181215809"></p><p>简单的了解过springboot所支持的配置文件，以及不同类型配置文件之间的优缺点之后，接下来我们就来了解下yml配置文件的基本语法：</p><ul><li>大小写敏感</li><li>数值前边必须有空格，作为分隔符</li><li>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day11-SpringBootWeb案例\讲义\assets\image-20230103084645450.png" alt="image-20230103084645450"></p><p>了解完yml格式配置文件的基本语法之后，接下来我们再来看下yml文件中常见的数据格式。在这里我们主要介绍最为常见的两类：</p><ol><li>定义对象或Map集合</li><li>定义数组、list或set集合</li></ol><p>对象&#x2F;Map集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>数组&#x2F;List&#x2F;Set集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hobby:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sport</span></span><br></pre></td></tr></table></figure><p>@ConfigurationProperties(prefix &#x3D; “aliyun.oss”)</p><p>Spring提供的简化方式套路：</p><ol><li><p>需要创建一个实现类，且实体类中的属性名和配置文件当中key的名字必须要一致</p><blockquote><p>比如：配置文件当中叫endpoints，实体类当中的属性也得叫endpoints，另外实体类当中的属性还需要提供 getter &#x2F; setter方法</p></blockquote></li><li><p>需要将实体类交给Spring的IOC容器管理，成为IOC容器当中的bean对象@Compoent</p></li><li><p>在实体类上添加<code>@ConfigurationProperties</code>注解，并通过perfect属性来指定配置参数项的前缀</p></li><li><p>直接@Autowired自动注入bean对象，调用get方法获取到属性值即可</p></li></ol><p>分</p><h4 id="登录认证："><a href="#登录认证：" class="headerlink" title="登录认证："></a>登录认证：</h4><p>新建LoginController控制层，service层和mapper，因为是底层校验员工的数据，所以还是用员工emp层的即可</p><p>select * from emp where userame &#x3D; #{} and pasword &#x3D; #{}</p><p>返回查询到的员工信息，判断是否为null，判断成功或者失败</p><p>直接登陆的功能有漏洞，开发的接口功能在服务端没有做任何的判断，就去实现，所以无论用于是否登陆，都能执行数据的操作，所以需要登陆校验</p><h4 id="登陆校验"><a href="#登陆校验" class="headerlink" title="登陆校验"></a>登陆校验</h4><p>HTTP协议是无状态协议，每次请求都是独立的，下次的请求不会携带上一次的数据，所以我们在执行业务操作的时候，服务器也不知道这个员工是否登陆了</p><p>解决方法：</p><p>1.登陆标记</p><p>2.同意拦截，登陆校验</p><h4 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h4><p>会话跟踪技术有两种：</p><ol><li>Cookie（客户端会话跟踪技术）<ul><li>数据存储在客户端浏览器当中</li></ul></li><li>Session（服务端会话跟踪技术）<ul><li>数据存储在储在服务端</li></ul></li><li>令牌技术</li></ol><p>在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><h5 id="方案一：cookie"><a href="#方案一：cookie" class="headerlink" title="方案一：cookie"></a>方案一：cookie</h5><p>cookie是会话跟踪技术，存储在客户端浏览器的，<strong>第一次发起请求的时候，在服务器设置一个cookie</strong>，在cookie中存储用户相关的一些数据信息，例如：登陆的用户名称，id等等</p><p>之后服务端在给客户端响应的时候，同时会将cookie响应给浏览器，浏览器收到cookie后，会自动将其存储在浏览器本地，在后面的每一次请求之后，都会将本地存储的cookie自动携带到服务端，服务端就会判断是否存在cookie的数值，如果有，就说明之前已经登陆完成了，，基于cookie的在同一次会话的不同请求之间共享数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie会话跟踪技术的主要过程</span><br><span class="line">1.客户端发起请求</span><br><span class="line">2.服务器处理请求：服务器会在响应中包含一个Set-Cookie头部，用来设置cookie</span><br><span class="line">3.设置cookie：浏览器接收到服务器的响应后，会解析set-cookie，将其中的cookie信息保存到浏览器本地中</span><br><span class="line">4.发送请求：浏览器再次向服务端发起请求，浏览器会将cookie包含在请求头中，发送给服务器</span><br><span class="line">5.服务器读取cookie，根据cookie的内容，识别用户的身份，会话状态等信息</span><br><span class="line">6.服务器根据收到的 Cookie 信息，对请求进行处理。根据需要，可以向客户端发送新的 Cookie 信息，更新会话状态。</span><br><span class="line">7，重复1-6步</span><br></pre></td></tr></table></figure><p>cookie是浏览器HTTP协议之中所支持的数据，所以</p><p>用了 3 个自动：</p><ul><li><p>服务器会 <strong>自动</strong> 的将 cookie 响应给浏览器。</p></li><li><p>浏览器接收到响应回来的数据之后，会 <strong>自动</strong> 的将 cookie 存储在浏览器本地。</p></li><li><p>在后续的请求当中，浏览器会 <strong>自动</strong> 的将 cookie 携带到服务器端。</p></li></ul><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day12-SpringBootWeb登录认证\讲义\assets\image-20230112101804878.png" alt="image-20230112101804878"></p><p>cookie的优缺点</p><p>优点：HTTP协议之中支持的技术，浏览器自动响应，存储cookie，无需我们手动进行</p><p>缺点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">移动端无法使用cookie，浏览器设置中可以自己禁止使用cookie</span><br><span class="line"></span><br><span class="line">​开发中通常前端Tomcat和服务器端会部署在不同的的服务器中，IP地址和端口号各不相同</span><br><span class="line"></span><br><span class="line">​就存在跨域操作，cookie无法跨域</span><br></pre></td></tr></table></figure><p>补充:区分跨域的维度：</p><ul><li>协议</li><li>IP&#x2F;协议</li><li>端口</li></ul><p>只要上述的三个维度有任何一个维度不同，那就是跨域操作</p><h5 id="方案二：Session会话跟踪"><a href="#方案二：Session会话跟踪" class="headerlink" title="方案二：Session会话跟踪"></a>方案二：Session会话跟踪</h5><p>底层基于cookie实现的，但是存储在服务器端，相较于cookie更安全一些</p><p>前面介绍的时候，我们提到Session，它是服务器端会话跟踪技术，所以它是存储在服务器端的。而 Session 的底层其实就是基于我们刚才所介绍的 Cookie 来实现的。</p><ul><li><p>获取Session</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day12-SpringBootWeb登录认证\讲义\assets\image-20230112105938545.png" alt="image-20230112105938545"> </p><p>如果我们现在要基于 Session 来进行会话跟踪，浏览器在第一次请求服务器的时候，我们就可以直接在服务器当中来获取到会话对象Session。如果是第一次请求Session ，会话对象是不存在的，这个时候服务器会自动的创建一个会话对象Session 。而每一个会话对象Session ，它都有一个ID（示意图中Session后面括号中的1，就表示ID），我们称之为 Session 的ID。</p></li><li><p>响应Cookie (JSESSIONID)</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day12-SpringBootWeb登录认证\讲义\assets\image-20230112110441075.png" alt="image-20230112110441075"> </p><p>接下来，服务器端在给浏览器响应数据的时候，它会将 Session 的 ID 通过 Cookie 响应给浏览器。其实在响应头当中增加了一个 Set-Cookie 响应头。这个  Set-Cookie  响应头对应的值是不是cookie？ cookie 的名字是固定的 JSESSIONID 代表的服务器端会话对象 Session 的 ID。浏览器会自动识别这个响应头，然后自动将Cookie存储在浏览器本地。</p></li><li><p>查找Session</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day12-SpringBootWeb登录认证\讲义\assets\image-20230112101943835.png" alt="image-20230112101943835"> </p><p>接下来，在后续的每一次请求当中，都会将 Cookie 的数据获取出来，并且携带到服务端。接下来服务器拿到JSESSIONID这个 Cookie 的值，也就是 Session 的ID。拿到 ID 之后，就会从众多的 Session 当中来找到当前请求对应的会话对象Session。</p></li></ul><p><strong>优缺点</strong></p><ul><li>优点：Session是存储在服务端的，安全</li><li>缺点：<ul><li>服务器集群环境下无法直接使用Session</li><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.客户端发起请求： 用户在浏览器中输入网址或点击链接，向服务器发起请求。</span><br><span class="line"></span><br><span class="line">2.服务器处理请求： 服务器接收到请求后，根据请求的内容进行处理。如果需要进行会话跟踪，服务器会为每个客户端创建一个唯一的会话标识，并将该会话标识与客户端关联起来。</span><br><span class="line"></span><br><span class="line">3.生成 Session ID： 在服务器端生成一个唯一的 Session ID，用来标识当前会话。Session ID 可以是一个随机生成的字符串，也可以是其他形式的唯一标识符。</span><br><span class="line"></span><br><span class="line">4.存储 Session 数据： 服务器将生成的 Session ID 与会话数据进行关联，并将该关联保存在服务器端的存储介质中，如内存、数据库、文件系统等。会话数据可以包含用户的身份信息、会话状态、购物车内容等。</span><br><span class="line"></span><br><span class="line">5.返回 Session ID： 服务器在响应中包含一个 Set-Cookie 头部，用来设置一个名为 &quot;JSESSIONID&quot; 的 Cookie，并将 Session ID 的值设置为该 Cookie 的内容。这样，客户端在收到响应后就会保存 Session ID。</span><br><span class="line"></span><br><span class="line">6.发送请求： 当用户再次向服务器发起请求时，浏览器会自动将之前保存的 Session ID 包含在请求头中，并发送给服务器。</span><br><span class="line"></span><br><span class="line">7.读取 Session 数据： 服务器接收到请求后，从请求头中读取到 Session ID。根据 Session ID，服务器可以在存储介质中检索到相应的会话数据，并根据需要进行处理。</span><br><span class="line"></span><br><span class="line">8.处理请求： 服务器根据收到的 Session 数据，对请求进行处理。根据需要，可以更新会话状态、添加新的会话数据等。</span><br><span class="line"></span><br><span class="line">重复步骤 6~8： 在会话过程中，客户端和服务器会持续交互，根据需要更新和读取 Session 数据，以实现持续的会话跟踪。</span><br></pre></td></tr></table></figure><p>一般企业项目不会部署在同一个服务器上的，因为一个挂了就没法访问了，所以是服务器集群</p><p>会有一个均衡负载服务器，将前端请求均匀的分发给集群的服务器</p><h5 id="方案三：令牌技术"><a href="#方案三：令牌技术" class="headerlink" title="方案三：令牌技术"></a>方案三：令牌技术</h5><p>​在请求登陆接口的时候，如果登陆成功，就生成一个令牌，令牌就是用户的合法身份凭证，接下来响应数据的时候，将令牌响应给前端</p><p>​接下来我们在前端程序当中接收到令牌之后，就需要将这个令牌存储起来。这个存储可以存储在 cookie 当中，也可以存储在其他的存储空间(比如：localStorage)当中。</p><p>​接下来，在后续的每一次请求当中，都需要将令牌携带到服务端。携带到服务端之后，接下来我们就需要来校验令牌的有效性。如果令牌是有效的，就说明用户已经执行了登录操作，如果令牌是无效的，就说明用户之前并未执行登录操作。</p><p><strong>优缺点</strong></p><ul><li>优点：<ul><li>支持PC端、移动端</li><li>解决集群环境下的认证问题</li><li>减轻服务器的存储压力（无需在服务器端存储）</li></ul></li><li>缺点：需要自己实现（包括令牌的生成、令牌的传递、令牌的校验）</li></ul><h4 id="JWT令牌：JSON-Web-Token"><a href="#JWT令牌：JSON-Web-Token" class="headerlink" title="JWT令牌：JSON Web Token"></a>JWT令牌：JSON Web Token</h4><p>定义了一种简洁的，自包含的，用于通信双方以JSON数据格式安全传递信息，由于数字签名的存在，这些信息是可靠的。</p><p>组成：三部分组成</p><p>第一部分：head头，记录令牌的类型，签名是算法</p><p>第二部分：payload有效载荷，携带一些自定义，默认的信息</p><p>第三部分：数字签名：防止token被篡改等</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day12-SpringBootWeb登录认证\讲义\assets\image-20230106085442076.png" alt="image-20230106085442076"></p><blockquote><p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？</p><p>其实在生成JWT令牌时，会对JSON格式的数据进行一次编码：进行base64编码</p><p>Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号</p><p>需要注意的是Base64是编码方式，而不是加密方式。</p></blockquote><p>jwt令牌的应用场景：登录认证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.登陆成功后，生成一个jwt令牌，并且返回给前端</span><br><span class="line"></span><br><span class="line">2.前端拿到存储起来，后续每一次的请求都会将jwt令牌携带到服务器端口</span><br><span class="line"></span><br><span class="line">3.服务器端口，统一拦截请求后，判断和校验jwt令牌，通过即可放行处理</span><br></pre></td></tr></table></figure><p>生成JWT令牌：引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JWT依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调用依赖jar包中的相关函数，实现JWT令牌的生成和校验，具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">signKey</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>;<span class="comment">//签名密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">43200000L</span>; <span class="comment">//有效时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims JWT第二部分负载 payload 中存储的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateJwt</span><span class="params">(Map&lt;String, Object&gt; claims)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .addClaims(claims)<span class="comment">//自定义信息（有效载荷）</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, signKey)<span class="comment">//签名算法（头部）</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expire))<span class="comment">//过期时间</span></span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> jwt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT第二部分负载 payload 中存储的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span>&#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(signKey)<span class="comment">//指定签名密钥</span></span><br><span class="line">                .parseClaimsJws(jwt)<span class="comment">//指定令牌Token</span></span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h4><p>Filter是过滤器，是Javaweb三大组件之一：Servlet，Filter，Listener</p><p>把资源对应的请求拦截下来，实现过滤，过滤器处理完毕以后，才能够访问对应的资源</p><p>应用场景：比如：统一校验，统一编码处理，敏感字符处理等</p><p><img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day12-SpringBootWeb登录认证\讲义\assets\image-20230106222559935.png" alt="image-20230106222559935"></p><p><strong>1.定义过滤器</strong>：定义一个类，实现servlet中的Filter接口，并且重写其方法</p><p>Filter中有三个方法，分别对应</p><p>init过滤器的初始化，web服务器启动的时候 会自动创建Filter过滤器对象</p><p>doFilter拦截到后调用，每一次拦截到请求之后都会调用</p><p>destroy销毁方法后调用，关闭服务的时候会调用</p><p><strong>2.配置过滤器</strong>：在Filter类上加@WebFilter注解@WebFilter(urlPatterns &#x3D; “&#x2F;*”)&#x2F;&#x2F;表示拦截所有的请求</p><p>由于springboot中不包含对web组件servlet的支持，所以要在引导类上加@ServletComponentScan</p><p>开启servlet组件的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> <span class="comment">//配置过滤器要拦截的请求路径（ /* 表示拦截浏览器的所有请求 ）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//初始化方法, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 初始化方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//拦截到请求之后调用, 调用多次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo 拦截到了请求...放行前逻辑&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//销毁方法, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy 销毁方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程我们搞清楚之后，接下来再来介绍一下过滤器的拦截路径，Filter可以根据需求，配置不同的拦截资源路径：</p><table><thead><tr><th>拦截路径</th><th>urlPatterns值</th><th>含义</th></tr></thead><tbody><tr><td>拦截具体路径</td><td>&#x2F;login</td><td>只有访问 &#x2F;login 路径时，才会被拦截</td></tr><tr><td>目录拦截</td><td>&#x2F;emps&#x2F;*</td><td>访问&#x2F;emps下的所有资源，都会被拦截</td></tr><tr><td>拦截所有</td><td>&#x2F;*</td><td>访问所有资源，都会被拦截</td></tr></tbody></table><p><strong>过滤器链：</strong>一个web中，可以配置多个过滤器，形成一个过滤器链</p><p> <img src="/2024/03/25/JavaWeb/百度云下载\Javaweb资料\day12-SpringBootWeb登录认证\讲义\assets\image-20230107084730393.png" alt="image-20230107084730393"></p><p>过滤器链的执行顺序：通过注解@WebFilter配置的过滤器，优先级是通过按照过滤器的类名称（字符串)自然排序</p><h4 id="登陆校验流程"><a href="#登陆校验流程" class="headerlink" title="登陆校验流程"></a>登陆校验流程</h4><p>-在doFilter函数中具体要操作的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.获取请求url</span><br><span class="line"></span><br><span class="line">2.判断url中是否包含/login。如果包含，就是第一次登陆，放行</span><br><span class="line"></span><br><span class="line">3.获取请求头中的token的值jwt令牌</span><br><span class="line"></span><br><span class="line">4.判断令牌是否存在，如果不存在，返回错误结果</span><br><span class="line"></span><br><span class="line">5.解析token，如果解析失败，返回错误</span><br><span class="line"></span><br><span class="line">6.成功，放行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> <span class="comment">//拦截所有请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//前置：强制转换为http协议的请求对象、响应对象 （转换原因：要使用子类中特有方法）</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURL().toString();</span><br><span class="line">        log.info(<span class="string">&quot;请求路径：&#123;&#125;&quot;</span>, url); <span class="comment">//请求路径：http://localhost:8080/login</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.判断请求url中是否包含login，如果包含，说明是登录操作，放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;/login&quot;</span>))&#123;</span><br><span class="line">            chain.doFilter(request, response);<span class="comment">//放行请求</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//结束当前方法的执行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取请求头中的令牌（token）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;从请求头中获取的令牌：&#123;&#125;&quot;</span>,token);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断令牌是否存在，如果不存在，返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(token))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;Token不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Result</span> <span class="variable">responseResult</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONObject.toJSONString(responseResult);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//响应</span></span><br><span class="line">            response.getWriter().write(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.解析token，如果解析失败，返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(token);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;令牌解析失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Result</span> <span class="variable">responseResult</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONObject.toJSONString(responseResult);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//响应</span></span><br><span class="line">            response.getWriter().write(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>类似于过滤器，是springboot框架中提供的，用来动态拦截控制方法的执行</p><p>在拦截器中，拦截前端发起的请求，将登陆校验的逻辑全部写在拦截器当中，</p><p>拦截器的使用步骤：1.定义拦截器，2.注册配置拦截器</p><p><strong>自定义拦截器</strong>：实现HandlerInterceptor接口，并且重写其所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义拦截器</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//将该类交给IOC容器管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//目标资源方法执行前执行。 返回true：放行    返回false：不放行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle .... &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true表示放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标资源方法执行后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视图渲染完毕后执行，最后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion .... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册配置拦截器</strong>：实现WebMvcConfigurer接口，并且重写addInterceptor方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//说明该类是配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);<span class="comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拦截路径</strong>：首先我们先来看拦截器的拦截路径的配置，在注册配置拦截器的时候，我们要指定拦截器的拦截路径，通过<code>addPathPatterns(&quot;要拦截路径&quot;)</code>方法，就可以指定要拦截哪些资源。</p><p>在入门程序中我们配置的是<code>/**</code>，表示拦截所有资源，而在配置拦截器时，不仅可以指定要拦截哪些资源，还可以指定不拦截哪些资源，只需要调用<code>excludePathPatterns(&quot;不拦截路径&quot;)</code>方法，指定哪些资源不需要拦截。</p><p>在拦截器中除了可以设置<code>/**</code>拦截所有资源外，还有一些常见拦截路径设置：</p><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>一级路径</td><td>能匹配&#x2F;depts，&#x2F;emps，&#x2F;login，不能匹配 &#x2F;depts&#x2F;1</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2</td></tr><tr><td>&#x2F;depts&#x2F;*</td><td>&#x2F;depts下的一级路径</td><td>能匹配&#x2F;depts&#x2F;1，不能匹配&#x2F;depts&#x2F;1&#x2F;2，&#x2F;depts</td></tr><tr><td>&#x2F;depts&#x2F;**</td><td>&#x2F;depts下的任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2，不能匹配&#x2F;emps&#x2F;1</td></tr></tbody></table><p>拦截器和过滤器的执行流程：</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240308102935645.png" alt="image-20240308102935645"></p><p>1.Tomcat并不识别所编写的Controller程序，但是它识别Servlet程序，所以在Spring的Web环境中提供了一个非常核心的Servlet：DispatcherServlet（前端控制器），所有请求都会先进行到DispatcherServlet，再将请求转给Controller。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Filter过滤器和Interceptor拦截器</span><br><span class="line">接口规范不同：Filter是Servlet规范的接口，属于servlet容器的一部分，而interceptor是spring框架中提供的一种拦截机制，属于springMVC中的一部分</span><br><span class="line"></span><br><span class="line">拦截范围不同：过滤器会拦截所有资源，而拦截器只会拦截spring环境中的资源</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>1.在所有的Controller的方法中，进行try…catch处理（代码臃肿）</p><p>2.全局异常处理：定义全局异常处理器</p><ul><li>定义全局异常处理器非常简单，就是定义一个类，在类上加上一个注解@RestControllerAdvice，加上这个注解就代表我们定义了一个全局异常处理器。</li><li>在全局异常处理器当中，需要定义一个方法来捕获异常，在这个方法上需要加上注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定我们要捕获的是哪一类型的异常。</li></ul><p>@RestControllerAdvice<br>public class GlobalExceptionHandler {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span> <span class="comment">//指定能够处理的异常类型</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ex</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();<span class="comment">//打印堆栈中的异常信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//捕获到异常之后，响应一个标准的Result</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;对不起,操作失败,请联系管理员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务管理-AOP"><a href="#事务管理-AOP" class="headerlink" title="事务管理&amp;AOP"></a>事务管理&amp;AOP</h2><p>事务：事务是一组操作的集合，这些操作要么同时成功，要么同时失败</p><p>事务的操作主要有三步：</p><ol><li>开启事务（一组操作开始前，开启事务）：start transaction &#x2F; begin ;</li><li>提交事务（这组操作全部成功后，提交事务）：commit ;</li><li>回滚事务（中间任何一个操作出现异常，回滚事务）：rollback ;</li></ol><p>@Transactional注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Transaction作用：在当前方法执行前开启事务，方法执行完毕后结束事务，如果在这个方法执行的过程中出现了异常，就会进行事务的回滚操作</span><br><span class="line"></span><br><span class="line">作用地点：通常在业务层service层添加注解，因为在业务层中，一个业务的功能可能会包含多个数据操作的访问，在业务层控制事务，就可以将多个数据访问的操作控制在一个事物的范围内</span><br><span class="line"></span><br><span class="line">书写位置：方法：当前方法交给spring进行事务管理</span><br><span class="line">类：当前类中的所有方法都交给事务管理</span><br><span class="line">接口：接口下所有实现类中的所有方法都交给spring事务管理</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="事物进阶："><a href="#事物进阶：" class="headerlink" title="事物进阶："></a>事物进阶：</h3><p>@Transaction中的两个属性</p><p>1.事物回滚的异常属性：rollbackFor():</p><p>2.事物传播行为：propagation()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line"> &gt; 结论：</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 在Spring的事务管理中，默认只有运行时异常 RuntimeException才会回滚。</span><br><span class="line">&gt; - 如果还需要回滚指定类型的异常，可以通过rollbackFor属性来指定。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>propagation：</p><p>用来控制事务的传播属性，就是当一个事物方法被另一个事物方法调用时候，这个事物方法该如何进行事务控制</p><p>我们要想控制事务的传播行为，在@Transactional注解的后面指定一个属性propagation，通过 propagation 属性来指定传播行为。接下来我们就来介绍一下常见的事务传播行为。</p><table><thead><tr><th><strong>属性值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>REQUIRED</td><td>【默认值】需要事务，有则加入，无则创建新事务</td></tr><tr><td>REQUIRES_NEW</td><td>需要新事务，无论有无，总是创建新事务</td></tr><tr><td>SUPPORTS</td><td>支持事务，有则加入，无则在无事务状态中运行</td></tr><tr><td>NOT_SUPPORTED</td><td>不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务</td></tr><tr><td>MANDATORY</td><td>必须有事务，否则抛异常</td></tr><tr><td>NEVER</td><td>必须没事务，否则抛异常</td></tr><tr><td>…</td><td></td></tr></tbody></table><blockquote><p>对于这些事务传播行为，我们只需要关注以下两个就可以了：</p><ol><li>REQUIRED（默认值）</li><li>REQUIRES_NEW</li></ol></blockquote><h3 id="AOP：面相切面编程"><a href="#AOP：面相切面编程" class="headerlink" title="AOP：面相切面编程"></a>AOP：面相切面编程</h3><p>AOP：Aspect Oriented Programming 就是面向特定方法的编程</p><p> 而AOP面向方法编程，就可以做到在不改动这些原始方法的基础上，针对特定的方法进行功能的增强。</p><blockquote><p>AOP的作用：在程序运行期间在不修改源代码的基础上对已有方法进行增强（无侵入性: 解耦）</p></blockquote><p>比如：我们只想通过 部门管理的 list 方法的执行耗时，那就只有这一个方法是原始业务方法。  而如果，我们是先想统计所有部门管理的业务方法执行耗时，那此时，所有的部门管理的业务方法都是 原始业务方法。 <strong>那面向这样的指定的一个或多个方法进行编程，我们就称之为 面向切面编程。</strong></p><p>AOP面向切面编程和OOP面向对象编程一样，它们都仅仅是一种编程思想，而动态代理技术是这种思想最主流的实现方式。而Spring的AOP是Spring框架的高级技术，旨在管理bean对象的过程中底层使用动态代理机制，对特定的方法进行编程(功能增强)。</p><p>优势：减少重复代码。提高开发效率，维护方便</p><h4 id="AOP的快速入门："><a href="#AOP的快速入门：" class="headerlink" title="AOP的快速入门："></a>AOP的快速入门：</h4><p>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.编写AOP入门程序：根据特定方法根据业务需要编程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//当前类为切面类</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//记录方法执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录方法执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算方法执行耗时</span></span><br><span class="line">        log.info(pjp.getSignature()+<span class="string">&quot;执行耗时: &#123;&#125;毫秒&quot;</span>,end-begin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AOP的功能：记录操作日志，权限控制，事务管理</p><p>优势：代码无侵入，减少了重复代码，提高开发效率，维护方便</p><h3 id="AOP的核心概念："><a href="#AOP的核心概念：" class="headerlink" title="AOP的核心概念："></a>AOP的核心概念：</h3><p>1.连接点：JoinPiont，可以被AOP控制的方法</p><p>2.通知：Advice，指哪儿些重复方法，也就是共性功能（最终体现为一个方法），</p><p>3.切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用</p><p>4.切面：Aspect，描述通知与切入点对应关系（通知+切入点），切面在的类，通常用切面类表示，被@Aspect注解标识的类</p><p>5.目标对象：Target，通知所应用的对象</p><p>Spring的AOP底层是基于动态代理的技术来实现的，也就是说，在程序运行的时候，会自动的基于动态代理技术为目标对象生成一个对应的代理对象，在代理对象中就会对目标对象中的原始方法的功能进行增强。</p><p>![image-20230112161821401](D:\百度云下载\Javaweb资料\day13-SpringBootWeb AOP\讲义\assets\image-20230112161821401.png)</p><h3 id="AOP进阶"><a href="#AOP进阶" class="headerlink" title="AOP进阶"></a>AOP进阶</h3><p>1.通知类型</p><p>Spring中AOP的通知类型：</p><ul><li>@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行</li><li>@Before：前置通知，此注解标注的通知方法在目标方法前被执行</li><li>@After ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行</li><li>@AfterReturning ： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行</li><li>@AfterThrowing ： 异常后通知，此注解标注的通知方法发生异常后执行</li></ul><p> 在使用通知时的注意事项：</p><ul><li>@Around环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行</li><li>@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值，否则原始方法执行完毕，是获取不到返回值的。</li></ul><p>怎么来解决这个切入点表达式重复的问题？ 答案就是：<strong>抽取</strong></p><p>Spring提供了@PointCut注解，该注解的作用是将公共的切入点表达式抽取出来，需要用到时引用该切入点表达式即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切入点方法（公共的切入点表达式）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知（引用切入点）</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;before ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;around before ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用目标对象的原始方法执行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="comment">//原始方法在执行时：发生异常</span></span><br><span class="line">        <span class="comment">//后续代码不在执行</span></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;around after ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回后通知（程序在正常执行的情况下，会执行的后置通知）</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterReturning ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知（程序在出现异常的情况下，执行的后置通知）</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterThrowing ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：当切入点方法使用private修饰时，仅能在当前切面类中引用该表达式， 当外部其他切面类中也要引用当前类中的切入点表达式，就需要把private改为public，而在引用的时候，具体的语法为：</p><p>全类名.方法名()，具体形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect2</span> &#123;</span><br><span class="line">    <span class="comment">//引用MyAspect1切面类中的切入点表达式</span></span><br><span class="line">    <span class="meta">@Before(&quot;com.itheima.aspect.MyAspect1.pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect2 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上程序运行可以看出在不同切面类中，默认按照切面类的类名字母排序：</p><ul><li>目标方法前的通知方法：字母排名靠前的先执行</li><li>目标方法后的通知方法：字母排名靠前的后执行</li></ul><p>如果我们想控制通知的执行顺序有两种方式：</p><ol><li>修改切面类的类名（这种方式非常繁琐、而且不便管理）</li><li>使用Spring提供的@Order注解</li></ol><p>使用@Order注解，控制通知的执行顺序：</p><p>通知的执行顺序大家主要知道两点即可：</p><ol><li>不同的切面类当中，默认情况下通知的执行顺序是与切面类的类名字母排序是有关系的</li><li>可以在切面类上面加上@Order注解，来控制不同的切面类通知的执行顺序</li></ol><h4 id="3-切入点表达式"><a href="#3-切入点表达式" class="headerlink" title="3.切入点表达式"></a>3.切入点表达式</h4><p>切入点表达式：</p><ul><li><p>描述切入点方法的一种表达式</p></li><li><p>作用：主要用来决定项目中的哪些方法需要加入通知</p></li><li><p>常见形式：</p><ol><li>execution(……)：根据方法的签名来匹配</li></ol><img src="/2024/03/25/JavaWeb/百度云下载/Javaweb资料/day13-SpringBootWeb AOP/讲义/assets/image-20230110214150215.png" alt="image-20230110214150215"><ol start="2"><li>@annotation(……) ：根据注解匹配</li></ol></li></ul><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240311215753015.png" alt="image-20240311215753015"></p><p>excution:主要根据方法的返回值，包名，类名，方法参数，等信息来匹配，语法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;excution(访问修饰符 ? 返回值 包名.类名.?方法名称(方法参数) throws 异常?)&quot;)</span></span><br></pre></td></tr></table></figure><p>其中带<code>?</code>的表示可以省略的部分</p><ul><li><p>访问修饰符：可省略（比如: public、protected）</p></li><li><p>包名.类名： 可省略</p></li><li><p>throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）</p></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))&quot;)</span></span><br></pre></td></tr></table></figure><p>可以使用通配符描述切入点</p><ul><li><p><code>*</code> ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分</p></li><li><p><code>..</code> ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数</p></li></ul><p>切入点表达式的语法规则：</p><ol><li>方法的访问修饰符可以省略</li><li>返回值可以使用<code>*</code>号代替（任意返回值类型）</li><li>包名可以使用<code>*</code>号代替，代表任意包（一层包使用一个<code>*</code>）</li><li>使用<code>..</code>配置包名，标识此包以及此包下的所有子包</li><li>类名可以使用<code>*</code>号代替，标识任意类</li><li>方法名可以使用<code>*</code>号代替，表示任意方法</li><li>可以使用 <code>*</code>  配置参数，一个任意类型的参数</li><li>可以使用<code>..</code> 配置参数，任意个任意类型的参数</li></ol><p><strong>切入点表达式示例</strong></p><ul><li><p>省略方法的修饰符号 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">void</span> com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替返回值类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替包名（一层包使用一个<code>*</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.*.*.DeptServiceImpl.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>..</code>省略包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..DeptServiceImpl.delete(java.lang.Integer))    </span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..*.delete(java.lang.Integer))   </span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..*.*(java.lang.Integer))   </span><br></pre></td></tr></table></figure></li><li><p>使用 <code>*</code> 代替参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.service.impl.DeptServiceImpl.delete(*))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>..</code>省略参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..*.*(..))</span><br></pre></td></tr></table></figure><h4 id="annotation"><a href="#annotation" class="headerlink" title="@annotation"></a>@annotation</h4><p>  要匹配多个无规则的方法，比如list和delete方法，基于excution这种切入表达式描述起来就很不方便，将两个切入点表达式组合在一起，是比较繁琐的</p><p>  实现步骤：</p><p>  1.编写自定义注解</p><p>  2.在业务类要作为连接点的方法上添加自定义注解</p></li></ul><p>自定义注解类：MyLog</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect6</span> &#123;</span><br><span class="line">    <span class="comment">//针对list方法、delete方法进行前置通知和后置通知</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;@annotation(com.itheima.anno.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect6 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;@annotation(com.itheima.anno.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect6 -&gt; after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类：DeptServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@MyLog</span>  <span class="comment">//自定义注解（表示：当前方法属于目标方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 删除部门</span></span><br><span class="line">    deptMapper.delete(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能在调用delete方法的时候，匹配当前定义的注解，执行前置通知和后置通知了</p><p>总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- execution切入点表达式</span><br><span class="line">  - 根据我们所指定的方法的描述信息来匹配切入点方法，这种方式也是最为常用的一种方式</span><br><span class="line">  - 如果我们要匹配的切入点方法的方法名不规则，或者有一些比较特殊的需求，通过execution切入点表达式描述比较繁琐</span><br><span class="line">- annotation 切入点表达式</span><br><span class="line">  - 基于注解的方式来匹配切入点方法。这种方式虽然多一步操作，我们需要自定义一个注解，但是相对来比较灵活。我们需要匹配哪个方法，就在方法上加上对应的注解就可以了</span><br></pre></td></tr></table></figure><h3 id="3-4连接点"><a href="#3-4连接点" class="headerlink" title="3.4连接点"></a>3.4连接点</h3><p>连接点：简单来说就是可以被AOP控制的方法</p><p>在spring中用JoinPoint抽象了连接点，用它可以获得方法执行的先关信息，比如方法的类名，方法名称， 方法参数等等</p><p>1.对于@Around通知，获取连接点的信息只能使用ProceedingJoinPoint类型</p><p>2.对于其他四种，after before AfterReturnning AfterThrowing </p><p>获取连接点的信息只能用JointPoint，它是ProceedingJoinPoint的父类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//获取目标类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pjp.getTarget().getClass().getName();</span><br><span class="line">        log.info(<span class="string">&quot;目标类名：&#123;&#125;&quot;</span>,name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pjp.getSignature().getName();</span><br><span class="line">        log.info(<span class="string">&quot;目标方法名：&#123;&#125;&quot;</span>,methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法执行时需要的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        log.info(<span class="string">&quot;目标方法参数：&#123;&#125;&quot;</span>, Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240312213621023.png" alt="image-20240312213621023"></p><p>AOP 案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">需求：将案例中增、删、改相关接口的操作日志记录到数据库表中</span><br><span class="line"></span><br><span class="line">- 就是当访问部门管理和员工管理当中的增、删、改相关功能接口时，需要详细的操作日志，并保存在数据表中，便于后期数据追踪。</span><br><span class="line"></span><br><span class="line">操作日志信息包含：</span><br><span class="line"></span><br><span class="line">- 操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长</span><br><span class="line"></span><br><span class="line">&gt; 所记录的日志信息包括当前接口的操作人是谁操作的，什么时间点操作的，以及访问的是哪个类当中的哪个方法，在访问这个方法的时候传入进来的参数是什么，访问这个方法最终拿到的返回值是什么，以及整个接口方法的运行时长是多长时间。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实现具体思路</span><br><span class="line"><span class="number">1.</span>数据库建表，包含需要操作的日志段，id，操作人ID，操作时间，方法，参数，返回值，耗时等</span><br><span class="line"><span class="number">2.</span>创建表对应的实体类，操作日志实体类</span><br><span class="line"><span class="number">3.</span>创建mapper接口，定义Insert()方法，使用<span class="meta">@Insert</span>的MySQL注解，写好SQL的插入语句</span><br><span class="line"><span class="number">4.</span>需要记录日志，将横向的关注点从业务的核心业务逻辑中分离出来，就需要AOP面向切面编程，因为只是记录增删改的日志，使用execution的表达式繁琐，所以使用<span class="meta">@annotation</span>的注解的切入点表达式</span><br><span class="line"><span class="number">5.</span>自定义注解类<span class="meta">@Log</span>，</span><br><span class="line">    <span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//当前注解作用在方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//表示是运行时注解</span></span><br><span class="line"><span class="number">6.</span>自定义切面类，使用切面表达式将之前的注解类引用进来</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.itheima.anno.Log)&quot;)</span></span><br><span class="line">    表示：拦截标注了Log的注解的方法，并且在方法执行前后进行环绕通知</span><br><span class="line"><span class="number">7.</span>在切面类中，通过连接点JoinPoint获取相关记录日志的参数，再调用Mapper接口中的Insert方法，将日志数据插入到数据库中</span><br></pre></td></tr></table></figure><h3 id="Springboot原理"><a href="#Springboot原理" class="headerlink" title="Springboot原理"></a>Springboot原理</h3><h4 id="1-配置文件的优先级"><a href="#1-配置文件的优先级" class="headerlink" title="1.配置文件的优先级"></a>1.配置文件的优先级</h4><p>在SpringBoot项目当中，常见的属性配置方式有5种， 3种配置文件，加上2种外部属性的配置(Java系统属性、命令行参数)。通过以上的测试，我们也得出了优先级(从低到高)：</p><ul><li>application.yaml（忽略）</li><li>application.yml</li><li>application.properties</li><li>java系统属性（-Dxxx&#x3D;xxx）</li><li>命令行参数（–xxx&#x3D;xxx）</li></ul><h4 id="2-Bean管理"><a href="#2-Bean管理" class="headerlink" title="2.Bean管理"></a>2.Bean管理</h4><p>前面讲过，通过Spring当中提供的注解@Component以及它的三个衍生注解（@Controller@Service@Repository）来声明IOC容器中的bean对象，同时我们也学习了如何为应用程序注入运行时所需要的依赖的bean对象，也就是依赖注入DI</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总的来说，@Repository 注解用于标识数据访问层的组件，而 @Mapper 注解用于标识 MyBatis 的映射接口。</span><br></pre></td></tr></table></figure><p>1.如何总IOC容器中拿到bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 根据name获取bean</span><br><span class="line"></span><br><span class="line">   Object <span class="title function_">getBean</span><span class="params">(String name)</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 根据类型获取bean</span><br><span class="line"></span><br><span class="line">   &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 根据name获取bean（带类型转换）</span><br><span class="line"></span><br><span class="line">   &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.bean对象的作用域配置</p><p>前面提到的IOC容器中，默认的bean对象是单列模式（只有一个实例对象）那么如何设置bean对象为非单列呢？需要设置bean的作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在Spring中支持五种作用域，后三种在web环境才生效：</span><br><span class="line"></span><br><span class="line">| **作用域**  | **说明**                                        |</span><br><span class="line">| ----------- | ----------------------------------------------- |</span><br><span class="line">| singleton   | 容器内同名称的bean只有一个实例（单例）（默认）  |</span><br><span class="line">| prototype   | 每次使用该bean时会创建新的实例（非单例）        |</span><br><span class="line">| request     | 每个请求范围内会创建新的实例（web环境中，了解） |</span><br><span class="line">| session     | 每个会话范围内会创建新的实例（web环境中，了解） |</span><br><span class="line">| application | 每个应用范围内会创建新的实例（web环境中，了解） |</span><br></pre></td></tr></table></figure><p>如何设置一个bean的作用域呢？借助@Scope注解来进行配置作用域</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240314104531033.png" alt="image-20240314104531033"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//默认bean的作用域为：singleton (单例)</span><br><span class="line">@Lazy //延迟加载（第一次使用bean对象时，才会创建bean对象并交给ioc容器管理）</span><br><span class="line"></span><br><span class="line">@Scope(&quot;prototype&quot;) //bean作用域为非单例</span><br></pre></td></tr></table></figure><p>3.管理第三方的bean对象</p><p>之前我们所配置的bean，像controller、service，dao三层体系下编写的类，这些类都是我们在项目当中自己定义的类(自定义类)。当我们要声明这些bean，也非常简单，我们只需要在类上加上@Component以及它的这三个衍生注解。</p><p>如果这个类不是我们自己编写的，而是第三方提供的，那么如何使用和定义第三方的bean？：使用@Bean注解</p><p>解决方案一：在启动类上添加@Bean标识的方法 &#x2F;&#x2F;保持启动类的干净，不推荐使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明第三方bean</span></span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span></span><br><span class="line"><span class="keyword">public</span> SAXReader <span class="title function_">saxReader</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案二：在配置类中定义@Bean标识的方法</p><p>如果需要第三方定义的Bean时候，通常会单独定义一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类  (在配置类当中对第三方bean进行集中的配置管理)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明第三方bean</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span></span><br><span class="line">          <span class="comment">//通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名</span></span><br><span class="line">    <span class="keyword">public</span> SAXReader <span class="title function_">reader</span><span class="params">(DeptService deptService)</span>&#123;</span><br><span class="line">        System.out.println(deptService);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法上添加一个@Bean注解，Spring容器在启动的时候，会自动的调用这个方法，并将方法的返回值声明为Spring容器当中的Bean对象</p><h3 id="3-Springboot原理"><a href="#3-Springboot原理" class="headerlink" title="3.Springboot原理"></a>3.Springboot原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring 是一款轻量级的java开发框架，一般指的是spring framework,他是很多模块的集合，包括springboot快速启动，springcloud微服务，spring Data数据库等spring全家桶</span><br><span class="line"></span><br><span class="line">springboot就是帮助我们快速的构建应用程序，简化开发，提高效率</span><br></pre></td></tr></table></figure><p>Springboot之所以能简化Spring的开发，是因为SpringBoot底层提供了两个非常重要的功能，一个是起步依赖，一个是自动配置</p><p><strong>起步依赖：</strong></p><p>Springboot所提供的起步依赖，可以大大简化pom文件当中的依赖配置，从而解决了Spring框架中依赖配置繁琐的问题</p><p><strong>自动配置：</strong></p><p>通过自动配置功能就可以打打简化Spring框架在使用Bean的声明以及Bean的配置，我们只需要引入程序开发时候所需要的起步依赖，项目开发时所用到的常见配置都有了，我们直接使用就可以了</p><h4 id="3-1起步依赖："><a href="#3-1起步依赖：" class="headerlink" title="3.1起步依赖："></a>3.1起步依赖：</h4><p>假设没有使用SpringBoot，用的Spring框架进行Web开发，这时候我们需要引入相关依赖</p><p>Spring-webmvc依赖，Servlet依赖，aop依赖，JSON处理依赖，Tomcat依赖，还要保证依赖的版本匹配，避免出现版本冲突的问题</p><p>如果我们使用了SpringBoot，直接引用web开发的起步依赖，springboot-starter-web起步依赖即可，因为有<strong>Maven依赖传递</strong>，所需要的依赖就都有了</p><h4 id="3-2自动配置："><a href="#3-2自动配置：" class="headerlink" title="3.2自动配置："></a>3.2自动配置：</h4><p>概述：Springboot的自动配置，就是当Spring容器启动后，一些配置类，Bean对象就自动存储到了IOC容器中，不需要我们手动声明，从而简化了开发，省去了繁琐的配置操作</p><p>比如：我们要进行事务管理，要进行AOP切面开发，就不需要手动声明这些Bean对象了，直接注入就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在IOC容器中，除了我们自己定义的Bean以外，还有很多配置类，这些配置类都是在SpringBoot启动的时候加载进来的配置类，这些配置类加载进来后，也会生成很多的Bean对象，我们并没有声明，却可以通过@Autowired自动注入Bean对象，</span><br></pre></td></tr></table></figure><p>解析自动配置的原理：分析在Springboot中，我们引入对应的依赖后，Springboot是如何将依赖jar包当中提供的Bean以及配置类直接加载到当前项目的springIOC容器当中的</p><p>我们先引入第三方的依赖，执行测试方法发现：在Spring容器中没有找到com.example.TokenParse类型的bean对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思考：为什么引入的第三方依赖当中的Bean以及配置类，没有生效</span><br><span class="line">1.在类上添加@Component注解来声明Bean对象时候，还要保证Bean对象能被Spring的组件扫描到</span><br><span class="line">2.SpringBoot项目中的@SpringBootApplication注解，具有扫描包的作用，但是只会扫描启动类所在的当前的包，以及其子包</span><br><span class="line">3.没在一个包下，所以扫描不到</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>1.@Component组件扫描、、繁琐不推荐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima&quot;,&quot;com.example&quot;&#125;)</span> <span class="comment">//指定要扫描的包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.@import导入（使用@import导入的类会被Spring加载到IOC容器当中去）</p><p>导入形式主要有以下几种：</p><ol><li>导入普通类</li><li>导入配置类</li><li>导入ImportSelector接口实现类</li></ol><p>不推荐，我们不知道第三方具体类，导入繁琐</p><p>​4.使用第三方提供的@EnableXxxxx注解（推荐），第三方打包好的</p><p>只需要在启动类上加上@EnableXxxxx注解即可</p><h3 id="3-3原理分析：源码跟踪"><a href="#3-3原理分析：源码跟踪" class="headerlink" title="3.3原理分析：源码跟踪"></a>3.3原理分析：源码跟踪</h3><p>SpringBoot启动类的核心注解，@SpringBootApplication开始分析</p><p>在@SpringBootApplication包含了注解如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">四个元注解：</span><br><span class="line">@Retention():表示注解生效的地方，取值如下是</span><br><span class="line">RetentionPolicy.SOURCE：注解仅存在于源代码中，编译时会被忽略。</span><br><span class="line">RetentionPolicy.CLASS：注解存在于类文件中，但在运行时不可见，这是默认值。</span><br><span class="line">RetentionPolicy.RUNTIME：注解存在于类文件中，并在运行时可见，可以通过反射机制读取。</span><br><span class="line"></span><br><span class="line">@Target():表示注解可以修饰的目标元素的范围：取值如下</span><br><span class="line">ElementType.TYPE：可以修饰类、接口、枚举等。</span><br><span class="line">ElementType.FIELD：可以修饰字段、成员变量。</span><br><span class="line">ElementType.METHOD：可以修饰方法。</span><br><span class="line">ElementType.PARAMETER：可以修饰方法的参数。</span><br><span class="line">ElementType.CONSTRUCTOR：可以修饰构造方法。</span><br><span class="line">ElementType.LOCAL_VARIABLE：可以修饰局部变量。</span><br><span class="line">ElementType.ANNOTATION_TYPE：可以修饰注解类型。</span><br><span class="line">ElementType.PACKAGE：可以修饰包。</span><br><span class="line"></span><br><span class="line">@Documented：表示注解将会被标注在Javadoc文档中</span><br><span class="line">@Inherited:表示注解具有继承性</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240315101257039.png" alt="image-20240315101257039"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在@SpringBootApplication注解中包含了：</span><br><span class="line"></span><br><span class="line">- 元注解（不再解释）</span><br><span class="line">- @SpringBootConfiguration：表示SpringBoot启动类是一个配置类</span><br><span class="line">- @EnableAutoConfiguration：</span><br><span class="line">- @ComponentScan：用来进行组件扫描的，扫描范围为启动类所在的包以及其子包下所有被Component及其衍生注解声明的类</span><br><span class="line"></span><br><span class="line">主要的是@EnableAutoConfiguration注解(自动配置核心注解)：</span><br><span class="line">此注解下有两个注解：</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(AutoConfigurationImportSelector.class)：导入接口实现类</span><br><span class="line">public @interface EnableAutoConfiguration &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240315101525188.png" alt="image-20240315101525188"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用@Import注解，导入了实现ImportSelector接口的实现类。</span><br><span class="line">AutoConfigurationImportSelector类是ImportSelector接口的实现类。</span><br><span class="line">AutoConfigurationImportSelector类中重写了ImportSelector接口的selectImports()方法：</span><br><span class="line">selectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合</span><br><span class="line">getAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合</span><br></pre></td></tr></table></figure><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240315101059913.png" alt="image-20240315101059913"></p><p>在起步依赖中打开配置文件的所在位置</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240315101935391.png" alt="image-20240315101935391"></p><p>在测试类的时候，我们直接在测试类中，注入了一个叫gson的Bean对象，用来进行JSON格式转换，虽然我们没有配置对象，但是我们可以直接注入使用，原因就是在SpringBoot在启动时在自动配置类实现了自动配置，我们双击shift进入这个类的源码，</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240315102606421.png" alt="image-20240315102606421"></p><p>@AutoConfiguration底层就封装了@Configuration注解，表示该类是一个配置类</p><p><code>@Configuration</code>注解的类可以使用<code>@Bean</code>注解来声明Bean，Spring容器会根据这些Bean的定义来创建和管理Bean实例，调用配置类中的@Bean标识的方法，并且把方法的返回值注册到IOC容器中去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，那这些bean都会注册到Spring的IOC容器中吗？</span><br><span class="line"></span><br><span class="line">答案：并不是。 在声明bean对象时，上面有加一个以@Conditional开头的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）</span><br></pre></td></tr></table></figure><p>@Conditional注解</p><p>作用：按照一定的条件进行判断，满足相应的条件后，才会注册对应的Bean对象到Spring的IOC容器中</p><p>Conditional 是一个父注解，会派生出大量的子注解：</p><ul><li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li><li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li><li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li><li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li><li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li><li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li><li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li><li><code>@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件</li><li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li><li><code>@ConditionalOnJndi</code>：在 JNDI 存在的条件下差在指定的位置</li><li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下</li><li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项 目的条件下</li></ul><hr><p>主要用的有三个：</p><ul><li>@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。</li><li>@ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。</li><li>@ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。</li></ul><p>底层的自动配置原理总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简单来说就是：SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">详细来说：自动配置的核心就在Spring启动类@SpringBootApplication的注解上，底层包含了</span><br><span class="line">@EnableAutoConfiguration，这个注解才是自动配置的核心</span><br><span class="line"></span><br><span class="line">它封装了一个@import注解，import注解里面制定了一个接口的实现类，在这个实现类中重写了selectImport()方法，而这个方法会去读取对应jar包地下的配置文件，这些配置文件源码都试用贴@Configuration标注，表示是Spring的配置类，方法使用@Bean和@Conditional修饰</span><br><span class="line">表示只要满足了Conditional的条件，才会将这个Bean对象交给IOC容器管理。</span><br></pre></td></tr></table></figure><h3 id="案例：自定义starter分析"><a href="#案例：自定义starter分析" class="headerlink" title="案例：自定义starter分析"></a>案例：自定义starter分析</h3><p>业务场景：</p><p>​我们案例中使用的阿里云oss对象存储服务，阿里云并没有提供起步依赖，这时候用起来就比较繁琐，我们需要1.引入对应依赖 2.在配置文件中配置3.基于官方SDK来改造相应的工具类</p><p>​这时候我们需要自定义一些公共组件，在这些公共组件中，提前把需要配置的Bean都配置好，到时候直接将对应组件的坐标引入进来，交给Spring自动配置，大大简化开发</p><p>需求：自定义起步依赖，完成对阿里云OSS操作工具类AliyunOSSUtils的自动配置</p><p>​引入起步依赖后，要想使用阿里云OSS，注入AliyunOSSUtils直接使用即可</p><p>​<img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240315170105728.png" alt="image-20240315170105728"></p><p>在自定义一个起步依赖starter的时候，按照规范需要定义两个模块:</p><p>1.starter模块：进行依赖管理（程序开发过程所需要的依赖，都定义在starter起步依赖中）</p><p>2.autoconfigure模块：自动配置模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">需求明确了，接下来我们再来分析一下具体的实现步骤：</span><br><span class="line"></span><br><span class="line">- 第1步：创建自定义starter模块（进行依赖管理）</span><br><span class="line">  - 把阿里云OSS所有的依赖统一管理起来</span><br><span class="line">- 第2步：创建autoconfigure模块</span><br><span class="line">  - 在starter中引入autoconfigure （我们使用时只需要引入starter起步依赖即可）</span><br><span class="line">- 第3步：在autoconfigure中完成自动配置</span><br><span class="line">  1. 定义一个自动配置类，在自动配置类中将所要配置的bean都提前配置好</span><br><span class="line">  2. 定义配置文件，把自动配置类的全类名定义在配置文件中</span><br><span class="line"></span><br><span class="line">我们分析完自定义阿里云OSS自动配置的操作步骤了，下面我们就按照分析的步骤来实现自定义starter。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前两步骤好说，在autoconfiguration中配置好相关依赖，再在starter模块中引入autoconfiguration依赖即可</span><br><span class="line"></span><br><span class="line">我们要想引入起步依赖后直接注入AliOSSUtils，就需要定义一个自动配置类，并且自动以自动配置类的的配置文件</span><br><span class="line"></span><br><span class="line">主要难以理解的是，自动配置类怎么去写</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AliOSSUtils <span class="title function_">aliOSSUtils</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AliOSSUtils</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不带参数的配置类，声明Bean，因为需要注入AliOSSUtils，所以声明一个返回值为AliOSSUtils的函数，返回一个AliOSSUtils类型的对象，交给IOC容器管理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但我们声明这个对象是需要来给赋值的，AliOSSUtils中声明了private AliOSSProperties aliOSSProperties，来导入秘钥等配置，我们在声明的时候是需要给这个成员变量赋值的，</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(AliOSSProperties.class)</span></span><br><span class="line"><span class="comment">//它告诉Spring Boot要将配置文件中的属性值绑定到AliOSSProperties类的实例中。</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//定义了一个名为aliOSSUtils的Bean，它的类型是AliOSSUtils，并且依赖于AliOSSProperties类的一个实例。</span></span><br><span class="line">    <span class="keyword">public</span> AliOSSUtils <span class="title function_">aliOSSUtils</span><span class="params">(AliOSSProperties aliOSSProperties)</span>&#123;</span><br><span class="line">        <span class="type">AliOSSUtils</span> <span class="variable">aliOSSUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliOSSUtils</span>();</span><br><span class="line">        aliOSSUtils.setAliOSSProperties(aliOSSProperties);</span><br><span class="line">        <span class="keyword">return</span> aliOSSUtils;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AliOSSAutoConfiguration这个配置类要想被加载到，就需要在一份固定的配置文件中，Spring启动时，会自动加载该文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//org.springframework.boot.autoconfigure.AutoConfiguration.imports</span></span><br><span class="line"><span class="comment">//在此Imports文件中，声明需要被自动配置的类的全类名com.aliyun.oss.AliOSSAutoConfiguration，这样Spring在启动的时候，就会自动加载该配置文件中定义的所有配置类</span></span><br></pre></td></tr></table></figure><h2 id="web开发总结："><a href="#web开发总结：" class="headerlink" title="web开发总结："></a>web开发总结：</h2><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240318210310671.png" alt="image-20240318210310671"></p><p>后端开发流程：</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240318210652587.png" alt="image-20240318210652587"></p><p>我们在学习这些web后端开发技术的时候，我们都是基于主流的SpringBoot进行整合使用的。而SpringBoot又是用来简化开发，提高开发效率的。</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240318210736030.png" alt="image-20240318210736030"></p><p>而Spring框架的web开发模块，我们也称为：SpringMVC</p><p>SpringMVC，SpringFramework，Mybatis俗称SSM</p><p>基于传统的SSM框架进行整合项目开发会比较繁琐，而且开发效率低，所以现在的企业开发当中，基本上都是基于SpringBoot整合SSM进行项目开发的</p><p>web后端开发内容完结撒花！</p><h1 id="Maven高级"><a href="#Maven高级" class="headerlink" title="Maven高级"></a>Maven高级</h1><p>Maven高级内容包括:</p><ul><li>分模块设计与开发</li><li>继承与聚合</li><li>私服</li></ul><h3 id="1-分模块设计与开发"><a href="#1-分模块设计与开发" class="headerlink" title="1.分模块设计与开发"></a>1.分模块设计与开发</h3><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240318212929002.png" alt="image-20240318212929002"></p><p>而且分模块设计之后，如果我们需要用到另外一个模块的功能，我们直接依赖模块就可以了。比如商品模块、搜索模块、购物车订单模块都需要依赖于通用组件当中封装的一些工具类，我只需要引入通用组件的坐标就可以了。</p><p><strong>分模块设计就是将项目按照功能&#x2F;结构拆分成若干个子模块，方便项目的管理维护、拓展，也方便模块键的相互调用、资源共享。</strong></p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240318213039063.png" alt="image-20240318213039063"></p><p>方案一：直接依赖我们当前项目 tlias-web-management ，但是存在两大缺点：</p><ul><li>这个项目当中包含所有的业务功能代码，而想共享的资源，仅仅是pojo下的实体类，以及 utils 下的工具类。如果全部都依赖进来，项目在启动时将会把所有的类都加载进来，会<strong>影响性能</strong>。</li><li>如果直接把这个项目都依赖进来了，那也就意味着我们所有的业务代码都对外公开了，这个是非常<strong>不安全</strong>的。</li></ul><p>方案二：分模块设计</p><p>1.将pojo包下的实体类，抽取到一个Maven模块tlias-pojo</p><p>2.将utils包下的工具类，抽取到一个Maven模块中tlias-utils</p><p>3.在具体的工程文件中，直接引入对应的依赖即可</p><p><strong>注意：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。</strong></p><h3 id="2-继承与聚合"><a href="#2-继承与聚合" class="headerlink" title="2.继承与聚合"></a>2.继承与聚合</h3><p>在案例项目分模块开发之后啊，我们会看到tlias-pojo、tlias-utils、tlias-web-management中都引入了一个依赖 lombok 的依赖。我们在三个模块中分别配置了一次。</p><p>功能虽然能实现，但是很繁琐</p><h4 id="2-1继承"><a href="#2-1继承" class="headerlink" title="2.1继承"></a>2.1继承</h4><p>我们可以再创建一个父工程 tlias-parent ，然后让上述的三个模块 tlias-pojo、tlias-utils、tlias-web-management 都来继承这个父工程 。 然后再将各个模块中都共有的依赖，都提取到父工程 tlias-parent中进行配置，只要子工程继承了父工程，依赖它也会继承下来，这样就无需在各个子工程中进行配置了。</p><p>Maven不支持多继承，但是支持多继承，与Java类似</p><p>所有的SpringBoot工程都有一个父工程，spring-boot-starter-parent。</p><p>我们为了将公共的依赖抽离出来，就可以自己创建一个父工程，保存公共的依赖，再由子工程去继承，如下图所示</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240318223702481.png" alt="image-20240318223702481"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tlias-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里打包方式设置为pom，提及到Maven的打包方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Maven打包方式：</span><br><span class="line"></span><br><span class="line">- jar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行）</span><br><span class="line">- war：普通web程序打包，需要部署在外部的tomcat服务器中运行</span><br><span class="line">- pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理</span><br></pre></td></tr></table></figure><p>在子工程的pom文件中，配置继承关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tlias-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../tlias-parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tlias-utils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">注意：relativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找该工程）。</span><br><span class="line"></span><br><span class="line">-  ../ 代表的上一级目录</span><br></pre></td></tr></table></figure><h4 id="2-2版本锁定"><a href="#2-2版本锁定" class="headerlink" title="2.2版本锁定"></a>2.2版本锁定</h4><p>场景：如果项目中各个模块都公共的各部分依赖，我们可以定义在父工程中，从而简化子工程的配置，然而在项目开发中，还有一些模块，并不是各个模块共有的，有可能只有其中的一小部分模块使用到了这个依赖</p><p>问题：如果项目拆分的够多，每次更新版本，我们都找得到这个项目中的每一个模块，一个一个改，很容易出现问题，遗漏掉一个模块，忘记更换版本的情况。</p><p>这时候就需要Maven的版本锁定功能</p><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一管理依赖版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--JWT令牌--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--JWT令牌--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在Maven中，可以在父工程pom文件中，通过&lt;dependencyManagement&gt;来统一管理依赖版本</span><br><span class="line">1.在父工程中的&lt;dependencyManagement&gt;只能统一管理依赖版本，并不会直接将这个依赖引入进来，这点和&lt;dependencies&gt;是不同的</span><br><span class="line">2.子工程要使用这个依赖，还是要引入的，只是此时就无需指定&lt;version&gt;版本，由父工程统一管理，变更依赖版本，只需要在父工程中统一变更。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>属性配置</strong></p><p>我们也可以通过自定义属性以及属性的引用形式，在父工程中，将依赖的版本号进行集中管理和维护，具体的语法为：</p><p>1). 自定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2). 引用属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们就可以在父工程中，将所有的版本号，都集中管理维护出来。</p><p><strong>面试题：<code>&lt;dependencyManagement&gt;</code> 与 <code>&lt;dependencies&gt;</code> 的区别是什么?</strong></p><ul><li><code>&lt;dependencies&gt;</code> 是直接依赖，在父工程配置了依赖，子工程会直接继承下来。 </li><li><code>&lt;dependencyManagement&gt;</code> 是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需依赖(无需指定版本)</li></ul><h4 id="2-3聚合"><a href="#2-3聚合" class="headerlink" title="2.3聚合"></a>2.3聚合</h4><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240319160756422.png" alt="image-20240319160756422" style="zoom:50%;"><p>分模块设计和开发之后，我们的项目被拆分了很多模块，比如如上图，我们在打包management的时候，需要将parent，pojo，utils分别执行install生命周期安装到Maven的本地仓库，在针对management模块执行package打包操作。就很繁琐</p><p>通过Maven聚合就能够实现项目的统一构建（清理，编译，测试，打包，安装等）</p><p><strong>聚合</strong>：将多个模块组织成一个整体</p><p><strong>聚合工程</strong>：一个不具有业务功能的空工程，有且只有一个pom文件，一般来讲，继承关系中的父工程和聚合工程是同一个</p><p><strong>作用</strong>：快速构建项目，无需根据依赖关系构建，直接在聚合工程上构建即可</p><p><strong>实现：</strong>在聚合工程中，通过<moudules>设置当前聚合工程所包含的字模块的名称，我们可以在parent（聚合工程）的pom文件中，添加如下配置</moudules></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--聚合其他模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-utils<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-web-management<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在module中添加聚合模块的名称   ../表示上一级目录--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-继承与聚合对比"><a href="#2-3-继承与聚合对比" class="headerlink" title="2.3 继承与聚合对比"></a>2.3 继承与聚合对比</h3><ul><li><p><strong>作用</strong></p><ul><li><p>聚合用于快速构建项目</p></li><li><p>继承用于简化依赖配置、统一管理依赖</p></li></ul></li><li><p><strong>相同点：</strong></p><ul><li><p>聚合与继承的pom.xml文件打包方式均为pom，通常将两种关系制作到同一个pom文件中</p></li><li><p>聚合与继承均属于设计型模块，并无实际的模块内容</p></li></ul></li><li><p><strong>不同点：</strong></p><ul><li><p>聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些</p></li><li><p>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</p></li></ul></li></ul><h2 id="3-私服"><a href="#3-私服" class="headerlink" title="3.私服"></a>3.私服</h2><p>本地搭建私服，供不同的电脑去访问和上传相应的依赖jar包</p><p><strong>私服：</strong>是一中特殊的远程仓库，架设在局域网内的仓库服务，用来代理与外部的中央仓库，用于解决团队内部资源共享与资源同步问题</p><p><strong>依赖查找顺序</strong>：本地仓库，私服仓库，中央仓库</p><p><strong>资料的上传与下载</strong>：</p><p><img src="/2024/03/25/JavaWeb/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240319173844509.png" alt="image-20240319173844509"></p><p>资源上传与下载，我们需要做三步配置，执行一条指令。</p><p>第一步配置：在maven的配置文件中配置访问私服的用户名、密码。</p><p>第二步配置：在maven的配置文件中配置连接私服的地址(url地址)。</p><p>第三步配置：在项目的pom.xml文件中配置上传资源的位置(url地址)。</p><p>配置好了上述三步之后，要上传资源到私服仓库，就执行执行maven生命周期：deploy。</p><blockquote><p>私服仓库说明：</p><ul><li>RELEASE：存储自己开发的RELEASE发布版本的资源。</li><li>SNAPSHOT：存储自己开发的SNAPSHOT发布版本的资源。</li><li>Central：存储的是从中央仓库下载下来的依赖。</li></ul></blockquote><blockquote><p>项目版本说明：</p><ul><li>RELEASE(发布版本)：功能趋于稳定、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。</li><li>SNAPSHOT(快照版本)：功能不稳定、尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。</li></ul></blockquote><p><strong>具体操作：</strong></p><p><strong>1.设置私服的访问用户名、密码</strong>：在Maven安装目录下conf&#x2F;settings.xml中的servers中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.设置私服依赖下载的仓库组地址（在自己maven安装目录下的conf&#x2F;settings.xml中的mirrors、profiles中配置）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>allow-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.IDEA的maven工程的pom文件中配置上传（发布）地址(直接在tlias-parent中配置发布地址)</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- release版本的发布地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- snapshot版本的发布地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成之后，我们就可以在tlias-parent中执行<strong>deploy</strong>生命周期，将项目发布到私服仓库中。 </p>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（三）哈希表篇</title>
      <link href="/2024/03/25/hash/"/>
      <url>/2024/03/25/hash/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表篇"><a href="#哈希表篇" class="headerlink" title="哈希表篇"></a>哈希表篇</h1><h1 id="字母异味，数组交集，数字，字符串"><a href="#字母异味，数组交集，数字，字符串" class="headerlink" title="字母异味，数组交集，数字，字符串"></a>字母异味，数组交集，数字，字符串</h1><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="字母异位"><a href="#字母异位" class="headerlink" title="字母异位"></a>字母异位</h2><h3 id="242-有效的字母异位"><a href="#242-有效的字母异位" class="headerlink" title="242.有效的字母异位"></a>242.有效的字母异位</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                map.remove(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (map.get(c) &lt; 0) return false;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.size() == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// return true;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HashMap，put,remove,如果get(元素)&lt;0,返回false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*字符串转数组再排序，判断是否相等</span></span><br><span class="line"><span class="comment">注意：要使用Arrays.equals(str1, str2)，而不是str1.equals(str2)</span></span><br><span class="line"><span class="comment">Arrays.equals(str1, str2) 是用于判断两个数组是否相等的正确表达式。str1.equals(str2) 用于比较字符串对象的内容是否相等，而不是数组，即是这里比较的是地址值，肯定不相等。</span></span><br><span class="line"><span class="comment">正确的数组比较应该使用 Arrays.equals 方法，该方法会逐个比较数组中的元素，确保数组内容相同。</span></span><br></pre></td></tr></table></figure><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h3><p>s字符串是否能由t构成，s中字符只能在t中使用1次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lens</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lent</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="keyword">if</span> (lens &gt; lent) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lent; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lens; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(c) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正常HashMap的put插入覆盖更新，如果表内的value&lt;0.说明s中的新字符或者超过1次的限制</span></span><br></pre></td></tr></table></figure><h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序后将String作为key，list&lt;String&gt;作为value，寻找相同的string添加list&lt;String&gt;即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            List&lt;String&gt; value = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            value.add(s);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 集合的集大成之作，key，value是集合，ArrayList + HashMap，差点绕晕过去了</span></span><br></pre></td></tr></table></figure><h3 id="438-找到字符串中的所有字母异位词"><a href="#438-找到字符串中的所有字母异位词" class="headerlink" title="438.找到字符串中的所有字母异位词"></a>438.找到字符串中的所有字母异位词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lens</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenp</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="keyword">if</span> (lens &lt; lenp) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] arr = p.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= lens - lenp; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(i, i + lenp);</span><br><span class="line">            <span class="keyword">if</span> (isAnagram(str, p) == <span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        <span class="comment">// Arrays.sort(str2);</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//核心判断是字符串排序后比较值是否相等来判断异位词</span></span><br><span class="line"><span class="comment">//遍历，查找长度一样的字串，substring()提取字串的方法s是小写，没啥说的</span></span><br></pre></td></tr></table></figure><h2 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h2><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)&#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(i))&#123;</span><br><span class="line">                set2.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : set2)&#123;</span><br><span class="line">            ans[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 思路是，使用set集合存入nums1，再遍历nums2，判断set中是否包含</span></span><br><span class="line"><span class="comment">// 最后将set转为数组</span></span><br><span class="line"><span class="comment">// 要定义两个set，因为包含的也会重复</span></span><br></pre></td></tr></table></figure><h3 id="350-两个数组的交集II"><a href="#350-两个数组的交集II" class="headerlink" title="350.两个数组的交集II"></a>350.两个数组的交集II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*与I不同点在于，I的交集是用set记录去重的，直接用set记录交集就好</span></span><br><span class="line"><span class="comment">II要交集出现的次数，与出现的最小次数一致，正常用map记录nums1的词和次数，再扫描nums2，判断存在就次数--，加入到list中去，直到次数为0，为止，记录list，再转为数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(i) &amp;&amp; map.get(i) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(i, map.get(i) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : list) &#123;</span><br><span class="line">            ans[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * list和数组的转换，不能直接int[] ans = list.toArray()</span></span><br><span class="line"><span class="comment"> * 因为，不能把Object集合强转为int类型的，像我那样一个一个遍历又太麻烦了</span></span><br><span class="line"><span class="comment"> list.toArray()只能转换为，没啥用额包装类的类型Object[]，还要转换</span></span><br><span class="line"><span class="comment"> * 正确的写法是</span></span><br><span class="line"><span class="comment"> * Integer[] ans = list.toArray(new Integer[list.size()])</span></span><br><span class="line"><span class="comment"> * 不如一个一个遍历算啦</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路，用set记录和值n的值，不断调用方法，求解下一个n,来判断n是否出现在set集合内，若出现，则判断false</span></span><br><span class="line"><span class="comment"> * 若sum==1，判定为快乐数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !set.contains(n)) &#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = nextNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += Math.pow(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没啥说的，记个时，五分钟内写出来</span></span><br><span class="line"><span class="comment">//用map记录数组元素，以及数组的下标，从i遍历数组，判断map是否存在target-i的值，返回即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, map.get(target - nums[i]) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="454-四数相加"><a href="#454-四数相加" class="headerlink" title="454.四数相加"></a>454.四数相加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：正常四层循环，count++肯定超时,考虑空间换时间</span></span><br><span class="line"><span class="comment"> * 考虑将四层循环减为两层</span></span><br><span class="line"><span class="comment"> * 定义一个map，用于存放两数的和sum，以及和出现的次数</span></span><br><span class="line"><span class="comment"> * 寻找，在3,4表中两层for，寻找-sum出现的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                map.put(i + j, map.getOrDefault(i + j, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                count += map.getOrDefault(-i - j, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// if (map.containsKey(-i - j)) &#123;</span></span><br><span class="line">                <span class="comment">// count += map.get(-i - j);</span></span><br><span class="line">                <span class="comment">// 获取默认值＋0，效率高于查找key再获取值</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="383-赎金信-1"><a href="#383-赎金信-1" class="headerlink" title="383.赎金信"></a>383.赎金信</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断第一个字符串能不能由第二个字符串组成</span></span><br><span class="line"><span class="comment">//思路：map存储第一个字符串以及出现的次数，遍历第二个字符串，将map对应的值-1，再判断当前元素对应的value值，如果&lt;0，即为false</span></span><br><span class="line"><span class="comment">//已经做过了，就写个思路吧</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：两层for循环确定i,j的值。再判断hashmap中是否存在(-i-j)的值,存在放入list&lt;Integer&gt;集合中，</span></span><br><span class="line"><span class="comment">//题目说不能重复的三元组，所以对list集合要去重，可以再定义一个set集合去重，试试</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这样定义ArrayList的每一个对象都是List&lt;Integer&gt;类型的</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 当前i与前一个重复的时候，直接跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[i] - nums[j];</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(target)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (target == nums[i] || target == nums[j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (map.get(target) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="comment">// 只有一个重复的话</span></span><br><span class="line">                            <span class="comment">// map中的个数要&gt;=2才能确保不是自己</span></span><br><span class="line">                            <span class="comment">// 所以&lt;2的时候，直接跳出循环</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (target == nums[i] &amp;&amp; target == nums[j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (map.get(target) &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="comment">// 同理针对都是0的情况，个数要大于3次</span></span><br><span class="line">                            <span class="comment">// 小于3次直接跳出循环</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list = Arrays.asList(nums[i], nums[j], target);</span><br><span class="line">                    Collections.sort(list);<span class="comment">// 排序后加到集合中，方便set去重</span></span><br><span class="line">                    ans.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将ArrayList集合转为set集合，直接定义将结果扔进去就行</span></span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(ans);</span><br><span class="line">        <span class="comment">// 再转为AerrayList集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//思路好理解，去重浪费太多时间了</span></span><br><span class="line"><span class="comment">//我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</span></span><br><span class="line"><span class="comment">//所以这里是有两个重复的维度</span></span><br><span class="line"><span class="comment">//熟悉定理复杂list集合，以及ArrayList和Set集合之间的转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，</span></span><br><span class="line">            <span class="comment">// 那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 去重a</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针的去重逻辑比map简单多了，不用考虑那么多情况，也不用map，set，ArrayList一起用又排序，又去重，还有两个重复的维度，太慢了，再也不头铁了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思路：使用双指针法的话，要O^3，</span></span><br><span class="line"><span class="comment">使用map记录两种和出现的次数，查找另外两个，O^2</span></span><br><span class="line"><span class="comment">先试试map吧，都试试。完全没思路了，去重因为是数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        list = Arrays.asList(nums[i], nums[j], nums[left], nums[right]);</span><br><span class="line">                        <span class="comment">// Collections.sort(list);</span></span><br><span class="line">                        ans.add(list);</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;(ans);</span></span><br><span class="line">        <span class="comment">// return new ArrayList&lt;&gt;(set);</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = t;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没啥说的，或者调用StringBuilder，调用里面的reverse方法</span></span><br></pre></td></tr></table></figure><h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541.反转字符串II"></a>541.反转字符串II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Math.min(i + k - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            arr = subReverse(arr, i, r);</span><br><span class="line">            i = i + <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] subReverse(<span class="type">char</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//就是判断尾指针的长度，是不能超过数组的长度</span></span><br><span class="line"><span class="comment">//还有就是。是，charAt()只能取值，不能赋值给另一个charAt，涉及到数组字符串交换的，要转为数组处理</span></span><br></pre></td></tr></table></figure><h3 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h3><p>将字符串中的数字替换为字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;number&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不熟悉ACM格式，用StringBuilder秒了，不用扩长度</span></span><br></pre></td></tr></table></figure><h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i--;<span class="comment">// 搜索首个空格出现的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            ans.append(sub);</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//想了半天不知道字符串中间的单词空格怎么处理，直接+&quot;&quot;到后面再trim()处理，真的妙啊</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="右旋字符串"><a href="#右旋字符串" class="headerlink" title="右旋字符串"></a>右旋字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scan.next();</span><br><span class="line">        <span class="type">char</span> arr[] = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">char</span>[] ans = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - k; i &lt; n; i++) &#123;</span><br><span class="line">            ans[j++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - k; i++) &#123;</span><br><span class="line">            ans[j++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ACM模式，开辟了额外空间</span></span><br><span class="line"><span class="comment">//如果O(1),就先倒序，再倒序字串，就行</span></span><br></pre></td></tr></table></figure><h3 id="28-找出字符串中第一个匹配的下标"><a href="#28-找出字符串中第一个匹配的下标" class="headerlink" title="28.找出字符串中第一个匹配的下标"></a>28.找出字符串中第一个匹配的下标</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String h, String n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenh</span> <span class="operator">=</span> h.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenn</span> <span class="operator">=</span> n.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= lenh - lenn; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i, b = <span class="number">0</span>;<span class="comment">// 分别指向两个字符串的指针</span></span><br><span class="line">            <span class="keyword">while</span> (b &lt; lenn &amp;&amp; h.charAt(a) == n.charAt(b)) &#123;</span><br><span class="line">                a++;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b == lenn) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟法。分别指向两个字符串的指针，a是发起点，每循环一次，长的字符串都要有不同的发起点去匹配。y也就是暴力算法，时间复杂度O(m*n)</span></span><br><span class="line"><span class="comment">//KMP算法，</span></span><br></pre></td></tr></table></figure><h3 id="459-重复的字串"><a href="#459-重复的字串" class="headerlink" title="459.重复的字串"></a>459.重复的字串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, i);</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n / i; j++) &#123;</span><br><span class="line">                    sb.append(sub);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sb.toString().equals(s)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力模拟，找出字串，重复n次，判断是否与原有的串相等</span></span><br><span class="line"><span class="comment">//KMP算法，太复杂了不想弄了，就暴力吧</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> leecode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（二）链表篇</title>
      <link href="/2024/03/25/lianbiao/"/>
      <url>/2024/03/25/lianbiao/</url>
      
        <content type="html"><![CDATA[<h1 id="链表篇"><a href="#链表篇" class="headerlink" title="链表篇"></a>链表篇</h1><h1 id="移除链表元素，设计链表，反转链表，交换链表节点，删除链表，相交链表，环形链表"><a href="#移除链表元素，设计链表，反转链表，交换链表节点，删除链表，相交链表，环形链表" class="headerlink" title="移除链表元素，设计链表，反转链表，交换链表节点，删除链表，相交链表，环形链表"></a>移除链表元素，设计链表，反转链表，交换链表节点，删除链表，相交链表，环形链表</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表这一张，集合中的LinkedList底层实现就是双链表，封装好了增删改查等各种方法，这里相当于是手写源码了属于是</p><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//传入头结点和值，头结点是一个结构体，包含一个值，和下一个节点</span></span><br><span class="line">        <span class="comment">//next，以及三个构造器</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        preNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> preNode;<span class="comment">//定义临时表示当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.val == val)&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手写源码了属于是，定义一个虚拟头结点，确保不用在判断头结点就是要删除的情况，</span></span><br><span class="line"><span class="comment">//其次就是，定义零食变量temp的节点，表示当前结点，以便后续操作</span></span><br></pre></td></tr></table></figure><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p>他奶奶的，人linkedList底层封装好的，要我重新设计，写这些方法，离谱啊，算了，熟能生巧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义链表类，val是当前节点的值，next是指向下一个节点的引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 链表的长度</span></span><br><span class="line">    ListNode head;<span class="comment">// 链表的首节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下标为index节点的数值，如果下标无效，则返回-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            preNode = preNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个值为val的节点差插入到链表第一个元素之前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">        <span class="comment">// ListNode Node = new ListNode(val);</span></span><br><span class="line">        <span class="comment">// Node.next = head.next;</span></span><br><span class="line">        <span class="comment">// head.next = Node;</span></span><br><span class="line">        <span class="comment">// size++;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个值val的节点加入到链表作为链表的最后一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">        <span class="comment">// ListNode Node = head;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; size; i++) &#123;</span></span><br><span class="line">        <span class="comment">// Node = Node.next;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// Node.next = new ListNode(val);</span></span><br><span class="line">        <span class="comment">// size++;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将值为val的节点插入到index节点之前，若index==链表长度，插入最后</span></span><br><span class="line">    <span class="comment">// 若大于链表长度，则不会插入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">Node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        Node.next = temp.next;</span><br><span class="line">        temp.next = Node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果下标有效，则删除这个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = temp.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="comment">/*单链表的具体实现思路是有的，定义，创建，初始化的各种细节都需要熟悉</span></span><br><span class="line"><span class="comment">  不需要定义head头结点之前的虚拟节点，妈的，自动有了，get方法写错，排查了半天，浪费时间</span></span><br><span class="line"><span class="comment">  第二遍重写花了16分钟，还有小瑕疵。边界条件index的判断</span></span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">            t = n.next;<span class="comment">// 先保存这个节点,不然反转后会丢失</span></span><br><span class="line">            n.next = p;</span><br><span class="line">            p = n;<span class="comment">// n和p都向后一位</span></span><br><span class="line">            n = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">// 最后一次n被赋值为null，返回p作为头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单链表无法返回找回，需要临时变量存储下一个节点的位置</span></span><br></pre></td></tr></table></figure><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n</span> <span class="operator">=</span> pre;</span><br><span class="line">        ListNode t;</span><br><span class="line">        ListNode firstNode;</span><br><span class="line">        ListNode secondNode;</span><br><span class="line">        <span class="keyword">while</span> (n.next != <span class="literal">null</span> &amp;&amp; n.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            t = n.next.next.next;</span><br><span class="line">            firstNode = n.next;</span><br><span class="line">            secondNode = n.next.next;</span><br><span class="line"></span><br><span class="line">            n.next = secondNode;</span><br><span class="line">            secondNode.next = firstNode;</span><br><span class="line">            firstNode.next = t;</span><br><span class="line">            n = firstNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*交换的方法画个图就出来了，三步走，要记录的临时变量太多了，开始写那么多的next的头都写晕了</span></span><br><span class="line"><span class="comment">然后，因为临时变量要不停的变，要在循环内赋值，不能在循环外面赋值</span></span><br><span class="line"><span class="comment">然后，&amp;&amp; 与&amp;的问题，开始写的是，n.next.next != null &amp;&amp; n.next != null，运行错误</span></span><br><span class="line"><span class="comment">&amp; 是两个条件都要判定一下，而&amp;&amp;是第一个不正确就不判断第二个了，当然next都=null了，就更不需要判断后面的了，所以要把小的放在&amp;&amp;的前面</span></span><br></pre></td></tr></table></figure><h3 id="19-删除链表倒数第n个节点"><a href="#19-删除链表倒数第n个节点" class="headerlink" title="19.删除链表倒数第n个节点"></a>19.删除链表倒数第n个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        last.next = last.next.next;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*很巧妙的方法，删除简单，关键是找到链表还是倒数第n个元素，众所周知，链表不好查询</span></span><br><span class="line"><span class="comment">双指针定义了一个长度为n的区间，不停移动 ，直到快指针指向null，慢指针的位置后面就是要删除元素的位置</span></span><br></pre></td></tr></table></figure><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h3><p><img src="/2024/03/25/lianbiao/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240116144358853.png" alt="image-20240116144358853"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*末尾对齐，指针B多移动(lenB-lenA),然后一起向后遍历是否相等</span></span><br><span class="line"><span class="comment">需要注意的是，要判断长度，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">B</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (A != <span class="literal">null</span>) &#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            A = A.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (B != <span class="literal">null</span>) &#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            B = B.next;</span><br><span class="line">        &#125;</span><br><span class="line">        A = headA;<span class="comment">// 刚刚遍历长度到末尾了，再指向头结点</span></span><br><span class="line">        B = headB;</span><br><span class="line">        <span class="keyword">if</span> (lenA &gt; lenB) &#123;<span class="comment">// 交换A，B头结点,确保A短</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> lenA;</span><br><span class="line">            lenA = lenB;</span><br><span class="line">            lenB = t;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">T</span> <span class="operator">=</span> A;</span><br><span class="line">            A = B;</span><br><span class="line">            B = T;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> lenB - lenA;</span><br><span class="line">        <span class="keyword">while</span> (d-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            B = B.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (A != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A == B) &#123;</span><br><span class="line">                <span class="keyword">return</span> A;</span><br><span class="line">            &#125;</span><br><span class="line">            A = A.next;</span><br><span class="line">            B = B.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="142.环形链表"></a>142.环形链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义两个指针，fast，slow，指向链表的head，，fast指针每次走两步，slow指针每次走一步</span></span><br><span class="line"><span class="comment">1：fast指针走到null，说明链表无环，</span></span><br><span class="line"><span class="comment">2.若有环的话，fast一定会遇到slow，&#123;</span></span><br><span class="line"><span class="comment">1.fast先进环，会在环内转圈圈，slow再进环，会在环内相遇</span></span><br><span class="line"><span class="comment">2.假定一个环，fast在任意节点追赶slow指针，无论环数为奇数偶数，初始差多少，这样理解，等同于slow走0步，fast走一步，fast是慢慢接近slow的，所以一定可以重合</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">此时就可以判断链表有环了。如何确定环的入口呢？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.当fast==slow的时候，设置链表前面有a个节点， 链表环有b个节点，</span></span><br><span class="line"><span class="comment">fast走的距离是slow的两倍，f=2s</span></span><br><span class="line"><span class="comment">fast比slow多走了n个环的长度，f = s+n*b,所以，slow走过的长度s=nb,f=2nb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4.让指针一直走，走到链表入口的位置是，a+nb，绕了n圈，而slow指针只走了nb步数，只要再让slow指针走a步数，就能在入口处停下来，如何再让slow指针走a步数&#123;</span></span><br><span class="line"><span class="comment">1.将fast重新指向head头结点</span></span><br><span class="line"><span class="comment">2.fast，slow重新开始走，再次重合是后，刚好走了a步数，fast，slow停留在入口位置</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;<span class="comment">// 有环</span></span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码写出来很简单，但分析过程的时候可不简单</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（一）数组篇</title>
      <link href="/2024/03/25/shuzu/"/>
      <url>/2024/03/25/shuzu/</url>
      
        <content type="html"><![CDATA[<h1 id="数组篇"><a href="#数组篇" class="headerlink" title="数组篇"></a>数组篇</h1><h1 id="两数之和，二分查找，移除元素，长度最小子数组，螺旋矩阵"><a href="#两数之和，二分查找，移除元素，长度最小子数组，螺旋矩阵" class="headerlink" title="两数之和，二分查找，移除元素，长度最小子数组，螺旋矩阵"></a>两数之和，二分查找，移除元素，长度最小子数组，螺旋矩阵</h1><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常规两层for循环，注意同一个元素不能再匹配一次，所以，内层循环从J=i+1开始</span></span><br><span class="line"><span class="comment">//区别常规的，判断冒泡排序的算法，内层是n-i-1,因为每次已经将前i个元素排号了，所以内层循环要减去</span></span><br><span class="line"><span class="comment">//时间复杂度是O(n^2)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用map集合简化时间复杂度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意put放入元素的顺序，不能先放入元素，再查找，这样会查到到自己本身，会重复，</span></span><br><span class="line"><span class="comment">//先查找，再放入元素能完美的避开这一点</span></span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 while(left &lt; right) 还是 while(left &lt;= right)，到底是right = middle呢，还是要right = middle - 1呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这就涉及到区间的问题哦，使用while(left&lt;=right)，说明区间是[left.right],所以right开始要赋值为nums.length-1，当(mid&gt;target)时候，因为相等的时候已经判断过了，所以不需要再判断了，所以right=mid-1,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当使用while(left&lt;right)时候 ，说明区间是[left,right),所以开始right要赋值为nums.length，因为取不到，当(mid &gt; right)的时候，因为又开区间，相等的时候没没判断过。所欲right=mid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总之区间的问题，只要熟悉一种写法就够了</span></span><br></pre></td></tr></table></figure><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标准的二分查找，注意理解题目要求返回的东西，被顺序插入的地方，不一定是返回mid的位置，因为mid有可能找到 ，也有可能没有无法找到</span></span><br></pre></td></tr></table></figure><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                left = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; left, right &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常规暴力思路，两次for循环分别找第一个位置和最后一个位置，复杂度0(n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                first = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;<span class="comment">// 相等后继续从左区间找到首次位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">// 相等后继续从右区间找到最后位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; first, end &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为有重复的元素，所以二分法在相等后还需要调整区间，确保找到首次末次的，时间复杂度O(log(n))</span></span><br></pre></td></tr></table></figure><h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69. x的平方根"></a>69. x的平方根</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &gt; x) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &lt; x) &#123;</span><br><span class="line">                ans = mid;<span class="comment">//因为平方根向下取整，所以要在小于的时候，记录ans的值</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(long)mid*mid，乘法注意强转为long类型的，防止溢出报错</span></span><br></pre></td></tr></table></figure><h3 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367.有效的完全平方数"></a>367.有效的完全平方数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &gt; num) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &lt; num) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//熟能生巧，没啥说的，一遍过</span></span><br></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用解法，遍历，对于不是目标元素的，在原有基础上覆盖，时间O(n)，空间O(1)</span></span><br><span class="line"><span class="comment">//这就是双指针，快指针指向全部元素，判断符合条件的赋值给慢指针，最后返回慢指针的个数即可</span></span><br></pre></td></tr></table></figure><h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>; fast &lt; nums.length ; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针，注意边界的取值问题，fast从1开始，确保能取值到数组末端，且能够跟前一位比较，而不发生数组溢出的问题，slow从1开始，因为第一个元素必定不重复，送0开始会漏掉第一个元素。</span></span><br></pre></td></tr></table></figure><h3 id="283-移动0"><a href="#283-移动0" class="headerlink" title="283.移动0"></a>283.移动0</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, fast, slow);</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换的解法</span></span><br><span class="line"><span class="comment">//1.交换过程一定要把要交换的数据放入，传入的数据不能只是swap(int a,int b)，不然无法交换</span></span><br><span class="line"><span class="comment">//2.判断交换的条件，开始想着必须nums[slow]==0并且nums[fast]!=0，看起来对，但是这样条件苛刻会导致slow无法执行++的操作，进而一直指向某一位不动，无法继续，所以nums[fast]不为0交换即可实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> slow; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不用交换，直接覆盖，再把之后的赋值为0就行</span></span><br></pre></td></tr></table></figure><h3 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844.比较含退格的字符串"></a>844.比较含退格的字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                s1.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                s1.deleteCharAt(s1.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                t1.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                t1.deleteCharAt(t1.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.toString().equals(t1.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuilder工具类的方法还是不熟悉，detete(int start,int end),deleteCharAt(int index),还有就是比较的时候，转化为字符串调用String类中的equals()方法比较。这其实就是栈的数据结构，进栈，出栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//使用栈方式，如果字符为#，则出栈顶元素，如果是普通字符，则压栈</span></span><br><span class="line">        Stack&lt;Character&gt; stacks=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        Stack&lt;Character&gt; stackt=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                stacks.push(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stacks.isEmpty())&#123;</span><br><span class="line">                    stacks.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i)!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                stackt.push(t.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stackt.isEmpty())&#123;</span><br><span class="line">                    stackt.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stacks.equals(stackt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈数据结构的方法：Stack&lt;Character&gt; s = new Stack()</span></span><br><span class="line"><span class="comment">//s.push()压栈</span></span><br><span class="line"><span class="comment">//              s.pop()出栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">countS</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录s中#的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">countT</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录t中#的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    countS++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span> &amp;&amp; countS != <span class="number">0</span>) &#123;</span><br><span class="line">                    countS--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    countT++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span> &amp;&amp; countT != <span class="number">0</span>) &#123;</span><br><span class="line">                    countT--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) != t.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*   双指针。</span></span><br><span class="line"><span class="comment">准备两个指针i,j，指向两个字符串的末尾，从后往前扫描，准备两个变量countS,countT,记录扫描到的#的个数</span></span><br><span class="line"><span class="comment">1.若当前字符是#，count++,继续扫描j--</span></span><br><span class="line"><span class="comment">2.若当前不是#，并且当前的s的count！=0，说明字符后面有退格，字符被抵消，count--，i--;</span></span><br><span class="line"><span class="comment">3,若当前不是#，并且当前的s的count==0，说明当前字符没有退格，跳出S的循环，等待t找出没有退格的字符，在进行比较。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当i,j都&gt;=0，没有越界的时候，比较，不相等返回false</span></span><br><span class="line"><span class="comment">当都小于0 时候，退格空字符串也是空串，说明两个都是空串，返回true</span></span><br><span class="line"><span class="comment">其他情况，返回false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ans[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//平方再排序，时间复杂度O(n*log(n))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &gt;= nums[j] * nums[j]) &#123;</span><br><span class="line">                ans[k--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[k--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针，因为本来数组就有序，所以定义首尾指针，判断平方后的大小放入新数组即可</span></span><br></pre></td></tr></table></figure><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">substring</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; l; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                    substring = j - i + <span class="number">1</span>;</span><br><span class="line">                    ans = Math.min(ans, substring);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力解法，java中int类型的最大值的表示方式，Integer.MAX_VALUE,Integer.MIN_VALUE</span></span><br><span class="line"><span class="comment">//需要先把ans设置为最大值，要不然调用Math.min()的时候，一直就是0了。然后最后判断ans是否被赋值了再返回答案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">substring</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//滑动窗口起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                substring = j - i + <span class="number">1</span>;</span><br><span class="line">                ans = Math.min(ans, substring);</span><br><span class="line">                sum -= nums[i];<span class="comment">//窗口滑动，从sum中减去左边的值</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i记录左边窗口的位置，当sum&gt;target的时候，记录当前的substring，再减去左边窗口的位置，其他流程不变，核心代码为： sum-=nums[i++];</span></span><br></pre></td></tr></table></figure><h3 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904.水果成篮"></a>904.水果成篮</h3><p><strong>（找最多包含两种元素的最长字串，并且返回其长度。）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fruits.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> fruits[right];<span class="comment">// 快指针遍历的值</span></span><br><span class="line">            map.put(a, map.getOrDefault(a, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将a的值与a元素的个数加入</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> fruits[left];<span class="comment">// 慢指针遍历的值</span></span><br><span class="line">                map.put(b, map.get(b) - <span class="number">1</span>);<span class="comment">// 将慢指针遍历的个数-1</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(b) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(b);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针+HashMap</span></span><br><span class="line"><span class="comment">/*使用双指针形成窗口，使用HashMap存储窗口 中的元素和元素的个数，记录此时临时窗口的长度为：     right-left+1，当hash表长度＞2时候，即出现第三个元素，我们将left++，左边元素的个数+1</span></span><br><span class="line"><span class="comment">滑动窗口，滑动的是数组fruits的窗口，与right与left有关，而与HashMap的a,b无关</span></span><br><span class="line"><span class="comment">窗口不断滑动，右边次数+1，左边次数-1，左边为0时候，remove即可，不停的记录窗口的长度，返回最大值即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">map中的函数，getOrDefault(key,default),因为开始存入都没有数值，会出现null的情况，所以需要设置默认值，其他没什么了，这题，花了俩小时，还是看答案+花示例图才理解原因，对双指针+map组合的解法，又了解了许多</span></span><br></pre></td></tr></table></figure><h3 id="76-覆盖最小字串"><a href="#76-覆盖最小字串" class="headerlink" title="76.覆盖最小字串"></a>76.覆盖最小字串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>();  <span class="comment">// 用来记录窗口中的字符和数量</span></span><br><span class="line">        Map&lt;Character,Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>();  <span class="comment">// 需要凑齐的字符和数量</span></span><br><span class="line">        <span class="comment">// 构建need字符集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">needChar</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            need.put(needChar,need.getOrDefault(needChar,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = <span class="number">0</span>,valid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// valid是用来记录窗口中满足need要求的字符和数量的数目，比如need中要求字符a数量为2，如果window中的a字符的数量等于了2，valid就＋1，反之-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;  <span class="comment">// 记录最小字串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 记录最小字串的起始位置</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">addChar</span> <span class="operator">=</span> s.charAt(right);  <span class="comment">// 即将要加入window的字符</span></span><br><span class="line">            window.put(addChar,window.getOrDefault(addChar,<span class="number">0</span>) + <span class="number">1</span>);  </span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 如果加入的字符是need中要求的字符，并且数量已经达到了need要求的数量，则valid+1</span></span><br><span class="line">            <span class="comment">// 这里和下面都有个坑，window.get(addChar)和need.get(addChar)返回的都是对象，最好用.equals()方法比较大小</span></span><br><span class="line">            <span class="keyword">if</span>(need.containsKey(addChar) &amp;&amp; window.get(addChar).equals(need.get(addChar)))&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 当window中记录的字符和数量满足了need中要求的字符和数量，考虑缩窗口</span></span><br><span class="line">            <span class="keyword">while</span>(valid == need.size())&#123;</span><br><span class="line">                <span class="comment">// 先判断当前的最小覆盖字串是否比之前的最小覆盖字串短</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; len)&#123;  <span class="comment">// 注意，这里上面已经对right实施了++操作，所以这里的长度不是right - left + 1</span></span><br><span class="line">                    len = right - left ;</span><br><span class="line">                    start = left;  <span class="comment">// 如果最短，则记录下该最小覆盖字串的起始位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">removeChar</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="comment">// 开始缩减窗口，left右移，如果要从window删除的字符正好是need中需要的并且，数目也等于need中需要的数目，则删减后，该该字符要求的数量</span></span><br><span class="line">                <span class="comment">// 显然不满足need要求的数量，所以valid要-1；</span></span><br><span class="line">                <span class="keyword">if</span>(need.containsKey(removeChar) &amp;&amp; window.get(removeChar).equals(need.get(removeChar)))&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(removeChar,window.get(removeChar) - <span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最小覆盖字串的长度相对于定义时没变，则t不包含s中所有的字符，返回&quot;&quot;,如果长度改变过，说明存在这样的最小覆盖字串，直接输出。</span></span><br><span class="line">        <span class="keyword">return</span> len == Integer.MAX_VALUE?<span class="string">&quot;&quot;</span>:s.substring(start,start+len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个HashMap+滑动窗口，如何判断当前窗口包含t的所有字符呢？使用一个哈希表t记录t中所有的字符和个数，使用一个哈希表记录窗口中的所有字符以及个数，如果动态表中的t包含哈希表中的所有字符，并且对应个数不小于t中的个数，那么当前窗口是可行的</span></span><br><span class="line"><span class="comment">//代码我是写不出来了，copy一份吧，不浪费时间了</span></span><br></pre></td></tr></table></figure><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> ans[][] = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 循环次数</span></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录起始位置,控制遍历长度</span></span><br><span class="line">        <span class="comment">//int site = 1;// 控制每条边的遍历长度，每次遍历收缩1位</span></span><br><span class="line">        <span class="keyword">while</span> ((loop++) &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = start; j &lt; n - start - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans[start][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = start; i &lt; n - start - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                ans[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; start; j--) &#123;</span><br><span class="line">                ans[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; start; i--) &#123;</span><br><span class="line">                ans[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            <span class="comment">// site++;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*loop控制循环次数,</span></span><br><span class="line"><span class="comment">site控制每条边的遍历长度,初始为1，每次遍历[ , )，左闭右开区间的数据，写入</span></span><br><span class="line"><span class="comment">最后奇数写入中间的即可，或者不用site，用start-1控制也行，一样</span></span><br><span class="line"><span class="comment">i,j分别表示横纵坐标，所以开始先从j开始，</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对不是不是正方形的矩阵，即m不等于n，上述算法要改进，我开始按照上面的做，寻找m,n的最小值的一半作为循环条件，进入循环，但是最后的结果不对，只有最外圈的成功，内圈如果min(m,n)有奇数的话，进入最后一轮，就会赋值重复，(debug发现因为左右没有值，所以上下，在下上，赋值会重复)，所以需要单独给矩阵最中间的位置赋值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Math.min(m, n);</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">starty</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((loop++) &lt; l / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = startx; j &lt; n - startx - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                list.add(matrix[startx][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = starty; i &lt; m - starty - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; startx; j--) &#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; starty; i--) &#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = startx; j &lt; n - startx; j++) &#123;</span><br><span class="line">                    list.add(matrix[startx][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = starty; i &lt; m - starty; i++) &#123;</span><br><span class="line">                    list.add(matrix[i][starty]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意边界条件，单独给矩阵中间赋值的边界条件，画个图一下子就看出来了</span></span><br></pre></td></tr></table></figure><h3 id="LCR-146-螺旋遍历二维数组"><a href="#LCR-146-螺旋遍历二维数组" class="headerlink" title="LCR 146. 螺旋遍历二维数组"></a>LCR 146. 螺旋遍历二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralArray(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[m * n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Math.min(m, n);</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">starty</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((loop++) &lt; l / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = startx; j &lt; n - startx - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans[count++] = matrix[startx][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = starty; i &lt; m - starty - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                ans[count++] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; startx; j--) &#123;</span><br><span class="line">                ans[count++] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; starty; i--) &#123;</span><br><span class="line">                ans[count++] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = startx; j &lt; n - startx; j++) &#123;</span><br><span class="line">                    ans[count++] = matrix[startx][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = starty; i &lt; m - starty; i++) &#123;</span><br><span class="line">                    ans[count++] = matrix[i][starty];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//思路一样，只是返回值变成了数组</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（四）栈与队列篇</title>
      <link href="/2024/03/25/stack-queue/"/>
      <url>/2024/03/25/stack-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="栈与队列篇"><a href="#栈与队列篇" class="headerlink" title="栈与队列篇"></a>栈与队列篇</h1><h1 id="用队列实现栈，有效的括号，逆波兰表达式，滑动窗口最大值，前K个高频元素"><a href="#用队列实现栈，有效的括号，逆波兰表达式，滑动窗口最大值，前K个高频元素" class="headerlink" title="用队列实现栈，有效的括号，逆波兰表达式，滑动窗口最大值，前K个高频元素"></a>用队列实现栈，有效的括号，逆波兰表达式，滑动窗口最大值，前K个高频元素</h1><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();<span class="comment">// 负责进栈</span></span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();<span class="comment">// 负责出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队的操作,过程即将数据压入进栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InTuOut</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stackOut.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackIn.isEmpty()) &#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从队列的开头移除元素，将In栈的元素全部放到out栈中，</span></span><br><span class="line">    <span class="comment">// 再从out栈移除即可，所以需要写一个移动函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        InTuOut();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        InTuOut();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟，理清思路路，用两个栈模拟队列，入栈的时候，入栈IN，出栈的时候，将In栈内元素全部转到OUT栈，再出栈，</span></span><br></pre></td></tr></table></figure><h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用两个队列，实现。这样实现没什么意思不想写了</span></span><br></pre></td></tr></table></figure><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || c != stack.pop()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匹配括号，检测到左括号，就入栈右括号即可，最后栈空，或者栈顶元素不等于匹配的元素，就返回false</span></span><br></pre></td></tr></table></figure><h3 id="1047-删除字符串中所有相邻的重复项"><a href="#1047-删除字符串中所有相邻的重复项" class="headerlink" title="1047.删除字符串中所有相邻的重复项"></a>1047.删除字符串中所有相邻的重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || c != stack.peek()) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// StringBuilder sb = new StringBuilder();</span></span><br><span class="line">        <span class="comment">// while (!stack.isEmpty()) &#123;</span></span><br><span class="line">        <span class="comment">// sb.append(stack.pop());</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// sb.reverse();</span></span><br><span class="line">        <span class="comment">// return sb.toString();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            str = stack.pop() + str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用栈，栈空或者下一个字符与栈不同，则入栈，反之出栈，</span></span><br><span class="line"><span class="comment">//使用StringBuilder循环接受出栈元素</span></span><br><span class="line"><span class="comment">//或者直接拼接，为什么直接拼接190ms比循环遍历反转80ms慢了这么多？搞不懂了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="150-逆波兰表达式"><a href="#150-逆波兰表达式" class="headerlink" title="150.逆波兰表达式"></a>150.逆波兰表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路很简单，遇到数字压入栈，遇到字符出栈，计算结果并且入栈，</span></span><br><span class="line"><span class="comment">/*实现过程中的问题，可是给的是String类型的数组，不能用==判断，==判断的是地址值是否相等，charAt()转为字符类型后，因为后面运算要使用Intege.valueOf()把String转为int类型的，所以直接用Sting类型的，调用equals方法去比较值的相等即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tokens.length;</span><br><span class="line">        Stack&lt;Integer&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> tokens[i];</span><br><span class="line">            <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    sk.push(sk.pop() + sk.pop());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    sk.push(-sk.pop() + sk.pop());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    sk.push(sk.pop() * sk.pop());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    <span class="comment">// sk.push(sk.pop() / sk.pop());</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">                    sk.push(end / first);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    sk.push(Integer.valueOf(s));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意乘法和加法无所谓，没有顺序，除法和减法有顺序的，要注意先后顺序</span></span><br></pre></td></tr></table></figure><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i + k - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left + <span class="number">1</span>; j &lt;= right; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; max) &#123;</span><br><span class="line">                    max = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : list) &#123;</span><br><span class="line">            ans[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力法，在滑动的数组中寻找最大值，再赋值给数组，复杂度O(n^2)，暴力超时</span></span><br><span class="line"><span class="comment">//可以考虑使用一个双端队列，记录首个范围的最大值max，入队操作，若right大，则左边的全部出队，若已有的大，入队就行（长度大于k左边出队），模拟是这个模拟，代码谢不出来</span></span><br></pre></td></tr></table></figure><h3 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="347.前k个高频元素"></a>347.前k个高频元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="comment">// map记录元素以及元素出现的次数</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将map中所有key-value的集合转换为list集合</span></span><br><span class="line">        <span class="comment">// Map.Entry表示java中操作键值对的接口，Map 接口的实现类（如 HashMap）的 entrySet() 方法返回一个包含 Map.Entry</span></span><br><span class="line">        <span class="comment">// 对象的集合</span></span><br><span class="line">        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(map.entrySet());</span><br><span class="line">        <span class="comment">// 重写comparator方法。通过比较value的值进行排序</span></span><br><span class="line">        list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 排序后输出前k个高频元素的key值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans[i] = list.get(i).getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*能想到的常规思路只有，使用HashMap计数，再通过value的值排序，得到前k个高频次的元素，在对map中的value值排序中遇到的问题已经写在了注释里</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">其他题解：使用优先队列，使用堆，我都看不懂</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（五）二叉树篇</title>
      <link href="/2024/03/25/tree/"/>
      <url>/2024/03/25/tree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树篇"><a href="#二叉树篇" class="headerlink" title="二叉树篇"></a>二叉树篇</h1><h1 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h1><h3 id="树的基础"><a href="#树的基础" class="headerlink" title="树的基础"></a>树的基础</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">节点的度： 一个节点含有的子树的个数称为该节点的度。如上图，T 节点的度为4</span><br><span class="line">树的度： 一颗树中，最大的节点的度称为树的度。如上图，该树的度为4</span><br><span class="line">叶子节点或终端节点： 度为0的节点称为叶子节点。如上图，T4、T11、T21、T22、T31、T32、T33为叶子节点</span><br><span class="line">双亲节点或父节点： 若一个节点含有子节点，则这个节点称为其子节点的父节点。如上图，T 节点是 T4 节点的父节点</span><br><span class="line">孩子节点或子节点： 一个节点含有的子树的根节点称为该节点的子节点。如上图，T4 节点是 T 节点的子节点</span><br><span class="line">根节点： 一颗树中，没有双亲节点的节点称为根节点。如上图，T 节点为根节点</span><br><span class="line">节点的层次： 从根开始定义，根为第1层，根的子节点为第二层，以此类推。如上图，该树有3层</span><br><span class="line">节点的深度： 某节点层次是第几层，则它的深度是多少。如上图，T 节点深度为1，T1 节点深度为2</span><br><span class="line">树的高度： 树中节点的最大层次。如上图，树的高度为3</span><br><span class="line">非终端节点或分支节点： 度不为0的节点。如上图，T、T1、T2、T3 为分支节点</span><br><span class="line">兄弟节点： 父亲节点相同的节点互称为兄弟节点。如上图，T1、T2、T3、T4 互称为兄弟节点</span><br><span class="line">堂兄弟节点： 双亲在同一层次的节点互称为堂兄弟节点。如上图，T11、T21 互称为堂兄弟节点</span><br><span class="line">节点的祖先： 从根节点到该节点所经过分支上的所有节点都称为该节点的祖先。如上图，T、T1 节点都为 T11 节点的祖先</span><br><span class="line">子孙： 以某节点为根的子树中，任意节点都称为该节点的子孙。如上图，该树中除 T 节点其它节点都是 T 节点的子孙</span><br><span class="line">森林： 由 m（m&gt;=0）棵互不相交的树的集合称为森林。</span><br></pre></td></tr></table></figure><p>二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当集合为空时，该二叉树称为空二叉树。</span><br><span class="line">在二叉树中，一个元素也称为一个结点。</span><br><span class="line">每个结点最多有两棵子树，即二叉树不存在度大于2的结点。</span><br><span class="line">二叉树的子树有左右之分，其次子树的次序不能颠倒，因此二叉树是有序树。</span><br></pre></td></tr></table></figure><p>二叉树的种类：</p><p><strong>满二叉树：</strong> 一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树就是满二叉树。<strong>性质：</strong> 如果一个二叉树的层数是k，且节点数是 2k-1，则它就是满二叉树。</p><p><strong>完全二叉树</strong>：在完全二叉树中，除了最后一层的节点没填满以外，其余每层节点数都达到最大值，并且下面一层的节点数都集中在最左边的若干位置，</p><p><strong>二叉搜索树：</strong></p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p><strong>平衡二叉搜索树：</strong>空树，或者它的左右两个树的高度差的绝对值不超过1，并且左右子树都是平衡二叉树</p><h3 id="二叉树的存储方式："><a href="#二叉树的存储方式：" class="headerlink" title="二叉树的存储方式："></a>二叉树的存储方式：</h3><p>链式存储：用指针，（节点元素，左指针 ，右指针）</p><p>顺序存储：用数组，用数组下标记录左孩子右孩子的位置</p><h3 id="二叉树的遍历方式："><a href="#二叉树的遍历方式：" class="headerlink" title="二叉树的遍历方式："></a>二叉树的遍历方式：</h3><p>深度优先遍历：先往深处走，一层一层遍历</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>广度优先遍历：</p><ul><li>层次遍历</li></ul><p>java链式存储二叉树节点的定义方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;<span class="comment">//定义了一个TreeNode的类，用于表示二叉树中的节点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">//节点的值</span></span><br><span class="line">    TreeNode left;<span class="comment">//左子结点</span></span><br><span class="line">    TreeNode right;<span class="comment">//右子节点</span></span><br><span class="line"><span class="comment">//三个构造器，空参构造器，构造器等等</span></span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="144-二叉树的前序，中序，后续遍历（递归）"><a href="#144-二叉树的前序，中序，后续遍历（递归）" class="headerlink" title="144.二叉树的前序，中序，后续遍历（递归）"></a>144.二叉树的前序，中序，后续遍历（递归）</h3><p>145.后序遍历    94.中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        recursive(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursive</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        recursive(root.left, res);</span><br><span class="line">        recursive(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历是，中，左，右</span></span><br><span class="line"><span class="comment">//中序遍历是，左，中，右</span></span><br><span class="line"><span class="comment">//后序遍历是，左，右，中</span></span><br><span class="line"><span class="comment">//只需要在递归函数中 把递归调用的顺序改变就行了</span></span><br></pre></td></tr></table></figure><p>144，二叉树的前序，中序，后序遍历（迭代法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历，中左右</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            res.add(n.val);</span><br><span class="line">            <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(n.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(n.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈空使用isEmpty()函数，不能用！=null来判断</span></span><br><span class="line"><span class="comment">//用栈模拟，进栈顺序为先右后左</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后续遍历，左右中</span></span><br><span class="line"><span class="comment">//需要在先序遍历级基础上，生成中右左，再反转为左右中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            res.add(n.val);</span><br><span class="line">            <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(n.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(n.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//集合的反转不能直接调用reverse();</span></span><br><span class="line"><span class="comment">//Collections.reverse();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历，左中右</span></span><br><span class="line"><span class="comment">//思路就是，用临时变量temp记录当前的节点</span></span><br><span class="line"><span class="comment">//不为空入栈，左移，到最左边的节点后</span></span><br><span class="line"><span class="comment">//为空弹出栈，右移</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(temp);</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> s.pop();</span><br><span class="line">                res.add(n.val);</span><br><span class="line">                temp = n.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);<span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(n.val);</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列模拟，入队，确定队长，循环出队和遍历当前节点的左右子树即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归的方法，还不是很懂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        levelOrderHelper(root, <span class="number">0</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrderHelper</span><span class="params">(TreeNode node, <span class="type">int</span> level, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (level == result.size()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果当前层级等于列表结果的大小，则说明当前层级的列表还不存在，需要创建一个新的列表，并且将其添加到结果列表当中</span></span><br><span class="line">        result.get(level).add(node.val);</span><br><span class="line">        <span class="comment">//获取当前层级的列表，并且添加对应的元素值</span></span><br><span class="line">        levelOrderHelper(node.left, level + <span class="number">1</span>, result);</span><br><span class="line">        levelOrderHelper(node.right, level + <span class="number">1</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="107-二叉树的层序遍历II"><a href="#107-二叉树的层序遍历II" class="headerlink" title="107.二叉树的层序遍历II"></a>107.二叉树的层序遍历II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                list.add(n.val);</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans.add(res.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历再反转即可</span></span><br></pre></td></tr></table></figure><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历的基础上，记录循环出队的最后一个元素即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(n.val);</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">                    ans.add(n.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在层遍历的基础上，统计和在平均一下，没啥好说的</span></span><br></pre></td></tr></table></figure><h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);<span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(n.val);</span><br><span class="line">                <span class="keyword">for</span> (Node c : n.children) &#123;</span><br><span class="line">                    queue.offer(c);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//二叉树这里是遍历左右子树，N叉树这里直接循环遍历所有的子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="515-在每个树中找出最大值"><a href="#515-在每个树中找出最大值" class="headerlink" title="515.在每个树中找出最大值"></a>515.在每个树中找出最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                max = n.val &gt; max ? n.val : max;</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="116-（117）填充每个节点的下一个右侧节点指针"><a href="#116-（117）填充每个节点的下一个右侧节点指针" class="headerlink" title="116.（117）填充每个节点的下一个右侧节点指针"></a>116.（117）填充每个节点的下一个右侧节点指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;<span class="comment">//最右边不连接</span></span><br><span class="line">                    n.next = q.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列的peek()方法，获得队首的值，但是不出队</span></span><br><span class="line"><span class="comment">//最末尾的不连接，链接前size-1个元素的值即可</span></span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，len值++</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，当同时满足，节点的左右节点都为null时候，返回此时的len值</span></span><br><span class="line"><span class="keyword">if</span> (n.left == <span class="literal">null</span> &amp;&amp; n.right == <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归，翻转左右子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        swap(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归我还是很不熟练，自己调用自己</span></span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(left.left,right.right) &amp;&amp; compare(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归判断，判断左右节点非空，再判断左对右，右对左的数值是否相等</span></span><br></pre></td></tr></table></figure><h3 id="104-完全二叉树的节点个数"><a href="#104-完全二叉树的节点个数" class="headerlink" title="104.完全二叉树的节点个数"></a>104.完全二叉树的节点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，记录count值，或者递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right)&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getHeight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getHeight(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个计算当前二叉树高度的函数getheight</span></span><br><span class="line"><span class="comment">//满足平衡二叉树的定义:</span></span><br><span class="line"><span class="comment">//1.左右节点的高度差不超过1</span></span><br><span class="line"><span class="comment">//2.当前节点的左右节点都是为平衡二叉树</span></span><br><span class="line"><span class="comment">//知道这两个原理了，就很好写代码，不知道的话，就写不出来</span></span><br></pre></td></tr></table></figure><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, String path, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点不为空，拼接节点到当前路劲下</span></span><br><span class="line">            path += Integer.toString(node.val);</span><br><span class="line">            <span class="comment">// 如果节点到为叶子结点，添加到当前路径中</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                res.add(path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 非叶子节点，添加路径符号，继续遍历左右子树</span></span><br><span class="line">                path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                dfs(node.left, path, res);</span><br><span class="line">                dfs(node.right, path, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重要点是记录当前的路径</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
