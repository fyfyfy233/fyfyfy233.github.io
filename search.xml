<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue2</title>
      <link href="/2024/11/14/Interviews/vue2/"/>
      <url>/2024/11/14/Interviews/vue2/</url>
      
        <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件</code></pre><h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol><li>vue.js与vue.runtime.xxx.js的区别：<ol><li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li><li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li></ol></li><li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li></ol><h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol><li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li><li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li></ol><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol><li>被用来给元素或子组件注册引用信息（id的替代者）</li><li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li><li>使用方式：<ol><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ol></li></ol><h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line"><span class="attr">name</span>:&#123;</span><br><span class="line"><span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line"><span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line"><span class="attr">default</span>:<span class="string">&#x27;老王&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p></blockquote></li></ol><h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p><p> 第一步定义混合：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data()&#123;....&#125;,</span><br><span class="line">    methods:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二步使用混入：</p><p> ​全局混入：<code>Vue.mixin(xxx)</code><br> ​局部混入：<code>mixins:[&#39;xxx&#39;]</code></p></li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol><li><p>功能：用于增强Vue</p></li><li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用插件：<code>Vue.use()</code></p></li></ol><h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol><li>作用：让样式在局部生效，防止冲突。</li><li>写法：<code>&lt;style scoped&gt;</code></li></ol><h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol><li><p>组件化编码流程：</p><p> ​(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p><p> ​(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p> ​1).一个组件在用：放在组件自身即可。</p><p> ​2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p><p> ​(3).实现交互：从绑定事件开始。</p></li><li><p>props适用于：</p><p> ​(1).父组件 &#x3D;&#x3D;&gt; 子组件 通信</p><p> ​(2).子组件 &#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）</p></li><li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p></li><li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p></li></ol><h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol><li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p></li><li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p></li><li><p>相关API：</p><ol><li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p></li><li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p><p> ​该方法接受一个键名作为参数，返回键名对应的值。</p></li><li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p><p> ​该方法接受一个键名作为参数，并把该键名从存储中删除。</p></li><li><p><code> xxxxxStorage.clear()</code></p><p> ​该方法会清空存储中的所有数据。</p></li></ol></li><li><p>备注：</p><ol><li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li><li>LocalStorage存储的内容，需要手动清除才会消失。</li><li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li><li><code>JSON.parse(null)</code>的结果依然是null。</li></ol></li></ol><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol><li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p></li><li><p>第二种方式，在父组件中：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p></li><li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p></li></ol><h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>安装全局事件总线：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p></li></ol><h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>使用步骤：</p><ol><li><p>安装pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p></li></ol></li></ol><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li></ol><h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol><li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p></li><li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%"></p></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式：<ol><li>v-enter：进入的起点</li><li>v-enter-active：进入过程中</li><li>v-enter-to：进入的终点</li></ol></li><li>元素离开的样式：<ol><li>v-leave：离开的起点</li><li>v-leave-active：离开过程中</li><li>v-leave-to：离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li><li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p></li></ol></li></ol><h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​在vue.config.js中添加如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​编写vue.config.js配置具体代理规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>具名插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>作用域插槽：</p><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​多个组件需要共享数据时</p><h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol><li><p>创建文件：<code>src/store/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol><li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">//响应组件中加的动作</span></span><br><span class="line"><span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line"><span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">//执行加</span></span><br><span class="line"><span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line"><span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">state.<span class="property">sum</span> += value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p></li><li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p><blockquote><p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote></li></ol><h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol><li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">......</span><br><span class="line">getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol><li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p></blockquote><h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取state数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取getters数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用dispatch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用commit</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li></ol><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li><li>前端路由：key是路径，value是组件。</li></ol><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol><li><p>安装vue-router，命令：<code>npm i vue-router</code></p></li><li><p>应用插件：<code>Vue.use(VueRouter)</code></p></li><li><p>编写router配置项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li><li><p>实现切换（active-class可配置高亮样式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>指定展示位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li><li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li></ol><h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol><li><p>配置路由规则，使用children配置项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[ <span class="comment">//通过children配置子级路由</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,<span class="comment">//此处一定不要写：/message</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>跳转（要写完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;hello&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol><li><p>配置路由，声明接收params参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;xiangqing&#x27;,</span><br><span class="line">params:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p></blockquote></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​作用：让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line"><span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line"><span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-的replace属性"><a href="#8-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol><li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx,</span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx,</span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol><li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li><li>具体名字：<ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol></li></ol><h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li><li><p>全局守卫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line"><span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>)&#123; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>独享守卫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组件内守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol><li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li><li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li><li>hash模式：<ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li>history模式：<ol><li>地址干净，美观 。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泰隆银行面经</title>
      <link href="/2024/11/05/Written%20Examination/%E5%AE%81%E6%B3%A2%E9%93%B6%E8%A1%8C%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/11/05/Written%20Examination/%E5%AE%81%E6%B3%A2%E9%93%B6%E8%A1%8C%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="泰隆银行面经"><a href="#泰隆银行面经" class="headerlink" title="泰隆银行面经"></a>泰隆银行面经</h2><p>你专业是计算机相关的，很多同学会去互联⽹这样的企业去发展</p><p>对于⾏业这⼀块，你是怎么考虑的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">互联网高新意味着加班压榨牺牲健康</span><br><span class="line">国企稳定意味着薪资可能少一点</span><br><span class="line">我觉得行业这块，我都是能接受的</span><br><span class="line">前提是我明白选择不同的行业的时候</span><br><span class="line">不能只看到好的一面</span><br><span class="line">更要看到坏的一面你能不能接受</span><br><span class="line">对我来说，我能接受和适应高强度的工作</span><br><span class="line">毕竟在学校中也是这么过来的</span><br><span class="line">但是还是更愿意去做正常稳定的工作</span><br></pre></td></tr></table></figure><p>决定你选择什么样的⾏业的前三个影响因素是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一个就是说：城市，城市以为着机遇</span><br><span class="line"></span><br><span class="line">第一个就是说：工作的稳定性和环境</span><br><span class="line"></span><br><span class="line">最后一个就是说：职业发展的空间，个人兴趣和专长匹配，这些</span><br></pre></td></tr></table></figure><p>银行和互联网之间，选择银行的原因是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">职业发展空间：银行行业相对成熟，职业发展路径清晰，有更明确的晋升体系。</span><br><span class="line">可以通过积累经验和能力，逐步在业务或管理层面获得提升。</span><br><span class="line"></span><br><span class="line">个人兴趣与专长匹配度：银行的业务更接近金融与数据分析，能发挥对数据处理、逻辑分析等方面的专长，</span><br><span class="line">同时与银行的风控系统、数据分析等技术结合，应用到实际业务场景中，满足技术兴趣。</span><br><span class="line"></span><br><span class="line">工作稳定性：银行行业的稳定性相对较高，尤其是在经济波动时期。工作环境较为稳定，能够提供相对长期的职业安全感。</span><br><span class="line"></span><br><span class="line">工作环境和节奏：银行的工作环境相对稳定，有规范的工作流程和职业规范，</span><br><span class="line">对工作效率有较高要求，但整体节奏相比互联网行业较为适中。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 泰隆银行 </category>
          
          <category> 秋招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秋招 </tag>
            
            <tag> 泰隆银行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银行综合面经</title>
      <link href="/2024/11/05/Written%20Examination/%E6%B3%B0%E9%9A%86%E9%93%B6%E8%A1%8C%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/11/05/Written%20Examination/%E6%B3%B0%E9%9A%86%E9%93%B6%E8%A1%8C%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="银行综合面经"><a href="#银行综合面经" class="headerlink" title="银行综合面经"></a>银行综合面经</h2><p>你专业是计算机相关的，很多同学会去互联⽹这样的企业去发展</p><p>对于⾏业这⼀块，你是怎么考虑的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">互联网高新意味着加班压榨牺牲健康</span><br><span class="line">国企稳定意味着薪资可能少一点</span><br><span class="line">我觉得行业这块，我都是能接受的</span><br><span class="line">前提是我明白选择不同的行业的时候</span><br><span class="line">不能只看到好的一面</span><br><span class="line">更要看到坏的一面你能不能接受</span><br><span class="line">对我来说，我能接受和适应高强度的工作</span><br><span class="line">毕竟在学校中也是这么过来的</span><br><span class="line">但是还是更愿意去做正常稳定的工作</span><br></pre></td></tr></table></figure><p>决定你选择什么样的⾏业的前三个影响因素是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一个就是说：城市，城市以为着机遇</span><br><span class="line"></span><br><span class="line">第一个就是说：工作的稳定性和环境</span><br><span class="line"></span><br><span class="line">最后一个就是说：职业发展的空间，个人兴趣和专长匹配，这些</span><br></pre></td></tr></table></figure><p>银行和互联网之间，选择银行的原因是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">职业发展空间：银行行业相对成熟，职业发展路径清晰，有更明确的晋升体系。</span><br><span class="line">可以通过积累经验和能力，逐步在业务或管理层面获得提升。</span><br><span class="line"></span><br><span class="line">个人兴趣与专长匹配度：银行的业务更接近金融与数据分析，能发挥对数据处理、逻辑分析等方面的专长，</span><br><span class="line">同时与银行的风控系统、数据分析等技术结合，应用到实际业务场景中，满足技术兴趣。</span><br><span class="line"></span><br><span class="line">工作稳定性：银行行业的稳定性相对较高，尤其是在经济波动时期。工作环境较为稳定，能够提供相对长期的职业安全感。</span><br><span class="line"></span><br><span class="line">工作环境和节奏：银行的工作环境相对稳定，有规范的工作流程和职业规范，</span><br><span class="line">对工作效率有较高要求，但整体节奏相比互联网行业较为适中。</span><br></pre></td></tr></table></figure><p>为什么会选择来上海？选择来上海银行？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.城市的选择：上海作为中国经济最发展的城市，他的机遇或者说发展的机会是比较多的</span><br><span class="line">而且我目前在杭州距离上海也不较近，也去过很多次上海，我也有很多朋友在上海发展</span><br><span class="line">我也很喜欢这座城市</span><br><span class="line">2.为什么选择上海银行？我可以先说下为什么选择银行？</span><br><span class="line">1.我觉得行业这块，我都是能接受的</span><br><span class="line">前提是我明白选择不同的行业的时候</span><br><span class="line">不能只看到好的一面</span><br><span class="line">更要看到坏的一面你能不能接受</span><br><span class="line">对我来说，我能接受和适应高强度的工作</span><br><span class="line">毕竟在学校中也是这么过来的</span><br><span class="line">但是还是更愿意去做正常稳定的工作</span><br><span class="line">更愿意去平衡自己的生活和工作嘛</span><br><span class="line">所以我更愿意去选择银行</span><br></pre></td></tr></table></figure><p>我的职业规划</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">职业规划的话：</span><br><span class="line">短期：我更希望在技术的岗位上打好基础，熟悉业务，开发流程</span><br><span class="line">不断的学习进步，积累开发相关的经验</span><br><span class="line">成为团队或者项目的骨干成员</span><br><span class="line">长期：来看更希望成为一名更全面跟复合的人吧</span><br><span class="line"> 在积累了一定的开发经验后，我希望能够在项目中承担更多责任，</span><br><span class="line"> 往项目产品或者说是解决方案这边去发展</span><br><span class="line"> </span><br><span class="line">为什么：想干产品经理，或者解决方案？</span><br><span class="line">1.我在公司实习的时候嘛，其实开发也是按照产品经理或者解决方案经理的需求文档</span><br><span class="line">去完成开发的业务，</span><br><span class="line">但是开发人员通常聚焦于一个模块的实现</span><br><span class="line">通常也是别人说什么你就去做什么</span><br><span class="line">而我更希望能够从全局上看待产品或项目的需求</span><br><span class="line">2.从长远来看，很多人也是从技术转为产品</span><br><span class="line">并且得到了自己的新阶段的新发展</span><br><span class="line">既了解技术的实现，又懂业务的逻辑</span><br><span class="line">这种复合型的角色是我羡慕的</span><br><span class="line">虽然开始可能不具备</span><br><span class="line">        但是我还是希望能够向复合型道路去发展</span><br></pre></td></tr></table></figure><p>举一个生活中你工作生活平衡的例子？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.工作打卡，996</span><br><span class="line">2.爱好，骑行，摄影，出去周末骑行</span><br><span class="line">3.记录随笔，我自己搭建了网站去记录，</span><br><span class="line">记录工作，记录学习历程，记录生活</span><br><span class="line">这个也算是对我比较放松的事情吧</span><br></pre></td></tr></table></figure><p>选上海或者苏州</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我不是很了解这两个的区别？</span><br><span class="line">是根据业务去划分的么？薪资福利水平什么的都一样吗？</span><br><span class="line"></span><br><span class="line">如果可以选择，我可能会倾向于上海，因为上海作为金融科技的中心，</span><br><span class="line">有更多接触行业前沿技术和创新的机会</span><br><span class="line"></span><br><span class="line">其实，我对工作地点保持灵活性。如果团队或项目需要在苏州，</span><br><span class="line">也愿意接受这个选择。我相信在苏州同样可以很好地完成工作</span><br></pre></td></tr></table></figure><p>开发工作比较累怎么办？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.我理解比如说项目上线或者有新需求下，（或者在我不擅长的领域）</span><br><span class="line">可能会比较累</span><br><span class="line">在我实习中有遇到过这样的情况，就是说我遇到不熟悉模块的开发</span><br><span class="line">我会</span><br><span class="line">第一方面.就是制定工作计划。合理分配任务</span><br><span class="line">2.就是说，在自己不擅长或者需要重点客服的地方，花费额外的精力</span><br><span class="line">在实习过程中大家下班后我也还会呆一段时间</span><br><span class="line">3.我还会在工作之余进行适当的休息和锻炼，保持充沛的精力和良好的状态。</span><br><span class="line">通过这些方式，开发工作即使辛苦，我也能积极面对</span><br></pre></td></tr></table></figure><p>你对银行业务和金融科技的了解？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1，对银行基础业务的了解</span><br><span class="line">零售：个人存款，贷款，信用卡等</span><br><span class="line">公司：融资，资金管理等</span><br><span class="line">金融市场：外汇，证券，股票的交易等</span><br><span class="line">2.金融科技我了解就是，其实就是技术与银行的金融业务结合</span><br><span class="line">在于通过技术手段提升金融服务的效率、降低成本、提高用户体验</span><br><span class="line">3.</span><br></pre></td></tr></table></figure><p>反问：</p><p>1.我看我当时投递的是两个岗位，有两个志愿（开发，测试），我看了一下流程，是一起走的</p><p>这个是后面再去进一步的细分是吗？是自己选择的吗？</p><p>3。我了解到咱们的工作地有苏州和上海嘛，我不是很了解这两个的区别？</p><p>​是根据业务去划分的么？薪资福利水平什么的都一样吗？</p><p>2.想问下后续的流程是什么呢？</p>]]></content>
      
      
      <categories>
          
          <category> 银行综合 </category>
          
          <category> 秋招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秋招 </tag>
            
            <tag> 银行综合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宁波银行面经</title>
      <link href="/2024/10/16/Written%20Examination/%E5%AE%81%E6%B3%A2-%E9%93%B6%E8%A1%8C%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/10/16/Written%20Examination/%E5%AE%81%E6%B3%A2-%E9%93%B6%E8%A1%8C%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="宁波银行面经"><a href="#宁波银行面经" class="headerlink" title="宁波银行面经"></a>宁波银行面经</h2><p>Java创建对象的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new</span><br><span class="line">构造器</span><br><span class="line">反射</span><br><span class="line">克隆，clone</span><br><span class="line"></span><br><span class="line">new的底层：</span><br><span class="line">1.jvm的类加载机制，确保当前类已经被加载</span><br><span class="line">2.分配内存</span><br><span class="line">3.调用构造方法</span><br><span class="line">4.返回对象的引用</span><br></pre></td></tr></table></figure><p>servlet生命周期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">servlet是Javaweb开发的一种服务器组件，主要用于处理客户请求和生产动态响应</span><br><span class="line">创建、初始化、处理请求和销毁四个主要阶段</span><br><span class="line">加载和实例化：当客户端第一次发送请求到某个 Servlet 时，</span><br><span class="line">服务器会加载该 Servlet 类，并实例化一个 Servlet 对象</span><br><span class="line">调用 init() 方法：当 Servlet 对象被创建后，服务器会调用该对象的 init() 方法来初始化 Servlet</span><br><span class="line">调用 service() 方法：服务器会调用 Servlet 的 service() 方法来处理请求。</span><br><span class="line">service() 方法负责根据请求的类型（如 GET、POST）调用相应的处理方法。</span><br><span class="line">当服务器关闭或者 Servlet 被卸载时，服务器会调用 destroy() 方法</span><br></pre></td></tr></table></figure><p>HashMap和HashTable</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">都是存储键值对的集合类</span><br><span class="line">区别在于，hashmap是非线程安全的，hashTable是线程安全的</span><br><span class="line">这是由于hashTable里面内部的方法是同步的，加了锁</span><br><span class="line">但是hashTable是对整个map加锁</span><br><span class="line">导致其性能不够好</span><br><span class="line">现在都是用ConcurrentHashTable</span><br><span class="line">采用分段锁的机制，降低了锁的颗粒度</span><br><span class="line">提高性能</span><br></pre></td></tr></table></figure><p>序列化和反序列化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对象和字节流之间的相互转换机制</span><br><span class="line">序列化是指将 Java 对象的状态转换为字节流的过程，以便将对象的状态保存到文件中</span><br><span class="line">反序列化是指将字节流重新转换为对象的过程，通过反序列化可以从存储中读取对象</span><br><span class="line">Java 序列化：Serializable 是 Java 原生提供的序列化机制，但它的效率相对较低。</span><br><span class="line">JSON 序列化：常见的框架如 Jackson 或 Gson，将 Java 对象转换为 JSON 字符串，</span><br><span class="line">也可以视为一种序列化方式。</span><br></pre></td></tr></table></figure><p>接口和抽象类abstract</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">接口里面都是抽象方法，不能被实例化，表示能做什么，</span><br><span class="line">具体怎么做，要不同的类去实现这个接口，去重写</span><br><span class="line"></span><br><span class="line">抽象类是以包含抽象方法（没有实现的方法）和非抽象方法（有具体实现的方法）</span><br><span class="line">是类的模板设计，允许部分实现</span><br></pre></td></tr></table></figure><p>jdbc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DBC是 Java 提供的一套用于连接和操作数据库的 API（应用编程接口）。</span><br><span class="line">它为开发者提供了与不同类型的关系型数据库（如 MySQL、Oracle、PostgreSQL 等）</span><br><span class="line">进行交互的标准方法，能够执行 SQL 语句、检索数据和管理数据库事务。</span><br><span class="line">是开发 Java 数据库应用程序的基础工具。</span><br><span class="line"></span><br><span class="line">连接过程：</span><br><span class="line">1.加载MySQL驱动</span><br><span class="line">2.简历数据库连接</span><br><span class="line">3.创建sql语句</span><br><span class="line">4.执行sql操作</span><br><span class="line">5。关闭资源</span><br></pre></td></tr></table></figure><p>IO 流，BIO和NIO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BIO 是传统的 I/O 处理方式，称为 阻塞 I/O</span><br><span class="line">在 BIO 模型中，I/O 操作是阻塞的，意味着每一个请求都会占用一个独立的线程</span><br><span class="line">在处理大量并发连接时，BIO 通常需要为每个连接创建一个独立的线程</span><br><span class="line">NIO  非阻塞 I/O，提供了更高效的 I/O 操作，主要解决了 BIO 的高并发性能瓶颈问题</span><br><span class="line">NIO 通过通道（Channel）和缓冲区（Buffer）进行数据操作</span><br><span class="line">数据在 NIO 中被存放在缓冲区中，并通过通道（Channel）读写。</span><br><span class="line">Channel 类似于传统的流，但它是双向的，既可以读也可以写，而流只能是单向的。</span><br></pre></td></tr></table></figure><p>一个是Java父类和子类静态代码块，普通代码块，静态方法的执行顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">静态代码块，是在类加载的过程中执行的，只会被执行一次</span><br><span class="line">所以最先执行</span><br><span class="line">然后是实例代码块，每次创建对象时都会执行一次。</span><br><span class="line">且在构造方法执行前会先执行父类的实例代码块</span><br><span class="line">最后才是静态方法</span><br></pre></td></tr></table></figure><p>Bean的生命周期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Bean 是一个由 Spring IoC（控制反转）容器管理的对象。</span><br><span class="line">Bean 通常用于表示应用程序的核心组件，这些组件的创建、</span><br><span class="line">管理和生命周期都是由 Spring 框架来负责的。</span><br><span class="line"></span><br><span class="line">spring的bean的生命周期主要是创建bean的过程，一个bean的生命周期主要是4个步骤，</span><br><span class="line">实例化，属性注入，初始化，销毁</span><br><span class="line">Spring 提供了多种机制（如注解和接口）来管理 Bean 的生命周期，</span><br><span class="line">使得应用程序可以灵活地控制对象的创建和销毁过程。</span><br></pre></td></tr></table></figure><p>深拷贝，浅拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，深拷贝和浅拷贝是两种对象复制的方式</span><br><span class="line">浅拷贝是指创建一个新的对象，并将原始对象的字段值复制到新对象中。</span><br><span class="line">深拷贝是指创建一个新的对象，并递归地复制所有引用类型字段所引用的对象。</span><br><span class="line">这样，拷贝对象和原始对象之间不会共享任何对象的引用，修改拷贝对象的内容不会影响原始对象。</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20241016131809986.png" alt="image-20241016131809986"></p><p>常用数据结构，所占空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">  byte │   │</span><br><span class="line">       └───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line"> short │   │   │</span><br><span class="line">       └───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line">   int │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">  long │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line"> float │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">double │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line">  char │   │   │</span><br><span class="line">       └───┴───┘</span><br></pre></td></tr></table></figure><p>65535：65535 是 TCP 和 UDP 协议中可用的最大端口号</p><p>6379：Redis的默认端口号</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ddl:定义管理数据库的结构，创建表删除表这些</span><br><span class="line"></span><br><span class="line">dml:数据库操作语言，增删改查这些</span><br><span class="line"></span><br><span class="line">dcl:数据库控制，创建用户，给表的权限这些</span><br></pre></td></tr></table></figure><h2 id="搭建数据库"><a href="#搭建数据库" class="headerlink" title="搭建数据库"></a>搭建数据库</h2><p>Windows，docker</p><h2 id="线程的run和start"><a href="#线程的run和start" class="headerlink" title="线程的run和start"></a>线程的run和start</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start()：用于启动新线程并并发执行，真正实现多线程。</span><br><span class="line">run()：线程执行的逻辑，不会启动新线程，只是在当前线程中执行。</span><br></pre></td></tr></table></figure><p>HashMap的底层实现原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Java中的HashMap是一种基于哈希表的Map接口实现，</span><br><span class="line">它可以存储键值对，并且支持快速的插入、删除和查找操作。</span><br><span class="line">HashMap的底层实现原理是数组+链表/红黑树。</span><br><span class="line"></span><br><span class="line">具体来说，HashMap内部维护了一个Entry数组，每个Entry包含一个键值对。</span><br><span class="line">当插入一个键值对时，HashMap会根据键的哈希值计算出该键值对在数组中的位置，</span><br><span class="line">如果该位置已经有其他键值对了，则使用链表或红黑树来解决冲突。</span><br><span class="line">当查找一个键值对时，HashMap会根据键的哈希值计算出该键值对在数组中的位置，</span><br><span class="line">然后遍历链表或红黑树，找到对应的键值对。</span><br><span class="line"></span><br><span class="line">在Java 8中，HashMap的底层实现原理进行了优化，</span><br><span class="line">当链表长度超过一定阈值时，会将链表转换为红黑树，以提高查找效率。</span><br><span class="line">此外，HashMap还支持动态扩容和负载因子等特性，以提高存储和访问的效率。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HashSet是如何检查重复的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet底层还是HashMap，HashSet只考虑key的值，</span><br><span class="line">value都指向一个全局object常量</span><br><span class="line">比较过程：通过哈希法比较哈希值</span><br><span class="line">哈希值相等再调用equals比较方法</span><br></pre></td></tr></table></figure><p>equals和&#x3D;&#x3D;的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==比较的是地址</span><br><span class="line">equals如果不被重写，比较的是地址，底层调用==,</span><br><span class="line">如果被重写，就按照重写的逻辑比较</span><br></pre></td></tr></table></figure><p>Spring三件套框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Spring 三件套指的是 Spring 框架的三个核心模块，</span><br><span class="line">分别是 Spring Core、Spring AOP 和 Spring MVC。</span><br><span class="line"></span><br><span class="line">Spring Core：提供了 IoC（Inverse of Control）容器，</span><br><span class="line">用于对象之间的解耦，通过容器自动将对象之间的依赖注入。</span><br><span class="line">同时，Spring Core 还提供了对 AspectJ 的集成，</span><br><span class="line">以及对基于注解的 Spring Bean 的支持。</span><br><span class="line"></span><br><span class="line">Spring AOP：提供了基于 AOP（Aspect Oriented Programming）的编程方式，</span><br><span class="line">能够在不修改源代码的情况下，</span><br><span class="line">通过代理机制对对象进行增强，比如添加事务、日志、安全检查等功能。</span><br><span class="line"></span><br><span class="line">Spring MVC：是 Spring 框架的 Web 模块，</span><br><span class="line">提供了 MVC（Model-View-Controller）模式的支持，用于处理 Web 请求和响应。</span><br><span class="line">Spring MVC 通过 DispatcherServlet、HandlerMapping、Controller </span><br><span class="line">和 ViewResolver 等组件构成了完整的 MVC 模式的实现。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 宁波银行 </category>
          
          <category> 秋招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秋招 </tag>
            
            <tag> 宁波银行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易游戏测试面经</title>
      <link href="/2024/10/15/Written%20Examination/%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/10/15/Written%20Examination/%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="网易游戏测试面经"><a href="#网易游戏测试面经" class="headerlink" title="网易游戏测试面经"></a>网易游戏测试面经</h1><p>自我介绍，游戏测试的自我介绍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">面试官您好，我叫方圆，目前是杭州电子科技大学通信工程研三的学生</span><br><span class="line">在学校的学习期间呢，对通信和计算机的知识都有所了解</span><br><span class="line">然后呢我个人呢是比较熟悉Java语言，对web的开发有一定的实践</span><br><span class="line"></span><br><span class="line">读研呢参与了老师的一个横向课题，是数梦工厂消息中心项目的开发</span><br><span class="line">然后呢暑期实习是在华信咨询设计院参与的中国移动浙江公司的科研数字化管理平台项目</span><br><span class="line">其实在开发中呢，包括自己做的一些开源项目，对测试的工作也有所涉及</span><br><span class="line"></span><br><span class="line">今天面试的是游戏测试这样的一个岗位</span><br><span class="line">我本人呢也是一个游戏玩家</span><br><span class="line">然后我认为在开发领域的经验和作为一个游戏玩家</span><br><span class="line">能够快速适应游戏测试岗位的需求</span><br></pre></td></tr></table></figure><p>为什么学的开发，但是投游戏测试岗位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先呢，作为一名游戏玩家</span><br><span class="line">对游戏是很感兴趣的</span><br><span class="line">自己学的开发的技能算是工作的保证</span><br><span class="line">游戏是兴趣的所在，更希望能够在自己感兴趣的地方工作</span><br><span class="line">其次呢，自己在开发领域对测试有过一定的实践</span><br><span class="line">能够快速适应游戏测试岗位的需求</span><br></pre></td></tr></table></figure><p>你觉得你学的什么技能能够快速迁移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">后端开发与游戏测试虽然是不同的领域</span><br><span class="line">但是我在后端开发的学习能力，和测试</span><br><span class="line">能让我更快的适应游戏测试开发</span><br><span class="line">比如说，在开发中调试和排查问题的能力</span><br><span class="line">发现bug，可以定位反馈给直接负责人，省去中间的流程</span><br><span class="line">还有就是测试过程这些</span><br></pre></td></tr></table></figure><p>1.玩过什么游戏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我个人的话呢，除了fps游戏不完，因为会头晕</span><br><span class="line">然后其他各种类型的游戏其实都有所涉及</span><br><span class="line">像多人竞技的moba类：王者</span><br><span class="line">开放世界3A：艾尔登法环，黑悟空，只狼。原神等</span><br><span class="line">还有一些多人休闲单机：双人成行，植物大战僵尸等</span><br></pre></td></tr></table></figure><p>哪儿些游戏的优点吸引了你？比较细致的谈一谈这款游戏的特点？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我觉得能够吸引我的游戏有两类</span><br><span class="line">第一种是，精美的画面，丰富的剧情和世界观，丰富的战斗系统</span><br><span class="line">比较类似于3A游戏，黑悟空这些</span><br><span class="line"></span><br><span class="line">还有就是社交游戏</span><br><span class="line">我玩的比较多的，可能就是王者</span><br><span class="line">首先他就是带着强烈的社交属性</span><br><span class="line">高中的时候开始</span><br><span class="line">不论在哪儿个阶段，都能找到一起玩的搭子</span><br><span class="line"></span><br><span class="line">我觉得人才游戏的核心</span><br><span class="line">普通的3A可能玩玩就不会再碰了</span><br><span class="line">能够和别人一起玩的才能持久</span><br></pre></td></tr></table></figure><p>2.玩游戏中遇到的bug？怎么解决的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">其实我接触的游戏的bug是非常多的</span><br><span class="line">不知道您知不知道社区的一些游戏会有玩家速通anyway榜单</span><br><span class="line">快速打通一款游戏，就是利用bug</span><br><span class="line">有的时候开发是注意不到这种bug的，这就需要测试来做</span><br><span class="line"></span><br><span class="line">其实之前在玩黑悟空的时候，会有特别多的空气墙</span><br><span class="line">当我的角色碰到特定的地形，就卡在里面，动不了</span><br><span class="line">然后这可能就是碰撞检测算法出了问题吧</span><br><span class="line">在某些特定的地形没有处理好与墙壁的交互</span><br><span class="line">我左边有空气墙，右边还是有空气墙，</span><br><span class="line">导致觉得陷入了无解的状态</span><br><span class="line">这个可能是不同的两个开发人员开发的地形，并凑在一起的</span><br><span class="line">所以测试要重点测试这种场景下的bug</span><br><span class="line">后来自己传送解决的</span><br><span class="line"></span><br><span class="line">怎么解决的？</span><br><span class="line">因为我们作为游戏的玩家</span><br><span class="line">有时候的反馈是很无力的</span><br><span class="line">然后就发送到社区</span><br><span class="line">让之变的有影响力，才能有机会修复</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>软件测试和游戏测试的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">软件测试更注重功能，性能和安全的测试吧</span><br><span class="line">可能会用到jemeter，postman等这样的测试工具</span><br><span class="line">用于性能测试，自动化测试</span><br><span class="line">游戏测试不仅要保证功能，还要关注游戏的娱乐性、视觉效果、平衡性以及用户体验。</span><br><span class="line">他测试的地方就比较多</span><br><span class="line">游戏帧率，游戏在不同平台的兼容性，比如pc，手机,ps5等</span><br><span class="line">还有手柄，键鼠适配性等</span><br><span class="line">很多未知的bug</span><br><span class="line">跟多的依赖于手动测试和探索性测试</span><br></pre></td></tr></table></figure><p>游戏用户和测试用户，关注点的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">游戏用户点关注的是：游戏的可玩性，游戏难度，游戏的沉浸感</span><br><span class="line">以及角色之间的平衡性</span><br><span class="line">游戏测试关注的点在于：</span><br><span class="line">游戏功能的正常性，bug和异常</span><br><span class="line">性能稳定性，以及不同设备的兼容性</span><br><span class="line">但是我觉得，游戏测试也应该多在玩家的群体思考</span><br></pre></td></tr></table></figure><p>游戏角色太强，怎么判断？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先就是，数据分析嘛</span><br><span class="line">分析该角色的胜率，使用率等判断</span><br><span class="line">其次，看玩家的反馈，社区有没有太强的评价</span><br><span class="line">还有就是：自己做实战测试，去判断是不是强</span><br></pre></td></tr></table></figure><p>拿到测试任务，怎么去分配？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1，理解需求，了解测试范围、目标和优先级。</span><br><span class="line">2.评估测试范围：将整个系统或产品划分为多个功能模块，确定各模块的复杂性和优先级。</span><br><span class="line">3.任务分配：将测试任务细化为具体的子任务，如功能测试、性能测试、兼容性测试等。</span><br><span class="line">4，指定测试计划，编写测试计划，包含测试目标、测试方法、任务分配、时间安排等信息。</span><br><span class="line">5.监控进展</span><br><span class="line">6.评估调整，总结反馈</span><br></pre></td></tr></table></figure><p>那你最常玩的游戏举例，要测试哪儿方面？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">王者</span><br><span class="line">功能测试</span><br><span class="line">游戏基本功能：测试游戏的基本功能，如登录、注册、好友添加、组队、匹配、游戏开始等。</span><br><span class="line">角色和技能：验证各个英雄的技能是否按预期工作，包括技能效果、冷却时间、施法范围等。</span><br><span class="line">道具和装备：检查游戏中的道具、装备的功能，确保其描述与实际效果一致。</span><br><span class="line"> 游戏性测试</span><br><span class="line">平衡性测试：评估不同角色、技能和道具的强度，确保没有过强或过弱的角色影响游戏公平性。</span><br><span class="line">游戏进程：检查游戏中任务、目标的合理性，确保游戏的进展是平滑且富有挑战性的。</span><br><span class="line">性能测试</span><br><span class="line">帧率和流畅性：在不同设备上测试游戏的帧率，确保游戏运行流畅，特别是在高负载的情况下。</span><br><span class="line">响应时间：测量游戏操作的响应时间，确保玩家的输入能够即时反应。</span><br><span class="line">4. 兼容性测试</span><br><span class="line">设备兼容性：测试游戏在不同型号的手机、平板上运行的稳定性和性能，确保不同硬件环境下的兼容性。</span><br><span class="line">操作系统：验证游戏在不同操作系统（如Android、iOS）上的表现和兼容性。</span><br><span class="line">5. 网络测试</span><br><span class="line">延迟和稳定性：测试网络延迟，确保在不同网络环境下游戏的稳定性，尤其是在多人对战时。</span><br><span class="line">断线重连：验证在网络中断情况下，游戏的断线重连功能是否正常，是否能保持游戏进度。</span><br><span class="line">6. 安全性测试</span><br><span class="line">数据安全：检查用户数据的安全性，确保用户信息不被泄露。</span><br><span class="line">作弊检测：评估游戏中是否存在漏洞，防止作弊行为影响游戏公平性。</span><br></pre></td></tr></table></figure><p>游戏大厅聊天场景，如何测试？如何设计测试用例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.首先理解需求和测试的额类型</span><br><span class="line">聊天窗口的UI设计、消息显示区域和输入框。</span><br><span class="line">消息的发送、接收、显示规则。</span><br><span class="line">消息的长度限制、格式支持（如表情、图片、文字）。</span><br><span class="line">消息过滤（如敏感词过滤、广告检测）。</span><br><span class="line">多用户并发聊天支持。</span><br><span class="line">相关的用户权限（是否有禁言、举报功能）。</span><br><span class="line">2.确定测试类型</span><br><span class="line">功能测试：验证聊天功能的基本操作，如发送、接收消息等。</span><br><span class="line">性能测试：评估多用户同时聊天时的响应速度和系统负载。</span><br><span class="line">兼容性测试：测试不同设备、分辨率、网络状况下聊天功能的表现。</span><br><span class="line">安全性测试：检查聊天记录的隐私和防止恶意内容（如敏感词、攻击性语言、广告）传播。</span><br><span class="line">3.设计测试用例</span><br><span class="line">实际测试用例设计</span><br><span class="line">功能测试</span><br><span class="line">发送消息</span><br><span class="line"></span><br><span class="line">测试用户输入消息后点击发送按钮，消息能否成功发送并显示在聊天窗口中。</span><br><span class="line">测试按下回车键是否也能发送消息。</span><br><span class="line">接收消息</span><br><span class="line"></span><br><span class="line">验证当其他玩家发送消息时，本地客户端是否能够正确接收并显示。</span><br><span class="line">测试多名玩家同时发送消息时，消息能否按时间顺序显示。</span><br><span class="line">消息长度</span><br><span class="line"></span><br><span class="line">测试发送超长文本消息，验证是否有限制（如限制100字符），并确保有提示信息。</span><br><span class="line">发送极短消息（如1个字符），验证能否成功发送。</span><br><span class="line">消息格式</span><br><span class="line"></span><br><span class="line">测试发送消息中包含表情符号，验证能否正确显示。</span><br><span class="line">测试是否支持发送URL链接、图片（如聊天表情、游戏图片）。</span><br><span class="line">敏感词过滤</span><br><span class="line"></span><br><span class="line">发送包含敏感词的消息，验证是否有敏感词过滤功能，并正确屏蔽或替换为“*”号。</span><br></pre></td></tr></table></figure><p>一般设计测试用例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">确定测试输入和预期输出</span><br><span class="line">输入条件：根据需求确定每个用例的输入数据和前置条件，如用户输入、系统配置、环境设置等。</span><br><span class="line">预期输出：确定系统在给定输入条件下的正确输出，包括返回值、UI显示、数据库状态等。</span><br><span class="line">5. 编写测试用例模板</span><br><span class="line">测试用例一般使用模板编写，确保结构化和清晰。常见的测试用例模板包含以下几个关键字段：</span><br><span class="line"></span><br><span class="line">测试用例编号：每个测试用例的唯一标识。</span><br><span class="line">测试标题：简要描述测试的目的。</span><br><span class="line">前置条件：执行该测试所需的初始条件（如用户已登录、页面已加载等）。</span><br><span class="line">测试步骤：具体操作步骤，描述如何执行该用例。</span><br><span class="line">测试数据：提供测试需要的输入数据。</span><br><span class="line">预期结果：每个测试步骤的预期结果，确保测试人员能够判断测试是否通过。</span><br><span class="line">实际结果：测试执行后的实际表现。</span><br><span class="line">优先级：标识测试用例的重要性（如高、中、低）。</span><br><span class="line">测试环境：描述该测试用例执行的环境（如浏览器类型、操作系统等）。</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20241016101236396.png" alt="image-20241016101236396"></p><p>场景题</p><p>5.场景题。<br> 5.1 n+1个用户登录只收到了n个id，哪里出问题了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.出现了并发问题，导致其中一个的请求并为处理</span><br><span class="line">2.生成了，在传输的过程中，由于网络问题，请求丢失</span><br><span class="line">3.</span><br></pre></td></tr></table></figure><p> 5.2 n+1的id里有两个id重复了，怎么查出来（应该是问算法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">去重嘛，使用哈希表去重</span><br><span class="line">或者将问题抽象为链表找环</span><br><span class="line">用快慢指针，快指针走两步，慢指针走一步，</span><br><span class="line">然后重新定义一个指针指向起点，两个指针每次走一步，</span><br><span class="line">最终相遇的位置即为重复的 ID。</span><br></pre></td></tr></table></figure><p> 3.1 100个玩家，随机分布在一个圆形竞技场里。玩家坐标、圆心坐标、圆的半径已知，问如何生成一条线，将玩家对半分开（场地一分为二，两边各50）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">啊？测试问算法？</span><br><span class="line">我觉得可以将，玩家的坐标之类的通过一定的算法，抽象为一个数</span><br><span class="line">然后对100个数进行排序</span><br><span class="line">排序后取中间的，就是</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网易 </category>
          
          <category> 秋招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易 </tag>
            
            <tag> 秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荣耀面经</title>
      <link href="/2024/10/13/Written%20Examination/%E8%8D%A3%E8%80%80%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/10/13/Written%20Examination/%E8%8D%A3%E8%80%80%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="荣耀面经"><a href="#荣耀面经" class="headerlink" title="荣耀面经"></a>荣耀面经</h1><h2 id="笔试回顾"><a href="#笔试回顾" class="headerlink" title="笔试回顾"></a>笔试回顾</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">好像过了两道题吧</span><br><span class="line">前两道做出来了，第三题不怎么会，用测试用例过了15%</span><br><span class="line">第一题：</span><br><span class="line">好像是计算幂的累加和</span><br><span class="line">第二题是计算复数的绝对值</span><br><span class="line">用绝对值公式，根号下a²+b²</span><br><span class="line">需要注意的是，用Math.rand进行四舍五入</span><br></pre></td></tr></table></figure><h2 id="1-Redis常用的数据结构"><a href="#1-Redis常用的数据结构" class="headerlink" title="1.Redis常用的数据结构"></a>1.Redis常用的数据结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符串String，最常见的，可以存储任何数据，字符串整形符点都行</span><br><span class="line">链表list：链表结构</span><br><span class="line">集合set，</span><br><span class="line">有序集合zset</span><br><span class="line">哈希hash key-value的形式</span><br><span class="line">位图bigmap</span><br><span class="line">地理位置GEO</span><br><span class="line">HyperLogLog：去重统计登</span><br></pre></td></tr></table></figure><h2 id="2-zset的底层数据结构"><a href="#2-zset的底层数据结构" class="headerlink" title="2.zset的底层数据结构"></a>2.zset的底层数据结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Redis中set的底层数据结构就是hash表来实现的，这个和Java中的set一样</span><br><span class="line">就是将map中的key，添加作为到set中的元素，然后value是一个固定值</span><br><span class="line"></span><br><span class="line">有序集合zet:哈希表+跳表</span><br><span class="line">哈希表跟set一样，</span><br><span class="line">跳表用于维护元素的顺序，存放的时候按照顺序排序</span><br><span class="line"></span><br><span class="line">Java中的有序集合就是TreeSet</span><br><span class="line">底层是用红黑树的形式存放的</span><br></pre></td></tr></table></figure><h2 id="3-Redis的分布式锁和看门狗机制"><a href="#3-Redis的分布式锁和看门狗机制" class="headerlink" title="3.Redis的分布式锁和看门狗机制"></a>3.Redis的分布式锁和看门狗机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Redis的分布式锁，就是使用通过setNX 互斥和setEX设置过期时间</span><br><span class="line">但是基本上不用，因为还有很多缺陷</span><br><span class="line">不可重入、不可重试、超时释放、主从一致性等</span><br><span class="line">用的话就用依赖redission的锁，可以避免上述问题</span><br><span class="line"></span><br><span class="line">看门狗机制是Redis锁的一种机制</span><br><span class="line">防止持有锁的时候，由于业务逻辑出问题而导致没有释放锁的问题</span><br><span class="line">流程就是：</span><br><span class="line">1.获取到锁，对锁设置一个延迟任务</span><br><span class="line">2.这个任务每隔1/3锁的过期调用，如果线程没有执行完，重置锁的过期时间为1</span><br><span class="line">3.当程序出现异常，就会在锁过期后，自动锁释放锁</span><br><span class="line">简单来说就是：程序没执行完，锁不释放一直延时，程序异常，锁过期释放</span><br></pre></td></tr></table></figure><h2 id="4-ThreadLocal的作用和原理"><a href="#4-ThreadLocal的作用和原理" class="headerlink" title="4.ThreadLocal的作用和原理"></a>4.ThreadLocal的作用和原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread Local本地线程嘛，就是线程可以独立的获取自己的变量副本</span><br><span class="line">而不是共享变量，从而避免多线程的资源共享问题</span><br><span class="line">一般就是在拦截器intercepter中去拦截，然后将当前用户的信息放进去</span><br><span class="line">这样在其他地方就可以拿到用户信息</span><br><span class="line">最后remove清理变量</span><br><span class="line"></span><br><span class="line">原理：每隔线程都会维护一个ThreadLocalMap</span><br><span class="line">用于存储ThreadLocal以及其数据</span><br><span class="line">调用 threadLocal.set(value) 时，</span><br><span class="line">当前线程的 ThreadLocalMap 会将 ThreadLocal 对象作为键，value 作为值存储起来。</span><br><span class="line">获取值：调用 threadLocal.get() 时，</span><br><span class="line">当前线程的 ThreadLocalMap 会通过 ThreadLocal 对象查找并返回对应的值。</span><br></pre></td></tr></table></figure><h2 id="5-Redis的持久化机制"><a href="#5-Redis的持久化机制" class="headerlink" title="5.Redis的持久化机制"></a>5.Redis的持久化机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">快照文件和追加文件</span><br><span class="line">快照：就是把Redis中的数据保存到磁盘上面，方便宕机的时候做数据恢复</span><br><span class="line">追加：通过日志的方式，Redis每次执行写操作的时候，记录下来存储到文件中去</span><br></pre></td></tr></table></figure><h2 id="6-MySQL的索引结构"><a href="#6-MySQL的索引结构" class="headerlink" title="6.MySQL的索引结构"></a>6.MySQL的索引结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MySQL底层是通过B+树的方式实现索引的</span><br><span class="line">创建索引的时候，会将当前字段插入b+树</span><br><span class="line">b+树是多路平衡树</span><br><span class="line">他的非叶子节点只做索引，不含数据</span><br><span class="line">叶子节点包含全部的建，并且收尾互相连接，方便查找</span><br><span class="line"></span><br><span class="line">这种结构为什么快？</span><br><span class="line">1、每个节点有多个子指针，树的高度低，比较的次数就少</span><br><span class="line">2、叶子节点通过链表去连接的，方便查找</span><br></pre></td></tr></table></figure><h2 id="7-线程池工作流程"><a href="#7-线程池工作流程" class="headerlink" title="7.线程池工作流程"></a>7.线程池工作流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Java中有自带的线程池，在某些高并发的场景下，需要自定义线程池</span><br><span class="line"></span><br><span class="line">线程池：管理线程的池子，可以容纳多个线程，省去了频繁创建线程的操作</span><br><span class="line">Java中有几种常见的线程池，都是去实现了ThreadPoolExecutor这个类</span><br><span class="line">用这个类的构造器，去设置参数，核心线程，最大线程，超时时长，任务队列等</span><br><span class="line">可以直接用，然后重写run方法实现的</span><br><span class="line"></span><br><span class="line">设计一个线程池嘛</span><br><span class="line">1.创建N个线程</span><br><span class="line">2.把任务提交给线程运行</span><br><span class="line">3.执行的时候，入队</span><br><span class="line">4，执行完毕，出队</span><br><span class="line"></span><br><span class="line">使用场景：异步处理的时候要用到线程池开启线程，并发处理的时候也需要</span><br></pre></td></tr></table></figure><h2 id="8-进程与线程的区别"><a href="#8-进程与线程的区别" class="headerlink" title="8.进程与线程的区别"></a>8.进程与线程的区别</h2><p>进程间通信方式，说一种熟悉的进程间通信方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进程就是计算机的运行实例，一个进程中会有多个线程</span><br><span class="line">进程间相互独立，线程间共享进程的资源等</span><br><span class="line"></span><br><span class="line">进程中的通信方式：共享内存，允许多个进程访问同一块内存区域</span><br><span class="line">线程中的通信方式：共享变量，成员变量</span><br><span class="line">使用wait方法进入等待状态，等其他线程notify通知</span><br><span class="line">或者使用消息队列去传递消息</span><br></pre></td></tr></table></figure><h2 id="9-设计模式"><a href="#9-设计模式" class="headerlink" title="9.设计模式"></a>9.设计模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">设计模式就是通用的一种代码规范和解决方式</span><br><span class="line">可以提高代码的可维护和复用性等</span><br><span class="line">单例模式：spring中的bean是单例的，通过IOC容器对Bean管理，保证整个应用只有一个Bean实例</span><br><span class="line">工厂模式：springIOC负责容器的创建和管理实例，可以将IOC看做是一个工厂</span><br><span class="line">我们不需要知道对象是如何创建的</span><br><span class="line">只需要用注解直接注入对象就行</span><br><span class="line"></span><br><span class="line">代理模式：spring的AOP面相切面编程就用到了代理模式</span><br><span class="line">实现proxy类的方法，生成代理对象，在其他地方通过代理对象去调用方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10-排序算法"><a href="#10-排序算法" class="headerlink" title="10.排序算法"></a>10.排序算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">冒泡，选择，插入，堆排序等</span><br><span class="line">比较熟悉的冒泡</span><br><span class="line">每次交换相邻的元素，复杂度是n2</span><br><span class="line">快速排序的思想是，选一个基准元素，将数组分为两个子数组</span><br><span class="line">小于基准的，大于基准的</span><br><span class="line">然后递归的对两个子数组排序</span><br><span class="line">直到有序</span><br></pre></td></tr></table></figure><h2 id="11-设计一个高并发系统"><a href="#11-设计一个高并发系统" class="headerlink" title="11.设计一个高并发系统"></a>11.设计一个高并发系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.首先要从需求层面明确我的并发量，再决定去采用什么样的解决方案</span><br><span class="line">2.系统架构方面，可以将系统功能拆分为多个微服务，每个服务独立开发部署</span><br><span class="line">3，用负载均衡将请求分发到多个服务器中，防止一个过载</span><br><span class="line">4.高并发肯定要用到缓存了，先讲数据放入缓存中预热，减轻数据库压力</span><br><span class="line">5.数据库的话，就是分库分表，写的操作集中在主库，读的操作在分库，减轻数据库压力</span><br><span class="line">6.消息队列，对耗时的业务通过消息队列放入后台异步处理等</span><br><span class="line">7.设置熔断限流去控制流量等</span><br></pre></td></tr></table></figure><h2 id="12-KMP算法"><a href="#12-KMP算法" class="headerlink" title="12.KMP算法"></a>12.KMP算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我知道是一种字符串匹配的高效算法</span><br><span class="line">构建一个前缀表，去确定匹配的位置</span><br><span class="line">然后匹配过程中，通过前缀表快速匹配到下一个位置，而不是从头开始</span><br><span class="line">主要是利用部分的匹配信息，避免在匹配失败的时候，重新开始</span><br></pre></td></tr></table></figure><h2 id="13-tcp长链接短链接"><a href="#13-tcp长链接短链接" class="headerlink" title="13.tcp长链接短链接"></a>13.tcp长链接短链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">长连接在客户端和服务器之间建立一次连接后</span><br><span class="line">，保持连接的持续存在，除非主动断开或超时。</span><br><span class="line">TCP短连接：</span><br><span class="line">每次通信完成后立即关闭连接，下次通信时重新建立新的连接。</span><br><span class="line"></span><br><span class="line">长链接通道判断：</span><br><span class="line">我记得有一个心跳机制</span><br><span class="line">固定某一段时间去检查连接的状态</span><br><span class="line">从而判断是否连接</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="14-面向对象设计的6大原则"><a href="#14-面向对象设计的6大原则" class="headerlink" title="14.面向对象设计的6大原则"></a>14.面向对象设计的6大原则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我只记得其中几个，单一职责，开放闭合</span><br><span class="line">原因：高内聚，低耦合，易于扩展，提高可维护性等</span><br></pre></td></tr></table></figure><h2 id="15-OOM怎么去定位解决"><a href="#15-OOM怎么去定位解决" class="headerlink" title="15.OOM怎么去定位解决?"></a>15.OOM怎么去定位解决?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内存溢出嘛，首先看控制台去判断溢出的类型，</span><br><span class="line">是堆空间不足，还是老年代溢出，还是其他</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以去设置jvm的参数去监控内存</span><br><span class="line">去监控内存对象的，分析内存的使用情况</span><br><span class="line">然后可以分配一个大内存去解决</span><br><span class="line">或者优化数据结构</span><br></pre></td></tr></table></figure><h2 id="16-Class的底层，反射的原理"><a href="#16-Class的底层，反射的原理" class="headerlink" title="16.Class的底层，反射的原理"></a>16.Class的底层，反射的原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">编译的过程中，会将Java的源代码编译成字节码文件就是.class文件</span><br><span class="line">然后jvm通过类加载器，读取.class文件，生成Class文件</span><br><span class="line">这个大Class中就包含类的所有信息，如类名、构造方法、字段和方法等。</span><br><span class="line"></span><br><span class="line">反射允许程序在运行的时候，动态的获取类的所有信息，执行方法</span><br><span class="line">原理就是获取大Class对象，然后通过reflect包下的方法</span><br><span class="line">去动态的调用这些方法来实现功能</span><br></pre></td></tr></table></figure><h2 id="17-类的加载机制"><a href="#17-类的加载机制" class="headerlink" title="17.类的加载机制"></a>17.类的加载机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JVM 的类加载机制是动态的，能够在运行时根据需要加载类，而不是一开始就加载所有类</span><br><span class="line">加载：通过类的全限定名，查找此类的字节码文件，利用字节码文件创建Class对象</span><br><span class="line"></span><br><span class="line">加载机制：双亲委派机制</span><br><span class="line">当一个类加载器收到加载的请求的时候，会将这个请求给父类加载器去处理</span><br><span class="line">如果父类无法加载，才由当前类加载</span><br><span class="line">好处是：避免重复加载</span><br></pre></td></tr></table></figure><h2 id="18-多态的理解"><a href="#18-多态的理解" class="headerlink" title="18.多态的理解"></a>18.多态的理解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编译时多态：通过方法重载实现，发生在编译阶段，</span><br><span class="line">依据方法参数的类型和数量选择合适的方法。</span><br><span class="line">父类的引用指向子类的对象</span><br><span class="line">运行时多态：通过方法重写实现，发生在运行阶段，</span><br><span class="line">依据对象的实际类型来决定调用哪个方法。</span><br></pre></td></tr></table></figure><h2 id="19-树的深度优先和广度优先遍历"><a href="#19-树的深度优先和广度优先遍历" class="headerlink" title="19.树的深度优先和广度优先遍历"></a>19.树的深度优先和广度优先遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">深度优先就是，访问到叶子节点，再回溯上一节点遍历</span><br><span class="line">前序：中左右</span><br><span class="line">中序：左中右</span><br><span class="line">后续：左右中</span><br><span class="line">广度优先就是：层序遍历，一层一层的往下遍历</span><br><span class="line"></span><br><span class="line">红黑树：红黑树是一种自平衡的二叉搜索树，每个节点存储一个额外的颜色位</span><br><span class="line">适合频繁插入和删除的操作场景</span><br><span class="line">hashmap：数组+链表+红黑树</span><br><span class="line">treemap，TreeSet:红黑树</span><br></pre></td></tr></table></figure><h2 id="20-网络模型和常见的位置"><a href="#20-网络模型和常见的位置" class="headerlink" title="20.网络模型和常见的位置"></a>20.网络模型和常见的位置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见的网络模型主要是分为osi七层模型，和tcpip四层模型</span><br><span class="line">osi七层就是：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层</span><br><span class="line">tcpip技术：应用层，传输层，网络层，网路接口层</span><br><span class="line">其实都是对应的关系</span><br><span class="line">http、https:网页传输协议，在应用层</span><br><span class="line">tcp：通过三次握手建立连接，在传输层，可靠连接</span><br><span class="line">udp:不可靠连接，快速连接，传输层</span><br><span class="line">IP：网络层</span><br></pre></td></tr></table></figure><h2 id="21-synchronized修饰静态方法和实例方法有什么不一样"><a href="#21-synchronized修饰静态方法和实例方法有什么不一样" class="headerlink" title="21.synchronized修饰静态方法和实例方法有什么不一样"></a>21.synchronized修饰静态方法和实例方法有什么不一样</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程同步：当多个线程同时访问共享资源（例如变量、对象）时，</span><br><span class="line">使用 synchronized来防止线程之间的竞争，确保同一时间只有一个线程能访问该资源。</span><br><span class="line"></span><br><span class="line">修饰实例方法的话，针对的是实例，多个线程可以访问不同对象的</span><br><span class="line">修饰静态方法的话：静态方法是全局的，所以只有一个线程能访问</span><br></pre></td></tr></table></figure><h2 id="22-对java原子性操作的理解"><a href="#22-对java原子性操作的理解" class="headerlink" title="22.对java原子性操作的理解"></a>22.对java原子性操作的理解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原子性：要么全部成功，要么全部失败</span><br><span class="line">执行的过程中不能被其他线程干扰</span><br><span class="line">我们可以使用加锁synchronized修饰去得到原子性</span><br><span class="line">也可以使用Java中内带的一些原子类</span><br><span class="line">AutomicInteger等</span><br></pre></td></tr></table></figure><h2 id="面试回答不太好的"><a href="#面试回答不太好的" class="headerlink" title="面试回答不太好的"></a>面试回答不太好的</h2><p>1.注解底层实现，编译型注解，运行时注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">注解是一个代码说明</span><br><span class="line">就是在源代码中提供了一种添加补充机制</span><br><span class="line">注解可以在编译时，运行时使用</span><br><span class="line"></span><br><span class="line">注解的底层原理是通过Java中的反射实现的</span><br><span class="line">反射机制允许程序在运行的时候，动态的获取类的信息，操作类的字段</span><br><span class="line">当使用注解的时候，编译器将会将注解的信息保存到编译后的字节码文件中</span><br><span class="line">这样程序运行后，通过反射就会读取到这些注解，并根据注解的信息去处理</span><br><span class="line"></span><br><span class="line">注解的格式：</span><br><span class="line">public @interface 名称&#123;</span><br><span class="line">public 属性类型 属性名称（） default 默认值；</span><br><span class="line">&#125;</span><br><span class="line">编译型注解：在编译的时候去给编译器提供信息</span><br><span class="line">@override @Deprecated</span><br><span class="line">底层实现：编译时注解通常通过 Java 编译器（如 javac）进行处理。</span><br><span class="line">编译器在编译阶段识别这些注解，进行静态分析，并根据注解提供的元数据产生相应的编译错误或警告。</span><br><span class="line">处理方式：编译时注解一般不会被包含在字节码中，除非被显式定义为 @Retention(RetentionPolicy.SOURCE)。</span><br><span class="line"></span><br><span class="line">运行时注解：通过反射去获取</span><br><span class="line"></span><br><span class="line">元注解：@Retention：指定注解的生命周期</span><br><span class="line">@Target：指定注解的目标元素</span><br></pre></td></tr></table></figure><p>自定义注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">就是通过@interface关键字去自定义注解</span><br><span class="line">然后通过元注解去标记，当前注解的作用域</span><br><span class="line">@Target(ElementType.METHOD)//当前注解作用在方法上</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)//表示是运行时注解</span><br><span class="line"></span><br><span class="line">我在项目中有用到过自定义注解去做删除的一个日志记录</span><br><span class="line">先自定义注解后，用于标记需要记录日志的方法</span><br><span class="line">创建切面类，@Aspect，</span><br><span class="line">在切面类中通过前置通知@before，后置通知after，环绕通知around</span><br><span class="line">去将我的去将我的自定义注解引用进来</span><br><span class="line">在方法中实现插入删除日志的业务逻辑就行</span><br></pre></td></tr></table></figure><p>2.Redis，删除，延迟双删</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">延迟双删是一种常见的缓存失效策略</span><br><span class="line">1.从数据库中删除数据后，立即从缓存中删除</span><br><span class="line">2.延迟一段时间（确保系统的异步操作能完成）</span><br><span class="line">3.再次从缓存中删除对应的数据</span><br><span class="line">为什么要缓存的两次删除？</span><br><span class="line">1.在分布式系统中，数据库和缓存的操作是异步的</span><br><span class="line">但我们从数据库中删除数据的时候，可能缓存数据不会立即更新</span><br><span class="line">所以通过引入延迟，来给系统一些时间处理异步请求</span><br><span class="line">然后再删除确保数据真正删除了</span><br></pre></td></tr></table></figure><p>3.差不多这些</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 荣耀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秋招 </tag>
            
            <tag> 荣耀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快手，得物测试开发面经</title>
      <link href="/2024/10/08/Written%20Examination/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/10/08/Written%20Examination/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="测试开发面经（牛客）"><a href="#测试开发面经（牛客）" class="headerlink" title="测试开发面经（牛客）"></a>测试开发面经（牛客）</h1><p>1.你了解快手测试开发的岗位职责吗？那你大概说下快手的测试开发岗位主要工作内容有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.产品的测试嘛。设计测试用例和计划，保证产品的可靠性</span><br><span class="line">可能开发在写代码中没有考虑到的一些问题</span><br><span class="line">需要测试来测试出来</span><br><span class="line">2.通过测试用例反馈给产品和团队，提出改进意见，推送问题解决</span><br></pre></td></tr></table></figure><p>为什么想转到测试开发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一：从我的职业规划来说</span><br><span class="line">开发和测试开发都是我可以接受的职位</span><br><span class="line">然后</span><br><span class="line">我有过一些开发的经历，</span><br><span class="line">在功能测试和性能测试方面有过一定的了解</span><br><span class="line">了解开发的知识，可以定位bug和修改bug</span><br><span class="line">我觉得能够胜任测试开发这份工作</span><br><span class="line">接触过一些不同类型的Bug</span><br></pre></td></tr></table></figure><h2 id="测试的一般流程"><a href="#测试的一般流程" class="headerlink" title="测试的一般流程"></a>测试的一般流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我觉得和开发的流程差不多吧</span><br><span class="line">1.在评审的时候做需求分析，去了解文档和功能的细节，明确业务需求和目标嘛</span><br><span class="line">2.针对目标去做测试计划：测试的范围，目标啊，搭建测试环境啊这些</span><br><span class="line">和测试样例的设定</span><br><span class="line">比如说：功能性测试啊。性能测试啊。安全测试啊这些</span><br><span class="line">3.执行测试，发现缺陷就记录反馈给开发人员，并且进行复测</span><br><span class="line">4.在测试执行完毕后，我们会撰写测试报告，</span><br><span class="line">包括测试覆盖率、执行结果、缺陷情况、系统的稳定性和质量等。</span><br><span class="line">5.测试结束后的交付</span><br></pre></td></tr></table></figure><h2 id="测试方法和使用场景"><a href="#测试方法和使用场景" class="headerlink" title="测试方法和使用场景"></a>测试方法和使用场景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 功能测试：概述：验证软件的每个功能是否按预期工作。</span><br><span class="line">场景：在产品开发的各个阶段，对所有功能模块进行测试，如登录、注册等基本功能。</span><br><span class="line">12. 异常测试：概述：模拟意外情况或错误输入，检查系统的异常处理机制。</span><br><span class="line">场景：对于输入字段、文件上传等，验证异常数据是否能安全处理。</span><br><span class="line">2. 性能测试：概述：检查系统的性能表现，包括响应时间、吞吐量等。</span><br><span class="line">场景：对需高并发处理的系统进行测试，如银行、交易所、社交平台等，以确保系统在高负载下的性能和稳定性。</span><br><span class="line">7. 兼容性测试：概述：测试软件在不同硬件、操作系统、浏览器等环境中的表现。</span><br><span class="line">场景：跨平台应用或网站上线前，验证是否兼容主流浏览器和设备。</span><br><span class="line">4. 压力测试：概述：超出系统设计的负荷进行测试，观察系统崩溃点。</span><br><span class="line">场景：银行系统、医疗系统等关键应用，确保在超出预期负载下系统能稳定降级而不崩溃。</span><br><span class="line">8. 安全性测试：概述：验证系统的安全性，防止数据泄露、未授权访问等。</span><br><span class="line">场景：电商、金融等涉及敏感信息的系统，需防范SQL注入、XSS等常见攻击。</span><br><span class="line"></span><br><span class="line">1.功能，边界，安全，性能，异常，兼容性</span><br></pre></td></tr></table></figure><h2 id="测试用例包含的内容"><a href="#测试用例包含的内容" class="headerlink" title="测试用例包含的内容"></a>测试用例包含的内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.测试的标识编号</span><br><span class="line">2.测试用例的描述</span><br><span class="line">3.测试数据</span><br><span class="line">4.测试步骤</span><br><span class="line">5.预期结果</span><br><span class="line">6.实际结果</span><br></pre></td></tr></table></figure><h2 id="2-讲下你实习的测试工作有哪些？"><a href="#2-讲下你实习的测试工作有哪些？" class="headerlink" title="2.讲下你实习的测试工作有哪些？"></a>2.讲下你实习的测试工作有哪些？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">作为开发，在开发的时候，会测一下自己写的功能是不是实现了</span><br><span class="line">然后在提交代码的时候，针对我们的需求文档要求做一下测试</span><br><span class="line">比如</span><br><span class="line">1．对于编辑类需求，如无特殊说明，每次交互响应时间要求&lt;2秒。</span><br><span class="line">2．对于日常检索类需求，如无特殊说明，检索响应时间要求&lt;5秒。</span><br><span class="line">3．对于统计分析类需求，如无特殊说明，统计表与图形成的响应时间要求&lt;10秒。</span><br><span class="line">4．对于每项业务功能需求，如无特殊说明，均要求能够并发400用户，并要求目标系统能够承受所有功能并发400用户的压力。</span><br><span class="line"></span><br><span class="line">他系统其实要求的并发量有400</span><br><span class="line">使用jMteter去测一下，对我后端接口进行访问模拟并发小于2s即可</span><br></pre></td></tr></table></figure><p>3.以一个你觉得印象比较深刻的需求来讲一下从需求评审到整个上线的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我们做的统计分析模块，产品经理会做一个需求文档</span><br><span class="line">包括所需要展示的统计数据，图标类型，数据权限等</span><br><span class="line">然后评审，团队开发给出修改意见，去讨论能不能做</span><br><span class="line">然后照着修改过后的文档做</span><br><span class="line">完成之后交给产品经理测试功能等</span><br><span class="line">上线我不知道了</span><br></pre></td></tr></table></figure><h2 id="4-测试过程中印象比较深刻的bug？"><a href="#4-测试过程中印象比较深刻的bug？" class="headerlink" title="4.测试过程中印象比较深刻的bug？"></a>4.测试过程中印象比较深刻的bug？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">其实我自己在实习的过程中遇到的小问题比较多</span><br><span class="line">可能刚开始对项目不是很熟悉</span><br><span class="line">印象比较深刻的反倒是我的组长和所长检查代码检查出来的</span><br><span class="line">1.第一个就是流程审批这个模块</span><br><span class="line">我做完这个模块后，开始测试了功能没有问题</span><br><span class="line">就去提交到了测试环境</span><br><span class="line">然后组长测试的额时候</span><br><span class="line">发现卡在流程节点无法推进</span><br><span class="line"></span><br><span class="line">检查发现</span><br><span class="line">我们在自定义审批人策略的时候</span><br><span class="line">是从当前人所在的部门去获取项目经理</span><br><span class="line">然后组长是超级管理员身份登录，这个super没有部门</span><br><span class="line">我第一反应是去数据库给这个super加一个部门</span><br><span class="line">然后组长说：但其实这个解决不太好</span><br><span class="line">因为可能还会有其他没有部门的角色</span><br><span class="line">让我使用回退机制</span><br><span class="line">如果当前用户没有部门信息</span><br><span class="line">可以回退到一个预定义的备选策略</span><br><span class="line">比如：超级管理员</span><br><span class="line"></span><br><span class="line">这个也是一点收获吧</span><br><span class="line">有时候自己解决问题的过程确实太粗暴简单了</span><br><span class="line">没有考虑到自己解决了问题还会带来其他的问题</span><br><span class="line">这个也是我需要学习进步的地方</span><br><span class="line"></span><br><span class="line">还有就是：做智能评估点开发功能</span><br><span class="line">被所长发现性能不好</span><br><span class="line"></span><br><span class="line">做Excel导入导出</span><br><span class="line">被组长发现性能不好</span><br></pre></td></tr></table></figure><p>实习项目中做的测试</p><h2 id="Excel导入导出校验的测试"><a href="#Excel导入导出校验的测试" class="headerlink" title="Excel导入导出校验的测试"></a>Excel导入导出校验的测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1.对Excel导入导出校验，那边做的测试</span><br><span class="line">主要还是以功能测试为主，这边的话，测试内容比较多，</span><br><span class="line">然后也测出一些bug去解决</span><br><span class="line">比如说，我做导入导出检验功能后首先会进行</span><br><span class="line">1.功能测试：我会给一些正确的数据，验证系统能否正确的导入数据</span><br><span class="line">2.校验测试：因为我在开发代码逻辑是有做校验的</span><br><span class="line">比如说：导入的项目人员在人员表中存不存在啊</span><br><span class="line">手机号格式是否满足正则匹配啊</span><br><span class="line">重复项目不能重复导入啊这些</span><br><span class="line">这里报错的话我会用try-catch捕获异常返回前端错误的类型</span><br><span class="line">3.边界测试：</span><br><span class="line">导入空文件，</span><br><span class="line">3.性能测试：开始的话，因为项目这块只有几千条数据，</span><br><span class="line">响应还是比较快的</span><br><span class="line">但是我在做人员导出那块，就会出现响应比较慢</span><br><span class="line">然后我分析就是，如果涉及到大数据量的导出的话</span><br><span class="line">有可能会造成内存溢出，或者无响应的情况</span><br><span class="line">数据量太大会导致</span><br><span class="line">这个我后续也是做了一些优化</span><br><span class="line"></span><br><span class="line">针对上述问题，其实也看到过有现成的一些解决方案</span><br><span class="line">放弃使用Apache的api,使用阿里的easyExcel这种</span><br><span class="line">但是其实我作为实习生并没有这种权限去新加依赖</span><br><span class="line">后面就是用的分批分页的方法</span><br><span class="line">比如说一次只查询5000条数据，5000条批量写入到excel以后，</span><br><span class="line">清空当前List，释放内存</span><br><span class="line">避免内存溢出的情况</span><br><span class="line">(分批分页查询db数据到内存，比如一次查询5000条，分20次分批查询出来每次加载指定大小的数据到内存，</span><br><span class="line">比如每次5000条，5000条批量写入到excel以后，清空当前List，</span><br><span class="line">释放内存分多个sheet写入，每个sheet比如放20w，100百万数据放到5个sheet</span><br><span class="line">每次从数据库批量读取指定大小的数据写入到excel，比如每次5000条)</span><br><span class="line"></span><br><span class="line">但其实我们是有限流机制的，不允许频繁的调用这个导入导出方法</span><br><span class="line">限流机制这块不是我做的</span><br><span class="line">但是我了解</span><br><span class="line">前端的话，每分钟只能调用一次这个方法</span><br><span class="line">后端令牌桶算法：用一个“桶”来存储一定数量的令牌，</span><br><span class="line">每个请求需要消耗一个令牌才能通过，当令牌不足时阻止请求。</span><br></pre></td></tr></table></figure><h2 id="对activity流程审批模块的测试样例设计"><a href="#对activity流程审批模块的测试样例设计" class="headerlink" title="对activity流程审批模块的测试样例设计"></a>对activity流程审批模块的测试样例设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.功能性测试：流程是否正常流转？是否正常通知给节点人员？</span><br><span class="line">驳回是否生效？审批人能否动态调整</span><br><span class="line">2，异常：审批人缺失情况下，能否提示？流程是否重复提交？</span><br><span class="line">审批途中系统故障，恢复后是否流程继续？</span><br><span class="line">是否只有当前人能提交审批？</span><br><span class="line">3.性能的测试：</span><br><span class="line">设置几十几百个流程节点，测试在多节点的流转性能</span><br><span class="line">每个流程节点的响应时间，</span><br><span class="line">多线程下的并发审批是否出问题？</span><br><span class="line">5.安全权限测试：不同权限的用户是否符合预期？</span><br><span class="line">是否能在审批中篡改敏感信息等</span><br><span class="line"></span><br><span class="line">1.还是流程这里，我在做流程审批的时候，遇到过两个bug</span><br><span class="line">第一个是退回审批不成功，第二个是流程卡在节点无法推进</span><br><span class="line">然后我也是打断电去调试代码找错误</span><br><span class="line">发现，退回审批不成功是我在画流程图的时候</span><br><span class="line">应该从网关出的路由</span><br><span class="line">画在了节点上</span><br><span class="line">第二个找到是</span><br><span class="line"></span><br><span class="line">我们在自定义审批人策略的时候</span><br><span class="line">是从当前人所在的部门去获取项目经理</span><br><span class="line">然后我用的是超级管理员身份登录，这个super没有部门</span><br><span class="line">所以就出现问题</span><br><span class="line">解决方法是，在数据库中给super创建一个部门</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.讲一下你实习中做过的性能测试和自动化测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">性能测试：jemeter去压力测试，看看接口的响应速度能不能达到并发</span><br><span class="line">自动化测试:好像用Selenium可以做，但是我没做过</span><br></pre></td></tr></table></figure><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">自动化测试这块，其实在实习和自己开发中，接触的不是很多</span><br><span class="line">大多数都是自己手动测试和一些性能测试</span><br><span class="line">Java中的单元测试框架junit</span><br><span class="line">jemeter去做性能和压力测试</span><br><span class="line"></span><br><span class="line">我知道好像selenium可以去做web端的自动化测试</span><br><span class="line">去模拟一些用户的行为（点击，链接等）</span><br><span class="line"></span><br><span class="line">然后如果有实际需要的化，我也愿意去深入学习和掌握自动化测试相关技术栈</span><br><span class="line">提高效率</span><br></pre></td></tr></table></figure><p>性能测试和压力测试的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">以我的项目需求书来说</span><br><span class="line">要求400个并发量下＜1s的查询性能嘛</span><br><span class="line">性能测试就是</span><br><span class="line">我去开启400个线程去访问接口</span><br><span class="line">得到平均相应时间，比如说500ms</span><br><span class="line">达到了我项目需求的性能，就可</span><br><span class="line"></span><br><span class="line">压力测试就是说</span><br><span class="line">我去测试平均相应＞1s的</span><br><span class="line">用户有多少个</span><br><span class="line">看看系统的极限在哪儿里</span><br></pre></td></tr></table></figure><p>6.你们性能测试的时候通过哪些指标来判断已经达到瓶颈的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口的响应时间，并发的用户数量，CPU的占用情况等</span><br></pre></td></tr></table></figure><h2 id="7-登录态信息token"><a href="#7-登录态信息token" class="headerlink" title="7.登录态信息token"></a>7.登录态信息token</h2><p>自动化接口测试是在平台写的？那有时候一些接口需要登录态，你们是怎么解决的？</p><p>（比如一个接口如果你没有登录态的信息，那他就会显示你没登陆，有遇到过吗？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">就是在使用jemeter的时候，在http请求的下的tokens去设置文件名称</span><br><span class="line">文件里是已有用户的token</span><br><span class="line">因为他这个框架登录请求是JWT令牌，</span><br><span class="line"></span><br><span class="line">以为移动公司的用户大概要3W多人，我们不需要那么多token</span><br><span class="line">我们查询数据库前400的用户</span><br><span class="line">然后随机uuid生成token，写入到txt文档中</span><br><span class="line">后面只需要把这个文件放在jmeter的登录状态头中</span><br><span class="line">这样在请求的过程中，就会自动携带请求头了</span><br></pre></td></tr></table></figure><h2 id="异常测试会想到哪儿些？"><a href="#异常测试会想到哪儿些？" class="headerlink" title="异常测试会想到哪儿些？"></a>异常测试会想到哪儿些？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">异常测试：我在开发中主要用到的还是功能方面的异常测试</span><br><span class="line">1，输入异常：边界值：最大最小值，空值，超出范围的值</span><br><span class="line">特殊字符：sql注入字符，转义字符等</span><br><span class="line">不匹配的数据类型：</span><br><span class="line">不匹配的文件类型：</span><br><span class="line">去看看有没有相应的异常提示</span><br><span class="line">其他异常我想到的有</span><br><span class="line">2.接口的异常：网络异常，数据库异常，服务器异常</span><br><span class="line">或者说不同设备的兼容性异常这些</span><br><span class="line">这些不是很常见的异常吧</span><br></pre></td></tr></table></figure><h2 id="测试理论：白盒测试，黑盒测试"><a href="#测试理论：白盒测试，黑盒测试" class="headerlink" title="测试理论：白盒测试，黑盒测试"></a>测试理论：白盒测试，黑盒测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">白盒测试：测试人员了解程序的内部结构，并且根据代码的实现，来设计测试用例</span><br><span class="line"></span><br><span class="line">黑盒测试：测试人员对程序的内部逻辑和实现没有了解，主要关注系统的功能需求和输出结果。</span><br><span class="line">白盒测试多用于单元测试、集成测试，黑盒测试多用于系统测试、验收测试</span><br><span class="line"></span><br><span class="line">其实根据我来说，我在测试过程中，基本上测的都是我实现的功能</span><br><span class="line">根据我实现的代码来设计测试用例</span><br><span class="line">比如说：Excel导入导出这块</span><br></pre></td></tr></table></figure><h2 id="黑盒测试的等价类划分"><a href="#黑盒测试的等价类划分" class="headerlink" title="黑盒测试的等价类划分"></a>黑盒测试的等价类划分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">等价类划分是黑盒测试中常用的一种测试设计技术</span><br><span class="line">用于减少测试用例的数量，同时确保覆盖所有可能的输入场景。</span><br><span class="line">它的基本思想是将所有可能的输入值划分为若干个等价类，</span><br><span class="line">以便从每个类中选择一个或几个代表性的测试用例进行测试。</span><br></pre></td></tr></table></figure><p>因果图法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">因果图法是一种黑盒测试设计技术，用于系统地识别输入条件与输出结果之间的关系，</span><br><span class="line">以设计测试用例。它通过将输入条件（因）和输出结果（果）可视化，</span><br><span class="line">帮助测试人员理解不同输入条件如何影响系统行为，并有效生成测试用例。</span><br><span class="line">示例</span><br><span class="line">假设我们要测试一个简化的登录系统</span><br><span class="line">因果图示例</span><br><span class="line">输入条件：</span><br><span class="line">A：用户名有效</span><br><span class="line">B：密码正确</span><br><span class="line">C：用户未锁定</span><br><span class="line">输出结果：</span><br><span class="line">X：登录成功</span><br><span class="line">Y：登录失败</span><br></pre></td></tr></table></figure><p>8.对一个杯子设计测试用例。（功能性、易用性、安全性、外观、压力测试、项目说明&#x2F;使用手册）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.功能性：</span><br><span class="line">测试描述：测试杯子是否能容纳规定的最大容量</span><br><span class="line">预期结果：杯子在加满水后无溢出现象</span><br><span class="line">执行步骤：1.向杯子注入水，直到置顶水量</span><br><span class="line">2.观察是否溢出</span><br><span class="line">2. 易用性测试用例</span><br><span class="line">3. 安全性测试用例</span><br><span class="line">4. 外观测试用例</span><br><span class="line">5. 压力测试用例</span><br><span class="line">6. 项目说明/使用手册</span><br></pre></td></tr></table></figure><p>12.查每个班级最高成绩sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    class_id, </span><br><span class="line">    <span class="built_in">MAX</span>(score) <span class="keyword">AS</span> highest_score</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    students_scores</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    class_id; </span><br></pre></td></tr></table></figure><p>13.T型用户访问量，在中间的数据量级很慢，什么原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据库性能问题，测试的时候，压力测试去排查</span><br><span class="line">CPU的问题，高并发导致服务器CPU占用过高的话，升级CPU</span><br><span class="line">排查是否使用缓存提高性能等</span><br></pre></td></tr></table></figure><h2 id="以登录为例，要如何测试登录功能是否正常？"><a href="#以登录为例，要如何测试登录功能是否正常？" class="headerlink" title="以登录为例，要如何测试登录功能是否正常？"></a>以登录为例，要如何测试登录功能是否正常？</h2><p>包括交付质量、高可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从设计测试样例的一般性原则来说，可以从一下几个方面入手</span><br><span class="line">1.功能性的测试：正确登录，错误用户名，错误密码，空值登录，账号锁定登录..</span><br><span class="line">2.边界测试：使用特殊字符，额外程长度</span><br><span class="line">3.安全测试：sql注入，暴力破解？等</span><br><span class="line">4.性能测试：高并发，响应时间，回复时间</span><br><span class="line">5.兼容性测试：不同浏览器，不同设备，手机，网页等</span><br></pre></td></tr></table></figure><p>下单为例子，哪儿些测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.功能，边界，安全，性能，异常，兼容性</span><br></pre></td></tr></table></figure><p>如何保证请求是通过前台传过来的而不是直接通过地址传接口的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jwt登陆认证，携带token</span><br><span class="line">用jemeter</span><br><span class="line">在单元测试中读取400位用户，生成token</span><br></pre></td></tr></table></figure><p>13.对括号匹配算法的测试用例</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20241008100702962.png" alt="image-20241008100702962">14.日志升级？不懂</p><p>15.traceID，从生成到传递的全过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在分布式系统中，Trace ID（追踪标识符） 是用于跟踪和关联一次完整请求在多个服务之间流转的唯一标识。</span><br><span class="line">它在微服务架构、分布式系统的监控和故障排查中扮演着至关重要的角色。</span><br><span class="line">本文将详细介绍 Trace ID 从生成到传递的全过程，包括其生成方式、传播机制以及在实际应用中的实现方法。</span><br></pre></td></tr></table></figure><p>16.登录页面的测试用例怎么设计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设计登录注册页面的测试用例时，需要全面考虑各种输入情况、用户行为、边界条件和系统的安全性。</span><br><span class="line">以下是一个详细的测试用例设计示例，包括功能测试、边界测试、安全测试等方面。</span><br></pre></td></tr></table></figure><p>vi和vim都是经典的文本编辑器，vim是vi的增强版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在基本上都是在图形化界面去做，基本上不用了</span><br></pre></td></tr></table></figure><p>异常处理类，全局异常处理类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sqlException</span><br><span class="line">ClassNotFountException</span><br><span class="line">runtimeException</span><br><span class="line">ArrayOutOfBoundException</span><br><span class="line">NumberFormateException</span><br><span class="line">除0错误</span><br><span class="line"></span><br><span class="line">在springboot中定义全局异常处理类@ControllerAdvice</span><br><span class="line">集中处理异常</span><br></pre></td></tr></table></figure><p>得物测试没回答上来的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.慢查询，除了和前端的通信，微服务接口的通信的测试相关？</span><br><span class="line">RPC测试</span><br><span class="line">2.消息队列相关，confirm确认机制</span><br></pre></td></tr></table></figure><h2 id="你有系统学习过测试吗？"><a href="#你有系统学习过测试吗？" class="headerlink" title="你有系统学习过测试吗？"></a>你有系统学习过测试吗？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">虽然我没有系统地学习过测试理论课程，但在开发的过程中，</span><br><span class="line">我接触并实践了一些测试相关的工作。例如，在项目中，</span><br><span class="line">我会编写单元测试来验证代码的功能正确性，同时也参与过功能测试和接口测试，</span><br><span class="line">确保系统的稳定性。通过这些实践，我对测试的重要性和基本方法有了一定的认识。</span><br><span class="line">如果有机会，我希望进一步深入学习测试理论，</span><br><span class="line">补充自己的短板，以更全面地支持开发和测试工作</span><br></pre></td></tr></table></figure><p>7、说说95%响应时间<br>8、性能测试中jmeter怎么计算的95%响应时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它表示在所有请求中，95% 的请求响应时间都低于这个值，</span><br><span class="line">仅有 5% 的请求响应时间超过该值。</span><br><span class="line">收集响应时间，排序，找到95%的位置就行</span><br></pre></td></tr></table></figure><p>等价类划分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个应该算是一种测试方法吧</span><br><span class="line">就是说：讲输入的测试数据去划分为若干个具有相同性质的类别</span><br><span class="line">然后这些类别是等价的，以此来减少测试用例</span><br><span class="line">比如说，我需要测试一个[1,9]的数字范围，</span><br><span class="line">我只需要测试其中一个就可以了，没必要全部测试</span><br></pre></td></tr></table></figure><h2 id="编写测试用例，如何确保测试用例的质量"><a href="#编写测试用例，如何确保测试用例的质量" class="headerlink" title="编写测试用例，如何确保测试用例的质量"></a>编写测试用例，如何确保测试用例的质量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.明确需求，根据需求文档确保测试用例覆盖所有的功能点，包括异常情况</span><br><span class="line">2.设计规范：使用统一的模版，确保步骤明确、预期结果具体，便于执行和复现问题</span><br><span class="line">3.</span><br></pre></td></tr></table></figure><p>从浏览器访问远程一台电脑的图片有哪些方法实现？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.链接在同一个WiFi下，用Windows共享文件夹</span><br><span class="line">2.自己开发服务比较繁琐，使用上传到云服务器</span><br><span class="line">阿里云这些对象存储服务，通过网址的方式去访问</span><br></pre></td></tr></table></figure><p>测试需要的能力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，快速理解产品和业务的能力，能够从用户的角度设计测试用例</span><br><span class="line">2.发现问题发现bug的能力，不能等系统上线了让用户发现</span><br><span class="line">3.沟通能力，发现问题与与开发，产品去沟通，解决问题</span><br><span class="line">4.耐心吧，有的问题需要重复很多次，应该要保证测试覆盖全面，避免遗漏</span><br></pre></td></tr></table></figure><h2 id="职业规划："><a href="#职业规划：" class="headerlink" title="职业规划："></a>职业规划：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我的职业规划更多还是在开发和测试开发这方面</span><br><span class="line">因为自己的包括自己学习，实习经历都是在这方面</span><br><span class="line">我也有在自己网站中积累和回顾自己的所学嘛</span><br><span class="line">学习了这么多也不能说轻易放弃</span><br><span class="line">当然我也不排除新技术的学习</span><br><span class="line"></span><br><span class="line">长远来看，我希望我计划在工作中不断积累项目经验，</span><br><span class="line">提升解决实际问题的能力，力争能独立负责部分模块或项目</span><br><span class="line">并为团队贡献我的力量。</span><br></pre></td></tr></table></figure><p>讯飞产品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有过了解，我认识中科大讯飞是做语音识别这块是行业的领先者</span><br><span class="line">后来跟ai相关做了特别多的产品，星火大模型这些</span><br><span class="line">然后其实一面的面试官也有介绍</span><br><span class="line">他们是做智能汽车这块的，与很多车企合作</span><br><span class="line">智能座舱，智能音效，智能交互这方面的测试开发</span><br></pre></td></tr></table></figure><p>17，反问：业务中用到测试的地方有哪儿些？测试和开发占的比重多少？</p><p>2.您刚刚提到了自动化测试，咱们业务场景用到的自动化测试场景多吗？会用到哪儿些技术栈这些？</p><p>3.后续流程</p>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 快手 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快手 </tag>
            
            <tag> 秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结（秋招）</title>
      <link href="/2024/10/07/Interviews/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/10/07/Interviews/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="秋招面试总结"><a href="#秋招面试总结" class="headerlink" title="秋招面试总结"></a>秋招面试总结</h1><p>自我介绍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">面试官您好，我叫方圆，目前是杭州电子科技大学通信工程专业研三的学生</span><br><span class="line">熟悉Java语言，对web端的开发有一定的实践</span><br><span class="line"></span><br><span class="line">读研的时候，是以校企合作的方式</span><br><span class="line">参与数梦工厂的消息中心项目</span><br><span class="line">主要负责Java后端</span><br><span class="line">后来暑期实习</span><br><span class="line">在华信咨询设计院参与了</span><br><span class="line">中国移动浙江公司的科研数字化管理平台项目</span><br><span class="line">担任前后端开发实习生</span><br><span class="line"></span><br><span class="line">与此同时呢，我也做过一些开源项目，学到过一些技术栈</span><br><span class="line">并且搭建了自己的个人网站</span><br><span class="line">主要用来记录和回顾学习的知识，笔记，算法等</span><br><span class="line"></span><br><span class="line">（然后今天面试的是测试开发嘛</span><br><span class="line">因为自己在实际的开发过程中</span><br><span class="line">也是做过一些功能和性能方面的测试</span><br><span class="line">对测试这块也有所了解</span><br><span class="line">所以。我觉得自己能够胜任这个职位）</span><br><span class="line"></span><br><span class="line">以上就是我的自我介绍</span><br></pre></td></tr></table></figure><h1 id="华信-科研数智化管理平台"><a href="#华信-科研数智化管理平台" class="headerlink" title="华信-科研数智化管理平台"></a>华信-科研数智化管理平台</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2024.06-2024.09：中国移动浙江公司-科研创新数智化平台（华信咨询设计研究院有限公司）  全栈开发实习生</span><br><span class="line">项目描述：</span><br><span class="line">浙江移动科研创新数智化平台主要是基于ACWS5框架搭建，该系统分为系统管理、个人工作台、项目流程管理、统计分析、成</span><br><span class="line">本度量、专家库管理等多个模块，目标是建成覆盖通信工程建设全过程的信息化管理平台。</span><br><span class="line">技术栈：ACWS5框架+SpringBoot + MybatisPlus + Oracle+ Vue2+ ElementUI + Echarts + Activity7</span><br><span class="line">责任描述：</span><br><span class="line">◆系统主页面：主页面表头、近半年工时情况、一周项目动态、资料上传情况、日程安排的前后端开发、数据展示。</span><br><span class="line">◆项目管理模块：数据库项目表的设计实现，前端项目列表展示页面、编辑页面、评估页面的开发</span><br><span class="line">                            查询分页、表格拖动排序、模板下载、Excel导出、导入校验、发起评估、附件上传等功能点的前后端实现</span><br><span class="line">◆统计分析模块：开发项目进度、工时、成本、智能评估质量的柱状图、饼状图的后端数据与前端展示。</span><br><span class="line">◆成本度量模块：开发成本相关数据的采集与导入，成本估算、预算管理、实际支出对比、成本度量功能变更审批等功能</span><br><span class="line">◆流程评估模块：后端 Activity流程图的设计、代码实现；前端流程编辑页面、审批页面的开发；</span><br></pre></td></tr></table></figure><p>acws5框架：也是基于spring框架去搭建的，包括Shiro的安全框架+JWT的登录认证Swagger UI的API发布等</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20241007232225034.png" alt="image-20241007232225034"></p><p>介绍一下你负责的项目和模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">好的面试官，这个科研数智化平台是给移动公司提供的一个覆盖项目工程全过程的信息化管理平台</span><br><span class="line">我在一下几个模块的功能业务都有所涉及，</span><br><span class="line">1.系统主页面的一个前后端的开发，是对于其他模块的概要总结，因为开始进入系统是项目管理模块，没有主页面</span><br><span class="line">2.然后项目管理模块是已有的，然后评审的实际主要是对一些功能的增加，比如Excel导入导出校验，拖动排序等等</span><br><span class="line">3.统计分析模块：主要是对项目数据做的分析，前端可视化的展示</span><br><span class="line">4.成本度量模块：主要是对于项目成本的一个管理</span><br><span class="line">5.流程审批模块：存在于项目管理模块和成本度量模块中的，主要是对项目，成本的的一个审批</span><br></pre></td></tr></table></figure><p>系统主页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">主页面主要是分了五个模块，主要是对于其他模块的一个简要总结和展示</span><br><span class="line">比如这个表头去展示当前登录人员权限下的项目数量、项目代办已办、待阅已阅这些这些</span><br><span class="line">前端的话就是引入他们内部的一些自定义的组件</span><br><span class="line">后端去根据项目表，代办表中查找他权限下的相应字段即可</span><br><span class="line"></span><br><span class="line">半年工时情况就是，资料上传情况也差不多</span><br><span class="line">获取当年时间，往前推六个月获取当前月份数组</span><br><span class="line">再去工时表中动态SQL，foreach标签去查找整个月份的数据</span><br><span class="line">这边有问题就是，前端自定义组件返回值要包括线条颜色等其他信息</span><br><span class="line">就需要前端再写js方法去处理</span><br><span class="line">包括为了美观去截取名次，再次排序等等</span><br><span class="line"></span><br><span class="line">比较复杂的是，日程安排这里，没有专门的表</span><br><span class="line">整合日历任务表和WBS代办任务表</span><br><span class="line">并且这两张表是没有外键关联的</span><br><span class="line">所以就要去写建视图的代码</span><br><span class="line">去做一些字段映射as，拼接contact,子查询等</span><br><span class="line">写的还是比较麻烦的</span><br><span class="line">去生成前端说需要的数据表，再去查询试图就行</span><br><span class="line">为什么用视图？</span><br><span class="line">就是为了实时性，视图是虚拟表，内容是根据底层的表实时生成的</span><br><span class="line">底层表中的数据发生变化的时候，视图的数据也会变化</span><br><span class="line">如果新建表的话，就不会变化，原有的提交任务代码还需要重写保存一份在新表中</span><br><span class="line">就比较麻烦</span><br><span class="line"></span><br><span class="line">（整体的开发逻辑：在评审会的时候，项目经理会设计UI，并且告诉我们开发的一些组件）</span><br><span class="line">（配置api中的方法，在后端取值）</span><br><span class="line">（后端主要做的就是，对前端响应数据的一个封装）</span><br><span class="line">复杂：日程安排这里</span><br></pre></td></tr></table></figure><p>项目管理模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">项目管理模块主要是对表的一些字段的增加，还有一些功能的增加</span><br><span class="line">数据库表的设计主要是使用pdmaner这个软件去做</span><br><span class="line">我做的主要功能有Excel的导入导出，校验，表格拖动排序，等</span><br><span class="line">先做的是模板的导出，导入的话前端调用导入的方法</span><br><span class="line">用的是Apache的api，</span><br><span class="line">会有一个公共方法读取表单，转为list&lt;map&lt;String,String&gt;&gt;结构</span><br><span class="line">后面就处理这个结构</span><br><span class="line">做一些逻辑校验（人员是否存在），数据格式校验（正则匹配）等</span><br><span class="line"></span><br><span class="line">然后就是新增了项目列表可拖动的功能</span><br><span class="line">这个主要实现在前端</span><br><span class="line">需要使用到 SortableJS 这样的第三方库，通常依赖于存在的 DOM 元素来进行操作，</span><br><span class="line">回调方法中执行更新顺序保存到数据库</span><br><span class="line">这里遇到过bug，就是这里就很奇怪，只有点击了添加附件类型才能生成 dom 元素 tag</span><br><span class="line">后面也是找了很久才解决</span><br><span class="line">设置监听器，用$nextTick 确保在dom已经更新完成后再获取dom元素就行</span><br><span class="line"></span><br><span class="line">审批流程等</span><br></pre></td></tr></table></figure><p>统计分析模块：开发项目进度、工时、成本、智能评估质量的柱状图、饼状图的后端数据与前端展示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">前端主要用到的是他们自己封装过后的echarts，因为vue2不能直接用</span><br><span class="line">主要是一些柱状图，折线图，条形图等</span><br><span class="line">然后后端去查询相应的数据</span><br><span class="line"></span><br><span class="line">难点是智能评估质量这块</span><br><span class="line">这边需要做算法的处理</span><br><span class="line">讲项目表中的字段分为不同的评估维度</span><br><span class="line">比如成本，预算，人员，交付等字段</span><br><span class="line">然后去设定权重</span><br><span class="line">归一化处理，计算综合得分</span><br><span class="line"></span><br><span class="line">开始查整张表写，被骂，性能不好，后来就乖了</span><br></pre></td></tr></table></figure><p>PDmaner</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我们导入sql就可以看到整体的项目200多张表的结构</span><br><span class="line">以及每个模块表的结构图，对应关系ER图等</span><br><span class="line">然后建表的时候，也可以直接去页面加字段，自动生成sql而不用自己写</span><br><span class="line">并且生成的表，后端的方法也能生成，省去自己写重复代码的过程</span><br><span class="line">使用这个好处是</span><br><span class="line">我觉得对于开发对数据库表的结构人生还是比较重要的</span><br><span class="line">有时候就是，对表不熟悉，我自己去重写方法，后来组长说这个方法已经写过了</span><br><span class="line">就白费功夫</span><br><span class="line">而且，在开发的时候，也方便去注入对应的service层调用方法</span><br></pre></td></tr></table></figure><p>成本度量模块：开发成本相关数据的采集与导入，成本估算、预算管理、实际支出对比、成本度量功能变更审批等功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">采集就是前端写一个dialog，用elementui相关的元素，然后获得成本度量相关的信息，保存到数据库中</span><br><span class="line">导入就Excel批量导入，要做校验等</span><br><span class="line"></span><br><span class="line">成本估算就是：成本表，</span><br><span class="line">根据项目的开始时间和结束时间，然后项目的工作量，团队规模，其他资源等</span><br><span class="line">去计算整个项目周期的估算成本</span><br><span class="line"></span><br><span class="line">预算管理：实际预算表，各个阶段预算等，可以发起审批增加预算等等</span><br><span class="line"></span><br><span class="line">对比的话就是，各个阶段的预算和实际的对比，计算超出百分数等</span><br><span class="line"></span><br><span class="line">审批：对当前业务发起评估等</span><br></pre></td></tr></table></figure><p>流程评估模块：后端 Activity流程图的设计、代码实现；前端流程编辑页面、审批页面的开发；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">activity流程引擎，它是通过一系列数据库的表</span><br><span class="line">和sql语句实现流程的存储与管理</span><br><span class="line">画bpmn的流程图</span><br><span class="line">他本质上就是一个xml文件，去存放我们流程节点的相应数据</span><br><span class="line">流程引擎解析xml文件的时候，解析成一条一条的sql插入到表中</span><br><span class="line"></span><br><span class="line">流程定义表：</span><br><span class="line">流程定义表：存储流程定义的静态信息，如流程ID、版本等。</span><br><span class="line">每当一个新流程定义被部署时，相关数据会通过SQL语句插入该表。</span><br><span class="line">运行时表：保存流程实例的执行状态，保存当前任务信息。</span><br><span class="line">当启动一个流程实例时，操作将实例数据存入这些表；任务完成后则通过操作更新状态。</span><br><span class="line">历史表：流程执行结束后，等表保存流程实例和任务的历史记录。</span><br><span class="line">将运行时表的数据复制到历史表中。</span><br><span class="line">流程变量表：存储流程实例中的动态变量，保存已结束流程的历史变量数据。</span><br><span class="line">Activity利用这些表和SQL操作，实现流程的启动、执行、任务指派及历史追踪等功能，</span><br><span class="line">确保流程执行状态和历史数据的持久化存储。</span><br><span class="line"></span><br><span class="line">我主要做的呢</span><br><span class="line">在项目管理模块呢，是对项目的一个审批，还有对资料的审批</span><br><span class="line">成本度量管理模块，是对成本的一个评估</span><br><span class="line"></span><br><span class="line">后端我们部署的流程就是</span><br><span class="line">起草人（当前用户）-部门经理-公司领导等</span><br><span class="line">部门经理可以审批通过也可以退回，</span><br><span class="line">公司领导也可以提交和退回</span><br><span class="line">根据这个</span><br><span class="line">去配置每个流程节点，路由，网关等</span><br><span class="line">流程节点：每个节点去写人员选择策略类，在流程实例中获取流程节点人的信息</span><br><span class="line">比如我们要获取部门经理，就要先拿到当前流程实例的发起人</span><br><span class="line">查询发起人所在的部门，再查询当前部门的部门经理这样</span><br><span class="line">网关：实现决策的，一般用排它网关</span><br><span class="line">路由：节点之前连接顺序</span><br><span class="line"></span><br><span class="line">最后还会用到一个观察者模式</span><br><span class="line">流程实例发布后，会创建事件对象给spring事件系统</span><br><span class="line">然后就是使用注解@EventListener标注方法去监听</span><br><span class="line">判断是不是 当前流程的事件</span><br><span class="line">如果是的话，就调用通知类中的方法，去发送通知给需要审批的人员                                                                             </span><br><span class="line"></span><br><span class="line">后端部署好后</span><br><span class="line">前端只需要去发起这个流程，前端主要写了两页页面，</span><br><span class="line">一个是流程编辑页面，还有一个就是流程审批页面</span><br><span class="line">编辑页面呢，就是对当前项目信息的编辑</span><br><span class="line">在审批的页面呢，就展示审批的信息，包括</span><br><span class="line">审批意见，流程监控，审批路由。人员选择的组件</span><br></pre></td></tr></table></figure><p>开发流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">然后我们整个开发的流程，就是，评审后的需求文档</span><br><span class="line">照着需求文档，去做</span><br><span class="line">前端的话就是写一些页面，页面上的一些按钮功能，和数据展示的实现</span><br></pre></td></tr></table></figure><p>遇到的困难</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.在我负责的activity项目审批流程中，动态获取审批人是我遇到的一个难点</span><br><span class="line">这个问题的复杂性在于，不同的节点需要不同的审批人，</span><br><span class="line">这些审批人可能根据业务规则动态生成，</span><br><span class="line">无法在设计的时候静态的获取</span><br><span class="line"></span><br><span class="line">为了解决这个问题，我去搜索了解了业务节点的处理机制</span><br><span class="line">任务节点可以配置为手动指定受理人，或者通过流程变量、表达式等方式动态分配。</span><br><span class="line">最后发现到，可以通过自定义审批人策略，结合业务系统的数据动态获取审批人信息。</span><br><span class="line">我设计了一种基于业务规则和用户角色的动态审批人分配方案，借助Activity的TaskListener接口，</span><br><span class="line">在任务创建时从数据库或外部系统动态获取审批人，并通过流程变量的方式传递到审批节点。</span><br><span class="line">（比如说，从threadlocal中获取当前人，再获取当前人所在部门，在获取部门的经理这样）</span><br><span class="line"></span><br><span class="line">2.activity流程图的设计实现，这部分也是之前没接触过的</span><br><span class="line">我在流程建模、任务节点配置、用户权限管理等方面遇到了很多问题。</span><br><span class="line">为了解决这些问题，我深入研究了 Activity 的官方文档，分析了其 BPMN 流程模型，</span><br><span class="line">并在实践中逐步掌握了如何通过配置动态任务分配和复杂的审批流转条件来满足项目需求。</span><br><span class="line"></span><br><span class="line">3.第二个就是我在做Excel导出的功能这块遇到的问题吧</span><br><span class="line">我们用的是Apache的api，</span><br><span class="line">会有一个公共方法读取表单，转为list&lt;map&lt;String,String&gt;&gt;结构</span><br><span class="line">在我做项目导出，大概有几千条项目数据的时候</span><br><span class="line">响应还是比较快的</span><br><span class="line">但是我在做人员导出那块，就会出现响应比较慢</span><br><span class="line">然后我分析就是，如果涉及到大数据量的导出的话</span><br><span class="line">有可能会造成内存溢出，或者无响应的情况</span><br><span class="line"></span><br><span class="line">针对上述问题，其实也看到过有现成的一些解决方案</span><br><span class="line">放弃使用Apache的api,使用阿里的easyExcel这种</span><br><span class="line">但是其实我并没有这种权限去新加依赖</span><br><span class="line">后面就是用的分批分页的方法</span><br><span class="line">比如说一次只查询5000条数据，5000条批量写入到excel以后，</span><br><span class="line">清空当前List，释放内存</span><br><span class="line">避免内存溢出的情况</span><br><span class="line">(分批分页查询db数据到内存，比如一次查询5000条，分20次分批查询出来每次加载指定大小的数据到内存，</span><br><span class="line">比如每次5000条，5000条批量写入到excel以后，清空当前List，</span><br><span class="line">释放内存分多个sheet写入，每个sheet比如放20w，100百万数据放到5个sheet</span><br><span class="line">每次从数据库批量读取指定大小的数据写入到excel，比如每次5000条)</span><br></pre></td></tr></table></figure><p>遇到的bug</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.还是流程这里，我在做流程审批的时候，遇到过两个bug</span><br><span class="line">第一个是退回审批不成功，第二个是流程卡在节点无法推进</span><br><span class="line">然后我也是打断电去调试代码找错误</span><br><span class="line">发现，退回审批不成功是我在画流程图的时候</span><br><span class="line">应该从网关出的路由</span><br><span class="line">画在了节点上</span><br><span class="line">第二个找到是</span><br><span class="line">我们在自定义审批人策略的时候</span><br><span class="line">是从当前人所在的部门去获取项目经理</span><br><span class="line">然后我用的是超级管理员身份登录，这个super没有部门</span><br><span class="line">所以就出现问题</span><br><span class="line">解决方法是，在数据库中给super创建一个部门</span><br><span class="line"></span><br><span class="line">1.前端的调用方法是异步请求，所以我有时候查询完数据，显示列表数据方法的时候</span><br><span class="line">回调方法有时候可能先一步于执行，而不是按照代码顺序，有时候会显示有时候不会显示</span><br><span class="line">后来问了正式员工，就在方法的回调方法里面写</span><br><span class="line">2.开始培训期做demo的时候，我没有按照代码规范写，导致出bug</span><br><span class="line">就是他们的实体类，还有服务类其实还继承了很多其他的一些公共类，</span><br><span class="line">这些我没有加上</span><br><span class="line">还有就是，他表的主键id不是叫id，所以我开始做demo用mp做</span><br><span class="line">找不到实体类，后面用mybatis试了下可以</span><br><span class="line">就用mybatis写了。所所长检查代码的时候</span><br><span class="line">说要遵循代码规范，遇到问题要解决问题</span><br><span class="line">而不是变通，用另一种方法解决了</span><br><span class="line">还有就是分页查询的时候，用的是pageHelper的插件，我自己用mybatisplus的Page，就会有问题</span><br><span class="line">3. /0的错误，小错误等，数据精度处理用BigDecimal等</span><br><span class="line">4.写sql，而不是在service层写一堆逻辑</span><br></pre></td></tr></table></figure><p>实习的收获</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.新技术栈的学习，VUE前端，activity流程引擎这些，掌握技能</span><br><span class="line">2.接触项目开发的一整套流程嘛，包括，评审+任务分配+合作交流完成+测试</span><br><span class="line">3.更多的团队沟通和合作能力</span><br><span class="line">因为我一开始我遇到问题可能不善于去问别人，先自己百度解决</span><br><span class="line">如果解决不了，再去问，但是有时候可能会影响进度嘛</span><br><span class="line">组长给我说，就一句话的事情就能解决问题，</span><br><span class="line">以后遇到就知道了，这个还需要慢慢积累经验吧</span><br><span class="line">4.解决问题能力</span><br><span class="line">1.解决问题能力太暴力简单了，不考虑后果这些</span><br><span class="line">1.代码规范，开始实习培训阶段，代码不规范被说</span><br><span class="line">2.团队沟通，前端组件有自己的组件库，我却用elementUI硬写，写到遇到问题不会问别人，才说有组件库</span><br><span class="line">3.问题的解决能力和技术能力的提升</span><br></pre></td></tr></table></figure><h1 id="DTphere消息中心"><a href="#DTphere消息中心" class="headerlink" title="DTphere消息中心"></a>DTphere消息中心</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">这个消息中心的项目，分为平台侧（管理的人去看的）和用户侧（用户去看的）</span><br><span class="line">在平台侧呢</span><br><span class="line">消息的管理</span><br><span class="line"></span><br><span class="line">模版管理</span><br><span class="line"> --对不同的渠道，钉钉，微信，短信，邮件设计不同的消息模版</span><br><span class="line"> --设计实体关系图，一张表维护不同的消息模版Id</span><br><span class="line"> --每个Id作为外键关联一张模板表</span><br><span class="line"> </span><br><span class="line">渠道管理</span><br><span class="line"> --渠道管理负责去配置各个渠道的信息，短信，邮件，企业微信，钉钉机器人等</span><br><span class="line"> --引入钉钉，微信等相关依赖，配置用户名密码服务器去做测试链接</span><br><span class="line">用户侧：</span><br><span class="line">全部类型消息的查看</span><br><span class="line">--搜索，查看，批量标记已读未读，删除消息，全部已读等</span><br><span class="line">告警消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line">系统消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line">审批消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line">产品消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line"></span><br><span class="line">对需要删除的消息：用AOP日志记录</span><br><span class="line">使用yapi.pro那个平台编写接口文档，做接口文档的开发</span><br></pre></td></tr></table></figure><p>这个消息中心的项目，分为平台侧（管理的人去看的）和用户侧（用户去看的）</p><h2 id="平台侧"><a href="#平台侧" class="headerlink" title="平台侧"></a>平台侧</h2><ul><li>消息的管理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--绑定管理，将产品与消息模板绑定，当前产品对应的消息模板</span><br><span class="line">--这里是新建一张绑定关系表，将产品Id和模板Id对应起来</span><br><span class="line">查询模版、查询产品消息、绑定、回显</span><br></pre></td></tr></table></figure><ul><li>模版管理</li></ul><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240513091758796.png" alt="image-20240513091758796" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> --对不同的渠道，钉钉，微信，短信，邮件设计不同的消息模版</span><br><span class="line"> --设计实体关系图，一张表维护不同的消息模版Id，</span><br><span class="line"> --每个Id作为外键关联一张模板表</span><br><span class="line"> --我在开始数据库中创建了五张模板表，分别对应五种消息</span><br><span class="line"> --（后来就是五张表维护起来太麻烦了，每次增删改查还要在不同表里</span><br><span class="line">  还要创建一个模版表去记录创建好的所有Id）</span><br><span class="line"> --优化就是：因为模版表有很多相同的字段，创建一张表整合所有字段，</span><br><span class="line"> 没有设置的字段，就默认为null</span><br><span class="line"> 然后再新建五个vo类作为返回给前端的消息实体类，去封装对应模版的信息</span><br><span class="line"> </span><br><span class="line"> 不同的消息模板有不同的字段，我根据它们提供的图去在数据库中创建模板</span><br><span class="line"> 这里是参照了它们官方提供的开发手册</span><br><span class="line"> 定义字段的时候，选择合适的字段内容来建标</span><br><span class="line">字符串就结合存储的内容来使用char  或者varchar</span><br><span class="line">用户名称邮箱类型的可变，使用varchar</span><br><span class="line">文章内容使用text</span><br><span class="line">邮编长度使用char等等</span><br><span class="line">模版类型这里，因为只有几个嘛，开始用的int，后来该改的tinyint</span><br><span class="line"></span><br><span class="line">优化这里</span><br><span class="line">1.分页和摘要</span><br><span class="line">因为text字段过大，表里只存放指针，MySQL还需要二次查询</span><br><span class="line">会影响查询性能，所以我们做了一个分表</span><br><span class="line">将text列分离到单独的扩展表中，用ID字段做一个关联</span><br><span class="line">然后，创建一个varchar（255）字段，来记录text的前255个字符作为摘要</span><br><span class="line">这样在分页查询的时候，文章内容我们就只需要查询这个varchar字段就行</span><br><span class="line">点进去具体查询的时候，就需要关联text表查询text字段了</span><br><span class="line"></span><br><span class="line">2.联合索引</span><br><span class="line">因为我们每次查询的未读消息的SQL语句，的where条件是</span><br><span class="line">where user_id = ? and is_read = fasle</span><br><span class="line">所以我们对这表中的两个字段添加复合索引</span><br><span class="line">CREATE INDEX idx_user_id_is_read ON messages (user_id, is_read);</span><br><span class="line">增加查询的效率</span><br><span class="line"></span><br><span class="line">3.过期策略</span><br><span class="line">用户去查找太久远的消息的几率不大</span><br><span class="line">所以就去做一个分表，定期将历史消息归档在历史表中</span><br><span class="line">可以按照季度或者月份归档</span><br><span class="line">我们前端点击查看历史消息的时候，才会去访问这张表</span><br></pre></td></tr></table></figure><ul><li>渠道管理</li></ul><p>​下图只是举例，</p><p>​我们是：邮件、短信、企业微信、钉钉机器人、钉钉联系人等（字段也不同）</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240513095713632.png" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--渠道管理负责去配置各个渠道的信息，短信，邮件，企业微信，钉钉机器人等</span><br><span class="line">--引入钉钉，微信等相关依赖，配置用户名密码服务器等</span><br><span class="line"></span><br><span class="line">我们负责测试，前端同学将这些参数封装在json中传递</span><br><span class="line">我们后端负责接受这些参数，然后在后台调用依赖</span><br><span class="line">尝试去获取消息，获取成功就测试成功</span><br><span class="line"></span><br><span class="line">邮件的话：我们是链接163邮箱，配置服务器，端口，这里是去163官网查看了相关demo</span><br><span class="line">短信：引入它们自己的api,提供的了网关插件地址，去做测试链接</span><br><span class="line">钉钉机器人、联系人、企业微信：都是去官方调用官方API</span><br><span class="line">看它们的示例demo，去做配置</span><br><span class="line">引入了第三方的依赖，去做测试链接</span><br></pre></td></tr></table></figure><ul><li>消息分类统计展示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从不同维度统计及展示消息发送情况</span><br><span class="line">例如根据消息的通知渠道、来源产品、消息分类(告警类型、工单提醒、license提醒)等。</span><br></pre></td></tr></table></figure><h2 id="用户侧"><a href="#用户侧" class="headerlink" title="用户侧"></a>用户侧</h2><p>主要是对站内信的处理（从它们数据库中获取）</p><ul><li>全部类型消息–  告警消息、系统消息、审批消息、产品消息</li><li>未读消息</li><li>已读消息</li></ul><p>表的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">消息表：存储站内具体消息相关内容</span><br><span class="line">用户消息表：存储每个用户接收到的站内消息，消息状态，是否已读，是否删除等</span><br><span class="line">用户表：所有的用户信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">这个就是对站内消息的处理</span><br><span class="line">文档中给的需求是，查看，搜索，标记已读，删除，分页查找，批量删除等</span><br><span class="line">并没有给我们接口文档。我们就先在实现的时候，根据功能编写接口文档</span><br><span class="line">我们找了yapi.pro去编写</span><br><span class="line"></span><br><span class="line">我们自己定义的规范就是，基于RESTful API定义的</span><br><span class="line">用户侧就/user开头</span><br><span class="line">说明请求参数，路径参数或者是实体参数开头的</span><br><span class="line">定义Result返回值对象，返回标准的响应值（响应码，响应信息，响应数据data等）</span><br><span class="line">数据库的实体参数作为DTO类，响应给前端的不一定是全部的字段</span><br><span class="line">所以创建一个vo实体类，封装专门响应给前端的信息</span><br><span class="line">（这里就用到了Hutul工具类的拷贝方法，不用一行一行复制很麻烦）</span><br><span class="line"></span><br><span class="line">在删除的时候，因为涉及到数据库的操作，所以需要记录日志</span><br><span class="line">（这里自定义了@logo注解和切面类@Aspect，用AOP的相关知识）</span><br><span class="line">自定义注解@log和切面类@ASpect</span><br><span class="line">注解表示在切面类中使用切面表达式，@Around，@Before前置循环后置，将注解引入进来</span><br><span class="line">并写入插入数据库的逻辑</span><br><span class="line">这样只需要在方法中加入自定义注解就可以实现记录日志操作的过程</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>难点：消息推送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">难点：未读消息的推送：</span><br><span class="line">我们一开始这里写的是，轮询</span><br><span class="line">客户端定时的去服务器获取最新的消息</span><br><span class="line">前端写一个定时器，定时的去请求后端未读消息的字段</span><br><span class="line">去遍历数据库去查询，去查询未读的字段</span><br><span class="line"></span><br><span class="line">轮询的话其实实时性不是太好</span><br><span class="line">后来考虑过其他消息推送的方法</span><br><span class="line">websocket和SSE</span><br><span class="line"></span><br><span class="line">websocket是双向通信，但我们不需要客户端向服务端通信</span><br><span class="line">所以选用SSE轻量级的推送</span><br><span class="line"></span><br><span class="line">具体的做法就是</span><br><span class="line">Server-Sent Events (SSE) 是一种轻量级的、基于 HTTP 的消息推送技术。</span><br><span class="line">通过维持长连接，服务器可以实时推送消息。</span><br><span class="line"></span><br><span class="line">具体的做法就是要做两步</span><br><span class="line">1.订阅，将当前用户的Id传入，</span><br><span class="line">通过map的映射方式，创建一个与当前用户关联的seeEmitter对象</span><br><span class="line">放到map中去</span><br><span class="line">2.推送：从map中获取到与当前id绑定的seeEmitter对象</span><br><span class="line">调用send方法，将我的消息推送给用户</span><br><span class="line">（高并发场景下可以考虑使用消息队列，做异步的推送）</span><br></pre></td></tr></table></figure><p>广播消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 广播消息的基本流程</span><br><span class="line"></span><br><span class="line">创建广播消息：由管理员或系统创建消息，标记为广播消息。</span><br><span class="line">向所有用户发送消息：为每个用户生成一条用户与消息的关联记录，或在展示时判断为广播消息直接显示。</span><br><span class="line">用户读取消息：用户查看广播消息，更新相应的已读状态。</span><br><span class="line">消息过期或撤回：广播消息在到达过期时间后自动失效或撤回。</span><br><span class="line">查了广播消息的两种实现：</span><br></pre></td></tr></table></figure><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><p>OSI七层模型</p><p>计算机网络通信协议划分为七个不同层次的标准化框架</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20241107001440318.png" alt="image-20241107001440318" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp、ip是在传输层</span><br><span class="line">http，https是在应用层</span><br></pre></td></tr></table></figure><p>http和https的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">http协议就是客户端与服务端的超文本传输协议</span><br><span class="line">http协议分为请求协议和响应协议</span><br><span class="line">请求协议：浏览器将数据以请求格式发送到服务器</span><br><span class="line">包括：请求行、请求头 、请求体</span><br><span class="line">像get,post都在请求行中</span><br><span class="line"></span><br><span class="line">响应协议：服务器将数据以响应格式返回给浏览器</span><br><span class="line">包括：响应行 、响应头 、响应体</span><br><span class="line">常见的响应状态码就在向银行中</span><br><span class="line">1XX：响应中</span><br><span class="line">2XX：响应成功</span><br><span class="line">3XX：等待响应</span><br><span class="line">4XX：客户端错误</span><br><span class="line">5XX：服务端错误</span><br><span class="line">区别的话</span><br><span class="line">1.就是响应的端口号不同，http是端口80，https是端口443</span><br><span class="line">2.https在http的基础上，通过SSL/TSL协议对数据加密</span><br><span class="line">确保在数据传输的过程中的安全性，防止数据被窃取或者篡改</span><br><span class="line"></span><br><span class="line">9. SSL/TLS 握手过程（HTTPS 专有）</span><br><span class="line">在 HTTPS 通信开始时，客户端和服务器会进行一次 SSL/TLS 握手，主要步骤如下：</span><br><span class="line"></span><br><span class="line">客户端请求：客户端向服务器请求建立安全连接。</span><br><span class="line">服务器响应并发送证书：服务器响应并向客户端发送数字证书，证书包含服务器的公钥等信息。</span><br><span class="line">客户端验证证书：客户端验证证书的合法性，确保服务器是可信的。</span><br><span class="line">生成会话密钥：客户端使用服务器的公钥加密一个随机生成的对称密钥，发送给服务器。</span><br><span class="line">加密通信：服务器使用私钥解密出对称密钥，之后双方使用该对称密钥进行加密通信。</span><br></pre></td></tr></table></figure><p>tcp,ip协议，三次握手，四次挥手</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tcp、IP是传输控制、网络协议</span><br><span class="line">他是一种可靠的链接</span><br><span class="line">他通过三次握手。建立可靠链接</span><br><span class="line">四次挥手去释放链接</span><br><span class="line"></span><br><span class="line">三次握手（TCP连接建立过程）：</span><br><span class="line">SYN： 客户端发送一个SYN（同步）包，请求建立连接，标志着客户端想要与服务器建立连接。</span><br><span class="line">SYN-ACK： 服务器收到SYN包后，回应一个SYN-ACK包，表示服务器同意建立连接。</span><br><span class="line">ACK： 客户端收到服务器的SYN-ACK包后，发送一个ACK包确认，连接建立成功。</span><br><span class="line"></span><br><span class="line">四次挥手（TCP连接关闭过程）：</span><br><span class="line">FIN： 客户端发送一个FIN包，表示客户端没有数据发送了，准备关闭连接。</span><br><span class="line">ACK： 服务器收到FIN包后，发送ACK包确认，表示服务器已准备关闭连接。</span><br><span class="line">FIN： 服务器发送FIN包，表示服务器也没有数据发送了，准备关闭连接。</span><br><span class="line">ACK： 客户端收到服务器的FIN包后，发送ACK包确认，连接完全关闭。</span><br></pre></td></tr></table></figure><p>10.tcp和udp的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是两种传输程序协议</span><br><span class="line">tcp:传输前三次握手，建立的是可靠链接，建立链接较慢，</span><br><span class="line">用在需要可靠链接的地方，web端，电子邮件等</span><br><span class="line">udp:传输无需建立链接，而是直接发送数据报，建立链接较快，</span><br><span class="line">用在需要实时性高但是可以接受数据部分丢失的地方，直播，视频会议，游戏等</span><br></pre></td></tr></table></figure><h1 id="项目：学生点评："><a href="#项目：学生点评：" class="headerlink" title="项目：学生点评："></a>项目：学生点评：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发了类似大众点评的单体web应用，包括店铺管理，优惠券下单，以及用户互动等功能</span><br></pre></td></tr></table></figure><h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><p>以及每种数据类型的使用场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">String类型：Redis最常见的数据结构，可以存储任何数据，字符串，整形，浮点型都可以，</span><br><span class="line">不管用哪儿种方式，底层都是以字节数组的形式存储的，适用于绝大多数场景</span><br><span class="line"></span><br><span class="line">列表List：相当于Java中的linkedList，列表是链表结构，</span><br><span class="line">可以做简单的消息队列功能,但一般不用Redis消息队列</span><br><span class="line"></span><br><span class="line">集合分为集合和有序集合，</span><br><span class="line"></span><br><span class="line">集合set：没有重复元素的集合嘛，一般用于点赞，我们维护一张点赞的表，</span><br><span class="line">每次用户请求点赞的时候，我们先用StringRedisTemplete.opsForSet()</span><br><span class="line">得到操作Redis中set集合的接口，</span><br><span class="line">调用其中的isMember()，去判断点赞是否存在，</span><br><span class="line">不存在就用add加入，再跟新到数据库，存在就返回已经点赞</span><br><span class="line"></span><br><span class="line">共同好友也是，在关注的时候，把当前ID的关注列表以set形式存储到Redis中，</span><br><span class="line">然后，用set求交集的interset()</span><br><span class="line">就可以求得共同的好友交集，</span><br><span class="line"></span><br><span class="line">有序集合sorted set：相对于集合set，是有顺序的，</span><br><span class="line">每个元素都会关联一个权重，按照权重进行排序，</span><br><span class="line">我主要用在点赞的排行傍等，使用的权重是时间，点赞时间早的会排序在前面，</span><br><span class="line">用ZSET的range(key，0,4)方法得到排行前几的，</span><br><span class="line">当然不同的排行傍会有不同的权重，可以是分数或者其他，使用权重排序的方式是不变的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">哈希hash：键值对，适合缓存对象的存储，</span><br><span class="line">因为我们Redis本来就是以键值对key-value的形式存储的，</span><br><span class="line">一般hash存储用在value属性中，value属性存储的也是一对键值对</span><br><span class="line"></span><br><span class="line">位图bigMap：用于存储二进制数据，可以位运算，统计用户签到比较方便</span><br><span class="line"></span><br><span class="line">地理位置GEO：用于存储地理位置的数据结构，我们在数据库中将存放地理位置坐标的位置信息用stringRedisTemplete.opsForGeo接口的add方法存储到Redis中</span><br><span class="line">，再调用Geodistance查找距离，GeoRadius查询一定范围内的餐厅</span><br><span class="line">（这个需要先把商铺位置数据存储到Redis中去）</span><br><span class="line"></span><br><span class="line">HyperLogLog:基于基数的数据结构，支持对大量元素的去重统计，占用和误差很小，</span><br><span class="line">用于网站的访问统计等，底层是概率估算，</span><br><span class="line">我们首先要在线程池里获得当前用户的唯一标识，</span><br><span class="line">针对访客数，和访问量选取不同的标识</span><br><span class="line">针对访客数，因为是不可重复的，可以选用唯一账户ID等</span><br><span class="line">针对访问量，可以重复，当前线程中拿到的cookie即可</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="项目具体功能的实现逻辑"><a href="#项目具体功能的实现逻辑" class="headerlink" title="项目具体功能的实现逻辑"></a>项目具体功能的实现逻辑</h2><p>1.短信验证码的发送，登录、注册、校验</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">发送短信验证码：对手机号进行格式校验，然后随机生成验证码，</span><br><span class="line">引用阿里云的依赖并做配置文件的配置，然后响应给前端</span><br><span class="line"></span><br><span class="line">登录：得到手机号和验证码之后，去判断验证码是否正确，正确就登录成功，</span><br><span class="line">再去数据库中判断是否存在，不存在就创建一个用户，保存到数据库中，</span><br><span class="line">同时用uuid生成一个唯一的token作为key去在Redis中存放用户数据，设置一个过期时间</span><br><span class="line"></span><br><span class="line">校验登录状态是：设置一个拦截器prehandle，去拦截登录请求，</span><br><span class="line">获取token，去Redis中判断token是否存在，如果存在的话，就保存当前用户到线程池当中，</span><br><span class="line">这样我们后续在其他地方获取当前用户信息就只需要在线程池中获取即可</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cookie和session会话跟踪技术，去管理用户的状态，因为HTTP响应是无状态的，</span><br><span class="line">每次请求都是独立的，下次的请求不会携带上次的数据，所以需要会话跟踪技术</span><br><span class="line">cookie是客户端会话跟踪技术，存储数据在客户端浏览器中</span><br><span class="line"></span><br><span class="line">session是服务端会话跟踪技术，数据存储在服务端中</span><br><span class="line">底层通过cookie发送，只需要发送JessieId就可以了，在服务端就可以找到对应Id所在的当前数据</span><br><span class="line">相比于cookie会更安全一些</span><br></pre></td></tr></table></figure><p>2.Redis分布式锁的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透：就是大量请求的数据在缓存和数据库中都不存在，就会造成给数据库请求压力大的情况</span><br><span class="line"></span><br><span class="line">解决方法有：</span><br><span class="line">缓存空对象在缓存中</span><br><span class="line">布隆过滤：就是在Redis和客户端之间再加了一层布隆过滤器，存在则通过，不存在则拒绝，</span><br><span class="line">布隆过滤器是用hash思想实现的，它底层是一个庞大的二进制数组</span><br><span class="line">来了一个key之后对这个key取模存入数组</span><br><span class="line">再来就可以判断它key是否存在了</span><br><span class="line">当然有hash的地方就不可避免有hash冲突，但因为它底层数组够大，冲突不超过5%</span><br><span class="line"></span><br><span class="line">缓存击穿：缓存击穿就是，热点击穿嘛，热点key失效，很多线程来重建key，造成数据库的压力</span><br><span class="line">解决方法就是</span><br><span class="line">1.互斥锁，最先来的线程获取锁，去执行key的重建，其他的线程就会被阻塞</span><br><span class="line">2.逻辑过期：就是存储一个过期的时间的字段到缓存中，但我们并不设置过期时间</span><br><span class="line">当请求达到的时候，从缓存中获取数据，去判断一下这个过期字段，若过期则认为失效</span><br><span class="line">失效的时候，就开启另外一个线程，去更新缓存的逻辑过期时间</span><br><span class="line">当前线程就返回旧的数据</span><br><span class="line">利弊：互斥锁保证了数据的一致性，但是会收到锁竞争的影响，考虑死锁的问题</span><br><span class="line">逻辑过期保证了高的可用性，但是可能会出现数据不一致的问题</span><br><span class="line"></span><br><span class="line">缓存雪崩：就是我们设置key的时候，设置了一样的过期时间，导致一起失效，数据直接打到数据库的时候</span><br><span class="line">缓存雪崩与击穿不同的是，击穿是一个热点key失效，雪崩是很多key通用失效</span><br><span class="line">解决方法就是：在原有的失效时间的基础上，随机增加几分钟的随机值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">分布式锁的实现：简单来说就是用setnx这个方法，去在Redis中设置锁，</span><br><span class="line">如果插入key成功别人就获取不到，相当于加锁</span><br><span class="line">setex获取锁的过期时间，最后在完成业务逻辑之后，再去删除释放锁</span><br><span class="line"></span><br><span class="line">因为执行逻辑和删除是有时间差的，为了确保锁的一致性，防止极端宕机情况，</span><br><span class="line">最好使用lua脚本去执行锁的创建和删除</span><br><span class="line">lua脚本在Redis中执行是单线程的，所以一定会确保执行的时候的原子性</span><br><span class="line"></span><br><span class="line">当然自己实现的还是会有很多考虑不到的地方，比如可重入啊，可靠啊等等</span><br><span class="line">后面都是引入Redis依赖，用redisson的分布式锁实现的</span><br><span class="line">底层会有看门口机制解决死锁的问题，死锁就是业务逻辑异常导致锁无法释放的问题</span><br><span class="line">看门狗机制会在获取锁成功后启动任务，更新锁的过期时间，避免死锁的发生</span><br><span class="line"></span><br><span class="line">乐观锁和悲观锁：</span><br><span class="line">悲观锁：假定一定会发生多线程的问题，就只允许单线程执行，比如Synchronized关键字</span><br><span class="line">乐观锁：允许多线程，但是会有一个版本号，只是在更新数据的时候，</span><br><span class="line"> 判断是否其他线程对数据进行了修改，是的话重试即可</span><br></pre></td></tr></table></figure><p>3.lua脚本实现高并发环境下的一人一单和线程安全问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">就是在lua脚本中去定义本地的处理逻辑</span><br><span class="line">检查本地的数量是否足够</span><br><span class="line">判断用户是否已经下单</span><br><span class="line">再去减库存</span><br><span class="line">返回操作结果</span><br><span class="line"></span><br><span class="line">rabbitMQ消息队列：</span><br><span class="line">生产者去创建一个交换机，交换机负责投递消息到哪儿一个队列，队列再把消息传给消费者处理</span><br><span class="line">用注解@RabbitListener去配置</span><br></pre></td></tr></table></figure><p>4.点赞，共同关注，排行榜</p><p>5.地理位置下的店铺查询</p><p>6.统计访问量和访客量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">集合分为集合和有序集合，</span><br><span class="line"></span><br><span class="line">集合set：没有重复元素的集合嘛，一般用于点赞，我们维护一张点赞的表，</span><br><span class="line">每次用户请求点赞的时候，我们先用StringRedisTemplete.opsForSet()</span><br><span class="line">得到操作Redis中set集合的接口，调用其中的isMember()，</span><br><span class="line">去判断点赞是否存在，不存在就用add加入，再跟新到数据库，存在就返回已经点赞</span><br><span class="line"></span><br><span class="line">共同好友也是，在关注的时候，把当前ID的关注列表以set形式存储到Redis中，</span><br><span class="line">然后，用set求交集的interset()</span><br><span class="line">就可以求得共同的好友交集，</span><br><span class="line"></span><br><span class="line">有序集合sorted set：相对于集合set，是有顺序的，</span><br><span class="line">每个元素都会关联一个权重，按照权重进行排序，</span><br><span class="line">我主要用在点赞的排行傍等，使用的权重是时间，</span><br><span class="line">点赞时间早的会排序在前面，用ZSET的range(key，0,4)方法得到排行前几的，</span><br><span class="line">当然不同的排行傍会有不同的权重，可以是分数或者其他，使用权重排序的方式是不变的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">哈希hash：键值对，适合缓存对象的存储，</span><br><span class="line">因为我们Redis本来就是以键值对key-value的形式存储的，</span><br><span class="line">一般hash存储用在value属性中，value属性存储的也是一对键值对</span><br><span class="line"></span><br><span class="line">位图bigMap：用于存储二进制数据，可以位运算，统计用户签到比较方便</span><br><span class="line"></span><br><span class="line">地理位置GEO：用于存储地理位置的数据结构，</span><br><span class="line">我们在数据库中将存放地理位置坐标的位置信息用</span><br><span class="line">stringRedisTemplete.opsForGeo接口的add方法存储到Redis中，</span><br><span class="line">再调用Geodistance查找距离，GeoRadius查询一定范围内的餐厅</span><br><span class="line">（这个需要先把商铺位置数据存储到Redis中去）</span><br><span class="line"></span><br><span class="line">HyperLogLog:基于基数的数据结构，支持对大量元素的去重统计，占用和误差很小，</span><br><span class="line">用于网站的访问统计等，底层是概率估算，</span><br><span class="line">我们首先要在线程池里获得当前用户的唯一标识，</span><br><span class="line">针对访客数，和访问量选取不同的标识</span><br><span class="line">针对访客数，因为是不可重复的，可以选用唯一账户ID等</span><br><span class="line">针对访问量，可以重复，当前线程中拿到的cookie即可</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始使用了session做登录校验，从当前线程里获取到session但是session在分布式中不能共享，所以</span><br><span class="line">集成阿里云的短信服务，就是引入了阿里云的依赖，先是对，做了配置文件的配置，</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Redis，MQ的相关面试题"><a href="#Redis，MQ的相关面试题" class="headerlink" title="Redis，MQ的相关面试题"></a>Redis，MQ的相关面试题</h1><p>Redis和MySQL如何做读写一致性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">不一致的原因有：</span><br><span class="line">1.更新缓存&lt;-&gt;更新数据库的操作，当一方发生失败导致不一致</span><br><span class="line">2.缓存过期或者缓存失效导致不一致</span><br><span class="line">针对以上原因呢，常用的策略分两种：强一致性、最终一致性</span><br><span class="line">强一致性</span><br><span class="line">1.惰性加载策略：</span><br><span class="line">读的时候：缓存未命中，去数据库重建缓存</span><br><span class="line">写的时候：写入数据库，删除缓存就行</span><br><span class="line">2.延迟双删：</span><br><span class="line">更新数据库，删除缓存，等待一定时间，再删除缓存</span><br><span class="line">最终一致性：</span><br><span class="line">3.最终一致性：使用消息队列异步处理</span><br></pre></td></tr></table></figure><p>Redis实现缓存优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Redis中有多重的数据结构嘛，String，list，hash。set,zset等</span><br><span class="line">针对具体的场景去使用具体的字段</span><br><span class="line">2.对缓存击穿，缓存穿透，缓存雪崩的一个处理方式</span><br><span class="line">3.预加载，在系统启动的时候，对热点数据的放入Redis中</span><br></pre></td></tr></table></figure><p>Redis实现分布式锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">分布式锁的实现：简单来说就是用setnx这个方法，去在Redis中设置锁，</span><br><span class="line">如果插入key成功别人就获取不到，相当于加锁</span><br><span class="line">setex获取锁的过期时间，最后在完成业务逻辑之后，再去删除释放锁</span><br><span class="line"></span><br><span class="line">当然自己实现的还是会有很多考虑不到的地方，比如不可重入，不可重试，超时释放等等</span><br><span class="line">后面都是引入Redis依赖，用redisson的分布式锁实现的</span><br><span class="line"></span><br><span class="line">不可重入问题：所以当一个线程，里去调用多把锁的时候，</span><br><span class="line">就会出现第一把锁获取成功，其他锁获取失败的情况</span><br><span class="line">解决：通过设计计数器的方式解决的，如果同一线程再次请求锁，</span><br><span class="line">Redis会检查该线程的标识符，并增加计数器。只有在计数器为0时，</span><br><span class="line">其他线程才能获取锁。这种机制允许同一线程多次获取锁，</span><br><span class="line">而不会导致死锁，从而实现可重入性。</span><br><span class="line"></span><br><span class="line">不可重试：获取锁失败后的重试机制</span><br><span class="line">解决：获取失败后，在指定的时间间隔内重试</span><br><span class="line">超时释放：防止锁的持有者未示释放锁，导致死锁问题</span><br><span class="line">解决：看门狗机制</span><br><span class="line">定时的发送续约请求延长锁的有效期，时间是过期时间的1/3</span><br><span class="line">如果线程崩溃未能续约，就到期自动释放</span><br><span class="line">确保其他线程能获取锁</span><br><span class="line"></span><br><span class="line">乐观锁和悲观锁：</span><br><span class="line">悲观锁：假定一定会发生多线程的问题，就只允许单线程执行，比如Synchronized关键字</span><br><span class="line">乐观锁：允许多线程，但是会有一个版本号，只是在更新数据的时候，</span><br><span class="line"> 判断是否其他线程对数据进行了修改，是的话重试即可</span><br></pre></td></tr></table></figure><p>Redis解决高并发场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">这里是我在找实习前做的一个开源项目</span><br><span class="line">里面有一块优惠券秒杀的并发场景</span><br><span class="line">具体流程是：</span><br><span class="line">1.在秒杀开始的时候，将优惠券信息存放到Redis中</span><br><span class="line">检查本地的数量是否足够</span><br><span class="line">判断用户是否已经下单</span><br><span class="line">再去减库存</span><br><span class="line">给用户返回抢购操作结果</span><br><span class="line"></span><br><span class="line">异步的通过消息队列</span><br><span class="line">去执行订单的创建过程</span><br><span class="line">rabbitMQ消息队列：</span><br><span class="line">生产者去创建一个交换机，交换机负责投递消息到哪儿一个队列，队列再把消息传给消费者处理</span><br><span class="line">用注解@RabbitListener去配置</span><br></pre></td></tr></table></figure><p>Redis持久化是怎么做的呢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两种持久化方案：</span><br><span class="line">1.快照文件，把Redis存储的数据保存到磁盘上，方便宕机的时候做数据恢复</span><br><span class="line">2.追加文件，Redis操作写操作的时候，会存储到这个文件中去</span><br></pre></td></tr></table></figure><p>Redis的数据过期策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">惰性删除：一般不管，我们使用到key后，如果判断过期再删除</span><br><span class="line">定期删除：每隔一段时间对key进行检查，定期清理</span><br><span class="line">一般Redis中的过期删除策略，是结合这两部分来的</span><br></pre></td></tr></table></figure><p>Redis淘汰策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">很多，一把用LRU，对最近少使用的key淘汰</span><br></pre></td></tr></table></figure><p>Redis集群</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主从复制：数据从一个主节点复制到其他节点</span><br><span class="line">哨兵模式：哨兵作为独立的节点监控集群，发生故障时候执行故障转移</span><br><span class="line">分片模式：将数据分片到多个节点上</span><br></pre></td></tr></table></figure><h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><p>Linux常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">文件操作：ls,ll,</span><br><span class="line">进入目录：cd..  cd/  cd</span><br><span class="line">显示路径：pwd 创建目录 mkdir</span><br><span class="line">删除：rf 复制：cp 移动：mv</span><br><span class="line">chown修改目录权限</span><br><span class="line"></span><br><span class="line">top / htop：查看实时系统资源使用情况。</span><br><span class="line">df -h：查看磁盘空间使用情况。</span><br><span class="line">du -sh &lt;directory&gt;：查看目录大小。</span><br><span class="line">free -m：查看内存使用情况。</span><br><span class="line">uptime：查看系统运行时间和负载。</span><br><span class="line">uname -a：查看系统信息。</span><br><span class="line">date：查看或设置系统时间。</span><br><span class="line"></span><br><span class="line">等等</span><br><span class="line">ps 显示所有进程</span><br><span class="line">top 显示CPU的占用</span><br><span class="line">pgrep按照进程的名称查找ID</span><br><span class="line">find查找文件或目录，grep查找文件中的内容。</span><br></pre></td></tr></table></figure><p>项目部署docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">使用docker，我们需要将项目打个包为镜像，镜像包含应用的本身，也包含运行的环境依赖等等</span><br><span class="line">docker在运行的时候会创建一个容器，运行我们的镜像文件</span><br><span class="line"></span><br><span class="line">使用docker很方便</span><br><span class="line">我用docker在我的虚拟机中创建运行了</span><br><span class="line">MySQL</span><br><span class="line">Redis</span><br><span class="line">rabbitmq</span><br><span class="line">openjdk</span><br><span class="line">nginx</span><br><span class="line">注意的是：Redis和MySQL需要进行目录的挂载</span><br><span class="line">将容器内的目录映射到外边来</span><br><span class="line">这样我们删除创建容器的时候，数据不会丢失</span><br><span class="line"></span><br><span class="line">并且将自己的项目文件用Maven打包，构建dockerFile构建镜像</span><br><span class="line">然后再执行构建镜像即可</span><br><span class="line">Dockerfile</span><br><span class="line"># 选择基础镜像</span><br><span class="line">FROM openjdk:11-jre-slim</span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"># 将本地代码拷贝到容器中</span><br><span class="line">COPY target/myapp.jar /app/myapp.jar</span><br><span class="line"># 暴露应用运行的端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"># 设置启动命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;myapp.jar&quot;]</span><br></pre></td></tr></table></figure><p>nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">启动nginx，在配置文件中修改参数</span><br><span class="line">监听我程序运行的端口80</span><br><span class="line">然后反向代理给启动的两个服务：8080和8081</span><br><span class="line">选择负载均衡的方法有：轮询，最少连接，哈希等</span><br></pre></td></tr></table></figure><h1 id="数据库MySQL"><a href="#数据库MySQL" class="headerlink" title="数据库MySQL"></a>数据库MySQL</h1><p>MySQL和Oracle区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我平时自己使用的是MySQL</span><br><span class="line">在公司使用的是Oracle</span><br><span class="line">其实他们作为关系型的数据库</span><br><span class="line">在使用sql去操作方面几乎是一样的</span><br><span class="line">在事物索引方面也都支持</span><br><span class="line">就是建表的时候的语句不同</span><br><span class="line">Oracle可能作为一种商业软件</span><br><span class="line">稳定性和提供技术支持会好一些</span><br><span class="line"></span><br><span class="line">在 MySQL 中可以使用 LIMIT 来截取数据，</span><br><span class="line">而在 Oracle 中则需要使用 ROW NUM 或者 ROW_NUMBER() 来实现类似的分页效果。</span><br></pre></td></tr></table></figure><p>数据库事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一系列的数据库操作被当作一个单独的逻辑单元，要么全部执行，要么全部回滚</span><br><span class="line">数据库事务是为了确保事务的完整性和一致性</span><br><span class="line">数据库事务由四个属性组成ACID</span><br><span class="line">原子性：要么全部执行，要么全部回滚</span><br><span class="line">一致性：事务执行前后，数据库的数据处于一致状态</span><br><span class="line">隔离性：每个事务独立于其他事务</span><br><span class="line">持久性：事务执行成功，就是持久的</span><br><span class="line"></span><br><span class="line">在sql中使用 start Transaction作为事务的开启，rollback回滚，commit提交</span><br><span class="line">在spring框架中，在service层使用注解@Transactional开启事务</span><br><span class="line"></span><br><span class="line">MySQL事物的隔离级别</span><br><span class="line">未提交读：可以看到没有提交的事物</span><br><span class="line">已提交读：只能看到已经提交的事物</span><br><span class="line">可重复读：默认，重复读取结果一样</span><br><span class="line">串行化：串行读取，隔离级别最高，性能最差</span><br></pre></td></tr></table></figure><p>索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">索引是一种特殊的数据结构，用于加快数据库中数据的查询速度</span><br><span class="line">类似于书中的目录，可以帮助快速查找目录</span><br><span class="line"></span><br><span class="line">索引分为：</span><br><span class="line"></span><br><span class="line">使用create index ...去为字段创建索引</span><br><span class="line">一般来讲是where子句中频繁出现的列，在表的特定列上创建索引</span><br><span class="line"></span><br><span class="line">主键是会自动创建索引的</span><br><span class="line">索引的底层是通过B+树来存放的，我们创建索引时候</span><br><span class="line">会将当前字段插入B+树</span><br><span class="line">B+树是一个多路平衡查找树，</span><br><span class="line">所有叶子节点包含全部的键相互连接，方便查找</span><br><span class="line">非叶子节点只做索引，不含实际数据</span><br></pre></td></tr></table></figure><p>锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在并发访问时候，解决数据一致性和有效性的机制</span><br><span class="line">全局锁：对整个数据库加锁，在备份的时候加锁 flush tables with readlock</span><br><span class="line">表级锁：锁表 lock tables..</span><br><span class="line">行级锁：锁行 lock </span><br></pre></td></tr></table></figure><p>慢查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">我们一般去排查慢查询的sql语句可以用到两个</span><br><span class="line">1.就是在MySQL中开启慢查询日志我们</span><br><span class="line">需要在配置文件中，指定查询时间的阈值</span><br><span class="line">这个超过查询时间的sql就会被记录</span><br><span class="line">我们再用explain关键字去分析查询语句</span><br><span class="line">2.第三方的一些监控工具</span><br><span class="line">去监控数据库的性能指标</span><br><span class="line"></span><br><span class="line">我在实习中</span><br><span class="line">我们更多的是关注于接口的响应时间</span><br><span class="line">在需求书中对查询的要求就是＜2秒</span><br><span class="line">我一般在开发的时候，就会用sql优化的思想</span><br><span class="line">避免去写一些慢的sql</span><br><span class="line">比如说</span><br><span class="line">1.避免使用select*这样查询额外的数据</span><br><span class="line">2.使用索引的时候，避免写一些索引失效的例子</span><br><span class="line">3.避免一次性join三张以上的表等等</span><br></pre></td></tr></table></figure><p>sql优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.建标的时候选择合适的类型</span><br><span class="line">2.使用索引</span><br><span class="line">3.sql语句的编写</span><br><span class="line">尽量避免select*的情况，查询具体的字段</span><br><span class="line">    尽量少用子查询，用join关联查询代替</span><br><span class="line">尽量不使用or，导致索引失效，分开几条sql写</span><br><span class="line">执行的时候，批量插入，而不是一条一条插入，分批删除</span><br><span class="line">避免索引失效的写法</span><br><span class="line">4.主从复制</span><br><span class="line">5.读写分离</span><br><span class="line"></span><br><span class="line">建标选择合适的类型</span><br><span class="line">参考的是阿里云的开发手册，定义字段的时候，选择合适的字段内容来建标</span><br><span class="line">字符串就结合存储的内容来使用char  或者varchar</span><br><span class="line">用户名称邮箱类型的，使用varchar</span><br><span class="line">文章内容使用text</span><br><span class="line">邮编长度使用char等等</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sql的执行顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select * from where groupby having orderby limit</span><br><span class="line"></span><br><span class="line">先执行from语句，查询确定查的表</span><br><span class="line">再是链接条件，join on</span><br><span class="line">再是where 过滤符合条件的</span><br><span class="line">再groupby分组</span><br><span class="line">having分组后过滤</span><br><span class="line">最后排序，limit输出</span><br><span class="line"></span><br><span class="line">where是分组前过滤，having是分组后过滤</span><br></pre></td></tr></table></figure><p>MySQL的读写分离如何实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读写分离的核心是通过主从复制实现数据同步。</span><br><span class="line">主库负责写操作，从库负责读操作</span><br><span class="line">主从复制是通过二进制文件binlog实现的</span><br><span class="line">就是说：主库上的数据变更，插入更新删除，都会记录在binlog中</span><br><span class="line">从库区读取binlog日志，按顺序执行这些操作</span><br><span class="line">从而是的从库与主库保存一致</span><br></pre></td></tr></table></figure><p>MySQL的事物隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL的事物隔离级别就是：定义了一个事物的执行过程中</span><br><span class="line">能看到其他事物对数据库的更改程度</span><br><span class="line">MySQL支持四中事物隔离级别</span><br><span class="line">读未提交：读其他事物未提交的数据</span><br><span class="line">读已提交：只能读其他事物提交的数据</span><br><span class="line">可重复读（默认）：事物内多次读取同一数据，结果是相同的</span><br><span class="line">串行化：事物完全串行化执行，避免发生事物冲突</span><br></pre></td></tr></table></figure><p>数据库的三范式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">对数据库规范化的一种定义嘛</span><br><span class="line">目的是保证数据的一致性，减少数据的冗余性</span><br><span class="line">第一范式（1NF）规定：</span><br><span class="line">数据表中的每个字段必须是原子性的，不可再分。</span><br><span class="line">比如说我们有一个商品列，记录的数据内容是5台电脑，那这就不符合第一范式了，</span><br><span class="line">因为五台电脑这个字段可以分为商品数量 5台 和商品名称 电脑 两个字段。</span><br><span class="line"></span><br><span class="line">所以说1NF这意味着一个字段不能包含多个值或重复的组合。1NF是所有关系型数据库的最基本要求。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二范式（2NF）规定：</span><br><span class="line">首先，数据表必须符合第一范式（1NF）。</span><br><span class="line">其次，数据表中的非主键字段必须完全依赖于主键，部分依赖都不行。</span><br><span class="line"></span><br><span class="line">如果有一个表（学生ID，课程ID，成绩）存储学生信息和课程成绩，</span><br><span class="line">成绩字段只依赖于学生ID和课程ID的组合主键，而不是单独依赖于学生ID。</span><br><span class="line">此时可以将表分成两个：一个存储学生信息，另一个存储课程成绩。</span><br><span class="line">所以说2NF这意味着一张表只能描述一件事情。</span><br><span class="line"></span><br><span class="line">第三范式（3NF）规定：</span><br><span class="line">首先，数据表必须符合第一范式（1NF）和第二范式（2NF）。</span><br><span class="line">其次，数据表中的非主键字段之间不能存在依赖关系。</span><br><span class="line">也就是说不能存在某非主键字段 A 可以确定 某非主键字段 B。</span><br><span class="line"></span><br><span class="line"> 如果有一个表（学号，学生姓名，学生地址，学生班级名称），</span><br><span class="line"> 其中“班级名称”依赖于“班级ID”，而“班级ID”又依赖于“学号”。</span><br><span class="line"> 这种情况下，可以通过将“班级名称”移到另一个表中，减少冗余数据。</span><br></pre></td></tr></table></figure><h1 id="spring-Web框架"><a href="#spring-Web框架" class="headerlink" title="spring Web框架"></a>spring Web框架</h1><p>spring框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring是Java开发的框架，有很多模块</span><br><span class="line">spring框架的web开发模块，就是springMVC</span><br><span class="line">springMVC + spring framework + Mybatis 就是俗称SSM</span><br><span class="line">springboot整合了ssm，快速开发</span><br></pre></td></tr></table></figure><p>springMVC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring MVC是Java中的web应用的框架</span><br><span class="line">采用了 model-view-control的结构</span><br><span class="line">来简化web端的开发</span><br><span class="line">model层：就是模型层，一般是数据库的实体、数据传输对象</span><br><span class="line">view层：视图层，接受控制器中传来的模型数据</span><br><span class="line">  根据数据生成HTML的响应格式，返回给用户</span><br><span class="line">Controller:控制层：处理用户请求，查询数据，选择合适的视图展示</span><br><span class="line"></span><br><span class="line">整个处理流程就是：</span><br><span class="line">control接受到http请求，</span><br><span class="line">根据请求的 URL 和参数，确定需要执行的业务逻辑，</span><br><span class="line">调用相应的服务层，获取模型数据，</span><br><span class="line">并将模型和视图进行结合，最终返回响应给用户。</span><br></pre></td></tr></table></figure><p>IOC控制反转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是一种设计模式，将原本在程序中手动创建对象的控制权，交给spring框架来管理</span><br><span class="line">IOC容器就是工厂一样，当我们需要创建一个对象的时候</span><br><span class="line">只需要用注解@Autowired，而不需要考虑对象是如何创建出来的</span><br><span class="line"></span><br><span class="line">Bean指的是被IOC容器所管理的对象</span><br></pre></td></tr></table></figure><p>AOP面相切面编程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AOP是spring的核心框架之一，它在程序运行时动态将额外的行为</span><br><span class="line">比如记录日志操作，事务处理，方法运行时间等功能，额外的插入到代码中</span><br><span class="line"></span><br><span class="line">它是通过动态代理的方式实现的</span><br><span class="line">JDK 动态代理：适用于实现了接口的类，代理对象会实现相同的接口，通过代理类执行增强逻辑。</span><br><span class="line">Spring 利用 java.lang.reflect.Proxy 生成代理对象。</span><br><span class="line">CGLIB 动态代理：适用于没有实现接口的类，CGLIB 通过生成目标类的子类并重写其方法来实现代理。</span><br><span class="line">Spring 会在需要时使用 CGLIB 代理。</span><br><span class="line"></span><br><span class="line">我在项目中用AOP的实现过程，对数据库修改操作的日志记录的实现过程</span><br><span class="line">创建操作日志的表格嘛，操作人Id，时间方法参数等</span><br><span class="line">根据表格创建实体类</span><br><span class="line">用@interface去自定义注解，用于标记需要记录日志的方法</span><br><span class="line">注解的格式：</span><br><span class="line">public @interface 名称&#123;</span><br><span class="line">public 属性类型 属性名称（） default 默认值；</span><br><span class="line">&#125;</span><br><span class="line">注解表示在切面类中使用切面表达式，@Around，@Before前置循环后置，将注解引入进来</span><br><span class="line">并写入插入日志的业务逻辑就行</span><br><span class="line">这样只需要在方法中加入自定义注解就可以实现记录日志操作的过程</span><br></pre></td></tr></table></figure><p>spring框架用到了哪儿些设计模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">单例模式：spring中的bean是单例的，通过IOC容器对Bean管理，保证整个应用只有一个Bean实例</span><br><span class="line">工厂模式：springIOC负责容器的创建和管理实例，可以将IOC看做是一个工厂</span><br><span class="line">我们不需要知道对象是如何创建的</span><br><span class="line">只需要用注解直接注入对象就行</span><br><span class="line"></span><br><span class="line">代理模式：spring的AOP面相切面编程就用到了代理模式</span><br><span class="line">实现proxy类的方法，生成代理对象，在其他地方通过代理对象去调用方法</span><br><span class="line">我在项目中遇到的</span><br><span class="line">流程实例发布后，会创建事件对象给spring事件系统</span><br><span class="line">然后就是使用注解@EventListener标注方法去监听</span><br><span class="line">判断是不是 当前流程的事件</span><br><span class="line">如果是的话，就调用通知类中的方法，去发送通知给需要审批的人员   </span><br></pre></td></tr></table></figure><p>spring事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Trancsacyional注解</span><br><span class="line">默认是required</span><br><span class="line">事务的传播，如果当前有事务，就加入该事务，如果没有，就创建新的事务</span><br></pre></td></tr></table></figure><p>spring的常用注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">最先就是启动注解@SpringBootApplication了，里面包含三个注解</span><br><span class="line">然后就是三层架构的</span><br><span class="line">@RestController @Service @MApper</span><br><span class="line"></span><br><span class="line">在controller层</span><br><span class="line">去处理请求HTTP相关的注解</span><br><span class="line">@GetMapping @PostMapping @DeleteMapping等</span><br><span class="line">传值相关的注解</span><br><span class="line">@RequestBody @PathVariable @RequestParam等</span><br><span class="line">mapper层的数据库注解</span><br><span class="line">@Insert @Select @Delete 等等</span><br><span class="line"></span><br><span class="line">还要通用的 @AutWired @configuration @Transcactional等等</span><br></pre></td></tr></table></figure><p>mybatis 和mybatisPlus的联系区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mybatis是用Java操作数据的的持久层框架，主要使用xml或者注解来配置sql语句</span><br><span class="line">使用时，会创建数据库连接池，解决了资源重用，提示响应</span><br><span class="line"></span><br><span class="line">MP内置了增删改查，通过扫描实体类，基于反射获取实体类的信息，作为数据库的信息表</span><br><span class="line">一般来讲，单表的增删改查就有MP实现</span><br><span class="line">多表的联合查询就没法用MP了，用mybatis去写</span><br><span class="line"></span><br><span class="line">MP自带了分页查询插件，不用去引入第三方的依赖，很方便</span><br><span class="line">创建一个Page&lt;&gt;对象，然后调用selectPage（）方法</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><h1 id="JVM面试题"><a href="#JVM面试题" class="headerlink" title="JVM面试题"></a>JVM面试题</h1><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/p9SowJU.png" alt="img"></p><p><code>内存模型</code>：各个部分的作用，保存哪儿些数据</p><p><code>类加载</code>：双亲委派加载机制，常用加载器分别加载哪儿种类型的类</p><p><code>GC</code>：分带回收的思想依据</p><p><code>性能调优</code>：JVM工具，性能分析工具</p><p><code>执行模式</code>：解释模式，编译模式，混合模式等</p><p><code>编译器优化</code>：javac的变异过程</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom:50%;"><p>线程私有：栈，本地方法栈，程序计数器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">栈</span><br><span class="line">又称方法栈，线程私有的，线程执行方法是都会创建一个栈帧，</span><br><span class="line">用来存储局部变量表、操作栈、动态链接、方法出口等信息。</span><br><span class="line">调用方法时执行入栈，方法返回时执行出栈</span><br><span class="line"></span><br><span class="line">本地方法栈</span><br><span class="line">与栈类似，也是用来保存执行方法的信息，</span><br><span class="line">执行Java方法是使用占，执行Native方法时是使用本地方法栈</span><br><span class="line"></span><br><span class="line">程序计数器</span><br><span class="line">保存当前线程执行的字节码位置，每个线程工作时都有独立的计数器，</span><br><span class="line">值为执行Java方法服务，执行Native方法时，程序计数器为空</span><br></pre></td></tr></table></figure><p>线程共享：堆，方法区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">堆</span><br><span class="line">JVM内存管理最大的一块，堆被线程共享，目的是存放对象的实例，几乎所有对象的实例都会放在这里。</span><br><span class="line">当堆没有可用空间时，会抛出OOM异常(Out of Menory内存溢出)，根据对象的存活周期不同，</span><br><span class="line">JVM把对象进行分代管理，由垃圾回收器进行垃圾的回收管理</span><br><span class="line">新生代内存(Young Generation)</span><br><span class="line">老生代(Old Generation)</span><br><span class="line">永久代(Permanent Generation)、1.8版本：元空间</span><br><span class="line"></span><br><span class="line">方法区</span><br><span class="line">又称非堆区，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器优化后的代码等数据</span><br><span class="line">1.7的永久代和1.8的源空间都是方法区的一种实现</span><br></pre></td></tr></table></figure><p>类的加载和卸载</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240606101850630.png" alt="image-20240606101850630" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">加载：通过类的全限定名，查找此类的字节码文件，利用字节码文件创建Class对象</span><br><span class="line"></span><br><span class="line">链接：分为三个阶段</span><br><span class="line">验证：确保Class文件符合当前虚拟机的要求，不会危害到虚拟机自身安全</span><br><span class="line">准备：进行内存分配，为static修饰的类变量分配内存，并设置初始值(0或null)，</span><br><span class="line">不包含final修饰的静态变量，因为final变量在编译时就分配好了</span><br><span class="line">解析：将常量池中的符号引用替换为直接引用的过程，直接引用为直接指向目标的指针或者相对偏移量等</span><br><span class="line">初始化：主要完成静态块执行以及静态变量的复制，先初始化父类，再初始化当前类。</span><br><span class="line">初始化是懒惰的，只有对类主动使用的时候才会初始化</span><br></pre></td></tr></table></figure><p>加载机制：双亲委派机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加载机制：双亲委派模式</span><br><span class="line">当一个类加载器收到类加载请求时，它首先会将这个请求委托给父类加载器去处理。</span><br><span class="line">如果父类加载器无法加载该类，则该类加载器才会自己去加载这个类。</span><br><span class="line">优点：避免类的重复加载，避免Java的核心API被篡改</span><br></pre></td></tr></table></figure><p>卸载过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类卸载的实现依赖于JVM的垃圾回收机制。当一个类不再被引用时</span><br><span class="line">JVM可能会通过垃圾回收机制将该类的实例回收</span><br></pre></td></tr></table></figure><p>对象的创建过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java对象的创建过程可以概括为以下几个步骤</span><br><span class="line"></span><br><span class="line">类加载：JVM会先检查类是否已经被加载了，如果没有则通过类加载器加载类的class文件，并将类的信息存储到方法区中</span><br><span class="line">内存分配：当类被加载后，JVM会为该类的对象分配内存，根据Java对象的特点，</span><br><span class="line">内存大小是在编译时就已经确定的，因此内存分配可以通过一些简单的算法来实现，例如指针碰撞和空闲列表等</span><br><span class="line">初始化：内存分配完成后，JVM会对对象进行默认初始化，即将对象的成员变量赋上默认值。</span><br><span class="line">基本类型的默认值是0或false，引用类型的默认值是null</span><br><span class="line">构造函数：默认初始化后，JVM会调用该对象的构造函数，进行对象的属性初始化和一些其他操作</span><br><span class="line">返回地址：构造函数执行完毕后，JVM会将对象的引用返回给调用者，此时对象创建过程完毕</span><br></pre></td></tr></table></figure><p>JVM中的垃圾回收机制，大致说一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GC是JVM的垃圾回收机制</span><br><span class="line">首先GC有多种算法：</span><br><span class="line">标记清除：遍历整个堆，清除所有未标记的对象，将其内存空间释放。</span><br><span class="line">标记压缩：将所有存活的对象压缩到堆的一端，保持连续的内存空间，清除端释放未使用的空间。</span><br><span class="line">复制算法：将堆内存分成两部分，活动对象从一个区域复制到另一个区域，不活动的对象直接丢弃</span><br><span class="line">（新生代）</span><br><span class="line">堆内存区域划分：</span><br><span class="line">新生代，老年代，元空间</span><br><span class="line">GC的过程：</span><br><span class="line">minor GC：年轻代满的时候发生，主要复制算法</span><br><span class="line">Full GC：老年代空间不够用的时候</span><br><span class="line"></span><br><span class="line">垃圾收集器</span><br><span class="line">JVM 提供了多种垃圾收集器，不同收集器适用于不同的应用场景：</span><br><span class="line"></span><br><span class="line">Serial 收集器：适用于单线程环境，简单高效。</span><br><span class="line">Parallel 收集器：适用于多线程环境，采用并行的方式进行垃圾回收。</span><br><span class="line">CMS（Concurrent Mark-Sweep）收集器：适用于低停顿时间的应用，主要用于老年代的垃圾回收。</span><br><span class="line">G1（Garbage First）收集器：适用于大内存和高吞吐量的应用，采用分区算法，能够并发和并行回收内存。</span><br></pre></td></tr></table></figure><p>有看过GC日志吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">没看过</span><br><span class="line">调用System.gc()方法后</span><br><span class="line">在IDEA中的application配置那里</span><br><span class="line">输入一个什么命令去查看</span><br><span class="line">-Xlog:gc*:file=&lt;path-to-log-file&gt;:time,uptime:filecount=10,filesize=10M</span><br></pre></td></tr></table></figure><p>如何判断一个对象是垃圾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.没有被引用的指向时候</span><br><span class="line">2，无法通过引用链到达的时候</span><br><span class="line">3,没有重写finalize方法</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>线程池</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程池：管理线程的池子，可以容纳多个线程，省去了频繁创建线程的操作</span><br><span class="line">Java中有几种常见的线程池，都是去实现了ThreadPoolExecutor这个类</span><br><span class="line">用这个类的构造器，去设置参数，核心线程，最大线程，超时时长，任务队列等</span><br><span class="line">可以直接用，然后重写run方法实现的</span><br><span class="line"></span><br><span class="line">设计一个线程池嘛</span><br><span class="line">1.创建N个线程</span><br><span class="line">2.把任务提交给线程运行</span><br><span class="line">3.线程满的话，就放入队列</span><br><span class="line">4，空闲时，从队列去除执行</span><br><span class="line"></span><br><span class="line">使用场景：异步处理的时候要用到线程池开启线程，并发处理的时候也需要</span><br></pre></td></tr></table></figure><p>threadLocal</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread Local本地线程嘛，就是线程可以独立的获取自己的变量副本</span><br><span class="line">而不是共享变量，从而避免多线程的资源共享问题</span><br><span class="line">一般就是在拦截器intercepter中去拦截，然后将当前用户的信息放进去</span><br><span class="line">这样在其他地方就可以拿到用户信息</span><br><span class="line">最后remove清理变量</span><br><span class="line"></span><br><span class="line">原理：每隔线程都会维护一个ThreadLocalMap</span><br><span class="line">用于存储ThreadLocal以及其数据</span><br><span class="line">调用 threadLocal.set(value) 时，</span><br><span class="line">当前线程的 ThreadLocalMap 会将 ThreadLocal 对象作为键，value 作为值存储起来。</span><br><span class="line">获取值：调用 threadLocal.get() 时，</span><br><span class="line">当前线程的 ThreadLocalMap 会通过 ThreadLocal 对象查找并返回对应的值。</span><br></pre></td></tr></table></figure><p>进程。线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">进程就是计算机的运行实例，就比如说我启动一个服务就是一个进程</span><br><span class="line">一个进程中会有多个线程</span><br><span class="line">进程间相互独立，线程间共享进程的资源等</span><br><span class="line"></span><br><span class="line">进程中的通信方式：共享内存，允许多个进程访问同一块内存区域</span><br><span class="line">线程中的通信方式：共享变量，成员变量</span><br><span class="line">使用wait方法进入等待状态，等其他线程notify通知</span><br><span class="line">或者使用消息队列去传递消息</span><br></pre></td></tr></table></figure><p>死锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">死锁就是：多线程的情况下，两个或者多个线程去竞争资源，</span><br><span class="line">但是都获取不到锁，从而导致卡主无法执行的情况</span><br><span class="line">死锁的四个必要条件：</span><br><span class="line">1.互斥条件：就是说：我得到了你就不能获取</span><br><span class="line">2.占有并等待条件：一个进程已经持有至少一个资源，</span><br><span class="line">但又请求其他资源，并且这些资源被其他进程持有。</span><br><span class="line">3.不剥夺条件：在使用完成之前，不能被剥夺</span><br><span class="line">4.循环等待条件：A等B，B等c这样</span><br><span class="line"></span><br><span class="line">我们要解决死锁，就要破坏他的条件：</span><br><span class="line">1.破坏占有并等待，就是在运行前的时候分配全部资源</span><br><span class="line">2.破坏循环等待，就是对资源的优先级进行编号按熟悉处理，</span><br></pre></td></tr></table></figure><h1 id="搭建网站的困难"><a href="#搭建网站的困难" class="headerlink" title="搭建网站的困难"></a>搭建网站的困难</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.基于hexo这样一种静态的heml博客生成框架，一开始的时候，部署在GitHub上</span><br><span class="line">然后发现这样访问太慢了。后来就看了一些解决方案，部署在vercel上</span><br><span class="line">2.性能优化，我的网页包含大量静态资源，图片，CSS，JS等</span><br><span class="line">然后我部署图片将JPG等格式转为WEPG这样的格式，</span><br><span class="line">把JS放在页脚做优化</span><br><span class="line">3.组件的兼容性</span><br><span class="line">样式和组件集成：使用npm引入组件时，可能会遇到组件兼容性问题，</span><br><span class="line">别如说我再的进度条，还有分页组件等</span><br><span class="line">就会有bug，后来也是换了一个组件解决了</span><br><span class="line"></span><br><span class="line">特别是在不同浏览器和设备上显示效果不同</span><br></pre></td></tr></table></figure><p>为什么搭建网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1，这个来源于机缘巧合吧，我在今年找实习那会儿牛可看别人简历有</span><br><span class="line">我想到自己其实也比较喜欢记录</span><br><span class="line">记录了很多笔记</span><br><span class="line">我觉得这个是一个展示机会吧</span><br><span class="line">展示自己的个人学习成长过程</span><br><span class="line">所以就做下去了</span><br><span class="line">2.因为学习也是与遗忘做斗争的事情嘛</span><br><span class="line">我自己记录的，我回顾起来很方便</span><br><span class="line">打开网页就能访问，方便我在知识遗忘的过程中做回顾</span><br><span class="line">3.我正做开源项目的时候，会写历程</span><br><span class="line">我会写一些面试总结，面试心得和经验这些</span><br><span class="line">也帮助到我的同门他们，他们在做项目或者面试的时候也会看</span><br><span class="line">这个算是对我来说是一种正向激励吧</span><br><span class="line">4.自己也学到了一些技术吧</span><br><span class="line">接触到了hexo这样的开源框架，</span><br><span class="line">使用到阿里云的OSS，DNS</span><br><span class="line">去做访问优化</span><br></pre></td></tr></table></figure><p>static关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作为一种静态关键字，可以修饰</span><br><span class="line">1.修饰属性：就是说当前对象属于类本身而不是某个对象</span><br><span class="line">一般用到全局常量的时候会用到static修饰</span><br><span class="line">2.修饰方法：当前方法属于类的方法不属于实例的方法</span><br><span class="line">3.静态代码块：在类加载的时候执行一次，所以适合去做初始化</span><br><span class="line">我在做导出到处校验的时候，就会定义一个common类</span><br><span class="line">定义map做一些数据的映射</span><br></pre></td></tr></table></figure><p>软件的设计原则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开放闭合原则</span><br><span class="line">高内聚低耦合</span><br></pre></td></tr></table></figure><h2 id="vue2前端"><a href="#vue2前端" class="headerlink" title="vue2前端"></a>vue2前端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">前端这块，我在实习中主要是</span><br><span class="line">一些页面的编写</span><br><span class="line">引入他们一些自定义的组件</span><br><span class="line">或者说是elementUI的组件</span><br><span class="line">去配置页面的路由</span><br><span class="line">配置方法的api</span><br><span class="line">然后我去后端写方法</span><br><span class="line">获取数值，返回给前端的方法</span><br><span class="line"></span><br><span class="line">有些还需要前端处理一些数据</span><br><span class="line">想有些组件除了数据还需要颜色</span><br><span class="line">这些返回值</span><br></pre></td></tr></table></figure><p>父组件向自组件传值用props</p><p>子组建向父组件传值用emit</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记 热门100篇</title>
      <link href="/2024/09/27/leetcode/hot_100/"/>
      <url>/2024/09/27/leetcode/hot_100/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣HOT100"><a href="#力扣HOT100" class="headerlink" title="力扣HOT100"></a>力扣HOT100</h1>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
          <category> hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> hot100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秋招笔试算法题汇总</title>
      <link href="/2024/09/27/Written%20Examination/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2024/09/27/Written%20Examination/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="秋招笔试算法题汇总"><a href="#秋招笔试算法题汇总" class="headerlink" title="秋招笔试算法题汇总"></a>秋招笔试算法题汇总</h1><h2 id="中兴"><a href="#中兴" class="headerlink" title="中兴"></a>中兴</h2><h3 id="1-字符排序"><a href="#1-字符排序" class="headerlink" title="1.字符排序"></a>1.字符排序</h3><p>给定一个正整数及非负整数 nus 的列表，第一个正整数表示nums列表中数字的总个数，需要将nums列表中数据排列组合出一个最大的数并返回它</p><p>思路：排序，拼接，再输出，按照拼接的字符排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输入第一个数字，表示待组合数据的总个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输入待组合的数字</span></span><br><span class="line">        String[] nums = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = scanner.next();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自定义排序，按拼接后的字符串降序排序</span></span><br><span class="line">        Arrays.sort(nums, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">order1</span> <span class="operator">=</span> a + b;</span><br><span class="line">                <span class="type">String</span> <span class="variable">order2</span> <span class="operator">=</span> b + a;</span><br><span class="line">                <span class="comment">// 按照组合后的字符串降序排序</span></span><br><span class="line">                <span class="keyword">return</span> order2.compareTo(order1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 处理特殊情况：如果最大的数是&quot;0&quot;，直接返回&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>].equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拼接排序后的数组</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String num : nums) &#123;</span><br><span class="line">            result.append(num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的自定义比较器可以用Java8简写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式自定义排序，按拼接后的字符串降序排序</span></span><br><span class="line">Arrays.sort(nums, (a, b) -&gt; (b + a).compareTo(a + b));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>compareTo</code> 是 <code>String</code> 类中的一个方法，作用是比较两个字符串的字典顺序。</p><ul><li>如果字符串 <code>s1</code> 大于字符串 <code>s2</code>，<code>s1.compareTo(s2)</code> 返回正整数。</li><li>如果 <code>s1</code> 等于 <code>s2</code>，返回0。</li><li>如果 <code>s1</code> 小于 <code>s2</code>，返回负整数。</li></ul><h3 id="2-动态规划问题"><a href="#2-动态规划问题" class="headerlink" title="2.动态规划问题"></a>2.动态规划问题</h3><p>新郎可以一次走一个或者两个台阶，每个台阶都要花费钱这种问题</p><p>给定每个台阶的花费，然后求最小花费</p><p>思路：动态规划数组，dp[i] &#x3D; min{dp[i-1]*cost[i-1], dp[i-2],cost[i-2]};</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">topic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + arr[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + arr[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h2><h3 id="1-石头问题"><a href="#1-石头问题" class="headerlink" title="1.石头问题"></a>1.石头问题</h3><p>桌子上放了一排石头，有n个，每块石头的颜色可以是红色，绿色或蓝色。现在要从这排石头取出的数个石头，以便剩余的石头里面，任何两颗相邻的石头具有不同的颜色的(取出1块石头后，就认为两边的石头是相邻的)请根据输入的石头数量、排序和颜色，计算最少要取出几块石头?</p><p>思路：遇到重复的，取出，count++</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">topic1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; next.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(next.charAt(i) == next.charAt(i+<span class="number">1</span>))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-最长子数组"><a href="#2-最长子数组" class="headerlink" title="2.最长子数组"></a>2.最长子数组</h3><p>给定一个数组，求不重复元素的最长子数组的长度</p><p>思路：滑动窗口，使用一个set集合放不重复的元素，更新最大长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 秋招 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 秋招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity7工作流</title>
      <link href="/2024/09/27/Project/Activity%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
      <url>/2024/09/27/Project/Activity%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Activity7工作流"><a href="#Activity7工作流" class="headerlink" title="Activity7工作流"></a>Activity7工作流</h1><h2 id="1-工作流介绍"><a href="#1-工作流介绍" class="headerlink" title="1.工作流介绍"></a>1.工作流介绍</h2><p>workflow通过计算机对业务流程自动化管理，用于设计、执行和监控复杂的业务流程</p><p>应用领域</p><p>企业: 采购流程、合同审核流程</p><p>客户: 客户电话投诉处理流程</p><p>生活中: 住房贷款审批流程、办理身份证、办理准生手续</p><p>行政: 出差审批、报销流程、请假审批、用车流程、会议室申请</p><p>银行业: 信贷审批、信用卡发卡审批</p><p>人事: 员工培训、绩效考核、职位变动</p><p>现实中的例子-<strong>出差费用报销</strong></p><h2 id="2-工作流引擎"><a href="#2-工作流引擎" class="headerlink" title="2.工作流引擎"></a>2.工作流引擎</h2><p>是一种按照预定义规则的[符合bpmn规范]进行部署</p><p>将业务节点的流程进行分离的特定形式的关联，实现节点自动流转的工作流框架</p><p>1.需要将预定于的流程文件BPMN部署到工作流引擎中,会把节点,路径信息存储到数据库</p><p>中.</p><p>2.工作流引擎提供了大量的API对流程进行查询处理,细节都是对应用程序屏蔽的,大大提供</p><p>开发效率</p><p>3.业务逻辑的处理和流程的流转是分离的，是通过BusinessKey进行关联的.</p><h2 id="Activity7"><a href="#Activity7" class="headerlink" title="Activity7"></a>Activity7</h2><p>Activiti 是一个工作流引擎， activiti 可以将业务系统中复杂的业务流程抽取出来，使</p><p>用专门的建模语言（BPMN2.0）进行定义，业务系统按照预先定义的流程进行执行，实现了</p><p>业务系统的业务流程由 activiti 进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，</p><p>从而提高系统的健壮性，同时也减少了系统开发维护成本。</p><h2 id="Activity7内部核心机制"><a href="#Activity7内部核心机制" class="headerlink" title="Activity7内部核心机制"></a>Activity7内部核心机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.业务流程图要规范化，需要遵守一套标准。</span><br><span class="line">2.业务流程图本质上就是一个XML文件，而XML可以存放所要的数据。</span><br><span class="line">᲼</span><br><span class="line">3.读取业务流程图的过程就是解析XML文件的过程。</span><br><span class="line">4.读取一个业务流程图的结点就相当于解析一个XML的结点，进一步将数据插入到</span><br><span class="line">MySQL表中，形成一条记录。</span><br><span class="line">5.将一个业务流程图的所有节点都读取并存入到MySQL表中。</span><br><span class="line">6.后面只要读取MySQL表中的记录就相当于读取业务流程图的一个节点。</span><br><span class="line">7.业务流程的推进，后面就转换为读取表中的数据，并且处理数据，结束的时候这</span><br><span class="line">一行数据就可以删除了。</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240715233900634.png" alt="image-20240715233900634"></p><h2 id="BPMN"><a href="#BPMN" class="headerlink" title="BPMN"></a>BPMN</h2><p>BPMN（Business Process Model And Notation），业务流程模型和符号</p><p>Activit就是使用BPMN2.0进行流程建模、流程执行管理，它包括很多的建模符号。</p><p>BPMN是用XML的形式表示流程业务的，我们画的流程图就会转为XML文件，交给Activity解析</p><h1 id="Activity使用步骤"><a href="#Activity使用步骤" class="headerlink" title="Activity使用步骤"></a>Activity使用步骤</h1><p>如何使用Activity工作流</p><p>1.整合Activity</p><ul><li>Activiti是一个工作流引擎，业务系统使用Activiti来对系统的业务流程进行自动化管理，为了方便业务系统访问（操作）Activiti的接口或功能，通常将Activiti和业务系统的环境集成在一起。</li></ul><p>2.业务流程建模</p><ul><li><p>使用Activiti流程建模工具(Activity-designer)定义业务流程(.bpmn文件)。</p></li><li><p>.bpmn文件就是业务流程定义文件，通过xml定义业务流程。</p></li><li><p>如果使用其他公司开发的工作引擎一般都提供了可视化的建模工具（Process</p><p>Designer）用于生成流程定义文件，建模工具操作直观，一般都支持图形化拖拽方</p><p>式、多窗口的用户界面、丰富的过程图形元素、过程元素拷贝、粘贴、删除等功能。</p></li></ul><p>3.部署业务流程</p><ul><li>定义bpmn文件，部署bpmn文件</li></ul><p>4.启动流程实例</p><ul><li>启动一个流程实例代表开始一次业务流程的执行，张三请假开启一个，李四请假开启一个，互不影响</li></ul><p>5.查询待办业务</p><ul><li>系统的业务流程已经交给Activity管理，通过Activity就可以查询到当前流程执行到哪里了，交给Activity管理不需要SQL查询</li></ul><p>6.处理代办业务</p><ul><li>用户查询待办业务后，就执行办理某个任务，执行完毕之后返回给下一个执行人或者流程终止</li></ul><p>7.流程结束</p><h2 id="集成Activity7"><a href="#集成Activity7" class="headerlink" title="集成Activity7"></a>集成Activity7</h2><p>引入Maven依赖，做好配置后，启动Activity自动生成25张表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- activiti引擎 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 整合Spring --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- bpmn 模型处理 ，把图形翻译成模型对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-bpmn-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- bpmn 转换 转换成XML语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-bpmn-converter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- bpmn json数据转换 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-json-converter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- bpmn 布局 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-bpmn-layout<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动流程引擎"><a href="#启动流程引擎" class="headerlink" title="启动流程引擎"></a>启动流程引擎</h2><p>1.配置数据库</p><p>2.Activity的流程引擎配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">      </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                  </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/contex</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///activiti&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认id对应的值 为processEngineConfiguration --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfigurat</span></span></span><br><span class="line"><span class="string"><span class="tag">ion&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            activiti数据库表处理策略</span></span><br><span class="line"><span class="comment">4.5 测试</span></span><br><span class="line"><span class="comment">创建一个测试类，调用activiti的工具类，生成acitivti需要的数据库表。代码如下:</span></span><br><span class="line"><span class="comment">4.6 数据库表的命名规则</span></span><br><span class="line"><span class="comment">此时我们查看数据库，发现25张表，结果如下所示：</span></span><br><span class="line"><span class="comment">Activiti的表都是以 ACT_ 开头。第二部分是表示表的用途的两个字母标识。用途也和服务</span></span><br><span class="line"><span class="comment">的API对应。</span></span><br><span class="line"><span class="comment">                false(默认值)：检查数据库的版本和依赖库的版本，如果不匹配就抛出</span></span><br><span class="line"><span class="comment">异常</span></span><br><span class="line"><span class="comment">                true：构建流程引擎时，执行检查，如果需要就执行更新。如果表不存</span></span><br><span class="line"><span class="comment">在，就创建。</span></span><br><span class="line"><span class="comment">                create-drop：构建流程引擎时创建数据库报表，关闭流程引擎时就删</span></span><br><span class="line"><span class="comment">除这些表。</span></span><br><span class="line"><span class="comment">                drop-create：先删除表再创建表。</span></span><br><span class="line"><span class="comment">                create：构建流程引擎时创建数据库表，关闭流程引擎时不删除这些表</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseSchemaUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.wolfcode.demo;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngine;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.ProcessEngines;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_01TestInit</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInit</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//初始化流程引擎</span></span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">        System.out.println(processEngine);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化后，数据库会生成25张表，流程引擎所需要的表</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722388737933.png" alt="QQ_1722388737933"></p><p>Activity的表都是以act开头，第二部分表示用途的标识</p><ul><li><p>act_re，表示Repository，包含了流程定义和静态资源</p></li><li><p>act_ru，表示runtime，运行时候的表，包含流程实例，任务、变量，异步任务等运行中的数据。Activiti只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。这些运行时表可以一直很小并且速度很快。</p></li><li><p>act_hi，history，表包含历史数据，历史流程实例，变量，任务等</p></li><li><p>act_ge，general，通用数据，用于不同场景下</p></li></ul><h2 id="流程引擎API"><a href="#流程引擎API" class="headerlink" title="流程引擎API"></a>流程引擎API</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722389507888.png" alt="QQ_1722389507888"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br></pre></td></tr></table></figure><p>这段代码启动默认的流程引擎，默认读取默认是读取 resource 目录下的 activiti.cfg.xml 文件，这个文件本质上就是spring的配置文件，加载之后会读取配置文件中id名为 processEngineConfiguration</p><p>的bean,通过这个配置对象可以获取到流程引擎对象 ProcessEngine</p><h2 id="Service层总览"><a href="#Service层总览" class="headerlink" title="Service层总览"></a>Service层总览</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722389652455.png" alt="QQ_1722389652455"></p><ul><li><p><strong>RepositoryService</strong>，是Activiti的资源管理接口，提供了管理和控制流程发布包和流</p><p>程定义的操作。使用工作流建模工具设计的业务流程图需要使用此Service将流程定</p><p>义文件的内容部署到计算机中。</p></li><li><p><strong>RuntimeService</strong>，是Activiti的流程运行管理接口，可以从这个接口中获取很多关于</p><p>流程执行相关的信息。</p></li><li><p><strong>TaskService</strong>，是Activiti的任务管理接口，可以从这个接口中获取任务的信息。</p></li><li><p><strong>HistoryService</strong>，是Activiti的历史管理类，可以查询历史信息，执行流程时，引擎</p><p>会包含很多数据（根据配置），比如流程实例启动时间，任务的参与者，完成任务的</p><p>时间，每个流程实例的执行路径，等等。</p></li><li><p><strong>ManagementService</strong>，是Activiti的引擎管理接口，提供了对Activiti流程引擎的管</p><p>理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于Activiti系统的</p><p>日常维护。</p></li></ul><h1 id="流程操作表"><a href="#流程操作表" class="headerlink" title="流程操作表"></a>流程操作表</h1><p>画好bpmn流程图后，再转为png格式</p><p>如果我们把 bpmn 文件部署到Web环境,那么就只能看到xml信息,无法看到类似上面的图形</p><p>了.</p><p>我们可以再部署之前，根据 bpmn 文件生成 png 文件，然后把 bpmn 和 png 文件同时部署到</p><p>Web环境中.如果我们想查看流程图的话，我们就可以通过Activiti把这个 png 文件读取出</p><p>来. 接下来我们把 bpmn 导出为 png 文件</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722392928410.png" alt="QQ_1722392928410"></p><p>将画的流程图信息，进行部署</p><h2 id="1、流程部署"><a href="#1、流程部署" class="headerlink" title="1、流程部署"></a>1、流程部署</h2><p>观察日志发现，进行部署会操作如下表</p><ul><li><h3 id="ACT-GE-PROPERTY-引擎属性表"><a href="#ACT-GE-PROPERTY-引擎属性表" class="headerlink" title="ACT_GE_PROPERTY 引擎属性表"></a>ACT_GE_PROPERTY 引擎属性表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">update</span> ACT_GE_PROPERTY <span class="keyword">SET</span> REV_ <span class="operator">=</span> ?, VALUE_ <span class="operator">=</span> ? <span class="keyword">where</span></span><br><span class="line">NAME_ <span class="operator">=</span> ? <span class="keyword">and</span> REV_ <span class="operator">=</span> ?</span><br><span class="line">Parameters: <span class="number">2</span>(<span class="type">Integer</span>), <span class="number">2501</span>(String), next.dbid(String), <span class="number">1</span>(<span class="type">Integer</span>)</span><br></pre></td></tr></table></figure><ul><li><h3 id="ACT-RE-PROCDEF-流程定义表"><a href="#ACT-RE-PROCDEF-流程定义表" class="headerlink" title="ACT_RE_PROCDEF 流程定义表"></a>ACT_RE_PROCDEF 流程定义表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_RE_PROCDEF(ID_, REV_, CATEGORY_, NAME_,</span><br><span class="line">KEY_, VERSION_, DEPLOYMENT_ID_, RESOURCE_NAME_, DGRM_RESOURCE_NAME_,</span><br><span class="line">DESCRIPTION_, HAS_START_FORM_KEY_, HAS_GRAPHICAL_NOTATION_ ,</span><br><span class="line">SUSPENSION_STATE_, TENANT_ID_, ENGINE_VERSION_) <span class="keyword">values</span> (?, <span class="number">1</span>, ?, ?,</span><br><span class="line">?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)</span><br><span class="line">Parameters: leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String),</span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span>www.activiti.org<span class="operator">/</span>test(String), 请假流程(String),</span><br><span class="line">leaveProcess(String), <span class="number">1</span>(<span class="type">Integer</span>), <span class="number">1</span>(String), bpmn<span class="operator">/</span>leave.bpmn(String),</span><br><span class="line">bpmn<span class="operator">/</span>leave.png(String), <span class="keyword">null</span>, <span class="literal">false</span>(<span class="type">Boolean</span>), <span class="literal">true</span>(<span class="type">Boolean</span>),</span><br><span class="line"><span class="number">1</span>(<span class="type">Integer</span>), (String), <span class="keyword">null</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="ACT-RE-DEPLOYMENT-流程部署表"><a href="#ACT-RE-DEPLOYMENT-流程部署表" class="headerlink" title="ACT_RE_DEPLOYMENT 流程部署表"></a>ACT_RE_DEPLOYMENT 流程部署表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_RE_DEPLOYMENT(ID_, NAME_, CATEGORY_, KEY_,</span><br><span class="line">TENANT_ID_, DEPLOY_TIME_, ENGINE_VERSION_) <span class="keyword">values</span>(?, ?, ?, ?, ?, ?,</span><br><span class="line">?)</span><br><span class="line">Parameters: <span class="number">1</span>(String), 请假流程(String), <span class="keyword">null</span>, <span class="keyword">null</span>, (String), <span class="number">2021</span><span class="number">-06</span><span class="operator">-</span></span><br><span class="line"><span class="number">02</span> <span class="number">11</span>:<span class="number">01</span>:<span class="number">44.838</span>(<span class="type">Timestamp</span>), <span class="keyword">null</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="ACT-GE-BYTEARRAY-二进制资源表"><a href="#ACT-GE-BYTEARRAY-二进制资源表" class="headerlink" title="ACT_GE_BYTEARRAY 二进制资源表"></a>ACT_GE_BYTEARRAY 二进制资源表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> ACT_GE_BYTEARRAY(ID_, REV_, NAME_, BYTES_,</span><br><span class="line">DEPLOYMENT_ID_, GENERATED_) <span class="keyword">VALUES</span> (?, <span class="number">1</span>, ?, ?, ?, ?) , (?, <span class="number">1</span>, ?, ?,</span><br><span class="line">?, ?)</span><br><span class="line">Parameters: <span class="number">2</span>(String), bpmn<span class="operator">/</span>leave.png(String),</span><br><span class="line">java.io.ByteArrayInputStream<span class="variable">@7fe7c640</span>(ByteArrayInputStream),</span><br><span class="line"><span class="number">1</span>(String), <span class="literal">false</span>(<span class="type">Boolean</span>), <span class="number">3</span>(String), bpmn<span class="operator">/</span>leave.bpmn(String),</span><br><span class="line">java.io.ByteArrayInputStream<span class="variable">@4c4748bf</span>(ByteArrayInputStream),</span><br><span class="line"><span class="number">1</span>(String), <span class="literal">false</span>(<span class="type">Boolean</span>)</span><br></pre></td></tr></table></figure><h2 id="2、启动流程实例"><a href="#2、启动流程实例" class="headerlink" title="2、启动流程实例"></a>2、启动流程实例</h2><ul><li><p>流程定义部署在Activiti中之后就可以通过工作流管理业务流程了。</p></li><li><p>针对该流程，启动一个流程表示发起一个新的请假申请单，这就相当于Java类和Java对象的关系，类定义好之后需要new创建一个对象使用，当然，也可以new多个对象。</p></li><li><p>对于请假申请流程，张三发起一个请假申请单需要启动一个流程实例，李四发起一个请求申请单也需要启动一个流程实例。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStartProcess</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line"> <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line"> <span class="comment">//获取RuntimeService对象</span></span><br><span class="line"> <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getRuntimeService();</span><br><span class="line"> <span class="comment">//根据流程定义的key启动流程实例,这个key是在定义bpmn的时候设置的</span></span><br><span class="line"> <span class="type">ProcessInstance</span> <span class="variable">instance</span> <span class="operator">=</span> runtimeService.</span><br><span class="line"> </span><br><span class="line">startProcessInstanceByKey(<span class="string">&quot;leaveProcess&quot;</span>);</span><br><span class="line"> <span class="comment">//获取流程实例的相关信息</span></span><br><span class="line"> System.out.println(<span class="string">&quot;流程定义的id = &quot;</span> +</span><br><span class="line">instance.getProcessDefinitionId());</span><br><span class="line"> System.out.println(<span class="string">&quot;流程实例的id = &quot;</span> + instance.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察日志发现，启动流程会操作如下表：</p><ul><li><h3 id="ACT-HI-TASKINST-历史任务表"><a href="#ACT-HI-TASKINST-历史任务表" class="headerlink" title="ACT_HI_TASKINST 历史任务表"></a>ACT_HI_TASKINST 历史任务表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_HI_TASKINST ( ID_, PROC_DEF_ID_,</span><br><span class="line">PROC_INST_ID_, EXECUTION_ID_, NAME_, PARENT_TASK_ID_, DESCRIPTION_,</span><br><span class="line">OWNER_, ASSIGNEE_, START_TIME_, CLAIM_TIME_, END_TIME_, DURATION_,</span><br><span class="line">DELETE_REASON_, TASK_DEF_KEY_, FORM_KEY_, PRIORITY_, DUE_DATE_,</span><br><span class="line">CATEGORY_, TENANT_ID_ ) <span class="keyword">values</span> ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,</span><br><span class="line">?, ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: <span class="number">2505</span>(String), leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), <span class="number">2501</span>(String),</span><br><span class="line"><span class="number">2502</span>(String), 部门经理审批(String), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, 李四(String),</span><br><span class="line"><span class="number">2021</span><span class="number">-06</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">52.827</span>(<span class="type">Timestamp</span>), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">_4(String), <span class="keyword">null</span>, <span class="number">50</span>(<span class="type">Integer</span>), <span class="keyword">null</span>, <span class="keyword">null</span>, (String)</span><br></pre></td></tr></table></figure><ul><li><h3 id="ACT-HI-PROCINST-历史流程实例表"><a href="#ACT-HI-PROCINST-历史流程实例表" class="headerlink" title="ACT_HI_PROCINST 历史流程实例表"></a>ACT_HI_PROCINST 历史流程实例表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_HI_PROCINST ( ID_, PROC_INST_ID_,</span><br><span class="line">BUSINESS_KEY_, PROC_DEF_ID_, START_TIME_, END_TIME_, DURATION_,</span><br><span class="line">START_USER_ID_, START_ACT_ID_, END_ACT_ID_,</span><br><span class="line">SUPER_PROCESS_INSTANCE_ID_, DELETE_REASON_, TENANT_ID_, NAME_ )</span><br><span class="line"><span class="keyword">values</span> ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: <span class="number">2501</span>(String), <span class="number">2501</span>(String), <span class="keyword">null</span>,</span><br><span class="line">leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), <span class="number">2021</span><span class="number">-06</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">52.798</span>(<span class="type">Timestamp</span>), <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">null</span>, <span class="keyword">null</span>, _2(String), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, (String), <span class="keyword">null</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="ACT-HI-ACTINST-历史活动信息表"><a href="#ACT-HI-ACTINST-历史活动信息表" class="headerlink" title="ACT_HI_ACTINST 历史活动信息表"></a>ACT_HI_ACTINST 历史活动信息表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_HI_ACTINST ( ID_, PROC_DEF_ID_,</span><br><span class="line">PROC_INST_ID_, EXECUTION_ID_, ACT_ID_, TASK_ID_, CALL_PROC_INST_ID_,</span><br><span class="line">ACT_NAME_, ACT_TYPE_, ASSIGNEE_, START_TIME_, END_TIME_, DURATION_,</span><br><span class="line">DELETE_REASON_, TENANT_ID_ ) <span class="keyword">values</span> (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,</span><br><span class="line">?, ?, ?, ?) , (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)</span><br><span class="line">Parameters: <span class="number">2503</span>(String), leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), <span class="number">2501</span>(String),</span><br><span class="line"><span class="number">2502</span>(String), _2(String), <span class="keyword">null</span>, <span class="keyword">null</span>, StartEvent(String),</span><br><span class="line">startEvent(String), <span class="keyword">null</span>, <span class="number">2021</span><span class="number">-06</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">52.815</span>(<span class="type">Timestamp</span>), <span class="number">2021</span><span class="operator">-</span></span><br><span class="line"><span class="number">06</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">52.816</span>(<span class="type">Timestamp</span>), <span class="number">1</span>(Long), <span class="keyword">null</span>, (String), <span class="number">2504</span>(String),</span><br><span class="line">leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), <span class="number">2501</span>(String), <span class="number">2502</span>(String), _4(String),</span><br><span class="line"><span class="number">2505</span>(String), <span class="keyword">null</span>, 部门经理审批(String), userTask(String), 李四</span><br><span class="line">(String), <span class="number">2021</span><span class="number">-06</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">52.817</span>(<span class="type">Timestamp</span>), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">(String)</span><br></pre></td></tr></table></figure><ul><li><h3 id="ACT-HI-IDENTITYLINK-历史身份连接表"><a href="#ACT-HI-IDENTITYLINK-历史身份连接表" class="headerlink" title="ACT_HI_IDENTITYLINK 历史身份连接表"></a>ACT_HI_IDENTITYLINK 历史身份连接表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_HI_IDENTITYLINK (ID_, TYPE_, USER_ID_,</span><br><span class="line">GROUP_ID_, TASK_ID_, PROC_INST_ID_) <span class="keyword">values</span> (?, ?, ?, ?, ?, ?)</span><br><span class="line">Parameters: <span class="number">2506</span>(String), participant(String), 李四(String), <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">null</span>, <span class="number">2501</span>(String)</span><br></pre></td></tr></table></figure><ul><li><h3 id="ACT-RU-EXECUTION-运行时执行实例表"><a href="#ACT-RU-EXECUTION-运行时执行实例表" class="headerlink" title="ACT_RU_EXECUTION 运行时执行实例表"></a>ACT_RU_EXECUTION 运行时执行实例表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ACT_RU_EXECUTION (ID_, REV_, PROC_INST_ID_,</span><br><span class="line">BUSINESS_KEY_, PROC_DEF_ID_, ACT_ID_, IS_ACTIVE_, IS_CONCURRENT_,</span><br><span class="line">IS_SCOPE_,IS_EVENT_SCOPE_, IS_MI_ROOT_, PARENT_ID_, SUPER_EXEC_,</span><br><span class="line">ROOT_PROC_INST_ID_, SUSPENSION_STATE_, TENANT_ID_, NAME_,</span><br><span class="line">START_TIME_, START_USER_ID_, IS_COUNT_ENABLED_, EVT_SUBSCR_COUNT_,</span><br><span class="line">TASK_COUNT_, JOB_COUNT_, TIMER_JOB_COUNT_, SUSP_JOB_COUNT_,</span><br><span class="line">DEADLETTER_JOB_COUNT_, VAR_COUNT_, ID_LINK_COUNT_) <span class="keyword">values</span> (?, <span class="number">1</span>, ?,</span><br><span class="line">?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,</span><br><span class="line">?, ?) , (?, <span class="number">1</span>, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,</span><br><span class="line">?, ?, ?, ?, ?, ?, ?, ?)</span><br><span class="line">Parameters: <span class="number">2501</span>(String), <span class="number">2501</span>(String), <span class="keyword">null</span>,</span><br><span class="line">leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), <span class="keyword">null</span>, <span class="literal">true</span>(<span class="type">Boolean</span>), <span class="literal">false</span>(<span class="type">Boolean</span>),</span><br><span class="line"><span class="literal">true</span>(<span class="type">Boolean</span>), <span class="literal">false</span>(<span class="type">Boolean</span>), <span class="literal">false</span>(<span class="type">Boolean</span>), <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line"><span class="number">2501</span>(String), <span class="number">1</span>(<span class="type">Integer</span>), (String), <span class="keyword">null</span>, <span class="number">2021</span><span class="number">-06</span><span class="number">-02</span></span><br><span class="line"><span class="number">16</span>:<span class="number">34</span>:<span class="number">52.798</span>(<span class="type">Timestamp</span>), <span class="keyword">null</span>, <span class="literal">false</span>(<span class="type">Boolean</span>), <span class="number">0</span>(<span class="type">Integer</span>),</span><br><span class="line"><span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>),</span><br><span class="line"><span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">2502</span>(String), <span class="number">2501</span>(String), <span class="keyword">null</span>,</span><br><span class="line">leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), _4(String), <span class="literal">true</span>(<span class="type">Boolean</span>), <span class="literal">false</span>(<span class="type">Boolean</span>),</span><br><span class="line"><span class="literal">false</span>(<span class="type">Boolean</span>), <span class="literal">false</span>(<span class="type">Boolean</span>), <span class="literal">false</span>(<span class="type">Boolean</span>), <span class="number">2501</span>(String), <span class="keyword">null</span>,</span><br><span class="line"><span class="number">2501</span>(String), <span class="number">1</span>(<span class="type">Integer</span>), (String), <span class="keyword">null</span>, <span class="number">2021</span><span class="number">-06</span><span class="number">-02</span></span><br><span class="line"><span class="number">16</span>:<span class="number">34</span>:<span class="number">52.813</span>(<span class="type">Timestamp</span>), <span class="keyword">null</span>, <span class="literal">false</span>(<span class="type">Boolean</span>), <span class="number">0</span>(<span class="type">Integer</span>),</span><br><span class="line"><span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>),</span><br><span class="line"><span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>)</span><br></pre></td></tr></table></figure><ul><li><h3 id="ACT-RU-TASK-运行时任务表"><a href="#ACT-RU-TASK-运行时任务表" class="headerlink" title="ACT_RU_TASK 运行时任务表"></a>ACT_RU_TASK 运行时任务表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_RU_TASK (ID_, REV_, NAME_,</span><br><span class="line">PARENT_TASK_ID_, DESCRIPTION_, PRIORITY_, CREATE_TIME_, OWNER_,</span><br><span class="line">ASSIGNEE_, DELEGATION_, EXECUTION_ID_, PROC_INST_ID_, PROC_DEF_ID_,</span><br><span class="line">TASK_DEF_KEY_, DUE_DATE_, CATEGORY_, SUSPENSION_STATE_, TENANT_ID_,</span><br><span class="line">FORM_KEY_, CLAIM_TIME_) <span class="keyword">values</span> (?, <span class="number">1</span>, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,</span><br><span class="line">?, ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: <span class="number">2505</span>(String), 部门经理审批(String), <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line"><span class="number">50</span>(<span class="type">Integer</span>), <span class="number">2021</span><span class="number">-06</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">34</span>:<span class="number">52.817</span>(<span class="type">Timestamp</span>), <span class="keyword">null</span>, 李四(String),</span><br><span class="line"><span class="keyword">null</span>, <span class="number">2502</span>(String), <span class="number">2501</span>(String), leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String),</span><br><span class="line">_4(String), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>(<span class="type">Integer</span>), (String), <span class="keyword">null</span>, <span class="keyword">null</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="ACT-RU-IDENTITYLINK-运行时身份连接表"><a href="#ACT-RU-IDENTITYLINK-运行时身份连接表" class="headerlink" title="ACT_RU_IDENTITYLINK 运行时身份连接表"></a>ACT_RU_IDENTITYLINK 运行时身份连接表</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_RU_IDENTITYLINK (ID_, REV_, TYPE_,</span><br><span class="line">USER_ID_, GROUP_ID_, TASK_ID_, PROC_INST_ID_, PROC_DEF_ID_) <span class="keyword">values</span></span><br><span class="line">(?, <span class="number">1</span>, ?, ?, ?, ?, ?, ?)</span><br><span class="line">Parameters: <span class="number">2506</span>(String), participant(String), 李四(String), <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">null</span>, <span class="number">2501</span>(String), <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h2 id="3、任务查询"><a href="#3、任务查询" class="headerlink" title="3、任务查询"></a>3、任务查询</h2><p>流程启动后，各个任务的负责人就可以查询自己当前需要处理的任务，查询出来的任</p><p>务都是该用户的待办任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectTodoTaskList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//任务负责人</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">assignee</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取TaskService</span></span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="comment">//获取任务集合</span></span><br><span class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery()</span><br><span class="line">           .processDefinitionKey(<span class="string">&quot;leaveProcess&quot;</span>)</span><br><span class="line">           .taskAssignee(assignee)</span><br><span class="line">           .list();</span><br><span class="line">    <span class="comment">//遍历任务列表</span></span><br><span class="line">    <span class="keyword">for</span>(Task task:taskList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;流程定义id = &quot;</span> +</span><br><span class="line">task.getProcessDefinitionId());</span><br><span class="line">        System.out.println(<span class="string">&quot;流程实例id = &quot;</span> +</span><br><span class="line">task.getProcessInstanceId());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务id = &quot;</span> + task.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务名称 = &quot;</span> + task.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察日志发现，查询任务会操作如下表：</p><ul><li>ACT_RU_TASK 运行时任务表</li><li>ACT_RE_PROCDEF 流程定义表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">select</span> <span class="keyword">distinct</span> RES.<span class="operator">*</span> <span class="keyword">from</span> ACT_RU_TASK RES <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">ACT_RE_PROCDEF D <span class="keyword">on</span> RES.PROC_DEF_ID_ <span class="operator">=</span> D.ID_ <span class="keyword">WHERE</span> RES.ASSIGNEE_ <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">and</span> D.KEY_ <span class="operator">=</span> ? <span class="keyword">order</span> <span class="keyword">by</span> RES.ID_ <span class="keyword">asc</span> LIMIT ? <span class="keyword">OFFSET</span> ?</span><br><span class="line">Parameters: 李四(String), leaveProcess(String), <span class="number">2147483647</span>(<span class="type">Integer</span>),</span><br><span class="line"><span class="number">0</span>(<span class="type">Integer</span>)</span><br></pre></td></tr></table></figure><h2 id="4、任务处理"><a href="#4、任务处理" class="headerlink" title="4、任务处理"></a>4、任务处理</h2><p>任务负责人查询待办任务，选择任务进行处理，完成任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompleteTask</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//任务负责人</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">assignee</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取TaskService</span></span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="comment">//获取任务集合</span></span><br><span class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery()</span><br><span class="line">           .processDefinitionKey(<span class="string">&quot;leaveProcess&quot;</span>)</span><br><span class="line">           .taskAssignee(assignee)</span><br><span class="line">           .list();</span><br><span class="line">    <span class="comment">//遍历任务列表</span></span><br><span class="line">    <span class="keyword">for</span>(Task task:taskList)&#123;</span><br><span class="line">        taskService.complete(task.getId());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察日志发现，查询任务会操作如下表.</p><ul><li>ACT_GE_PROPERTY 引擎属性表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">update</span> ACT_GE_PROPERTY <span class="keyword">SET</span> REV_ <span class="operator">=</span> ?, VALUE_ <span class="operator">=</span> ? <span class="keyword">where</span></span><br><span class="line">NAME_ <span class="operator">=</span> ? <span class="keyword">and</span> REV_ <span class="operator">=</span> ?</span><br><span class="line">Parameters: <span class="number">4</span>(<span class="type">Integer</span>), <span class="number">7501</span>(String), next.dbid(String), <span class="number">3</span>(<span class="type">Integer</span>)</span><br></pre></td></tr></table></figure><ul><li>ACT_HI_TASKINST 历史任务表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_HI_TASKINST ( ID_, PROC_DEF_ID_,</span><br><span class="line">PROC_INST_ID_, EXECUTION_ID_, NAME_, PARENT_TASK_ID_, DESCRIPTION_,</span><br><span class="line">OWNER_, ASSIGNEE_, START_TIME_, CLAIM_TIME_, END_TIME_, DURATION_,</span><br><span class="line">DELETE_REASON_, TASK_DEF_KEY_, FORM_KEY_, PRIORITY_, DUE_DATE_,</span><br><span class="line">CATEGORY_, TENANT_ID_ ) <span class="keyword">values</span> ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,</span><br><span class="line">?, ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: <span class="number">5002</span>(String), leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), <span class="number">2501</span>(String),</span><br><span class="line"><span class="number">2502</span>(String), 人事复批(String), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, 王五(String), <span class="number">2021</span><span class="operator">-</span></span><br><span class="line"><span class="number">06</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">19.036</span>(<span class="type">Timestamp</span>), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, _5(String),</span><br><span class="line"><span class="keyword">null</span>, <span class="number">50</span>(<span class="type">Integer</span>), <span class="keyword">null</span>, <span class="keyword">null</span>, (String)</span><br></pre></td></tr></table></figure><ul><li>ACT_HI_ACTINST 历史活动信息表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_HI_ACTINST ( ID_, PROC_DEF_ID_,</span><br><span class="line">PROC_INST_ID_, EXECUTION_ID_, ACT_ID_, TASK_ID_, CALL_PROC_INST_ID_,</span><br><span class="line">ACT_NAME_, ACT_TYPE_, ASSIGNEE_, START_TIME_, END_TIME_, DURATION_,</span><br><span class="line">DELETE_REASON_, TENANT_ID_ ) <span class="keyword">values</span> ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,</span><br><span class="line">?, ?, ?, ?, ? )</span><br><span class="line">Parameters: <span class="number">5001</span>(String), leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), <span class="number">2501</span>(String),</span><br><span class="line"><span class="number">2502</span>(String), _5(String), <span class="number">5002</span>(String), <span class="keyword">null</span>, 人事复批(String),</span><br><span class="line">userTask(String), 王五(String), <span class="number">2021</span><span class="number">-06</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">19.025</span>(<span class="type">Timestamp</span>),</span><br><span class="line"><span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, (String)</span><br></pre></td></tr></table></figure><ul><li>ACT_HI_IDENTITYLINK 历史身份连接表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preparing: insert into <span class="title function_">ACT_HI_IDENTITYLINK</span> <span class="params">(ID_, TYPE_, USER_ID_,</span></span><br><span class="line"><span class="params">GROUP_ID_, TASK_ID_, PROC_INST_ID_)</span> values (?, ?, ?, ?, ?, ?)</span><br><span class="line">Parameters: <span class="number">5003</span>(String), participant(String), 王五(String), <span class="literal">null</span>,</span><br><span class="line"><span class="literal">null</span>, <span class="number">2501</span>(String)</span><br></pre></td></tr></table></figure><ul><li>ACT_RU_TASK 运行时任务表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_RU_TASK (ID_, REV_, NAME_,</span><br><span class="line">PARENT_TASK_ID_, DESCRIPTION_, PRIORITY_, CREATE_TIME_, OWNER_,</span><br><span class="line">ASSIGNEE_, DELEGATION_, EXECUTION_ID_, PROC_INST_ID_, PROC_DEF_ID_,</span><br><span class="line">TASK_DEF_KEY_, DUE_DATE_, CATEGORY_, SUSPENSION_STATE_, TENANT_ID_,</span><br><span class="line">FORM_KEY_, CLAIM_TIME_) <span class="keyword">values</span> (?, <span class="number">1</span>, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,</span><br><span class="line">?, ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: <span class="number">5002</span>(String), 人事复批(String), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">50</span>(<span class="type">Integer</span>),</span><br><span class="line"><span class="number">2021</span><span class="number">-06</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">19.025</span>(<span class="type">Timestamp</span>), <span class="keyword">null</span>, 王五(String), <span class="keyword">null</span>,</span><br><span class="line"><span class="number">2502</span>(String), <span class="number">2501</span>(String), leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), _5(String),</span><br><span class="line"><span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>(<span class="type">Integer</span>), (String), <span class="keyword">null</span>, <span class="keyword">null</span></span><br></pre></td></tr></table></figure><ul><li>ACT_RU_IDENTITYLINK 运行时身份连接表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_RU_IDENTITYLINK (ID_, REV_, TYPE_,</span><br><span class="line">USER_ID_, GROUP_ID_, TASK_ID_, PROC_INST_ID_, PROC_DEF_ID_) <span class="keyword">values</span></span><br><span class="line">(?, <span class="number">1</span>, ?, ?, ?, ?, ?, ?)</span><br><span class="line">Parameters: <span class="number">5003</span>(String), participant(String), 王五(String), <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">null</span>, <span class="number">2501</span>(String), <span class="keyword">null</span></span><br></pre></td></tr></table></figure><ul><li>ACT_RU_EXECUTION 运行时执行实例表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">update</span> ACT_RU_EXECUTION <span class="keyword">set</span> REV_ <span class="operator">=</span> ?, BUSINESS_KEY_ <span class="operator">=</span> ?,</span><br><span class="line">PROC_DEF_ID_ <span class="operator">=</span> ?, ACT_ID_ <span class="operator">=</span> ?, IS_ACTIVE_ <span class="operator">=</span> ?, IS_CONCURRENT_ <span class="operator">=</span> ?,</span><br><span class="line">IS_SCOPE_ <span class="operator">=</span> ?, IS_EVENT_SCOPE_ <span class="operator">=</span> ?, IS_MI_ROOT_ <span class="operator">=</span> ?, PARENT_ID_ <span class="operator">=</span> ?,</span><br><span class="line">SUPER_EXEC_ <span class="operator">=</span> ?, ROOT_PROC_INST_ID_ <span class="operator">=</span> ?, SUSPENSION_STATE_ <span class="operator">=</span> ?, NAME_</span><br><span class="line"><span class="operator">=</span> ?, IS_COUNT_ENABLED_ <span class="operator">=</span> ?, EVT_SUBSCR_COUNT_ <span class="operator">=</span> ?, TASK_COUNT_ <span class="operator">=</span> ?,</span><br><span class="line">JOB_COUNT_ <span class="operator">=</span> ?, TIMER_JOB_COUNT_ <span class="operator">=</span> ?, SUSP_JOB_COUNT_ <span class="operator">=</span> ?,</span><br><span class="line">DEADLETTER_JOB_COUNT_ <span class="operator">=</span> ?, VAR_COUNT_ <span class="operator">=</span> ?, ID_LINK_COUNT_ <span class="operator">=</span> ? <span class="keyword">where</span></span><br><span class="line">ID_ <span class="operator">=</span> ? <span class="keyword">and</span> REV_ <span class="operator">=</span> ?</span><br><span class="line">Parameters: <span class="number">2</span>(<span class="type">Integer</span>), <span class="keyword">null</span>, leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), _5(String),</span><br><span class="line"><span class="literal">true</span>(<span class="type">Boolean</span>), <span class="literal">false</span>(<span class="type">Boolean</span>), <span class="literal">false</span>(<span class="type">Boolean</span>), <span class="literal">false</span>(<span class="type">Boolean</span>),</span><br><span class="line"><span class="literal">false</span>(<span class="type">Boolean</span>), <span class="number">2501</span>(String), <span class="keyword">null</span>, <span class="number">2501</span>(String), <span class="number">1</span>(<span class="type">Integer</span>), <span class="keyword">null</span>,</span><br><span class="line"><span class="literal">false</span>(<span class="type">Boolean</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>),</span><br><span class="line"><span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">0</span>(<span class="type">Integer</span>), <span class="number">2502</span>(String),</span><br><span class="line"><span class="number">1</span>(<span class="type">Integer</span>)</span><br></pre></td></tr></table></figure><ul><li>ACT_HI_TASKINST 历史任务表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">update</span> ACT_HI_TASKINST <span class="keyword">set</span> PROC_DEF_ID_ <span class="operator">=</span> ?, EXECUTION_ID_</span><br><span class="line"><span class="operator">=</span> ?, NAME_ <span class="operator">=</span> ?, PARENT_TASK_ID_ <span class="operator">=</span> ?, DESCRIPTION_ <span class="operator">=</span> ?, OWNER_ <span class="operator">=</span> ?,</span><br><span class="line">ASSIGNEE_ <span class="operator">=</span> ?, CLAIM_TIME_ <span class="operator">=</span> ?, END_TIME_ <span class="operator">=</span> ?, DURATION_ <span class="operator">=</span> ?,</span><br><span class="line">DELETE_REASON_ <span class="operator">=</span> ?, TASK_DEF_KEY_ <span class="operator">=</span> ?, FORM_KEY_ <span class="operator">=</span> ?, PRIORITY_ <span class="operator">=</span> ?,</span><br><span class="line">DUE_DATE_ <span class="operator">=</span> ?, CATEGORY_ <span class="operator">=</span> ? <span class="keyword">where</span> ID_ <span class="operator">=</span> ?</span><br><span class="line">Parameters: leaveProcess:<span class="number">1</span>:<span class="number">4</span>(String), <span class="number">2502</span>(String), 部门经理审批</span><br><span class="line">(String), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, 李四(String), <span class="keyword">null</span>, <span class="number">2021</span><span class="number">-06</span><span class="number">-02</span></span><br><span class="line"><span class="number">16</span>:<span class="number">39</span>:<span class="number">18.995</span>(<span class="type">Timestamp</span>), <span class="number">266168</span>(Long), <span class="keyword">null</span>, _4(String), <span class="keyword">null</span>,</span><br><span class="line"><span class="number">50</span>(<span class="type">Integer</span>), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">2505</span>(String)</span><br></pre></td></tr></table></figure><ul><li>ACT_HI_TASKINST 历史任务表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">update</span> ACT_HI_ACTINST <span class="keyword">set</span> EXECUTION_ID_ <span class="operator">=</span> ?, ASSIGNEE_ <span class="operator">=</span></span><br><span class="line">?, END_TIME_ <span class="operator">=</span> ?, DURATION_ <span class="operator">=</span> ?, DELETE_REASON_ <span class="operator">=</span> ? <span class="keyword">where</span> ID_ <span class="operator">=</span> ?</span><br><span class="line">Parameters: <span class="number">2502</span>(String), 李四(String), <span class="number">2021</span><span class="number">-06</span><span class="number">-02</span></span><br><span class="line"><span class="number">16</span>:<span class="number">39</span>:<span class="number">19.009</span>(<span class="type">Timestamp</span>), <span class="number">266192</span>(Long), <span class="keyword">null</span>, <span class="number">2504</span>(String)</span><br></pre></td></tr></table></figure><ul><li>ACT_RU_TASK 运行时任务表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">delete</span> <span class="keyword">from</span> ACT_RU_TASK <span class="keyword">where</span> ID_ <span class="operator">=</span> ? <span class="keyword">and</span> REV_ <span class="operator">=</span> ?</span><br><span class="line">Parameters: <span class="number">2505</span>(String), <span class="number">1</span>(<span class="type">Integer</span>)</span><br></pre></td></tr></table></figure><h2 id="5、添加审批意见"><a href="#5、添加审批意见" class="headerlink" title="5、添加审批意见"></a>5、添加审批意见</h2><p>在执行任务之前可以给该任务添加审批意见,会存储在历史表中,我们后续可以审批历史中查看到该意见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddComment</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//任务负责人</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">assignee</span> <span class="operator">=</span> <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取TaskService</span></span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="comment">//获取任务集合</span></span><br><span class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery()</span><br><span class="line">           .processDefinitionKey(<span class="string">&quot;leaveProcess&quot;</span>)</span><br><span class="line">           .taskAssignee(assignee)</span><br><span class="line">           .list();</span><br><span class="line">    <span class="comment">//遍历任务列表</span></span><br><span class="line">    <span class="keyword">for</span>(Task task:taskList)&#123;</span><br><span class="line">        <span class="comment">//在任务执行之前任务添加批注信息</span></span><br><span class="line">      </span><br><span class="line">taskService.addComment(task.getId(),task.getProcessInstanceId(),task</span><br><span class="line">.getName()+<span class="string">&quot;审批通过&quot;</span>);</span><br><span class="line">        taskService.complete(task.getId());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察日志发现，其余操作和任务处理的表是一致的，但是添加批注会往如下表中插入记录:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">insert</span> <span class="keyword">into</span> ACT_HI_COMMENT (ID_, TYPE_, TIME_, USER_ID_,</span><br><span class="line">TASK_ID_, PROC_INST_ID_, ACTION_, MESSAGE_, FULL_MSG_) <span class="keyword">values</span> (?, ?,</span><br><span class="line">?, ?, ?, ?, ?, ?, ?)</span><br><span class="line">Parameters: <span class="number">7501</span>(String), comment(String), <span class="number">2021</span><span class="number">-06</span><span class="number">-02</span></span><br><span class="line"><span class="number">16</span>:<span class="number">43</span>:<span class="number">09.13</span>(<span class="type">Timestamp</span>), <span class="keyword">null</span>, <span class="number">5002</span>(String), <span class="number">2501</span>(String),</span><br><span class="line">AddComment(String), 人事复批审批通过(String),</span><br><span class="line">java.io.ByteArrayInputStream<span class="variable">@1b765a2c</span>(ByteArrayInputStream)</span><br></pre></td></tr></table></figure><h2 id="6、查看历史审批"><a href="#6、查看历史审批" class="headerlink" title="6、查看历史审批"></a>6、查看历史审批</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectHistoryTask</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//流程实例ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">processInstanceId</span> <span class="operator">=</span> <span class="string">&quot;2501&quot;</span>;</span><br><span class="line">    <span class="comment">//任务审核人</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">taskAssignee</span> <span class="operator">=</span> <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取historyService</span></span><br><span class="line">    <span class="type">HistoryService</span> <span class="variable">historyService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getHistoryService();</span><br><span class="line">    <span class="comment">//获取taskService</span></span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="comment">//获取历史审核信息</span></span><br><span class="line">    List&lt;HistoricActivityInstance&gt; list = historyService</span><br><span class="line">           .createHistoricActivityInstanceQuery()</span><br><span class="line">           .activityType(<span class="string">&quot;userTask&quot;</span>)<span class="comment">//只获取用户任务</span></span><br><span class="line">           .processInstanceId(processInstanceId)</span><br><span class="line">           .taskAssignee(taskAssignee)</span><br><span class="line">           .finished()</span><br><span class="line">           .list();</span><br><span class="line">    <span class="keyword">for</span>(HistoricActivityInstance instance:list)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务名称:&quot;</span>+instance.getActivityName());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+instance.getStartTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+instance.getEndTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+instance.getDurationInMillis());</span><br><span class="line">        <span class="comment">//获取审核批注信息</span></span><br><span class="line">        List&lt;Comment&gt; taskComments =</span><br><span class="line">taskService.getTaskComments(instance.getTaskId());</span><br><span class="line">        <span class="keyword">if</span>(taskComments.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;审批批</span></span><br><span class="line"><span class="string">注:&quot;</span>+taskComments.get(<span class="number">0</span>).getFullMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、流程定义查询"><a href="#8、流程定义查询" class="headerlink" title="8、流程定义查询"></a>8、流程定义查询</h2><p>查询流程相关信息，包含流程定义，流程部署，流程定义版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDefinitionQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取仓库服务</span></span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getRepositoryService();</span><br><span class="line">    <span class="comment">//获取流程定义集合</span></span><br><span class="line">    List&lt;ProcessDefinition&gt; processDefinitionList = repositoryService</span><br><span class="line">           .createProcessDefinitionQuery()</span><br><span class="line">           .processDefinitionKey(<span class="string">&quot;leaveProcess&quot;</span>)</span><br><span class="line">           .list();</span><br><span class="line">    <span class="comment">//遍历集合</span></span><br><span class="line">    <span class="keyword">for</span> (ProcessDefinition definition:processDefinitionList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;流程定义ID:&quot;</span>+definition.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;流程定义名称:&quot;</span>+definition.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;流程定义key:&quot;</span>+definition.getKey());</span><br><span class="line">        System.out.println(<span class="string">&quot;流程定义版本:&quot;</span>+definition.getVersion());</span><br><span class="line">        System.out.println(<span class="string">&quot;流程部署ID:&quot;</span>+definition.getDeploymentId());</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、流程资源下载"><a href="#9、流程资源下载" class="headerlink" title="9、流程资源下载"></a>9、流程资源下载</h2><p>现在我们的流程资源文件已经上传到数据库了，如果其他用户想要查看这些资源文件，可以从数据库中把资源文件下载到本地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDownloadResource</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取仓库服务</span></span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getRepositoryService();</span><br><span class="line">    <span class="comment">//获取流程定义集合</span></span><br><span class="line">    List&lt;ProcessDefinition&gt; list = repositoryService</span><br><span class="line">           .createProcessDefinitionQuery()</span><br><span class="line">           .processDefinitionKey(<span class="string">&quot;leaveProcess&quot;</span>)</span><br><span class="line">           .orderByProcessDefinitionVersion()<span class="comment">//按照版本排序</span></span><br><span class="line">           .desc()<span class="comment">//降序</span></span><br><span class="line">           .list();</span><br><span class="line"><span class="number">7.1</span><span class="number">.3</span> 流程定义删除</span><br><span class="line">根据部署Id删除对应的流程定义</span><br><span class="line">说明：</span><br><span class="line">    <span class="comment">//获取最新那个</span></span><br><span class="line">    <span class="type">ProcessDefinition</span> <span class="variable">definition</span> <span class="operator">=</span>list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//获取部署ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">deploymentId</span> <span class="operator">=</span> definition.getDeploymentId();</span><br><span class="line">    <span class="comment">//获取bpmn的输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">bpmnInput</span> <span class="operator">=</span> repositoryService.getResourceAsStream(</span><br><span class="line">                                        deploymentId,</span><br><span class="line">                                      </span><br><span class="line">definition.getResourceName());</span><br><span class="line">    <span class="comment">//获取png的输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">pngInput</span> <span class="operator">=</span> repositoryService.getResourceAsStream(</span><br><span class="line">                                        deploymentId,</span><br><span class="line">                                      </span><br><span class="line">definition.getDiagramResourceName());</span><br><span class="line">    <span class="comment">//设置bpmn输入</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">bpmnOutPut</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/leave.bpmn&quot;</span>);</span><br><span class="line">    <span class="comment">//设置png输入</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">pngOutPut</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/leave.png&quot;</span>);</span><br><span class="line">    IOUtils.copy(bpmnInput,bpmnOutPut);</span><br><span class="line">    IOUtils.copy(pngInput,pngOutPut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、流程定义删除"><a href="#9、流程定义删除" class="headerlink" title="9、流程定义删除"></a>9、流程定义删除</h2><p>根据部署Id删除对应的流程定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteDeploy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//流程部署Id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">deploymentId</span> <span class="operator">=</span> <span class="string">&quot;10001&quot;</span>;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取仓库服务</span></span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getRepositoryService();</span><br><span class="line">    <span class="comment">//删除流程定义，如果该流程定义已有流程实例启动则删除时出错</span></span><br><span class="line">    repositoryService.deleteDeployment(deploymentId);</span><br><span class="line">    <span class="comment">//设置true 级联删除流程定义，即使该流程有流程实例启动也可以删除，设置为false</span></span><br><span class="line">非级别删除方式，如果流程</span><br><span class="line">    <span class="comment">//repositoryService.deleteDeployment(deploymentId,true);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果该流程定义下没有正在运行的流程，则可以用普通删除。</li><li>如果该流程定义下存在已经运行的流程，使用普通删除报错，可用级联删除方法将流</li></ol><p>程及相关记录全部删除。</p><ol start="3"><li>项目开发中级联删除操作一般只开放给超级管理员使用.</li></ol><h1 id="流程实例相关"><a href="#流程实例相关" class="headerlink" title="流程实例相关"></a>流程实例相关</h1><p>用户按照程序定义内容发起一个流程，就是一个流程实例</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722482654864.png" alt="QQ_1722482654864"></p><p>那么申请人的请假信息【请假时间、请假理由】是如何绑定到流程中的呢?</p><h2 id="业务标识：BusinessKey"><a href="#业务标识：BusinessKey" class="headerlink" title="业务标识：BusinessKey"></a>业务标识：BusinessKey</h2><ul><li><p>启动流程实例时，指定的businessKey，就会在act_run_execution表中存储businessKey。</p></li><li><p>BusinessKey：业务标识，通常为业务表的主键，业务标识和流程实例一一对应。业务标识来源于业务系统。存储业务标识就是根据业务标识来关联查询业务系统的数据。比如：请假流程启动一个流程实例，就可以将请假单的id作为业务标识存储到Activiti中，将来查询Activiti的流程实例信息就可以获取请假单的id从而关联查询业务</p><p>系统数据库得到请假单信息。</p></li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722494589407.png" alt="QQ_1722494589407"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStartProcess</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">businessKey</span> <span class="operator">=</span> <span class="string">&quot;8001&quot;</span>;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取RuntimeService对象</span></span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getRuntimeService();</span><br><span class="line">    <span class="comment">//根据流程定义的key启动流程实例,这个key是在定义bpmn的时候设置的</span></span><br><span class="line">    <span class="comment">//在启动流程的时候将业务key加入进去</span></span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">instance</span> <span class="operator">=</span> runtimeService</span><br><span class="line">           .startProcessInstanceByKey(<span class="string">&quot;leaveProcess&quot;</span>,businessKey);</span><br><span class="line">    <span class="comment">//获取流程实例的相关信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;流程定义的id = &quot;</span> +</span><br><span class="line">instance.getProcessDefinitionId());</span><br><span class="line">    System.out.println(<span class="string">&quot;流程实例的id = &quot;</span> + instance.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察数据库可以发现，在activiti的act_ru_execution表，字段BUSINESS_KEY就是存放业务KEY的。</p><ul><li>在用户执行任务的时候如何获取 BusinessKey 并关联对应的业务信息呢?</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetBusinessKey</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//任务负责人</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">assignee</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取TaskService</span></span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="comment">//获取RuntimeService</span></span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getRuntimeService();</span><br><span class="line">    <span class="comment">//获取任务集合</span></span><br><span class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery()</span><br><span class="line">           .processDefinitionKey(<span class="string">&quot;leaveProcess&quot;</span>)</span><br><span class="line">           .taskAssignee(assignee)</span><br><span class="line">           .list();</span><br><span class="line">    <span class="comment">//遍历任务列表</span></span><br><span class="line">    <span class="keyword">for</span>(Task task:taskList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;流程定义id = &quot;</span> +</span><br><span class="line">task.getProcessDefinitionId());</span><br><span class="line">        System.out.println(<span class="string">&quot;流程实例id = &quot;</span> +</span><br><span class="line">task.getProcessInstanceId());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务id = &quot;</span> + task.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务名称 = &quot;</span> + task.getName());</span><br><span class="line">        <span class="comment">//根据任务上的流程实例Id查询出对应的流程实例对象，从流程实例对象中获取</span></span><br><span class="line">BusinessKey</span><br><span class="line">        <span class="type">ProcessInstance</span> <span class="variable">instance</span> <span class="operator">=</span> runtimeService</span><br><span class="line">               .createProcessInstanceQuery()</span><br><span class="line">               .processInstanceId(task.getProcessInstanceId())</span><br><span class="line">               .singleResult();</span><br><span class="line">        System.out.println(<span class="string">&quot;业务key:&quot;</span>+instance.getBusinessKey());</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程实例挂起-激活"><a href="#流程实例挂起-激活" class="headerlink" title="流程实例挂起&#x2F;激活"></a><strong>流程实例挂起&#x2F;激活</strong></h2><p>场景：例如公司制度改变过程中的流程, 总经理更换过程中的流程，有100个人的流程, 70个人</p><p>已经完成,30个人流程正好在总经理更换中,就需要挂起.就是暂停</p><ul><li>【C节点】的业务逻辑需要和外部接口交互，刚好外部接口出问题了,如果剩下的流程都走</li></ul><p>到【C节点】，执行【C节点】的业务逻辑，那都会报错，我们就可以把流程挂起，等待外</p><p>部接口可用之后再重新激活流程.</p><ul><li><p>业务流程发生改变,已经发起的流程实例继续按照旧的流程走,如果新发起的流程就按照新的业务流程走.这时候我们就需要挂起流程定义,但是不挂起流程实例.。</p><p>1.操作流程定义为挂起状态，该操作定义下面的所有的流程实例将全部暂停。</p><p>2.流程定义为挂起状态，该流程定义下将不允许启动新的流程实例，同时该流程定义下</p><p>的所有流程实例将全部挂起暂停执行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSuspendAllProcessInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取RepositoryService</span></span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getRepositoryService();</span><br><span class="line">    <span class="comment">//获取流程定义对象</span></span><br><span class="line">    <span class="type">ProcessDefinition</span> <span class="variable">processDefinition</span> <span class="operator">=</span> repositoryService</span><br><span class="line">           .createProcessDefinitionQuery()</span><br><span class="line">           .processDefinitionKey(<span class="string">&quot;leaveProcess&quot;</span>)</span><br><span class="line">           .singleResult();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">suspended</span> <span class="operator">=</span> processDefinition.isSuspended();</span><br><span class="line">    <span class="comment">//输出流程定义状态</span></span><br><span class="line">    System.out.println(<span class="string">&quot;流程定义状态:&quot;</span>+(suspended ?<span class="string">&quot;已挂起&quot;</span>:<span class="string">&quot;已激活&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">processDefinitionId</span> <span class="operator">=</span> processDefinition.getId();</span><br><span class="line">    <span class="keyword">if</span>(suspended)&#123;</span><br><span class="line">        <span class="comment">//如果是挂起，可以执行激活操作 ,参数1 ：流程定义id ，参数2：是否激活流程</span></span><br><span class="line">实例，参数<span class="number">3</span>：激活时间</span><br><span class="line">      </span><br><span class="line">repositoryService.activateProcessDefinitionById(processDefinitionId,</span><br><span class="line"><span class="literal">true</span>,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;流程ID:&quot;</span>+processDefinitionId+<span class="string">&quot;,已激活&quot;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果是激活，可以执行挂起操作 ,参数1 ：流程定义id ，参数2：是否暂停流程</span></span><br><span class="line">实例，参数<span class="number">3</span>：激活时间</span><br><span class="line">      </span><br><span class="line">repositoryService.suspendProcessDefinitionById(processDefinitionId,t</span><br><span class="line">rue,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;流程ID:&quot;</span>+processDefinitionId+<span class="string">&quot;,已挂起&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单个流程实例挂起场景"><a href="#单个流程实例挂起场景" class="headerlink" title="单个流程实例挂起场景"></a><strong>单个流程实例挂起场景</strong></h2><p>评分流程：可设置多级评分，评分流程会按照从上往下的顺序，依次评分；评分人必须在</p><p>评分截至时间内完成评分，否则不允许继续评分，流程将会挂起，停止流转；</p><ul><li><p>操作流程实例对象，针对单个流程执行挂起操作，某个流程实例挂起则此流程不再执</p><p>行，完成该流程实例的当前任务将报异常。</p></li></ul><p>查询所有的流程实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryProcessInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取RepositoryService</span></span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getRuntimeService();</span><br><span class="line">    List&lt;ProcessInstance&gt; processInstanceList = runtimeService</span><br><span class="line">           .createProcessInstanceQuery()</span><br><span class="line">           .processDefinitionKey(<span class="string">&quot;leaveProcess&quot;</span>)</span><br><span class="line">           .list();</span><br><span class="line">    <span class="keyword">for</span>(ProcessInstance processInstance:processInstanceList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;流程实例Id:&quot;</span>+processInstance.getId()+<span class="string">&quot;,状</span></span><br><span class="line"><span class="string">态:&quot;</span>+(processInstance.isSuspended()?<span class="string">&quot;已挂起&quot;</span>:<span class="string">&quot;已激活&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂起某个流程实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSuspendSingleProcessInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//流程实例Id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">processInstanceId</span> <span class="operator">=</span> <span class="string">&quot;2501&quot;</span>;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取RepositoryService</span></span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getRuntimeService();</span><br><span class="line">    <span class="comment">//根据流程实例Id获取流程实例对象</span></span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService</span><br><span class="line">           .createProcessInstanceQuery()</span><br><span class="line">           .processInstanceId(processInstanceId)</span><br><span class="line">           .singleResult();</span><br><span class="line">    <span class="comment">//状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">suspended</span> <span class="operator">=</span> processInstance.isSuspended();</span><br><span class="line">    System.out.println(<span class="string">&quot;流程实例ID:&quot;</span>+processInstanceId+<span class="string">&quot;,状态:&quot;</span>+</span><br><span class="line">(suspended?<span class="string">&quot;已挂起&quot;</span>:<span class="string">&quot;已激活&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(suspended)&#123;</span><br><span class="line">      </span><br><span class="line">runtimeService.activateProcessInstanceById(processInstanceId);</span><br><span class="line">        System.out.println(<span class="string">&quot;流程实例ID:&quot;</span>+processInstanceId+<span class="string">&quot;,状态修改为已</span></span><br><span class="line"><span class="string">激活&quot;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        runtimeService.suspendProcessInstanceById(processInstanceId);</span><br><span class="line">        System.out.println(<span class="string">&quot;流程实例ID:&quot;</span>+processInstanceId+<span class="string">&quot;,状态修改为已</span></span><br><span class="line"><span class="string">挂起&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="任务分配负责人"><a href="#任务分配负责人" class="headerlink" title="任务分配负责人"></a>任务分配负责人</h1><ul><li><h2 id="固定分配"><a href="#固定分配" class="headerlink" title="固定分配"></a>固定分配</h2></li></ul><p>在进行业务流程建模的时候指定固定的任务负责人</p><p>Assignee  张三</p><ul><li><h2 id="UEL表达式分配"><a href="#UEL表达式分配" class="headerlink" title="UEL表达式分配"></a>UEL表达式分配</h2></li></ul><p>Activiti 使用 UEL 表达式， UEL 是 java EE6 规范的一部分， UEL（Unified Expression</p><p>Language）即 统一表达式语言。</p><p>Assignee：${assignee0}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStartProcess</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取RuntimeService对象</span></span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span></span><br><span class="line">processEngine.getRuntimeService();</span><br><span class="line">    Map&lt;String,Object&gt; variables  = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    variables.put(<span class="string">&quot;assignee0&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    variables.put(<span class="string">&quot;assignee1&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    <span class="comment">//根据流程定义的key启动流程实例,这个key是在定义bpmn的时候设置的</span></span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">instance</span> <span class="operator">=</span> runtimeService</span><br><span class="line">           .startProcessInstanceByKey(<span class="string">&quot;leaveProcess&quot;</span>,variables);</span><br><span class="line">    <span class="comment">//获取流程实例的相关信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;流程定义的id = &quot;</span> +</span><br><span class="line">instance.getProcessDefinitionId());</span><br><span class="line">    System.out.println(<span class="string">&quot;流程实例的id = &quot;</span> + instance.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态的设置assignee的值</p><ul><li><h2 id="监听器分配"><a href="#监听器分配" class="headerlink" title="监听器分配"></a>监听器分配</h2></li></ul><p>任务监听器是发生对应的任务相关事件时执行自定义的Java逻辑或表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Event：</span><br><span class="line"></span><br><span class="line">Create：任务创建后触发。</span><br><span class="line"></span><br><span class="line">Assignment：任务分配后触发。</span><br><span class="line"></span><br><span class="line">Delete：任务完成后触发。</span><br><span class="line"></span><br><span class="line">All：所有事件发生都触发。</span><br></pre></td></tr></table></figure><p>自定义一个任务监听器类，然后此类必须实现org.activiti.engine.delegate.TaskListener接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.wolfcode;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.delegate.DelegateTask;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.delegate.TaskListener;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by wolfcode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssigneeTaskListener</span> <span class="keyword">implements</span> <span class="title class_">TaskListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(DelegateTask delegateTask)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(delegateTask.getName().equals(<span class="string">&quot;部门经理审批&quot;</span>))&#123;</span><br><span class="line">            delegateTask.setAssignee(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(delegateTask.getName().equals(<span class="string">&quot;部门经理审批&quot;</span>))&#123;</span><br><span class="line">            delegateTask.setAssignee(<span class="string">&quot;孙七&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去配置监听器</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722524110104.png" alt="QQ_1722524110104"></p><p>在实际开发中，一般也不使用监听器分配方式，太麻烦了。</p><h1 id="流程变量"><a href="#流程变量" class="headerlink" title="流程变量"></a>流程变量</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>流程变量在Activiti中是一个非常重要的角色，流程运转有时需要靠流程变量，业务系统和Activiti结合时少不了流程变量，流程变量就是Activiti在管理工作流时根据管理需要而设置的变量。</p><p>比如在请假流程流转时如果请假天数&gt;3天则有总经理审批，否则由人事直接审批，请假天数就可以设置流程变量，在流程流转时使用。</p><h2 id="流程变量的使用方法"><a href="#流程变量的使用方法" class="headerlink" title="流程变量的使用方法"></a>流程变量的使用方法</h2><ul><li>在属性上使用UEL表达式</li></ul><p>可以在 assignee 处设置 UEL 表达式，表达式的值为任务的负责人，比如：${assignee}， assignee 就是一个流程变量名称。</p><p>Activiti获取UEL表达式的值，即流程变量assignee的值 ，将assignee的值作为任务的负责人进行任务分配</p><ul><li>在连线上使用UEL表达式</li></ul><p>可以在连线上设置UEL表达式，决定流程走向。</p><p>比如：${price&lt;10000} 。price就是一个流程变量名称，uel表达式结果类型为布尔类型。如果UEL表达式是true，要决定 流程执行走向。</p><p><img src="/2024/09/27/Project/Activity%E5%B7%A5%E4%BD%9C%E6%B5%81/Users\fangyuan\AppData\Local\Temp\QQ_1722527474822.png" alt="QQ_1722527474822"></p><h2 id="任务候选人"><a href="#任务候选人" class="headerlink" title="任务候选人"></a>任务候选人</h2><p>在流程定义中在任务结点的 assignee 固定设置任务负责人，在流程定义时将参与者固定</p><p>设置在.bpmn 文件中，如果临时任务负责人变更则需要修改流程定义，系统可扩展性</p><p>差。</p><p>针对这种情况可以给任务设置多个候选人，可以从候选人中选择参与者来完成任务。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722527730519.png" alt="QQ_1722527730519"></p><h2 id="部署启动流程"><a href="#部署启动流程" class="headerlink" title="部署启动流程"></a>部署启动流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//进行部署</span></span><br><span class="line">        <span class="type">Deployment</span> <span class="variable">deployment</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">               .addClasspathResource(<span class="string">&quot;bpmn/leave-candidate.bpmn&quot;</span>)</span><br><span class="line">               .name(<span class="string">&quot;请假流程-候选人&quot;</span>)</span><br><span class="line">               .deploy();</span><br><span class="line">        <span class="comment">//输出部署的一些信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;流程部署ID:&quot;</span>+deployment.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;流程部署名称:&quot;</span>+deployment.getName());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="查询候选人任务"><a href="#查询候选人任务" class="headerlink" title="查询候选人任务"></a><strong>查询候选人任务</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询候选任务</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectCandidateTaskList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//任务负责人</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">candidateUser</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取TaskService</span></span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="comment">//获取任务集合</span></span><br><span class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery()</span><br><span class="line">           .processDefinitionKey(<span class="string">&quot;leaveCandidateProcess&quot;</span>)</span><br><span class="line">           .taskCandidateUser(candidateUser)</span><br><span class="line">           .list();</span><br><span class="line">    <span class="comment">//遍历任务列表</span></span><br><span class="line">    <span class="keyword">for</span>(Task task:taskList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;流程定义id = &quot;</span> +</span><br><span class="line">task.getProcessDefinitionId());</span><br><span class="line">        System.out.println(<span class="string">&quot;流程实例id = &quot;</span> +</span><br><span class="line">task.getProcessInstanceId());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务id = &quot;</span> + task.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务名称 = &quot;</span> + task.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="领取候选人任务"><a href="#领取候选人任务" class="headerlink" title="领取候选人任务"></a><strong>领取候选人任务</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testClaimTask()&#123;</span><br><span class="line">    //任务ID</span><br><span class="line">    String taskId = &quot;2505&quot;;</span><br><span class="line">    String assignee = &quot;张三&quot;;</span><br><span class="line">    //创建ProcessEngine对象</span><br><span class="line">    ProcessEngine processEngine =</span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    //获取TaskService</span><br><span class="line">    TaskService taskService = processEngine.getTaskService();</span><br><span class="line">    //领取任务</span><br><span class="line">    taskService.claim(taskId,assignee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完成任务"><a href="#完成任务" class="headerlink" title="完成任务"></a><strong>完成任务</strong></h2><p>如果候选任务没有进行领取就直接完成的话，那么在历史记录中就不会记录是哪个用户执</p><p>行了这个任务.</p><p>所以对于这种候选人的任务，我们需要先领取再完成.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行任务</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompleteTask</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//任务ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">taskId</span> <span class="operator">=</span> <span class="string">&quot;2505&quot;</span>;</span><br><span class="line">    <span class="comment">//创建ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span></span><br><span class="line">ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取TaskService</span></span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    taskService.complete(taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="排他网关"><a href="#排他网关" class="headerlink" title="排他网关"></a>排他网关</h2><p>排他网关(ExclusiveGateway)（异或网关或基于数据的排他网关），用来在流程中实现决策。当流程执行到这个网关的时候，所有分支都会判断条件是否为true，如果为true则执行该分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">排他网关只会选择一个为true的分支执行（即使有两个分支条件都为true，排他网关也只会选</span><br><span class="line">择一条分支去执行,现在序号小的路径执行）。</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722530250214.png" alt="QQ_1722530250214"></p><h2 id="并行网关"><a href="#并行网关" class="headerlink" title="并行网关"></a>并行网关</h2><p>并行网关(ParallelGateway)允许将流程分成多条分支，也可以把多条分支汇聚到一起，并行网关的功能是基于进入和外出的顺序流的。</p><ul><li>并行网关不会解析条件。即使顺序流中定义了条件，也会被忽略</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722530307943.png" alt="QQ_1722530307943"></p><h2 id="包含网关"><a href="#包含网关" class="headerlink" title="包含网关"></a><strong>包含网关</strong></h2><p>包含网关(InclusiveGateway)可以看做是排他网关和并行网关的结合体。</p><p>需求:出差申请大于3天需要由项目经理审批，小于3等于天由技术经理审批，出差申请必须经过人事助理审批。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722530368112.png" alt="QQ_1722530368112"></p><h1 id="华信Activity开发"><a href="#华信Activity开发" class="headerlink" title="华信Activity开发"></a>华信Activity开发</h1><ol><li>掌握Activity流程开发技术</li><li>掌握概念：工作流引擎、流程实例、流程任务、流程变量</li><li>流程图设计工具，Eclipse Activiti插件，或者IDEA插件 Activiti BPMN visualizer</li><li>流程使用图示</li></ol><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240802090834530.png" alt="image-20240802090834530"></p><p>​5.Activity常用表</p><p>​act_ge_bytearray 存放流程定义文件</p><p>​act_ru_task 流程任务运行表</p><p>​act_hi_actinst 流程任务历史表</p><h2 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h2><p>使用流程图工具绘制流程图，保存.bpmn文件</p><p>整体流程图如下：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722561970653.png" alt="QQ_1722561970653"></p><h3 id="设置流程信息"><a href="#设置流程信息" class="headerlink" title="设置流程信息"></a>设置流程信息</h3><p>studentExample</p><h3 id="设置节点信息"><a href="#设置节点信息" class="headerlink" title="设置节点信息"></a>设置节点信息</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722566694075.png" alt="QQ_1722566694075"></p><p>解释：</p><p>​<strong>Documentation配置用于记录节点相关信息和参数</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Documentation<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;NODE_NAME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;起草人编制&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;USER_STRATEGY_CLASS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.hii.acws.sample.activiti.service.InitiatorUserStrategy&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>NODE_NAME：用于记录节点名称（路由名称）</li><li>USER_STRATEGY_CLASS：指定这个节点的用户策略类（路由对应策略，哪儿些人可以审批）</li></ul><p>这个字段指向一个Java类，该类实现了特定的用户策略，用于确定在这个节点上该由谁来处理任务</p><p>​ <strong>Assignee：${assignee}<strong>：</strong>流程变量：处理人</strong></p><p>​用于动态的指定任务的受理人：流程运行时，根据流程变量 <code>assignee</code> 的值，动态确定该任务的办理人。例如，<code>assignee</code> 变量的值为 <code>manager123</code>，那么该任务会分配给ID为 <code>manager123</code> 的用户。</p><p>​<strong>Form key: &#x2F;example&#x2F;studentprocessedit</strong></p><p>​用于指定任务关联的表单页面的url：用户接到任务后，系统会引导其到路径为 <code>/example/leaveApproval</code> 的表单页面，在该页面上可以填写和提交请假审批的相关信息。</p><h3 id="设置网关和路由信息"><a href="#设置网关和路由信息" class="headerlink" title="设置网关和路由信息"></a>设置网关和路由信息</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722580043717.png" alt="QQ_1722580043717"></p><p>其他的ID名称什么的，随便设置，流程来源和目标什么的，线连起来就会自动有的</p><p>order1和order2是设置的路由排序</p><h3 id="节点配置信息详解"><a href="#节点配置信息详解" class="headerlink" title="节点配置信息详解"></a>节点配置信息详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:自由流人员选择策略</span></span><br><span class="line"><span class="comment"> * taskId 任务ID，非必选</span></span><br><span class="line"><span class="comment"> * processDefKey 流程定义key，非必选</span></span><br><span class="line"><span class="comment"> * appId 业务ID，非必选</span></span><br><span class="line"><span class="comment"> * transitionModel 输入路由信息，必选</span></span><br><span class="line"><span class="comment"> * baseModel 任务信息，必选</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: fangyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/2 15:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><h4 id="起草人节点"><a href="#起草人节点" class="headerlink" title="起草人节点"></a>起草人节点</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Documentation<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;NODE_NAME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;起草人编制&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;USER_STRATEGY_CLASS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.hii.acws.sample.activiti.service.InitiatorUserStrategy&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这个类就是获取流程起草人的策略类，继承UserStrategy（自由流人员选择策略类）</p><p>实现获取人员列表List<User>方法</User></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722615065918.png" alt="QQ_1722615065918"></p><p>获取起草人列表的逻辑就是：</p><ol><li>查询任务</li><li>查询该任务下的实例列表</li><li>用实例列表的Assignee字段去用户表中查询当前用户</li></ol><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722615859528.png" alt="QQ_1722615859528"></p><h4 id="审批人节点："><a href="#审批人节点：" class="headerlink" title="审批人节点："></a>审批人节点：</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Documentation<span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;NODE_NAME&quot;</span><span class="punctuation">:</span><span class="string">&quot;部门经理审批&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;USER_STRATEGY_CLASS&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="string">&quot;com.huaxin.acws.bpm.service.impl.RoleAssigneesStrategyServiceImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;ROLE_IDS&quot;</span><span class="punctuation">:</span><span class="string">&quot;10001&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>因为这个类是封装在别的jar包中的，我们要将这个对象交给spring容器管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name =&quot;com.huaxin.acws.bpm.service.impl.RoleAssigneesStrategyServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RoleAssigneesStrategyServiceImpl <span class="title function_">roleAssigneesStrategyServiceImpl</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleAssigneesStrategyServiceImpl</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取审批人节点的逻辑就是：</p><ol><li>在任务信息中获取我们documentation中封装的ROLE_IDS字段10001对应的角色</li><li>将roleIds转为角色ID数组</li><li>遍历数组，对每一个角色ID，创建查询对象，设置查询限制，将查到的用户添加到用户列表返回</li><li>（这谁写的封装的代码，真的臭！！！设置这么多额外多余的变量干什么？）</li></ol><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722617167631.png" alt="QQ_1722617167631"></p><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><p>后端在serviceimpl实现层去实现BpmTransitionFilter接口</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722582001718.png" alt="QQ_1722582001718"></p><p>去实现两个方法，分别是判断路由信息是否需要过滤，和过滤路由信息</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722582242660.png" alt="QQ_1722582242660"></p><p><code>同时设置两个监听器</code>，分别在流程启动和流程结束的时候调用方法</p><p>分别去监听两个事件</p><p>当事件被发布时，Spring会遍历所有使用 <code>@EventListener</code> 注解的方法，并检查它们是否监听该事件类型。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722583595488.png" alt="QQ_1722583595488"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722584229516.png" alt="QQ_1722584229516"></p><p>两个方法的主要作用还是去设置当前对象的工作状态，保存到数据库中</p><p>然后发送待阅通知</p><p><code>Activity流程很多都是自动实现的，后端写的东西很少，基本上就是配置流程图，配置好获取起草人的类 ，审批的类，过滤网关就行，其实写不写监听器问题都不大，也就是修改实习生流程中的一个字段，写过滤网管的代码也没必要，直接流程图不画那条线就行了呗，写过滤只是为了让我们熟悉还是有过滤这个功能的</code></p><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><p>流程图后端基本上都是Activity自动部署的，页面显示主要还是看前端</p><p>前端的话，主要是写了两个vue页面，一个ProcessEdit流程编辑页面，一个ProcessApprove审批页面，在这两个页面中，引入了已有的自定义组件</p><p>这里记一下引入自定义组件的使用和传值的一些逻辑吧，vue还不是很了解</p><p><strong>导入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getStudent, saveStudent &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/example&quot;</span>;<span class="comment">//引入方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProcessBox</span> <span class="keyword">from</span> <span class="string">&quot;@/components/Process/ProcessBox.vue&quot;</span>;<span class="comment">//引入组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export default 相当于导出当前vue组件，在其它引入当前组件时可以使用当前组件中的方法和变量。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//用于注册局部组件，使得在这个组件中使用</span></span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">Sticky</span>, <span class="title class_">FileUpload</span>, <span class="title class_">FileList</span>, <span class="title class_">ProcessBox</span>,<span class="title class_">ProcessSuggest</span> &#125;,</span><br><span class="line">    <span class="comment">//可以通过 this 访问 data 中定义的属性</span></span><br><span class="line">    <span class="comment">//data 选项用于定义组件的响应式数据对象</span></span><br><span class="line">    <span class="comment">//Vue 会监视这些数据对象中的属性，当它们发生变化时，Vue 会自动更新 DOM</span></span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">     activeNames[<span class="string">&quot;baseInfo&quot;</span>,<span class="string">&quot;detailInfo&quot;</span>,<span class="string">&quot;filelistInfo&quot;</span>,<span class="string">&quot;processSuggest&quot;</span>],</span><br><span class="line">      <span class="attr">student</span>: &#123;</span><br><span class="line">        <span class="attr">new</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">sex</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>传值</strong>：</p><p>子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    我是子组件：</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;msg&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;changeValFn&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;child&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&#x27;msg&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">changeValFn</span>(<span class="params">e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;changeMsg&#x27;</span>, e.<span class="property">target</span>.<span class="property">value</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件：&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span> @<span class="attr">changeMsg</span>=<span class="string">&quot;changeMsgFn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    child,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">msg</span>: <span class="string">&#x27;hello!&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">changeMsgFn</span>(<span class="params">value</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">msg</span> = value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>父组件向子组件传值props</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件里用props属性去接受父组件的值</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">afterProcess</span>: &#123; <span class="attr">type</span>: <span class="title class_">Function</span>, <span class="attr">default</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">//指定afterProcess的类型必须是一个函数，如果没有传值，默认是空函数，什么都不执行</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722819399722.png" alt="QQ_1722819399722"></p><p><strong>子组件向父组件传值</strong>，emit自定义事件</p><p>在子组件中，定义一个传值click事件，</p><p>this.$emit(父组件事件名称，传递数据)</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722821170000.png" alt="QQ_1722821170000"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722821284040.png" alt="QQ_1722821284040"></p><h3 id="自定义流程组件"><a href="#自定义流程组件" class="headerlink" title="自定义流程组件"></a>自定义流程组件</h3><ul><li>FlowChart.vue流程图组件</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/59ef4d1f90dca05b65de8184b528acc6.png" alt="59ef4d1f90dca05b65de8184b528acc6"></p><ul><li>ProcessBox.vue流程审批组件</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/cc3eeb564f9ff136c4335c757820b2e7.png" alt="cc3eeb564f9ff136c4335c757820b2e7"></p><ul><li>ProcessMonitor.vue流程监视组件</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/59ef4d1f90dca05b65de8184b528acc6.png" alt="59ef4d1f90dca05b65de8184b528acc6"></p><ul><li>ProcessSuggest.vue审批意见组件</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722826843400.png" alt="QQ_1722826843400"></p><h3 id="ProcessEdit页面"><a href="#ProcessEdit页面" class="headerlink" title="ProcessEdit页面"></a>ProcessEdit页面</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/e8b19781ce16c45131f0a6cf1b428bc0.png" alt="e8b19781ce16c45131f0a6cf1b428bc0"></p><p>按照按钮来说功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;saveData&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;!canOperate&quot;</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;saveData(&#x27;submit&#x27;)&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;!canOperate&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;withdrawTask&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;!canWithdraw&quot;</span>&gt;</span>撤回<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;processMonitor&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;!instanceId&quot;</span>&gt;</span>流程监控<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;closeMe&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;this.$parent.hideMenu&quot;</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>保存&amp;提交</strong>：根据是否带参数判断保存还是提交</p><p>部分代码已注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">saveData</span>(<span class="params">oper</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>[<span class="string">&quot;student&quot;</span>].<span class="title function_">validate</span>(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">      <span class="title function_">saveStudent</span>(<span class="variable language_">this</span>.<span class="property">student</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">student</span>.<span class="property">id</span> = response.<span class="property">id</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">student</span>.<span class="property">new</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&quot;submit&quot;</span>) &#123;</span><br><span class="line">          <span class="comment">//校验附件是否上传</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$refs</span>[<span class="string">&quot;ZW&quot;</span>].<span class="property">fileList</span>.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.$message(&#123;</span><br><span class="line">              <span class="attr">message</span>: <span class="string">&quot;请上传附件！&quot;</span>,</span><br><span class="line">              <span class="attr">type</span>: <span class="string">&quot;warning&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">submitProcess</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$notify(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;成功&quot;</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&quot;修改成功&quot;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;success&quot;</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提交流程</span></span><br><span class="line"><span class="title function_">submitProcess</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> jso = &#123;&#125;;</span><br><span class="line">  jso.<span class="property">processDefKey</span> = <span class="string">&quot;studentExample&quot;</span>; <span class="comment">// 流程标识符</span></span><br><span class="line">  jso.<span class="property">instanceName</span> = <span class="string">&quot;示例流程&quot;</span>;</span><br><span class="line">  jso.<span class="property">taskId</span> = <span class="variable language_">this</span>.<span class="property">taskId</span>;</span><br><span class="line">  jso.<span class="property">method</span> = <span class="string">&quot;submit&quot;</span>; <span class="comment">//submit和audit</span></span><br><span class="line">  jso.<span class="property">businessData</span> = &#123; <span class="attr">appId</span>: <span class="variable language_">this</span>.<span class="property">student</span>.<span class="property">id</span> &#125;; <span class="comment">//业务数据</span></span><br><span class="line">  <span class="comment">// 初始化审批插件</span></span><br><span class="line">  <span class="comment">//$refs是一个特殊的属性，用于访问已注册的子组件实例或DOM元素。这里，它正在访问名为&quot;processbox&quot;的子组件实例或DOM元素，调用Processbox的initialData方法初始化数据</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>[<span class="string">&quot;processbox&quot;</span>].<span class="title function_">initialData</span>(jso);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">processBoxVisible</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>撤回</strong>：API请求在后台撤回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//撤回任务</span></span><br><span class="line">    <span class="title function_">withdrawTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">withdraw</span>(<span class="variable language_">this</span>.<span class="property">taskId</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">canWithdraw</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="variable language_">this</span>.$notify(&#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&quot;成功&quot;</span>,</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;撤回成功！&quot;</span>,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">          <span class="attr">offset</span>: <span class="number">70</span>,</span><br><span class="line">          <span class="attr">duration</span>: <span class="number">2000</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//撤回API</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 撤回任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">data</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">withdraw</span>(<span class="params">taskId</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/rest/tasks/&#x27;</span> + taskId + <span class="string">&#x27;/actions/withdraw&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流程监控</strong>：跳转到流程监控页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//流程监控，传递了一个名为instanceId实例的查询参数</span></span><br><span class="line"><span class="comment">//你可以在该路由的组件中访问this.$route.query.instanceId来获取传递的值。</span></span><br><span class="line">   <span class="title function_">processMonitor</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">       <span class="attr">name</span>: <span class="string">&quot;ProcessMonitor&quot;</span>,</span><br><span class="line">       <span class="attr">query</span>: &#123;</span><br><span class="line">         instanceId : <span class="variable language_">this</span>.<span class="property">instanceId</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//路由router配置</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//流程监控</span></span><br><span class="line">       <span class="attr">path</span>:<span class="string">&#x27;processmonitor&#x27;</span>,</span><br><span class="line">       <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/components/Process/ProcessMonitor&#x27;</span>),</span><br><span class="line">       <span class="attr">name</span>: <span class="string">&#x27;ProcessMonitor&#x27;</span>,</span><br><span class="line">       <span class="attr">meta</span>: &#123;<span class="attr">title</span>: <span class="string">&#x27;流程监控&#x27;</span> , <span class="attr">icon</span>: <span class="string">&#x27;ProcessMonitor&#x27;</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在子组件中用this.$route.query.instanceId来获取传递的值</span></span><br><span class="line"> <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="attr">instanceId</span>: <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">instanceId</span>,</span><br><span class="line">     <span class="comment">//表格数据</span></span><br><span class="line">     <span class="attr">dataList</span>: [],</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;,</span><br><span class="line">     <span class="comment">//在子组件中传入流程实例ID给流程图组件</span></span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">flow-chart</span> <span class="attr">:instanceId</span>= <span class="string">&quot;instanceId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">flow-chart</span>&gt;</span></span></span><br><span class="line"><span class="comment">//流程图组件中使用    props:&#123;instanceId: &#x27;&#x27;&#125;接受</span></span><br><span class="line"><span class="comment">//再根据instanceId查询到流程实例，显示在页面上</span></span><br></pre></td></tr></table></figure><p><strong>关闭</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有在其父组件hideMenu为真时候，才显示       </span></span><br><span class="line">       &lt;el-button type=<span class="string">&quot;primary&quot;</span> @click=<span class="string">&quot;closeMe&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;this.$parent.hideMenu&quot;</span>&gt;关闭&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><h3 id="ProcessApprove审批页面"><a href="#ProcessApprove审批页面" class="headerlink" title="ProcessApprove审批页面"></a>ProcessApprove审批页面</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/QQ_1722826958921.png" alt="QQ_1722826958921"></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> 华信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> 华信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浙江移动科研创新数智化平台</title>
      <link href="/2024/09/20/Project/%E6%B5%99%E6%B1%9F%E7%A7%BB%E5%8A%A8%E7%A7%91%E7%A0%94%E5%88%9B%E6%96%B0%E6%95%B0%E6%99%BA%E5%8C%96%E5%B9%B3%E5%8F%B0/"/>
      <url>/2024/09/20/Project/%E6%B5%99%E6%B1%9F%E7%A7%BB%E5%8A%A8%E7%A7%91%E7%A0%94%E5%88%9B%E6%96%B0%E6%95%B0%E6%99%BA%E5%8C%96%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913142713840.png" alt="image-20240913142713840"></p><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913142834341.png" alt="image-20240913142834341"></p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913142906229.png" alt="image-20240913142906229"></p><h3 id="部门管理"><a href="#部门管理" class="headerlink" title="部门管理"></a>部门管理</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913142941307.png" alt="image-20240913142941307"></p><h3 id="接口监控"><a href="#接口监控" class="headerlink" title="接口监控"></a>接口监控</h3><h4 id="监控首页"><a href="#监控首页" class="headerlink" title="监控首页"></a>监控首页</h4><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143040403.png" alt="image-20240913143040403"></p><h4 id="服务列表"><a href="#服务列表" class="headerlink" title="服务列表"></a>服务列表</h4><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143329472.png" alt="image-20240913143329472"></p><p>调用日志</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143401705.png" alt="image-20240913143401705"></p><h4 id="问题清单"><a href="#问题清单" class="headerlink" title="问题清单"></a>问题清单</h4><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143424692.png" alt="image-20240913143424692"></p><h3 id="数据权限"><a href="#数据权限" class="headerlink" title="数据权限"></a>数据权限</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143500536.png" alt="image-20240913143500536"></p><h3 id="数据稽核"><a href="#数据稽核" class="headerlink" title="数据稽核"></a>数据稽核</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143540700.png" alt="image-20240913143540700"></p><h3 id="统一待办"><a href="#统一待办" class="headerlink" title="统一待办"></a>统一待办</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143624418.png" alt="image-20240913143624418"></p><h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143701027.png" alt="image-20240913143701027"></p><h3 id="PSM数据同步"><a href="#PSM数据同步" class="headerlink" title="PSM数据同步"></a>PSM数据同步</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143723796.png" alt="image-20240913143723796"></p><h3 id="定时任务列表"><a href="#定时任务列表" class="headerlink" title="定时任务列表"></a>定时任务列表</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143748990.png" alt="image-20240913143748990"></p><h3 id="模板上传"><a href="#模板上传" class="headerlink" title="模板上传"></a>模板上传</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143815539.png" alt="image-20240913143815539"></p><h3 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913143839632.png" alt="image-20240913143839632"></p><h2 id="个人工作台"><a href="#个人工作台" class="headerlink" title="个人工作台"></a>个人工作台</h2><h3 id="待办已办"><a href="#待办已办" class="headerlink" title="待办已办"></a>待办已办</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913155715822.png" alt="image-20240913155715822"></p><h3 id="待阅已阅"><a href="#待阅已阅" class="headerlink" title="待阅已阅"></a>待阅已阅</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913155743493.png" alt="image-20240913155743493"></p><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913155817339.png" alt="image-20240913155817339"></p><h3 id="项目台账"><a href="#项目台账" class="headerlink" title="项目台账"></a>项目台账</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913155942896.png" alt="image-20240913155942896"></p><h2 id="项目研发工时"><a href="#项目研发工时" class="headerlink" title="项目研发工时"></a>项目研发工时</h2><p>研发工时确认、项目创新管理、专职人员配置、研发工时配置，大差不差</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913160116765.png" alt="image-20240913160116765"></p><h2 id="资料主题归类"><a href="#资料主题归类" class="headerlink" title="资料主题归类"></a>资料主题归类</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913160517935.png" alt="image-20240913160517935"></p><h3 id="归类查看"><a href="#归类查看" class="headerlink" title="归类查看"></a>归类查看</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913160549979.png" alt="image-20240913160549979"></p><h2 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h2><h3 id="资料合规总统计"><a href="#资料合规总统计" class="headerlink" title="资料合规总统计"></a>资料合规总统计</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913160657812.png" alt="image-20240913160657812"></p><h3 id="费用研发工时统计"><a href="#费用研发工时统计" class="headerlink" title="费用研发工时统计"></a>费用研发工时统计</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913160820024.png" alt="image-20240913160820024"></p><h3 id="科技项目人力情况"><a href="#科技项目人力情况" class="headerlink" title="科技项目人力情况"></a>科技项目人力情况</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913160850648.png" alt="image-20240913160850648"></p><h3 id="本单位自立项项目表"><a href="#本单位自立项项目表" class="headerlink" title="本单位自立项项目表"></a>本单位自立项项目表</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913160955850.png" alt="image-20240913160955850"></p><h3 id="项目状态统计分析"><a href="#项目状态统计分析" class="headerlink" title="项目状态统计分析"></a>项目状态统计分析</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913161024137.png" alt="image-20240913161024137"></p><h3 id="项目结项率统计分析"><a href="#项目结项率统计分析" class="headerlink" title="项目结项率统计分析"></a>项目结项率统计分析</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913161051157.png" alt="image-20240913161051157"></p><h3 id="年度单位自立项统计"><a href="#年度单位自立项统计" class="headerlink" title="年度单位自立项统计"></a>年度单位自立项统计</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913161146945.png" alt="image-20240913161146945"></p><h3 id="投资进度明细报表"><a href="#投资进度明细报表" class="headerlink" title="投资进度明细报表"></a>投资进度明细报表</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913161236376.png" alt="image-20240913161236376"></p><h3 id="投资预告告警进度"><a href="#投资预告告警进度" class="headerlink" title="投资预告告警进度"></a>投资预告告警进度</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913161304483.png" alt="image-20240913161304483"></p><h2 id="WBS任务管理"><a href="#WBS任务管理" class="headerlink" title="WBS任务管理"></a>WBS任务管理</h2><p>这个分支没数据，得另一个分支才行</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913161552275.png" alt="image-20240913161552275"></p><h2 id="看板样例"><a href="#看板样例" class="headerlink" title="看板样例"></a>看板样例</h2><p>同样，这个分支没数据</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913162418894.png" alt="image-20240913162418894"></p><h2 id="专家库管理"><a href="#专家库管理" class="headerlink" title="专家库管理"></a>专家库管理</h2><p>这个分支没数据</p><h2 id="研发项目配置"><a href="#研发项目配置" class="headerlink" title="研发项目配置"></a>研发项目配置</h2><h3 id="项目里程碑配置-编辑"><a href="#项目里程碑配置-编辑" class="headerlink" title="项目里程碑配置-编辑"></a>项目里程碑配置-编辑</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913162623055.png" alt="image-20240913162623055"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913162831407.png" alt="image-20240913162831407"></p><h2 id="业支项目管理"><a href="#业支项目管理" class="headerlink" title="业支项目管理"></a>业支项目管理</h2><h3 id="业支项目管理列表"><a href="#业支项目管理列表" class="headerlink" title="业支项目管理列表"></a>业支项目管理列表</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913162956118.png" alt="image-20240913162956118"></p><p>管理年度列表</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913163027653.png" alt="image-20240913163027653"></p><p>维护列表</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913163048780.png" alt="image-20240913163048780"></p><p>新增</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913163112544.png" alt="image-20240913163112544"></p><p>人员选择</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913163132395.png" alt="image-20240913163132395"></p><p>关联</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913163202753.png" alt="image-20240913163202753"></p><p>发起评估（任务经理—管理员领导)</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913163337604.png" alt="image-20240913163337604"></p><p>评估待办—管理员</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913163520394.png" alt="image-20240913163520394"></p><p>附件列表与流程监控</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913163937694.png" alt="image-20240913163937694"></p><p>审批窗口</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913163717560.png" alt="image-20240913163717560"></p><p>会议纪要上传</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913164439508.png" alt="image-20240913164439508"></p><h3 id="成本度量管理"><a href="#成本度量管理" class="headerlink" title="成本度量管理"></a>成本度量管理</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240913170026523.png" alt="image-20240913170026523"></p><p>评估结果查看</p><p><img src="/2024/09/20/Project/%E6%B5%99%E6%B1%9F%E7%A7%BB%E5%8A%A8%E7%A7%91%E7%A0%94%E5%88%9B%E6%96%B0%E6%95%B0%E6%99%BA%E5%8C%96%E5%B9%B3%E5%8F%B0/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240920153732833.png" alt="image-20240920153732833"></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> 华信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> 华信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能结果评估</title>
      <link href="/2024/09/15/Project/%E6%99%BA%E8%83%BD%E7%BB%93%E6%9E%9C%E8%AF%84%E4%BC%B0/"/>
      <url>/2024/09/15/Project/%E6%99%BA%E8%83%BD%E7%BB%93%E6%9E%9C%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="智能结果评估"><a href="#智能结果评估" class="headerlink" title="智能结果评估"></a>智能结果评估</h1><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240822112521284.png" alt="image-20240822112521284"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240822112549363.png" alt="image-20240822112549363"></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> 华信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> 华信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel导入导出</title>
      <link href="/2024/08/27/Project/Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
      <url>/2024/08/27/Project/Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Excel导入导出"><a href="#Excel导入导出" class="headerlink" title="Excel导入导出"></a>Excel导入导出</h1><p>视图：虚拟存在的表，视图中的数据</p><h2 id="任务1"><a href="#任务1" class="headerlink" title="任务1"></a>任务1</h2><p>特定的角色（数据权限角色）才能编辑修改项目的附件的情况</p><p>修改的情况记录日志操作表，（这里说AOP吧）</p><p>（附件表，附件记录日志表）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.先去后端的角色表中创建一个数据编辑角色，对应roleID=10040，</span><br><span class="line">2.前端调用方法，获取当前人员所有的角色ID</span><br><span class="line">（后端有两张表，一个是role表，对应不同角色，一个是user-role表，</span><br><span class="line">对应userid和roleID的关系），直接用当前人员ID当去查所有的roleID就行</span><br><span class="line">3.编辑按钮的visable，根据当前角色ID去判断，不同的人有不同的按钮</span><br><span class="line">4.点击编辑按钮，的绑定事件为设置dialog属性为true，在dialog中用</span><br><span class="line">时间选择器，和人员选择器（自定义组件）设置人员</span><br><span class="line"></span><br><span class="line">5.</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240819182847877.png" alt="image-20240819182847877"></p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240819181851370.png" alt="image-20240819181851370" style="zoom:80%;"><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240819181755951.png" alt="image-20240819181755951" style="zoom: 80%;"><h2 id="任务2"><a href="#任务2" class="headerlink" title="任务2"></a>任务2</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240819184007816.png" alt="image-20240819184007816"></p><p>Excel的模板下载和导入</p><p>导入要做校验，正则匹配格式，导入类校验类</p><p>后端要校验，前段显示还要校验</p><p>根据Excel的是否待办已办字段，去生成待办已办</p><h2 id="任务3"><a href="#任务3" class="headerlink" title="任务3"></a>任务3</h2><p>项目信息编辑功能，主要是前端</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240819184051393.png" alt="image-20240819184051393"></p><p>点击编辑按钮后，生成dialog，数据的回显，修改保存项目信息，保存的时候做好校验</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240819184128936.png" alt="image-20240819184128936"></p><h2 id="任务4"><a href="#任务4" class="headerlink" title="任务4"></a>任务4</h2><p>项目团队信息的新增和删除</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240819184246716.png" alt="image-20240819184246716"></p><p>按照员工编号新增，</p><p>dialog里写一个分页查询所有的员工信息</p><p>和一个按照编号查询员工信息，不能乱新增人员</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240819184317719.png" alt="image-20240819184317719"></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> 华信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> 华信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科研创新管理平台</title>
      <link href="/2024/08/20/Project/%E7%A7%BB%E5%8A%A8%E7%A7%91%E5%88%9B%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/"/>
      <url>/2024/08/20/Project/%E7%A7%BB%E5%8A%A8%E7%A7%91%E5%88%9B%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p><em><strong>*【中国移动浙江公司】*</strong></em></p><p><em><strong>*【科研创新管理平台】*</strong></em></p><p><em><strong>*（成本度量线上化管理）*</strong></em></p><h1 id="总目标任务"><a href="#总目标任务" class="headerlink" title="总目标任务"></a>总目标任务</h1><p>1、 将现有成本度量工作线上化，实现线上提交、审批、确认等工作。</p><p>2、 将评估结果线上结构化，记录度量评估结果。</p><p>3、 对评估人员评估时长进行记录，方便后续进行工作质量考评。</p><p>1.1. <strong>功能性全局需求</strong></p><p>在后续章节阐述的业务功能需求、辅助功能需求、基础功能，如无特殊说明，必须遵循下列功能性要求：</p><p>1． 对于每一个工作流程需提供流程监控功能。</p><p>2． 对所有系统接口需提供运行监控功能，并记录详细日志。</p><p>1.2. <strong>非功能性全局需求</strong></p><p>在后续章节阐述的业务功能需求、辅助功能需求、基础功能，如无特殊说明，必须遵循下列非功能性要求：</p><p>1．对于编辑类需求，如无特殊说明，每次交互响应时间要求&lt;2秒。</p><p>2．对于日常检索类需求，如无特殊说明，检索响应时间要求&lt;5秒。</p><p>3．对于统计分析类需求，如无特殊说明，统计表与图形成的响应时间要求&lt;10秒。</p><p>4．对于每项业务功能需求，如无特殊说明，均要求能够并发400用户，并要求目标系统能够承受所有功能并发400用户的压力。</p><p>功能性需求说明</p><h2 id="1-业支项目管理"><a href="#1-业支项目管理" class="headerlink" title="1.业支项目管理"></a>1.业支项目管理</h2><p><em><strong>*用户目标*</strong></em></p><p>将立项前项目清单导入至系统中，可供任务经理选择；后续按照名称可系统自动识别关联已立项项目。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240828143750066.png" alt="image-20240828143750066"></p><h2 id="2-业支项目管理列表"><a href="#2-业支项目管理列表" class="headerlink" title="2.业支项目管理列表"></a>2.业支项目管理列表</h2><p><em><strong>*功能说明*</strong></em></p><p>展示业支类投资项目，包括未立项项目以及已立项项目。其中未立项项目需规划经理进行导入，等待立项完成接口获取已立项项目时，再进行关联。</p><p><em><strong>功能点</strong></em></p><table><thead><tr><th><em><strong>*【业支项目管理列表】*</strong></em></th><th align="center"></th></tr></thead><tbody><tr><td><em><strong>*1、功能点*</strong></em></td><td align="center"></td></tr><tr><td><em><strong>*功能名称*</strong></em></td><td align="center"><em><strong>*说明*</strong></em></td></tr><tr><td>项目导入</td><td align="center">点击进入“未立项项目导入”列表，可按照年度导入未立项项目。</td></tr><tr><td>项目关联</td><td align="center">勾选一个未立项项目，点击“项目关联”，选择已立项项目进行关联。关联操作也可在年度未立项表单进行关联。</td></tr><tr><td>发起评估</td><td align="center">规划经理勾选相应项目，可点击发起评估。勾选已立项项目，发起结算前评估；勾选未立项项目，发起立项前评估。</td></tr><tr><td>会审纪要上传</td><td align="center">规划经理勾选相应项目，上传立项前评估纪要或者结算前评估纪要。</td></tr><tr><td>查询</td><td align="center">通过查询条件，对列表数据进行查询。</td></tr><tr><td>导出</td><td align="center">可将列表中的数据导出EXCEL，所见即所得</td></tr><tr><td>2、规则定义</td><td align="center"></td></tr><tr><td>列表排序</td><td align="center">先展示未立项数据，再展示已立项数据。已立项数据按照导入时间进行倒叙。已立项数据按照“立项时间”进行倒叙。</td></tr><tr><td>分页</td><td align="center">每页显示10行数据。</td></tr><tr><td>默认展示数据</td><td align="center">全量数据</td></tr><tr><td><em><strong>*3权限说明*</strong></em></td><td align="center"></td></tr><tr><td><em><strong>*操作权限*</strong></em></td><td align="center">操作人：规划经理：项目导入、项目关联、发起评审、查询、导出任务经理：项目关联、查询、导出</td></tr><tr><td><em><strong>*数据权限*</strong></em></td><td align="center">管理员、规划经理：可查看所有数据。任务经理：只查看归属自己的项目评估人员：可查看自己评估的项目，点到项目台账中</td></tr></tbody></table><p><strong>列表字段查询栏</strong></p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*字段名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th align="center"><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">年度</td><td align="center">下拉选择框</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">项目名称</td><td align="center">文本查询栏</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">项目编号</td><td align="center">文本查询栏</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">规划经理</td><td align="center">文本查询栏</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">任务经理</td><td align="center">文本查询栏</td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">项目状态</td><td align="center">下拉选择框</td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">立项前评估是否完成</td><td align="center">下拉选择框</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">结算前评估是否完成</td><td align="center">下拉选择框</td><td align="center"></td></tr></tbody></table><p><strong>列表字段信息说明</strong></p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*字段名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">项目名称</td><td align="center">关联后，已立项项目名称和编号进行替换</td><td>蓝色超链接，点击进入项目台账，可看到项目下所有评审文件</td></tr><tr><td align="center">2</td><td align="center">项目编号</td><td align="center"></td><td></td></tr><tr><td align="center">3</td><td align="center">规划经理</td><td align="center">自动带出</td><td></td></tr><tr><td align="center">4</td><td align="center">任务经理</td><td align="center">自动带出</td><td></td></tr><tr><td align="center">5</td><td align="center">项目状态</td><td align="center">取接口字段“项目全流程状态”</td><td></td></tr><tr><td align="center">6</td><td align="center">实际立项时间</td><td align="center">取接口字段</td><td></td></tr><tr><td align="center">7</td><td align="center">项目概算</td><td align="center">取接口字段</td><td></td></tr><tr><td align="center">8</td><td align="center">设计预算</td><td align="center">取接口字段</td><td></td></tr><tr><td align="center">9</td><td align="center">立项前评估是否完成</td><td align="center">判断相应会审纪要是否上传</td><td></td></tr><tr><td align="center">10</td><td align="center">立项前评估金额</td><td align="center">上传相应会审纪要时，会提供系统内该项目已评估金额，因存在历史数据问题，可修改此金额，作为列表值</td><td></td></tr><tr><td align="center">11</td><td align="center">结算前评估是否完成</td><td align="center">判断相应会审纪要是否上传</td><td></td></tr><tr><td align="center">12</td><td align="center">结算前评估金额</td><td align="center">上传相应会审纪要时，会提供系统内该项目已评估金额，因存在历史数据问题，可修改此金额，作为列表值</td><td></td></tr></tbody></table><h2 id="3-项目导入"><a href="#3-项目导入" class="headerlink" title="3.项目导入"></a>3.项目导入</h2><p><em><strong>*功能说明*</strong></em></p><p>规划经理在【业支项目管理】列表点击“项目导入”按钮进入此功能模块，按照年度导入或者维护未立项数据。</p><p><strong>列表功能点按钮</strong></p><table><thead><tr><th align="center"><em><strong>*【项目导入列表】*</strong></em></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><em><strong>*1、功能点*</strong></em></td><td align="center"></td></tr><tr><td align="center"><em><strong>*功能名称*</strong></em></td><td align="center"><em><strong>*说明*</strong></em></td></tr><tr><td align="center">维护</td><td align="center">选择相应年度数据进行维护。系统默认产生2023-2025年年度数据，以后每年1月1号自动生成本年度数据。</td></tr><tr><td align="center">查询</td><td align="center">通过查询条件，对列表数据进行查询。</td></tr><tr><td align="center">导出</td><td align="center">可将列表中的数据导出EXCEL，所见即所得</td></tr><tr><td align="center">2、规则定义</td><td align="center"></td></tr><tr><td align="center">列表排序</td><td align="center">按照“年度”进行倒叙。</td></tr><tr><td align="center">分页</td><td align="center">每页显示10行数据。</td></tr><tr><td align="center">默认展示数据</td><td align="center">全量数据</td></tr><tr><td align="center"><em><strong>*3权限说明*</strong></em></td><td align="center"></td></tr><tr><td align="center"><em><strong>*操作权限*</strong></em></td><td align="center">操作人：规划经理</td></tr><tr><td align="center"><em><strong>*数据权限*</strong></em></td><td align="center">管理员、规划经理：可查看所有数据。</td></tr></tbody></table><p><strong>列表字段</strong></p><p>查询栏：</p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*字段名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th align="center"><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">项目年度</td><td align="center">下拉选择框</td><td align="center"></td></tr></tbody></table><p>列表字段信息说明：</p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*字段名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th align="center"><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">序号</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">项目年度</td><td align="center">自动带出，超链接，点击可查看</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">编辑人</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">最近更新时间</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">项目数</td><td align="center">自动计算带出</td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">已立项项目数</td><td align="center">自动计算带出</td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">状态</td><td align="center">草稿、已发布</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">操作</td><td align="center">编辑：对“草稿”状态的数据进行编辑维护：对“已发布”状态的数据进行维护</td><td align="center"></td></tr></tbody></table><p><em><strong>*表单功能点按钮*</strong></em></p><p>规划经理点击“新增”或者选择具体数据点击“维护”时，进入“业支项目管理”编辑表单。</p><table><thead><tr><th align="center"><em><strong>*【项目导入表单】*</strong></em></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><em><strong>*1、功能点*</strong></em></td><td align="center"></td></tr><tr><td align="center"><em><strong>*功能名称*</strong></em></td><td align="center"><em><strong>*说明*</strong></em></td></tr><tr><td align="center">发布</td><td align="center">对编辑的数据进行发布，点击时要求有提示信息：是否确认发布</td></tr><tr><td align="center">保存为草稿</td><td align="center">将编辑的数据保存为草稿</td></tr><tr><td align="center">注销</td><td align="center">将本次编辑的内容进行注销，点击时要求有提示信息：是否确认注销</td></tr><tr><td align="center">模版下载</td><td align="center">点击后下载预制模版</td></tr><tr><td align="center">导入</td><td align="center">按照模版编辑后，将信息进行导入</td></tr></tbody></table><p><em><strong>*表单字段*</strong></em></p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*归属类别*</strong></em></th><th align="center"><em><strong>*信息项名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">基本信息</td><td align="center">项目年度</td><td align="center">自动带出</td></tr><tr><td align="center">2</td><td align="center">编辑人</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">更新时间</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">项目清单</td><td align="center">序号</td><td align="center">自动带出</td></tr><tr><td align="center">5</td><td align="center">项目名称</td><td align="center">导入模版导入</td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">任务经理</td><td align="center">导入模版导入</td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">规划经理</td><td align="center">导入模版导入</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">项目编号（立项后）</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">操作</td><td align="center">关联：可手动关联从CPMS同步的项目； 新增：新增一条项目信息，编辑项目名称，选择任务经理 删除：删除一条项目信息，若删除时判断该项目下已经有成本评估信息，则不允许删除</td><td align="center"></td></tr></tbody></table><h2 id="4-业支项目台账"><a href="#4-业支项目台账" class="headerlink" title="4.业支项目台账"></a>4.业支项目台账</h2><p><em><strong>*功能说明*</strong></em></p><p>点击列表中数据“项目名称”，进入项目台账。</p><p>可全量查看、下载项目下评估附件，包括上传评估文件以及评估后报告等。</p><p><em><strong>*功能点按钮*</strong></em></p><table><thead><tr><th><em><strong>*【业支项目台账】*</strong></em></th><th></th></tr></thead><tbody><tr><td><em><strong>*1、功能点*</strong></em></td><td></td></tr><tr><td><em><strong>*功能名称*</strong></em></td><td><em><strong>*说明*</strong></em></td></tr><tr><td>打包下载</td><td>可勾选相应附件进行打包下载，下载时按照评估时维度在压缩包里</td></tr></tbody></table><p>附件列表</p><table><thead><tr><th><em><strong>*序号*</strong></em></th><th><em><strong>*归属类别*</strong></em></th><th><em><strong>*信息项名称*</strong></em></th><th><em><strong>*业务规则描述*</strong></em></th><th><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td>1</td><td>附件列表</td><td>附件类型</td><td>自动带出</td><td></td></tr><tr><td>2</td><td>附件名称</td><td>自动带出</td><td></td><td></td></tr><tr><td>3</td><td>上传时间</td><td>自动带出</td><td></td><td></td></tr><tr><td>4</td><td>上传人</td><td>自动带出</td><td></td><td></td></tr></tbody></table><p><em><strong>*示例*</strong></em></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/wps1.jpg" alt="img"> </p><h2 id="5-发起评估"><a href="#5-发起评估" class="headerlink" title="5.发起评估"></a>5.发起评估</h2><p><em><strong>*功能说明*</strong></em></p><p>规划经理选择项目发起评估，勾选未立项项目，发起立项前评估；勾选已立项项目，发起结算前评估</p><p><em><strong>*流程说明*</strong></em></p><p>要求退回时，可退至任何环节，由用户进行选择。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240828161803610.png" alt="image-20240828161803610"></p><table><thead><tr><th align="center"><em><strong>*【成本度量管理表单】*</strong></em></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><em><strong>*1、功能点*</strong></em></td><td align="center"></td></tr><tr><td align="center"><em><strong>*功能名称*</strong></em></td><td align="center"><em><strong>*说明*</strong></em></td></tr><tr><td align="center">提交审批</td><td align="center">对编辑的数据进行审批提交，点击时要求有提示信息：是否确认提交</td></tr><tr><td align="center">保存为草稿</td><td align="center">将编辑的数据保存为草稿</td></tr><tr><td align="center">注销</td><td align="center">将本次编辑的内容进行注销，点击时要求有提示信息：是否确认注销</td></tr><tr><td align="center">流程监控</td><td align="center">显示流程信息</td></tr><tr><td align="center">版本记录</td><td align="center">可查看变更前版本</td></tr><tr><td align="center">附件上传</td><td align="center">任务经理提交评估结果页面上传类型：表一：需求说明书<em>、表二：业务需求汇总表</em>、表三：成本度量模型表* 、其他评估负责人确认评估结果页面：成本度量报告（WORD）；成本度量报告（EXCEL）。其中excel文件需要去读取第一页相关数据，形成格式化数据。<strong>要求每一个类型可以批量上传，减少上传操作</strong></td></tr></tbody></table><p><strong>功能点按钮</strong></p><table><thead><tr><th align="center"><em><strong>*【成本度量管理表单】*</strong></em></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><em><strong>*1、功能点*</strong></em></td><td align="center"></td></tr><tr><td align="center"><em><strong>*功能名称*</strong></em></td><td align="center"><em><strong>*说明*</strong></em></td></tr><tr><td align="center">提交审批</td><td align="center">对编辑的数据进行审批提交，点击时要求有提示信息：是否确认提交</td></tr><tr><td align="center">保存为草稿</td><td align="center">将编辑的数据保存为草稿</td></tr><tr><td align="center">注销</td><td align="center">将本次编辑的内容进行注销，点击时要求有提示信息：是否确认注销</td></tr><tr><td align="center">流程监控</td><td align="center">显示流程信息</td></tr><tr><td align="center">版本记录</td><td align="center">可查看变更前版本</td></tr><tr><td align="center">附件上传</td><td align="center">任务经理提交评估结果页面上传类型：表一：需求说明书<em>、表二：业务需求汇总表</em>、表三：成本度量模型表* 、其他评估负责人确认评估结果页面：成本度量报告（WORD）；成本度量报告（EXCEL）。其中excel文件需要去读取第一页相关数据，形成格式化数据。<strong>要求每一个类型可以批量上传，减少上传操作</strong></td></tr></tbody></table><p><strong>发起表单字段</strong></p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*归属类别*</strong></em></th><th align="center"><em><strong>*信息项名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th align="center"><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">基本信息</td><td align="center">评估类型*</td><td align="center">单选下拉框：立项前评估；立项后评估</td><td align="center">进来根据规则默认</td></tr><tr><td align="center">2</td><td align="center">项目名称*</td><td align="center">自动带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">项目编号*</td><td align="center">自动带出，立项前评估无编号时，置灰</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">任务经理*</td><td align="center">默认带出，可变换</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">规划经理*</td><td align="center">默认带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">编辑时间*</td><td align="center">自动带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">说明*</td><td align="center">长文本编辑框</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">功能模块</td><td align="center">功能模块</td><td align="center"></td><td align="center">至少有一个功能模块</td></tr><tr><td align="center">9</td><td align="center">供应商</td><td align="center">关键字查询，比如输入华信，自动跳出华信咨询设计研究院</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">10</td><td align="center">操作</td><td align="center">新增、删除</td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>任务经理提交评估结果：</strong></p><p>根据发起时“供应商”情况，发起待办，一个供应商汇总为一条待办，并出现在相应【成本度量管理】列表。</p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*归属类别*</strong></em></th><th align="center"><em><strong>*信息项名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th align="center"><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">基本信息</td><td align="center">评估类型*</td><td align="center">自动带出</td><td align="center">进来根据规则默认</td></tr><tr><td align="center">2</td><td align="center">项目名称*</td><td align="center">自动带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">项目编号*</td><td align="center">自动带出，立项前评估无编号时，置灰</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">任务经理*</td><td align="center">默认带出，可变换</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">规划经理*</td><td align="center">默认带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">供应商*</td><td align="center">文本填写框</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">预估工作量（人天）*</td><td align="center">自动累加，不可更改</td><td align="center">任务经理编辑</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">预估金额（元）*</td><td align="center">自动累加</td><td align="center">任务经理编辑</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">编辑时间*</td><td align="center">自动带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">10</td><td align="center">说明*</td><td align="center">自动带出发起人</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">11</td><td align="center">说明*</td><td align="center">文本框，任务经理自行说明</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">12</td><td align="center">功能模块</td><td align="center">功能模块</td><td align="center"></td><td align="center">仅保留该厂商功能模块</td></tr><tr><td align="center">13</td><td align="center">供应商</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">14</td><td align="center">预估工作量（人天）*</td><td align="center">自行填写</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">15</td><td align="center">预估金额（元）*</td><td align="center">自行填写</td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>评估负责人初审</strong></p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*归属类别*</strong></em></th><th align="center"><em><strong>*信息项名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th align="center"><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">基本信息</td><td align="center">评估类型*</td><td align="center">自动带出</td><td align="center">进来根据规则默认</td></tr><tr><td align="center">2</td><td align="center">项目名称*</td><td align="center">自动带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">项目编号*</td><td align="center">自动带出，立项前评估无编号时，置灰</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">任务经理*</td><td align="center">默认带出，可变换</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">规划经理*</td><td align="center">默认带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">供应商*</td><td align="center">文本填写框</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">预估工作量（人天）*</td><td align="center">自动累加，不可更改</td><td align="center">任务经理编辑</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">预估金额（元）*</td><td align="center">自动累加，不可更改</td><td align="center">任务经理编辑</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">最终结果（人天）</td><td align="center">自动累加，不可更改</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">10</td><td align="center">最终结果（元）</td><td align="center">自动累加，不可更改</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">11</td><td align="center">编辑时间*</td><td align="center">自动带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">12</td><td align="center">说明*</td><td align="center">自动带出发起人</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">13</td><td align="center">说明*</td><td align="center">自动带出任务经理编写</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">14</td><td align="center">评估意见*</td><td align="center">长文本编辑框</td><td align="center">评估单位负责人确认评估结果时填写</td><td align="center"></td></tr><tr><td align="center">15</td><td align="center">功能模块</td><td align="center">功能模块</td><td align="center"></td><td align="center">仅保留该厂商功能模块</td></tr><tr><td align="center">16</td><td align="center">供应商</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">17</td><td align="center">预估工作量（人天）*</td><td align="center">自行填写</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">18</td><td align="center">预估金额（元）*</td><td align="center">自行填写</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">19</td><td align="center">评估结果</td><td align="center">需求名称</td><td align="center"></td><td align="center">1、评估单位上传评估报告（EXCEL）中自动读取 2、多个文件读取需累加 模版待定</td></tr><tr><td align="center">20</td><td align="center">供应商名称</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">21</td><td align="center">最终结果（人天）</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">22</td><td align="center">最终结果（元）</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="成本度量管理"><a href="#成本度量管理" class="headerlink" title="成本度量管理"></a><strong>成本度量管理</strong></h1><p><em><strong>*需求部门*</strong></em></p><p>规划技术部</p><p><em><strong>*用户目标*</strong></em></p><p>将投资项目<strong>成本度量管理线上化</strong>，任务经理通过该模块，提交相应<strong>立项前规模评估申请</strong>以及<strong>结算前规模评估申请</strong>；规划经理接收后转派给<strong>评估单位负责人进行评估。</strong></p><p><em><strong>*使用对象*</strong></em></p><p>任务经理、规划经理、评估单位负责人</p><h2 id="1-成本度量管理列表"><a href="#1-成本度量管理列表" class="headerlink" title="1.成本度量管理列表"></a>1.成本度量管理列表</h2><p><em><strong>*功能说明*</strong></em></p><p>任务经理可以在成本度量管理列表，查看项目成本度量申请，以及提交变更申请。</p><p><em><strong>*功能点按钮*</strong></em></p><table><thead><tr><th align="center"><em><strong>*【成本度量管理列表】*</strong></em></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><em><strong>*1、功能点*</strong></em></td><td align="center"></td></tr><tr><td align="center"><em><strong>*功能名称*</strong></em></td><td align="center"><em><strong>*说明*</strong></em></td></tr><tr><td align="center">变更</td><td align="center">列表上按钮，可点击该条业务数据进行变更；变更信息提交后，列表上业务数据更新为变更后数据；若想查看变更前数据，从查看页面中变更版本中进行查看。</td></tr><tr><td align="center">评估结果查看</td><td align="center">列表上按钮，点击此按钮，可查看评估结果页面，需流程审批结束。</td></tr><tr><td align="center">查询</td><td align="center">通过查询条件，对列表数据进行查询。</td></tr><tr><td align="center">模版下载</td><td align="center">将nesma以及cosmic模版放在一个压缩包里供用户下载</td></tr><tr><td align="center">导出</td><td align="center">可将列表中的数据导出EXCEL，所见即所得</td></tr><tr><td align="center">2、规则定义</td><td align="center"></td></tr><tr><td align="center">列表排序</td><td align="center">先按照状态进行排序，“草稿”、“审批中”、“已审批”；再按照“提交时间”进行倒叙。</td></tr><tr><td align="center">分页</td><td align="center">每页显示10-20行数据。</td></tr><tr><td align="center">默认展示数据</td><td align="center">全量数据</td></tr><tr><td align="center">兼容性</td><td align="center">随浏览器分辨率进行兼容</td></tr><tr><td align="center"><em><strong>*3权限说明*</strong></em></td><td align="center"></td></tr><tr><td align="center"><em><strong>*操作权限*</strong></em></td><td align="center">（1）操作人：任务经理可点击 “变更”、“导出”、“评估结果查看”等功能。（2）操作人：规划经理、评估单位负责人可点击“评估结果查看”、“导出”（3）其他角色仅有数据查看权限</td></tr><tr><td align="center"><em><strong>*数据权限*</strong></em></td><td align="center">任务经理：可以看到自己发起的项目的数据</td></tr><tr><td align="center">规划经理：全部数据</td><td align="center"></td></tr><tr><td align="center">评估单位负责人：规划经理委派给自己单位的数据</td><td align="center"></td></tr><tr><td align="center">部门管理员：可以看到自己部门的数据</td><td align="center"></td></tr><tr><td align="center">部门领导：规划技术部领导可看到全部数据；其他部门领导可看到自己部门的数据</td><td align="center"></td></tr></tbody></table><p><strong>列表字段</strong></p><p>查询栏：</p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*字段名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th align="center"><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">年度</td><td align="center">下拉选择框，默认最新项目的年度</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">项目名称</td><td align="center">文本查询栏</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">项目编号</td><td align="center">文本查询栏</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">评估类型</td><td align="center">下拉选择框，默认“全部”</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">供应商</td><td align="center">文本查询栏</td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">状态</td><td align="center">下拉选择框，默认“全部”</td><td align="center"></td></tr></tbody></table><p>列表字段信息说明：</p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*字段名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th align="center"><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">序号</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">项目名称</td><td align="center">自动带出 立项前评估时，项目还没有立项，列表和表单显示选择的或自行填写的项目；后续根据规则自动关联后自动替换 结算前评估时，直接带出</td><td align="center">蓝色超链接，点击可看任务经理提交的页面。</td></tr><tr><td align="center">3</td><td align="center">项目编号</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">评估类型</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">任务经理</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">规划经理</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">供应商</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">是否存在变更</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">提交时间</td><td align="center">自动带出</td><td align="center"></td></tr><tr><td align="center">10</td><td align="center">状态</td><td align="center">“审批中”、“已审批”</td><td align="center"></td></tr><tr><td align="center">11</td><td align="center">当前环节</td><td align="center">取流程中对应环节及其相应负责人，审批结束后置为空</td><td align="center"></td></tr><tr><td align="center">12</td><td align="center">当前环节处理人</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">13</td><td align="center">操作</td><td align="center">“变更”、“评估结果查看” 具体见功能点描述</td><td align="center"></td></tr></tbody></table><h2 id="2-成本度量变更"><a href="#2-成本度量变更" class="headerlink" title="2.成本度量变更"></a>2.<strong>成本度量变更</strong></h2><p><em><strong>*功能说明*</strong></em></p><p>任务经理提交成本度量变更申请，经过审批后，形成评估结果。</p><p><strong>功能点按钮</strong></p><table><thead><tr><th align="center"><em><strong>*【成本度量管理表单】*</strong></em></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><em><strong>*1、功能点*</strong></em></td><td align="center"></td></tr><tr><td align="center"><em><strong>*功能名称*</strong></em></td><td align="center"><em><strong>*说明*</strong></em></td></tr><tr><td align="center">提交审批</td><td align="center">对编辑的数据进行审批提交，点击时要求有提示信息：是否确认提交</td></tr><tr><td align="center">保存为草稿</td><td align="center">将编辑的数据保存为草稿</td></tr><tr><td align="center">注销</td><td align="center">将本次编辑的内容进行注销，点击时要求有提示信息：是否确认注销</td></tr><tr><td align="center">流程监控</td><td align="center">显示流程信息</td></tr><tr><td align="center">版本记录</td><td align="center">可查看变更前版本</td></tr><tr><td align="center">附件上传</td><td align="center">编辑页面上传类型：表一：需求说明书<em>、表二：业务需求汇总表</em>、表三：成本度量模型表* 、其他评估负责人确认评估结果页面：成本度量报告（WORD）；成本度量报告（EXCEL）。其中excel文件需要去读取第一页相关数据，形成格式化数据。<strong>每一个类型可以批量上传，减少上传操作</strong></td></tr></tbody></table><p><em><strong>*任务经理提交表单字段*</strong></em></p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*归属类别*</strong></em></th><th align="center"><em><strong>*信息项名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th align="center"><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">基本信息</td><td align="center">评估类型*</td><td align="center">自动带出</td><td align="center">进来根据规则默认</td></tr><tr><td align="center">2</td><td align="center">项目名称*</td><td align="center">自动带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">项目编号*</td><td align="center">自动带出，立项前评估无编号时，置灰</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">任务经理*</td><td align="center">默认带出，可变换</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">规划经理*</td><td align="center">默认带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">供应商*</td><td align="center">文本填写框</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">预估工作量（人天）*</td><td align="center">自动累加，不可更改</td><td align="center">任务经理编辑</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">预估金额（元）*</td><td align="center">自动累加</td><td align="center">任务经理编辑</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">编辑时间*</td><td align="center">自动带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">10</td><td align="center">说明*</td><td align="center">自动带出发起人</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">11</td><td align="center">说明*</td><td align="center">文本框，任务经理自行说明</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">12</td><td align="center">功能模块</td><td align="center">功能模块</td><td align="center"></td><td align="center">仅保留该厂商功能模块</td></tr><tr><td align="center">13</td><td align="center">供应商</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">14</td><td align="center">预估工作量（人天）*</td><td align="center">自行填写</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">15</td><td align="center">预估金额（元）*</td><td align="center">自行填写</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>评估单位负责人初审：</p><table><thead><tr><th align="center"><em><strong>*序号*</strong></em></th><th align="center"><em><strong>*归属类别*</strong></em></th><th align="center"><em><strong>*信息项名称*</strong></em></th><th align="center"><em><strong>*业务规则描述*</strong></em></th><th align="center"><em><strong>*备注*</strong></em></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">基本信息</td><td align="center">评估类型*</td><td align="center">自动带出</td><td align="center">进来根据规则默认</td></tr><tr><td align="center">2</td><td align="center">项目名称*</td><td align="center">自动带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">项目编号*</td><td align="center">自动带出，立项前评估无编号时，置灰</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">任务经理*</td><td align="center">默认带出，可变换</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">规划经理*</td><td align="center">默认带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">供应商*</td><td align="center">文本填写框</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">预估工作量（人天）*</td><td align="center">自动累加，不可更改</td><td align="center">任务经理编辑</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">预估金额（元）*</td><td align="center">自动累加，不可更改</td><td align="center">任务经理编辑</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">最终结果（人天）</td><td align="center">自动累加，不可更改</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">10</td><td align="center">最终结果（元）</td><td align="center">自动累加，不可更改</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">11</td><td align="center">编辑时间*</td><td align="center">自动带出</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">12</td><td align="center">说明*</td><td align="center">自动带出发起人</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">13</td><td align="center">说明*</td><td align="center">自动带出任务经理编写</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">14</td><td align="center">评估意见*</td><td align="center">长文本编辑框</td><td align="center">评估单位负责人确认评估结果时填写</td><td align="center"></td></tr><tr><td align="center">15</td><td align="center">功能模块</td><td align="center">功能模块</td><td align="center"></td><td align="center">仅保留该厂商功能模块</td></tr><tr><td align="center">16</td><td align="center">供应商</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">17</td><td align="center">预估工作量（人天）*</td><td align="center">自行填写</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">18</td><td align="center">预估金额（元）*</td><td align="center">自行填写</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">19</td><td align="center">评估结果</td><td align="center">需求名称</td><td align="center"></td><td align="center">1、评估单位上传评估报告（EXCEL）中自动读取 2、多个文件读取需累加 模版待定</td></tr><tr><td align="center">20</td><td align="center">供应商名称</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">21</td><td align="center">最终结果（人天）</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">22</td><td align="center">最终结果（元）</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="3-项目评估结果自动生成"><a href="#3-项目评估结果自动生成" class="headerlink" title="3.项目评估结果自动生成"></a>3.<strong>项目评估结果自动生成</strong></h2><p><em><strong>*需求部门*</strong></em></p><p>规划技术部</p><p><strong>用户目标</strong></p><p>规划经理基于项目，生成立项前或者结算前项目评估报告。</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> 华信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> 华信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端拖动可排序</title>
      <link href="/2024/08/18/Project/%E5%89%8D%E7%AB%AF%E5%8F%AF%E6%8B%96%E5%8A%A8%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/08/18/Project/%E5%89%8D%E7%AB%AF%E5%8F%AF%E6%8B%96%E5%8A%A8%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前端可拖动排序"><a href="#前端可拖动排序" class="headerlink" title="前端可拖动排序"></a>前端可拖动排序</h1><p>前端列表<el-row>和<el-tab>样式的可拖动排序</el-tab></el-row></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240822090004682.png" alt="image-20240822090004682"></p><p>1.步骤，前端正常写<el-row>表格，并且存放字段</el-row></p><p>2.在vue生命周期函数mounted中调用初始化拖动调整顺序的方法</p><p><strong>操作 DOM 元素</strong>：因为在 <code>mounted()</code> 调用时，组件的 DOM 结构已经被渲染出来，</p><p>​所有 DOM 元素都是可访问的。这时候可以安全地操作 DOM 元素。</p><p><strong>初始化第三方库</strong>：像 SortableJS 这样的第三方库，通常依赖于存在的 DOM 元素来进行操作，</p><p>​因此需要在 DOM 渲染完成后进行初始化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">initSort</span>()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>3.method里定义初始化排序方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">initSort</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于获取页面中所有符合指定选择器的元素的函数,这里查找的是表格的&lt;tbody&gt;部分。</span></span><br><span class="line">    <span class="comment">//选择第一个元素，el应该是一个dom元素，而不是一个值</span></span><br><span class="line">  <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.el-table__body-wrapper &gt; table &gt; tbody&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span><br><span class="line">    <span class="comment">//使用了 SortableJS 库，它是一个开源的库，用于实现可拖动排序的功能。</span></span><br><span class="line">  <span class="keyword">const</span> sortable = <span class="keyword">new</span> <span class="title class_">Sortable</span>(el, &#123;</span><br><span class="line">      <span class="comment">//这是 SortableJS 的一个回调函数，当拖拽操作结束时触发。</span></span><br><span class="line">      <span class="comment">//evt.oldIndex 和 evt.newIndex 分别表示拖动前后元素的索引位置。</span></span><br><span class="line">    <span class="attr">onEnd</span>: <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//移除被拖动的行。删除从oldIndex开始的第1行，返回被删除的第一个元素（唯一一个）</span></span><br><span class="line">      <span class="keyword">const</span> curRow = <span class="variable language_">this</span>.<span class="property">projectPhaseInputList</span>.<span class="title function_">splice</span>(evt.<span class="property">oldIndex</span>, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">      <span class="comment">//将移除的行插入到新位置。0表示不删除任何元素，curRow表示要插入元素</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">projectPhaseInputList</span>.<span class="title function_">splice</span>(evt.<span class="property">newIndex</span>, <span class="number">0</span>, curRow);</span><br><span class="line">        <span class="comment">//拖拽排序完成后对数据进行进一步处理</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">adjustPhaseOrder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.拖拽完成排序后，对数据进行进一步处理，生成弹窗</p><p>​<code>确定</code>：调整序号，保存</p><p>​    <code>取消</code>：放弃调整，重新获取列表数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">adjustPhaseOrder</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable language_">this</span>.$confirm(<span class="string">&#x27;是否按该顺序调整？&#x27;</span>, <span class="string">&#x27;提示&#x27;</span>, &#123;</span><br><span class="line">       <span class="attr">confirmButtonText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">       <span class="attr">cancelButtonText</span>: <span class="string">&#x27;取消&#x27;</span>,</span><br><span class="line">       <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">     &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">//点击确定的时候，执行保存方法，保存调整后的顺序</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">saveAdjustPhaseOrderData</span>();</span><br><span class="line">     &#125;).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">//点击取消的时候，放弃调整，重新获取列表数据</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">getProjectPhaseInputList</span>();</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br><span class="line">       </span><br><span class="line">   <span class="comment">//异步的方法：用于将调整后的阶段顺序保存到数据库中</span></span><br><span class="line">   <span class="keyword">async</span> <span class="title function_">saveAdjustPhaseOrderData</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="comment">//显示加载动画</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">tableLoading</span> = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">const</span> promises = [];</span><br><span class="line">       <span class="comment">//遍历调整序号，调整后调用api方法存入数据库中</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="variable language_">this</span>.<span class="property">projectPhaseInputList</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(i != <span class="variable language_">this</span>.<span class="property">projectPhaseInputList</span>[i-<span class="number">1</span>].<span class="property">phaseOrder</span>)&#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">projectPhaseInputList</span>[i-<span class="number">1</span>].<span class="property">phaseOrder</span> = i;</span><br><span class="line">         promises.<span class="title function_">push</span>(<span class="title function_">saveProjectPhaseInput</span>(<span class="variable language_">this</span>.<span class="property">projectPhaseInputList</span>[i-<span class="number">1</span>]).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">         &#125;));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="comment">// 等待所有异步操作完成</span></span><br><span class="line">     <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">tableLoading</span> = <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"> <span class="comment">//从后端获取当前项目阶段的输入列表，并更新      </span></span><br><span class="line">   <span class="title function_">getProjectPhaseInputList</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">//开始加载动画</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">tableLoading</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//api方法，发送请求，获取阶段输入列表</span></span><br><span class="line">   <span class="title function_">getProjectPhaseInputByConfigId</span>(<span class="variable language_">this</span>.<span class="property">projectTypeConfig</span>.<span class="property">boProjectTypeConfigId</span>)</span><br><span class="line">         .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">projectPhaseInputList</span> = response;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">tableLoading</span> = <span class="literal">false</span>;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><el-tab>拖动可排序</el-tab></p><p>同上，使用sortable的开源库，获取dom元素，</p><p>执行回调：移除被拖动的行，将移除的行插入到新的位置</p><p>再次执行，对拖拽完成的数据进一步处理</p><p>主要不同的地方是：dom元素的获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">initSort2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// const el1 = document.querySelectorAll(&#x27;#tagInput &gt; span&#x27;);</span></span><br><span class="line">    <span class="comment">// console.log(&quot;这是tags的el1元素长度&quot;+el1.length);</span></span><br><span class="line">    <span class="comment">// console.log(&quot;这是tags的el1元素&quot;+el1);</span></span><br><span class="line">    <span class="keyword">const</span> el2 = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;#tagInput&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// console.log(&quot;这是tags的el2元素&quot;+el2);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sortable2 = <span class="keyword">new</span> <span class="title class_">Sortable</span>(el2, &#123;</span><br><span class="line">      <span class="attr">onEnd</span>: <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> curRow = <span class="variable language_">this</span>.<span class="property">projectPhaseInput</span>.<span class="property">fileList</span>.<span class="title function_">splice</span>(evt.<span class="property">oldIndex</span>, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">projectPhaseInput</span>.<span class="property">fileList</span>.<span class="title function_">splice</span>(evt.<span class="property">newIndex</span>, <span class="number">0</span>, curRow);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">projectPhaseInput</span>.<span class="property">fileList</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//table</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.el-table__body-wrapper &gt; table &gt; tbody&#x27;</span>)[<span class="number">0</span>]      </span><br><span class="line"><span class="comment">//tag</span></span><br><span class="line"><span class="keyword">const</span> el2 = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;#tagInput&#x27;</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>table查看信息中的dom元素</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240828092126695.png" alt="image-20240828092126695"></p><p>tag查看信息中的dom元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tag</span></span><br><span class="line"><span class="keyword">const</span> el2 = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;#tagInput&#x27;</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>这里就很奇怪，只有点击了添加附件类型才能生成dom元素tag</p><p>才能拿到，有点小bug</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240828092337075.png" alt="image-20240828092337075"></p><p>解决bug方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;projectPhaseInput.fileList&#x27;</span>(newVal, oldVal) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initSort2</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置监听器，监听tag列表新值，和旧值的变化，</p><p>再<code>$nextTick</code> 是 Vue.js 中的一个方法，用于在下一次 DOM 更新循环之后执行回调。这确保了 DOM 已经完成更新，然后再执行接下来的操作。</p><p>就可以拿到dom元素了</p><p>再执行初始化拖动就可以获取dom元素了</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> 华信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> 华信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支管理</title>
      <link href="/2024/08/18/Project/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2024/08/18/Project/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Git分支管理</p><p>Git 分支（branch）是 Git 版本控制系统中的一个关键概念，允许开发人员并行开发、修复 bug、实验新功能以及管理多个开发版本。以下是对 Git 分支的详细介绍：</p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li><strong>分支</strong>：分支是一个可移动的指针，指向某个提交对象。创建一个新的分支意味着创建一个指针，指向当前的提交。通过切换分支，你可以在不同的开发线中自由地切换。</li><li><strong>主分支（Master&#x2F;Main）</strong>：传统上，<code>master</code> 是默认的主要分支，通常用于存放稳定的代码版本。近年来，<code>main</code> 分支逐渐取代 <code>master</code> 成为新的默认分支名称。</li></ul><h3 id="2-分支操作"><a href="#2-分支操作" class="headerlink" title="2. 分支操作"></a>2. 分支操作</h3><h4 id="2-1-创建分支"><a href="#2-1-创建分支" class="headerlink" title="2.1 创建分支"></a>2.1 创建分支</h4><p>创建一个新的分支可以使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>例如，创建一个名为 <code>feature-xyz</code> 的新分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch feature-xyz</span><br></pre></td></tr></table></figure><h4 id="2-2-切换分支"><a href="#2-2-切换分支" class="headerlink" title="2.2 切换分支"></a>2.2 切换分支</h4><p>切换到一个现有分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>例如，切换到 <code>feature-xyz</code> 分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-xyz</span><br></pre></td></tr></table></figure><h4 id="2-3-创建并切换分支"><a href="#2-3-创建并切换分支" class="headerlink" title="2.3 创建并切换分支"></a>2.3 创建并切换分支</h4><p>创建一个新分支并切换到该分支，可以使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>例如，创建并切换到 <code>feature-abc</code> 分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature-abc</span><br></pre></td></tr></table></figure><h4 id="2-4-查看分支"><a href="#2-4-查看分支" class="headerlink" title="2.4 查看分支"></a>2.4 查看分支</h4><p>查看所有分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>带上 <code>-a</code> 参数，可以查看所有本地和远程分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h4 id="2-5-合并分支"><a href="#2-5-合并分支" class="headerlink" title="2.5 合并分支"></a>2.5 合并分支</h4><p>将另一个分支合并到当前分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>例如，将 <code>feature-xyz</code> 分支合并到当前分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge feature-xyz</span><br></pre></td></tr></table></figure><h4 id="2-6-删除分支"><a href="#2-6-删除分支" class="headerlink" title="2.6 删除分支"></a>2.6 删除分支</h4><p>删除一个本地分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>例如，删除 <code>feature-xyz</code> 分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature-xyz</span><br></pre></td></tr></table></figure><p>强制删除一个分支（未完全合并时使用）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><h3 id="3-远程分支"><a href="#3-远程分支" class="headerlink" title="3. 远程分支"></a>3. 远程分支</h3><h4 id="3-1-推送分支到远程"><a href="#3-1-推送分支到远程" class="headerlink" title="3.1 推送分支到远程"></a>3.1 推送分支到远程</h4><p>将本地分支推送到远程仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>例如，将 <code>feature-xyz</code> 分支推送到远程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin feature-xyz</span><br></pre></td></tr></table></figure><h4 id="3-2-拉取远程分支"><a href="#3-2-拉取远程分支" class="headerlink" title="3.2 拉取远程分支"></a>3.2 拉取远程分支</h4><p>拉取远程分支并在本地创建对应的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git checkout -b &lt;branch_name&gt; origin/&lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>或者使用以下简化命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>如果本地不存在该分支，它会自动创建并切换到该分支。</p><h4 id="3-3-删除远程分支"><a href="#3-3-删除远程分支" class="headerlink" title="3.3 删除远程分支"></a>3.3 删除远程分支</h4><p>删除远程分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>例如，删除远程 <code>feature-xyz</code> 分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete feature-xyz</span><br></pre></td></tr></table></figure><h3 id="4-分支管理策略"><a href="#4-分支管理策略" class="headerlink" title="4. 分支管理策略"></a>4. 分支管理策略</h3><h4 id="4-1-Git-Flow"><a href="#4-1-Git-Flow" class="headerlink" title="4.1 Git Flow"></a>4.1 Git Flow</h4><p>Git Flow 是一种基于分支的工作流，定义了不同分支的用途和分支间的合并流程：</p><ul><li><strong>主分支（main&#x2F;master）</strong>：存放稳定的发布版本。</li><li><strong>开发分支（develop）</strong>：存放最新的开发版本。</li><li><strong>功能分支（feature）</strong>：用于开发新功能，从 <code>develop</code> 分支创建，开发完成后合并回 <code>develop</code>。</li><li><strong>发布分支（release）</strong>：用于发布准备，从 <code>develop</code> 分支创建，修复 bug 和准备发布，合并回 <code>main</code> 和 <code>develop</code>。</li><li><strong>热修复分支（hotfix）</strong>：用于紧急修复生产环境的 bug，从 <code>main</code> 分支创建，修复完成后合并回 <code>main</code> 和 <code>develop</code>。</li></ul><h4 id="4-2-GitHub-Flow"><a href="#4-2-GitHub-Flow" class="headerlink" title="4.2 GitHub Flow"></a>4.2 GitHub Flow</h4><p>GitHub Flow 是一种简化的工作流，适用于持续部署的项目：</p><ul><li><strong>主分支（main）</strong>：存放生产代码。</li><li><strong>功能分支（feature）</strong>：从 <code>main</code> 分支创建，用于开发新功能或修复 bug，开发完成后通过 Pull Request 合并回 <code>main</code>。</li></ul><h4 id="4-3-GitLab-Flow"><a href="#4-3-GitLab-Flow" class="headerlink" title="4.3 GitLab Flow"></a>4.3 GitLab Flow</h4><p>GitLab Flow 结合了 GitHub Flow 和 Git Flow 的优点：</p><ul><li><strong>环境分支</strong>：如 <code>main</code>、<code>pre-production</code>、<code>production</code>，每个分支对应一个环境。</li><li><strong>功能分支（feature）</strong>：从环境分支创建，开发完成后合并回相应的环境分支。</li></ul><h3 id="5-分支命名规范"><a href="#5-分支命名规范" class="headerlink" title="5. 分支命名规范"></a>5. 分支命名规范</h3><p>采用一致且有意义的分支命名规范可以提高团队协作效率和代码管理清晰度：</p><ul><li><strong>功能分支</strong>：<code>feature/description</code></li><li><strong>修复分支</strong>：<code>fix/description</code></li><li><strong>发布分支</strong>：<code>release/version</code></li><li><strong>热修复分支</strong>：<code>hotfix/description</code></li></ul><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feature/user-authentication</span><br><span class="line">fix/bug-1234</span><br><span class="line">release/v1.0.0</span><br><span class="line">hotfix/critical-bug</span><br></pre></td></tr></table></figure><p>通过这些操作和策略，你可以更好地管理 Git 中的分支，提高开发效率和代码质量。</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> 华信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> 华信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华信实习任务-主页面</title>
      <link href="/2024/07/28/Project/mainpage/"/>
      <url>/2024/07/28/Project/mainpage/</url>
      
        <content type="html"><![CDATA[<h1 id="主页面显示"><a href="#主页面显示" class="headerlink" title="主页面显示"></a>主页面显示</h1><p>2024年7月25日22:05:06</p><p>author：方圆</p><p>任务：主页面的编写和数据显示，前后端</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240725162031260.png" alt="image-20240725162031260"></p><p>五个模块，分别对应表头、近半年工时情况、一周项目动态、资料上传情况、日程安排</p><p>前端：引入自定义组件，去传递每个组件需要的数值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;general-dashboard</span><br><span class="line">    :offsetHeight=91</span><br><span class="line">    :head-data=&quot;generalHeaderData&quot;//表头数据</span><br><span class="line">    :head-click=&quot;handleHeadClick&quot;//表头点击事件</span><br><span class="line">    :left-center-data=&quot;generalLeftCenterData&quot;//折线图数据</span><br><span class="line">    :left-bottom-left-data=&quot;generalLeftBottomLeftData&quot; //一周项目动态</span><br><span class="line">    :left-bottom-left-click=&quot;handleLeftBottomLeftClick&quot; //项目动态点击事件</span><br><span class="line">    :left-bottom-right-data=&quot;generalLeftBottomRightData&quot;//资料上传情况数据</span><br><span class="line">&gt;&lt;/general-dashboard&gt;</span><br></pre></td></tr></table></figure><p>日程安排的组件，新建了一个数据库表单和视图</p><p>后端公共方法：获取用户权限和权限内用户项目数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> ProjectService projectService;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 数据权限类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> DataSecurityService dataSecurityService;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 用户服务类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> UserService userService;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 项目月度工时服务类</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> ProjectMouthManhourService projectMouthManhourService;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 项目阶段附件表service接口</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> ProjectPhaseFileService projectPhaseFileService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@description</span>:获取当前用户权限id和角色列表</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span>: fangyuan</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2024/7/25 11:00</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="keyword">public</span> List&lt;UserRole&gt; <span class="title function_">getUserRoleList</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">currentUserId</span> <span class="operator">=</span> Security.getCurrentUserID();</span><br><span class="line">     List&lt;UserRole&gt; userRoleList = userService.getRoleOfUser(currentUserId);</span><br><span class="line">     <span class="keyword">return</span> userRoleList;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@description</span>:获取当前用户权限内的项目数量的公共方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span>: fangyuan</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2024/7/25 10:26</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="keyword">public</span> List&lt;Project&gt; <span class="title function_">getUserProjects</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">currentUserId</span> <span class="operator">=</span> Security.getCurrentUserID();</span><br><span class="line">     <span class="type">ProjectQueryReq</span> <span class="variable">queryReq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProjectQueryReq</span>();</span><br><span class="line">     <span class="comment">// 设置数据权限</span></span><br><span class="line">     queryReq.setCurrentUserId(currentUserId);</span><br><span class="line">     queryReq.setFirstDeptId(Security.getOrgOfCurrentUser().getOrganizationId());</span><br><span class="line">     <span class="type">String</span> <span class="variable">policyType</span> <span class="operator">=</span> dataSecurityService.getAllPolicyType(<span class="string">&quot;/rest/project/query&quot;</span>);</span><br><span class="line">     queryReq.setPolicyType(policyType);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取当前用户权限内的项目数量</span></span><br><span class="line">     <span class="keyword">return</span> projectService.queryUserProject(queryReq);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1表头数据"><a href="#1表头数据" class="headerlink" title="1表头数据"></a>1表头数据</h2><p><code>后端逻辑</code>：格式化日期，满足要求的count++</p><p>注意：String类型的值比较用Stringutils工具类的equals方法，我直接用equals比较结果不对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@description</span>: res[0] :分母：总数量当前 -人权限内的项目总数量</span></span><br><span class="line"><span class="comment">  * res[1] :分子：本年度数量 -当前人权限内的当前数量</span></span><br><span class="line"><span class="comment">  * res[2] :分子：本年度数量 -当前人权限内的合规材料汇总为是的数量</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span>: fangyuan</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>: 2024/7/23 14:58</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span>[] queryProjectCounts() &#123;</span><br><span class="line">     List&lt;UserRole&gt; userRoleList = getUserRoleList();</span><br><span class="line">     <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">     <span class="keyword">if</span> (userRoleList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         List&lt;Project&gt; userProjects = getUserProjects();</span><br><span class="line">         result[<span class="number">0</span>] = userProjects.size();</span><br><span class="line">         <span class="type">int</span> <span class="variable">countYear</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="type">int</span> <span class="variable">countRule</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="comment">//获取当前年</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">currentYear</span> <span class="operator">=</span> DateFormatUtils.format(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;yyyy&quot;</span>);</span><br><span class="line">         <span class="keyword">for</span> (Project p : userProjects) &#123;</span><br><span class="line">             <span class="keyword">if</span> (Integer.parseInt(p.getProjectYear()) == Integer.parseInt(currentYear)) &#123;</span><br><span class="line">                 countYear++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;是&quot;</span>, p.getIsAdditionalDeductionAllFile())) &#123;</span><br><span class="line">                 countRule++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         result[<span class="number">1</span>] = countYear;</span><br><span class="line">         result[<span class="number">2</span>] = countRule;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>前端逻辑</code>：api.js中配置后端请求方法的url，vue页面中引入然后在methods中，调用方法将值传递进去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询工程数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queryProjectCounts</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>:<span class="string">&#x27;/rest/mainpage/query_project_counts&#x27;</span>,</span><br><span class="line">      <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span>&#123;queryProjectCounts,queryProjectMouthManhour,queryPersonalWork,queryProjectResource&#125; <span class="keyword">from</span> <span class="string">&quot;@/api/mainpage&quot;</span>;  </span><br><span class="line">    </span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">getHeaderData</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="title function_">queryProjectCounts</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">generalHeaderData</span>[<span class="number">0</span>].<span class="property">secNum</span> = response[<span class="number">0</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">generalHeaderData</span>[<span class="number">1</span>].<span class="property">secNum</span> = response[<span class="number">0</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">generalHeaderData</span>[<span class="number">0</span>].<span class="property">num</span> = response[<span class="number">1</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">generalHeaderData</span>[<span class="number">1</span>].<span class="property">num</span> = response[<span class="number">2</span>];</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="title function_">fetchTaskList</span>(<span class="variable language_">this</span>.<span class="property">listQuery</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">generalHeaderData</span>[<span class="number">2</span>].<span class="property">num</span> = response.<span class="property">total</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="title function_">queryViewTodo</span>(<span class="variable language_">this</span>.<span class="property">listQuery</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">generalHeaderData</span>[<span class="number">3</span>].<span class="property">num</span> = response.<span class="property">total</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-表头点击事件"><a href="#2-表头点击事件" class="headerlink" title="2.表头点击事件"></a>2.表头点击事件</h2><p><code>前端</code>:配置好了路由routeName，在点击事件的方法中，配置跳转就行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">generalHeaderData<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    title<span class="punctuation">:</span> <span class="string">&quot;项目建设数量&quot;</span><span class="punctuation">,</span></span><br><span class="line">    num<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    secNum<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    svgName<span class="punctuation">:</span> <span class="string">&quot;xiangmu&quot;</span><span class="punctuation">,</span></span><br><span class="line">    svgColor<span class="punctuation">:</span> <span class="string">&quot;#f4516c&quot;</span><span class="punctuation">,</span></span><br><span class="line">    routeName<span class="punctuation">:</span> <span class="string">&quot;ResearchProjectManagementList&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    title<span class="punctuation">:</span> <span class="string">&quot;资料未齐全项目数量&quot;</span><span class="punctuation">,</span></span><br><span class="line">    num<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    secNum<span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    svgName<span class="punctuation">:</span> <span class="string">&quot;gongzuo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    svgColor<span class="punctuation">:</span> <span class="string">&quot;#7bc94a&quot;</span><span class="punctuation">,</span></span><br><span class="line">    routeName<span class="punctuation">:</span> <span class="string">&quot;ResearchProjectManagementList&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    title<span class="punctuation">:</span> <span class="string">&quot;我的待办&quot;</span><span class="punctuation">,</span></span><br><span class="line">    num<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    svgName<span class="punctuation">:</span> <span class="string">&quot;huihua&quot;</span><span class="punctuation">,</span></span><br><span class="line">    svgColor<span class="punctuation">:</span> <span class="string">&quot;#36a3f7&quot;</span><span class="punctuation">,</span></span><br><span class="line">    routeName<span class="punctuation">:</span> <span class="string">&quot;Task&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    title<span class="punctuation">:</span> <span class="string">&quot;我的待阅&quot;</span><span class="punctuation">,</span></span><br><span class="line">    num<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    svgName<span class="punctuation">:</span> <span class="string">&quot;guanzhu&quot;</span><span class="punctuation">,</span></span><br><span class="line">    svgColor<span class="punctuation">:</span> <span class="string">&quot;#ffb822&quot;</span><span class="punctuation">,</span></span><br><span class="line">    routeName<span class="punctuation">:</span> <span class="string">&quot;View&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleHeadClick</span>(<span class="params">item</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: item.<span class="property">routeName</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="3-近半年工时情况"><a href="#3-近半年工时情况" class="headerlink" title="3.近半年工时情况"></a>3.近半年工时情况</h2><p><code>后端逻辑</code>：</p><p>​  1.先查询当前人权限内的项目信息<br>​      2.按月度查询权限内所有项目的工时数量之和</p><p>遇到的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1.我开始的做法是，根据ID列表查出表中所有月份和工时数量字段，`</span><br><span class="line"></span><br><span class="line">`然后在service层处理，对查到的字段用Map进行去重合并累加相同的月份`</span><br><span class="line"></span><br><span class="line">`但是组长说你这样可以，但是我们查的是半年内，不能查全部的月份字段，要把月份传进去`</span><br><span class="line"></span><br><span class="line">`然后，直接用sum 聚合函数在SQL内求和就不用在service层去写复杂的逻辑了</span><br><span class="line"></span><br><span class="line">2.注意往前递推月份的写法，我开始是定义一个common常量类，写死在common常量类中</span><br><span class="line">组长说往前递推半年不要写死，然后我在common类中使用static&#123;&#125;代码块去给月份的数组赋值，</span><br><span class="line">结果运行的时候报错，显示赋值不成功，调用的时候显示数组长度为0.不知道为什么。</span><br><span class="line">后来就直接在service层中定义了，</span><br><span class="line">定义日期格式-再currentDate.minusMonths(i)遍历</span><br><span class="line"></span><br><span class="line">3.还有前端需要的JSON格式的数据格式为：</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;category&quot;: &quot;2024-02&quot;,</span><br><span class="line">            &quot;value&quot;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;category&quot;: &quot;2024-03&quot;,</span><br><span class="line">            &quot;value&quot;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">我开始没有定义实体类，使用List&lt;Map&lt;String,Double&gt;&gt;类型的返回值去存储</span><br><span class="line">        &#123;</span><br><span class="line">            2024-02&quot;,</span><br><span class="line">             0</span><br><span class="line">        &#125;</span><br><span class="line">与需要的返回值类型不匹配，前端显示不了</span><br></pre></td></tr></table></figure><p>定义：实体类，返回给前端的JSON数据格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Res</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line">    <span class="keyword">private</span> Double value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@description</span>: 1.先查询当前人权限内的项目信息</span></span><br><span class="line"><span class="comment">    * 2.按月度查询权限内所有项目的工时数量之和</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span>: fangyuan</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@date</span>: 2024/7/24 9:14</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Res&gt; <span class="title function_">queryProjectMouthManhour</span><span class="params">()</span> &#123;</span><br><span class="line">       List&lt;UserRole&gt; userRoleList = getUserRoleList();</span><br><span class="line">       List&lt;Res&gt; resArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (userRoleList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           List&lt;Project&gt; userProjects = getUserProjects();</span><br><span class="line">           <span class="comment">// 提取项目id列表</span></span><br><span class="line">           List&lt;String&gt; projectIds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (Project project : userProjects) &#123;</span><br><span class="line">               projectIds.add(project.getBoProjectId());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//拿到过去六个月的数组</span></span><br><span class="line">           <span class="type">LocalDate</span> <span class="variable">currentDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 定义日期格式</span></span><br><span class="line">           <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 定义一个数组来存储过去六个月的年月字符串</span></span><br><span class="line">           String[] pastSixMonths = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 往前递推半年的月份并存储到数组中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">               <span class="type">LocalDate</span> <span class="variable">pastMonth</span> <span class="operator">=</span> currentDate.minusMonths(i);</span><br><span class="line">               <span class="type">String</span> <span class="variable">pastYearMonth</span> <span class="operator">=</span> pastMonth.format(formatter);</span><br><span class="line">               pastSixMonths[i] = pastYearMonth;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//翻转数组</span></span><br><span class="line">           List&lt;String&gt; list = Arrays.asList(pastSixMonths);</span><br><span class="line">           Collections.reverse(list);</span><br><span class="line">           pastSixMonths = list.toArray(pastSixMonths);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 根据项目id，查询项目年月和总和工时数据</span></span><br><span class="line">           <span class="comment">// String 年月，String 工时</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pastSixMonths.length; i++) &#123;</span><br><span class="line">               <span class="type">Res</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Res</span>();</span><br><span class="line">               res = projectMouthManhourService.getYearMonthAndManhour(projectIds, pastSixMonths[i]);</span><br><span class="line">               resArrayList.add(res);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> resArrayList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:根据列表编号查询项目年月和工时信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: fangyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/24 10:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Res <span class="title function_">getYearMonthAndManhour</span><span class="params">(List&lt;String&gt; projectIds, String yearMouth)</span> &#123;</span><br><span class="line">    <span class="type">Res</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Res</span>();</span><br><span class="line">    <span class="keyword">if</span>(projectIds != <span class="literal">null</span> &amp;&amp; projectIds.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">value</span> <span class="operator">=</span>  projectMouthManhourDao.selectByYearMonthAndManhour(projectIds,yearMouth);</span><br><span class="line">        res.setCategory(yearMouth);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;</span><br><span class="line">            res.setValue(<span class="number">0.0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByYearMonthAndManhour&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Double&quot;</span>&gt;</span></span><br><span class="line">    SELECT SUM(m.MANHOUR_MODIFY)</span><br><span class="line">    FROM BO_PROJECT_MOUTH_MANHOUR m</span><br><span class="line">    WHERE m.BO_PROJECT_ID IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;projectId&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;projectIds&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;projectId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    AND m.YEAR_MOUTH = #&#123;yearMouth&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>前端逻辑</code>：api配置和script方法引入就不说了，调用方法传值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getLeLeftCenterData</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">queryProjectMouthManhour</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">generalLeftCenterData</span>.<span class="property">data</span> = response;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-资料上传情况"><a href="#4-资料上传情况" class="headerlink" title="4.资料上传情况"></a>4.资料上传情况</h2><p><code>后端逻辑：</code>将查到的projectName和fileNum放在一个map集合中，返回给前端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:查询项目资料上传情况</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: fangyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/25 14:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">queryProjectResource</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserRole&gt; userRoleList = getUserRoleList();</span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; resultMapList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (userRoleList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Project&gt; userProjects = getUserProjects();</span><br><span class="line">            <span class="keyword">for</span> (Project project : userProjects) &#123;</span><br><span class="line">                Map&lt;String,Object&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                resultMap.put(<span class="string">&quot;projectName&quot;</span>,project.getProjectName());</span><br><span class="line">                <span class="type">String</span> <span class="variable">boProjectId</span> <span class="operator">=</span> project.getBoProjectId();</span><br><span class="line">                <span class="type">int</span> <span class="variable">fileNum</span> <span class="operator">=</span> projectPhaseFileService.selectAddFileNums(boProjectId);</span><br><span class="line">                resultMap.put(<span class="string">&quot;fileNum&quot;</span>,fileNum);</span><br><span class="line">                resultMapList.add(resultMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultMapList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAddFileNums&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">select COUNT(*) from BO_PROJECT_PHASE_FILE P</span><br><span class="line">where P.BO_PROJECT_ID = #&#123;boProjectId&#125;</span><br><span class="line">  AND P.BO_PROJECT_PHASE_CODE = &#x27;合规材料汇总&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>前端逻辑</code>：</p><p>注意：</p><pre><code>因为我们前端要求的数据格式为&quot;data&quot;: [    &#123;        &quot;name&quot;: &quot;竣工&quot;,        &quot;value&quot;: 2,        &quot;labelColor&quot;: &quot;#B5A77F&quot;,        &quot;backgroundColor&quot;: &quot;#D8C9B5&quot;    &#125;,    &#123;        &quot;name&quot;: &quot;试运行&quot;,        &quot;value&quot;: 2,        &quot;labelColor&quot;: &quot;#B57F7F&quot;,        &quot;backgroundColor&quot;: &quot;#D8B5B5&quot;    &#125;,]而我们后端查到的只有name和value，而背景颜色什么的要在前端赋值对filenum进行排序，按从大到小排序展示，然后取前七个元素并且为了美观，不让项目名称太长导致展示到第二行影响展示效果对姓名字段进行截取前七个字符然后依次赋值将剩下两个颜色字段补上，赋值给Data就行笨办法赋值，因为每次赋值的颜色字段都不一样，所以...</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getLeftBottomRightData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">queryProjectResource</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//response 按 fileNum 由大到小排序</span></span><br><span class="line">    response = response.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> b.<span class="property">fileNum</span> - a.<span class="property">fileNum</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//response 获取最多前 7 个元素</span></span><br><span class="line">    response = response.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = response.<span class="property">length</span>-<span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>: response[i].<span class="property">projectName</span>.<span class="property">length</span> &gt; <span class="number">9</span> ? response[i].<span class="property">projectName</span>.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">7</span>) + <span class="string">&quot;...&quot;</span> : response[i].<span class="property">projectName</span>,</span><br><span class="line">        <span class="attr">value</span>: response[i].<span class="property">fileNum</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        obj.<span class="property">labelColor</span> = <span class="string">&quot;#6A9FB5&quot;</span>;</span><br><span class="line">        obj.<span class="property">backgroundColor</span> = <span class="string">&quot;#A1C4D3&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        obj.<span class="property">labelColor</span> = <span class="string">&quot;#7FB5A6&quot;</span>;</span><br><span class="line">        obj.<span class="property">backgroundColor</span> = <span class="string">&quot;#B2D8C3&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        obj.<span class="property">labelColor</span> = <span class="string">&quot;#F0A762&quot;</span>;</span><br><span class="line">        obj.<span class="property">backgroundColor</span> = <span class="string">&quot;#F3C89A&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        obj.<span class="property">labelColor</span> = <span class="string">&quot;#A3C866&quot;</span>;</span><br><span class="line">        obj.<span class="property">backgroundColor</span> = <span class="string">&quot;#C6DEA1&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">        obj.<span class="property">labelColor</span> = <span class="string">&quot;#8E7FB5&quot;</span>;</span><br><span class="line">        obj.<span class="property">backgroundColor</span> = <span class="string">&quot;#C7B5D8&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        obj.<span class="property">labelColor</span> = <span class="string">&quot;#B57F7F&quot;</span>;</span><br><span class="line">        obj.<span class="property">backgroundColor</span> = <span class="string">&quot;#D8B5B5&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">6</span>) &#123;</span><br><span class="line">        obj.<span class="property">labelColor</span> = <span class="string">&quot;#B5A77F&quot;</span>;</span><br><span class="line">        obj.<span class="property">backgroundColor</span> = <span class="string">&quot;#D8C9B5&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">generalLeftBottomRightData</span>.<span class="property">data</span>.<span class="title function_">push</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">generalLeftBottomRightData</span>.<span class="property">data</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-一周项目动态"><a href="#5-一周项目动态" class="headerlink" title="5.一周项目动态"></a>5.一周项目动态</h2><p>前端需要数据格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;borderTitle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;一周项目动态&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;杭州市民生项目一期-已立项&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;创新接口人&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msgType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;消息&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msgButtonType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;primary&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;routeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ProcessApprovalInfo?projectId=e2b079c0-3e8a-11ef-bc62-c70f53d63ff1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msgDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-07-09&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;杭州市民生项目一期-已设计&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;创新接口人&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msgType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;逾期&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msgButtonType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;danger&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;routeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ProcessDesignInfo?projectId=e2b079c0-3e8a-11ef-bc62-c70f53d63ff1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;msgDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-07-15&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">后端查询拿到的是封装好的jar包，不能更改，所以就查到这些字段，需要前端处理</span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;isNew&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;createUserId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12077&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;createDate&quot;</span><span class="punctuation">:</span> <span class="number">1712813883000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;updateUserId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;109641561&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;updateDate&quot;</span><span class="punctuation">:</span> <span class="number">1713173705000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;boWbsTaskExtendInfoId&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;boWbsTaskId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;inputTest&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chooseTest&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;textTest&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dateTest&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isTest&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;parentWbsTaskId&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rootWbsTaskId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;渠道类系统研发项目A（2023）&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskCode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;R23303311CBF002&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskContent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;渠道类系统研发项目A（2023）&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;responsibleUserId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12077&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;responsibleOrgId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;234460635&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;planStartDate&quot;</span><span class="punctuation">:</span> <span class="number">1675209600000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;planEndDate&quot;</span><span class="punctuation">:</span> <span class="number">1703980800000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;actualStartDate&quot;</span><span class="punctuation">:</span> <span class="number">1675209600000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;actualEndDate&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isDelayed&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskFund&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskWeight&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskWeightOfParent&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskState&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskTier&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isLeaf&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskPriority&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WBS_TASK_PRIORITY_H&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;orderNum&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isDeleted&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskPriorityName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;高优先&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;responsibleUserName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;刘坤&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;responsibleOrgName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;信息技术管理部管理信息室&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;recordCount&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskRecordList&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskPassRecordList&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rootTaskName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;渠道类系统研发项目A（2023）&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;parentTaskName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;currentUserId&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stakeholder&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;applyFinishDate&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;checkUserId&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isPass&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isConfirm&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;unreadMessageCount&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stakeholderName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;editRouteName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;viewRouteName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ProjectLedger&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wbsTaskCompleteness&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;parentTaskPlanStartDate&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;parentTaskPlanEndDate&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;parentResponsibleUserId&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;parentResponsibleUserName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;completeRecordId&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isHangUp&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isParentHangUp&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cancelHangUp&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rootStakeholder&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;planWorkload&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;actualWorkload&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;siblingTasks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;new&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>后端逻辑</code>：封装在jar包中 ，只读，组长说直接用已有查出来的，前端再做数据处理，不用自己写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;queryPersonalWork&quot; resultType<span class="operator">=</span>&quot;com.hii.datateam.wbs.task.model.WbsTaskInfo&quot; databaseId<span class="operator">=</span>&quot;oracle&quot;<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">SELECT</span> wt.<span class="operator">*</span>,</span><br><span class="line">               (<span class="keyword">select</span> rt.WBS_TASK_NAME</span><br><span class="line">                <span class="keyword">from</span> bo_wbs_task rt</span><br><span class="line">                <span class="keyword">where</span> wt.ROOT_WBS_TASK_ID <span class="operator">=</span> rt.BO_WBS_TASK_ID)     root_task_name,</span><br><span class="line">               (<span class="keyword">select</span> pt.WBS_TASK_NAME</span><br><span class="line">                <span class="keyword">from</span> bo_wbs_task pt</span><br><span class="line">                <span class="keyword">where</span> wt.PARENT_WBS_TASK_ID <span class="operator">=</span> pt.BO_WBS_TASK_ID)   parent_task_name,</span><br><span class="line">               (<span class="keyword">SELECT</span> c.username</span><br><span class="line">                <span class="keyword">FROM</span> contact_ c</span><br><span class="line">                <span class="keyword">WHERE</span> wt.responsible_user_id <span class="operator">=</span> c.userid)        <span class="keyword">AS</span> responsibleUserName,</span><br><span class="line">               (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">from</span> bo_wbs_task_record wtr</span><br><span class="line">                <span class="keyword">WHERE</span> wt.BO_WBS_TASK_ID <span class="operator">=</span> wtr.BO_WBS_TASK_ID)   <span class="keyword">AS</span> recordCount,</span><br><span class="line">               (<span class="keyword">SELECT</span> o.name</span><br><span class="line">                <span class="keyword">FROM</span> organization_ o</span><br><span class="line">                <span class="keyword">WHERE</span> wt.responsible_org_id <span class="operator">=</span> o.organizationid) <span class="keyword">AS</span> responsibleOrgName,</span><br><span class="line">               (<span class="keyword">SELECT</span> d.dictionary_name</span><br><span class="line">                <span class="keyword">FROM</span> bo_wbs_dictionary d</span><br><span class="line">                <span class="keyword">WHERE</span> d.bo_wbs_dictionary_id <span class="operator">=</span> wt.wbs_task_priority</span><br><span class="line">                  <span class="keyword">AND</span> d.dictionary_type <span class="operator">=</span> <span class="string">&#x27;WBS_TASK_PRIORITY&#x27;</span>)  <span class="keyword">AS</span> wbsTaskPriorityName,</span><br><span class="line">               (<span class="keyword">select</span> rt.WBS_TASK_NAME</span><br><span class="line">                <span class="keyword">from</span> bo_wbs_task rt</span><br><span class="line">                <span class="keyword">where</span> wt.ROOT_WBS_TASK_ID <span class="operator">=</span> rt.BO_WBS_TASK_ID)     root_task_name</span><br><span class="line">        <span class="keyword">FROM</span> bo_wbs_task wt</span><br><span class="line">        <span class="keyword">WHERE</span> NVL(wt.is_deleted, <span class="string">&#x27;0&#x27;</span>) <span class="operator">&lt;&gt;</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">          <span class="keyword">and</span> RESPONSIBLE_USER_ID <span class="operator">=</span> #&#123;responsibleUserId&#125;</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> wt.order_num, wt.create_date</span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p><code>前端逻辑</code>：先过滤得到任务层级，再去获取当前时间一周内的时间戳，</p><p>根据字段的项目结束时间和开始时间去判断本周内的项目状态，逾期，已完成，未完成等</p><p>然后再去配置点击事件的路由routeName等等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取本人全部事项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queryPersonalWork</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/rest/wbs_task/personal_work&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getLeftBottomLeftData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 调用后端接口，传入用户ID，获取该用户的工作数据</span></span><br><span class="line">  <span class="title function_">queryPersonalWork</span>(&#123; <span class="attr">responsibleUserId</span>: <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">user</span>.<span class="property">cusermessage</span>.<span class="property">userId</span> &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 过滤出 wbsTaskTier 任务层级等于 &#x27;2&#x27; 的数据</span></span><br><span class="line">    <span class="keyword">let</span> data = response.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">wbsTaskTier</span> == <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 获取当前是本周的第几天（0是周日，1是周一，...，6是周六）</span></span><br><span class="line">    <span class="keyword">let</span> nowDayOfWeek = current.<span class="title function_">getDay</span>();</span><br><span class="line">    <span class="comment">// 如果是周日，则设为 7，以便计算本周的第一天和最后一天</span></span><br><span class="line">    <span class="keyword">if</span> (nowDayOfWeek === <span class="number">0</span>) nowDayOfWeek = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一天的毫秒数</span></span><br><span class="line">    <span class="keyword">let</span> dayNum = <span class="number">1</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 计算本周星期一的时间</span></span><br><span class="line">    <span class="keyword">let</span> firstDate = <span class="keyword">new</span> <span class="title class_">Date</span>(current.<span class="title function_">valueOf</span>() - (nowDayOfWeek - <span class="number">1</span>) * dayNum);</span><br><span class="line">    <span class="comment">// 计算本周星期天的时间</span></span><br><span class="line">    <span class="keyword">let</span> lastDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(firstDate).<span class="title function_">valueOf</span>() + <span class="number">6</span> * dayNum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取本周开始和结束的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> weekStartDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="variable language_">this</span>.<span class="title function_">startTime</span>(firstDate)).<span class="title function_">getTime</span>();</span><br><span class="line">    <span class="keyword">let</span> weekEndDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="variable language_">this</span>.<span class="title function_">endTime</span>(lastDate)).<span class="title function_">getTime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> thisWeekWork = [];</span><br><span class="line">    <span class="comment">// 遍历数据，根据计划和实际结束日期，分类数据</span></span><br><span class="line">    data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 逾期事项</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">planEndDate</span> &lt; weekStartDate &amp;&amp; (item.<span class="property">actualEndDate</span> &gt;= weekStartDate || item.<span class="property">actualEndDate</span> == <span class="literal">null</span>))&#123;</span><br><span class="line">        item.<span class="property">msgType</span> = <span class="string">&quot;逾期&quot;</span>;</span><br><span class="line">        item.<span class="property">msgButtonType</span> = <span class="string">&quot;danger&quot;</span>;</span><br><span class="line">        thisWeekWork.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(item)));</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 本周需完成事项</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">planEndDate</span> &gt;= weekStartDate &amp;&amp; item.<span class="property">planEndDate</span> &lt;= weekEndDate &amp;&amp; (item.<span class="property">actualEndDate</span> == <span class="literal">null</span> || item.<span class="property">actualEndDate</span> &gt;= weekStartDate)) &#123;</span><br><span class="line">        item.<span class="property">msgType</span> = <span class="string">&quot;本周需完成&quot;</span>;</span><br><span class="line">        item.<span class="property">msgButtonType</span> = <span class="string">&quot;warning&quot;</span>;</span><br><span class="line">        thisWeekWork.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(item)));</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 本周完成事项</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">planEndDate</span> &gt; weekEndDate &amp;&amp; item.<span class="property">actualEndDate</span> &lt;= weekEndDate &amp;&amp; item.<span class="property">actualEndDate</span> &gt;= weekStartDate) &#123;</span><br><span class="line">        item.<span class="property">msgType</span> = <span class="string">&quot;本周完成&quot;</span>;</span><br><span class="line">        item.<span class="property">msgButtonType</span> = <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        thisWeekWork.<span class="title function_">push</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(item)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将分类后的数据格式化，并赋值给 generalLeftBottomLeftData.data</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">generalLeftBottomLeftData</span>.<span class="property">data</span> = thisWeekWork.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">message</span>: item.<span class="property">parentTaskName</span> + <span class="string">&#x27;-&#x27;</span> + item.<span class="property">wbsTaskName</span>,</span><br><span class="line">        <span class="attr">userName</span>: item.<span class="property">responsibleUserName</span>,</span><br><span class="line">        <span class="attr">msgType</span>: item.<span class="property">msgType</span>,</span><br><span class="line">        <span class="attr">msgButtonType</span>: item.<span class="property">msgButtonType</span>,</span><br><span class="line">        <span class="attr">routeName</span>: <span class="string">&quot;WBSTaskEdit?appId=&quot;</span> + item.<span class="property">rootWbsTaskId</span> + <span class="string">&quot;&amp;focusMessage=false&quot;</span>,</span><br><span class="line">        <span class="attr">msgDate</span>: <span class="title function_">parseTime</span>(item.<span class="property">planEndDate</span>, <span class="string">&#x27;&#123;y&#125;-&#123;m&#125;-&#123;d&#125;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-项目动态点击事件"><a href="#6-项目动态点击事件" class="headerlink" title="6.项目动态点击事件"></a>6.项目动态点击事件</h2><p>路由配置为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;edit&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/wbs/WBSTaskEditDemo&#x27;</span>),</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;WBSTaskEdit&#x27;</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;WBS任务编辑&#x27;</span>,</span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;WBSTaskEdit&#x27;</span>,</span><br><span class="line">    <span class="attr">keepAlive</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">crumbs</span>: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;首页&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/pm/ResearchProjectManagementList&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;项目管理&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;任务树&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面项目动态的路由配置为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routeName: &quot;WBSTaskEdit?appId=&quot; + item.rootWbsTaskId + &quot;&amp;focusMessage=false&quot;,</span><br></pre></td></tr></table></figure><p>本地访问地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8081/#/wbs/edit?appId=7&amp;focusMessage=false</span><br><span class="line">http://localhost:8081/#/wbs/edit?appId=6&amp;focusMessage=false</span><br></pre></td></tr></table></figure><p>点击方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleLeftBottomLeftClick</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="comment">// 将 routeName 按照 &quot;?&quot; 分割，得到路由名和参数部分</span></span><br><span class="line">  <span class="keyword">let</span> parts = item.<span class="property">routeName</span>.<span class="title function_">split</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> params = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果分割后长度大于1，说明有参数部分</span></span><br><span class="line">  <span class="keyword">if</span> (parts.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 将参数部分按照 &quot;&amp;&quot; 分割，得到每个参数对</span></span><br><span class="line">    <span class="keyword">let</span> parameters = parts[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历每个参数对</span></span><br><span class="line">    parameters.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将每个参数对按照 &quot;=&quot; 分割，得到键和值</span></span><br><span class="line">      <span class="keyword">let</span> pair = item.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果分割后的数组长度为2，说明是有效的键值对</span></span><br><span class="line">      <span class="keyword">if</span> (pair.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 将键和值进行解码，并存入 params 对象中</span></span><br><span class="line">        params[<span class="built_in">decodeURIComponent</span>(pair[<span class="number">0</span>])] = <span class="built_in">decodeURIComponent</span>(pair[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的对象 query，将 params 对象的属性拷贝到 query 对象中</span></span><br><span class="line">  <span class="keyword">const</span> query = <span class="title class_">Object</span>.<span class="title function_">assign</span>(params);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 Vue Router 进行路由跳转</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: parts[<span class="number">0</span>], <span class="comment">// 路由名</span></span><br><span class="line">    <span class="attr">query</span>: query    <span class="comment">// 路由参数</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> 华信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> 华信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杭州银行面经</title>
      <link href="/2024/06/11/Written%20Examination/hangzhouyinhang/"/>
      <url>/2024/06/11/Written%20Examination/hangzhouyinhang/</url>
      
        <content type="html"><![CDATA[<h1 id="杭州银行面经"><a href="#杭州银行面经" class="headerlink" title="杭州银行面经"></a>杭州银行面经</h1><p>大学学的专业课都是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">除了通识的专业课，就是，Java，数据结构，计网，计组，数据结构等</span><br></pre></td></tr></table></figure><p>HashMap的底层实现原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Java中的HashMap是一种基于哈希表的Map接口实现，</span><br><span class="line">它可以存储键值对，并且支持快速的插入、删除和查找操作。</span><br><span class="line">HashMap的底层实现原理是数组+链表/红黑树。</span><br><span class="line"></span><br><span class="line">具体来说，HashMap内部维护了一个Entry数组，每个Entry包含一个键值对。</span><br><span class="line">当插入一个键值对时，HashMap会根据键的哈希值计算出该键值对在数组中的位置，</span><br><span class="line">如果该位置已经有其他键值对了，则使用链表或红黑树来解决冲突。</span><br><span class="line">当查找一个键值对时，HashMap会根据键的哈希值计算出该键值对在数组中的位置，</span><br><span class="line">然后遍历链表或红黑树，找到对应的键值对。</span><br><span class="line"></span><br><span class="line">在Java 8中，HashMap的底层实现原理进行了优化，</span><br><span class="line">当链表长度超过一定阈值时，会将链表转换为红黑树，以提高查找效率。</span><br><span class="line">此外，HashMap还支持动态扩容和负载因子等特性，以提高存储和访问的效率。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HashSet是如何检查重复的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet底层还是HashMap，HashSet只考虑key的值，</span><br><span class="line">value都指向一个全局object常量</span><br><span class="line">比较过程：通过哈希法比较哈希值</span><br><span class="line">哈希值相等再调用equals比较方法</span><br></pre></td></tr></table></figure><p>equals和&#x3D;&#x3D;的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==比较的是地址</span><br><span class="line">equals如果不被重写，比较的是地址，底层调用==,</span><br><span class="line">如果被重写，就按照重写的逻辑比较</span><br></pre></td></tr></table></figure><p>Spring三件套框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Spring 三件套指的是 Spring 框架的三个核心模块，</span><br><span class="line">分别是 Spring Core、Spring AOP 和 Spring MVC。</span><br><span class="line"></span><br><span class="line">Spring Core：提供了 IoC（Inverse of Control）容器，</span><br><span class="line">用于对象之间的解耦，通过容器自动将对象之间的依赖注入。</span><br><span class="line">同时，Spring Core 还提供了对 AspectJ 的集成，</span><br><span class="line">以及对基于注解的 Spring Bean 的支持。</span><br><span class="line"></span><br><span class="line">Spring AOP：提供了基于 AOP（Aspect Oriented Programming）的编程方式，</span><br><span class="line">能够在不修改源代码的情况下，</span><br><span class="line">通过代理机制对对象进行增强，比如添加事务、日志、安全检查等功能。</span><br><span class="line"></span><br><span class="line">Spring MVC：是 Spring 框架的 Web 模块，</span><br><span class="line">提供了 MVC（Model-View-Controller）模式的支持，用于处理 Web 请求和响应。</span><br><span class="line">Spring MVC 通过 DispatcherServlet、HandlerMapping、Controller </span><br><span class="line">和 ViewResolver 等组件构成了完整的 MVC 模式的实现。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 杭州银行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 杭州银行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易面经</title>
      <link href="/2024/06/07/Written%20Examination/wangyi/"/>
      <url>/2024/06/07/Written%20Examination/wangyi/</url>
      
        <content type="html"><![CDATA[<h1 id="网易牛客面经整理"><a href="#网易牛客面经整理" class="headerlink" title="网易牛客面经整理"></a>网易牛客面经整理</h1><h2 id="没回答上来的"><a href="#没回答上来的" class="headerlink" title="没回答上来的"></a>没回答上来的</h2><p>varchar和text的字段的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">varchar是可变长度的字符串，需要自定义长度，可以加索引，适合存储短的文本数据</span><br><span class="line">text字段是存放长文本数据的地方，存储在单独存储区，表中保存额外的指针，只能部分索引（前255字符）</span><br></pre></td></tr></table></figure><p>后端调用Test字段的一些注意事项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TEXT 有不同的子类型，每种类型的最大长度不同：</span><br><span class="line">TINYTEXT: 最多 255 字节。</span><br><span class="line">TEXT: 最多 65,535 字节。</span><br><span class="line">MEDIUMTEXT: 最多 16,777,215 字节。</span><br><span class="line">LONGTEXT: 最多 4,294,967,295 字节。</span><br><span class="line"></span><br><span class="line">分页和摘要</span><br><span class="line">因为text字段，表里只存放指针，MySQL还需要二次查询</span><br><span class="line">会影响查询性能，所以我们做了一个分表</span><br><span class="line">将text列分离到单独的扩展表中，用ID字段做一个关联</span><br><span class="line">然后，创建一个varchar（255）字段，来记录text的前255个字符作为摘要</span><br><span class="line">这样在分页查询的时候，文章内容我们就只需要查询这个varchar字段就行</span><br><span class="line">点进去具体查询的时候，就需要关联text表查询text字段了</span><br></pre></td></tr></table></figure><p>如何提取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SUBSTRING 函数（在某些数据库中也叫 SUBSTR 函数）用于从一个字符串中提取子字符串。在 UPDATE 语句中，SUBSTRING(content, 1, 255) 这部分代码的作用是从 content 字段的第一个字符开始，提取长度为 255 的子字符串。这样，你可以把 content 字段中的前 255 个字符提取出来，并赋值给 summary 字段。</span><br><span class="line"></span><br><span class="line">具体来说：</span><br><span class="line"></span><br><span class="line">content 是 TEXT 字段，其中存储了长文本内容。</span><br><span class="line">SUBSTRING(content, 1, 255) 从 content 字段的第一个字符开始，提取长度为 255 的子字符串。</span><br><span class="line">SET summary = SUBSTRING(content, 1, 255) 将提取出来的子字符串赋值给 summary 字段。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，</span><br><span class="line">查询时一定不要使用 `select *`而只需要取出必要的列，</span><br><span class="line">不需要 TEXT 列的数据时不要对该列进行查询。</span><br></pre></td></tr></table></figure><p>算法题：算法题，云音乐的歌单列表，调整顺序后需要保存到数据库，如何让每次保存的数据量最小，答使用数组标识该歌单是否有顺序调整，最后只更新有发生变化的那些数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">量更新，可以最大程度地减少数据库操作的次数，提高系统性能和效率。实现方法如下：</span><br><span class="line"></span><br><span class="line">使用数组标识顺序是否调整：</span><br><span class="line"></span><br><span class="line">维护一个与歌单列表对应的布尔数组，用于标识每个歌单是否发生了顺序调整。数组的索引对应着歌单在列表中的位置，数组的值表示该位置的歌单是否发生了顺序调整。</span><br><span class="line">调整歌单顺序时更新数组：</span><br><span class="line"></span><br><span class="line">当用户调整歌单的顺序时，相应地更新数组中对应位置的标记为true，表示该歌单发生了顺序调整。</span><br><span class="line">保存数据时只更新发生变化的数据：</span><br><span class="line"></span><br><span class="line">在保存歌单数据到数据库时，遍历数组，只更新标记为true的位置对应的歌单数据，其他位置的数据不进行更新。</span><br><span class="line">更新完成后，将数组重置为全false，等待下一次用户进行歌单顺序调整时再次更新。</span><br><span class="line">这种方法有效地减少了数据库操作的次数，只更新发生变化的数据，节省了系统资源，提高了系统的性能和效率。</span><br></pre></td></tr></table></figure><p>场景题：以微信朋友圈为例，你思考一下除了用户表之外需要建几张表才能实现微信朋友圈这个业务，并且每张表有哪些字段，你可以先思考一下再说？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">微信朋友圈实现的功能，有点赞，评论，好友关系，用户朋友圈的内容等</span><br><span class="line">所以至少先需要点赞，评论，好友关系，朋友圈内容等</span><br><span class="line">点赞表：巴拉巴拉</span><br><span class="line">评论表：巴拉巴拉</span><br><span class="line">好友关系表：巴拉巴拉</span><br><span class="line">内容表：巴拉巴拉</span><br></pre></td></tr></table></figure><p>Java集合类，如何处理hash冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体而言，当发生哈希冲突时，HashMap 会将具有相同哈希码的键值对存储在同一个桶（bucket）中，而不是简单地覆盖原来的值。这个桶通常是一个链表或者是红黑树。在 Java 8 之后的版本中，当链表长度超过一定阈值（默认为 8）时，链表会被转换为红黑树，以提高查询效率。</span><br></pre></td></tr></table></figure><p>Java的单例模式，枚举类enum</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于定义一组有限的常量。</span><br><span class="line">它提供了一种更好的方式来表示常量集合，使代码更具可读性和可维护性。</span><br></pre></td></tr></table></figure><p>Spring的单例模式，怎么实现的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单例模式的实现是通过 Spring 容器管理 Bean 的方式来实现的。默认情况下，Spring 容器创建的 Bean 都是单例的，也就是说在整个应用程序中只会创建一个该类型的实例。</span><br></pre></td></tr></table></figure><p>mysql的索引讲一下，一级和二级索引的区别，什么时候可以不用查一级索引。答覆盖索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一级索引（Primary Index）：</span><br><span class="line"></span><br><span class="line">一级索引是指直接基于表的主键构建的索引，主键索引是一种唯一性索引，能够确保表中每行数据的唯一性。</span><br><span class="line">主键索引通常是聚簇索引，即索引的叶子节点存储了整行数据，因此主键索引能够加速基于主键的单行数据查询。</span><br><span class="line">二级索引（Secondary Index）：</span><br><span class="line"></span><br><span class="line">二级索引是指基于表的非主键列构建的索引，用于加速对非主键列的查询操作。</span><br><span class="line">二级索引通常是非聚簇索引，即索引的叶子节点存储了索引字段的值以及指向对应行的主键值，因此在使用二级索引进行查询时，需要先查找索引，然后再根据主键值找到对应的数据行。</span><br><span class="line">覆盖索引是指查询语句的执行过程中，只需通过索引就能够获取到所需的数据，而不需要再访问数据表。当查询语句的列都包含在索引中时，就可以利用覆盖索引，这样能够减少IO操作和数据传输，提高查询效率。</span><br></pre></td></tr></table></figure><p>Redis使用keys遍历所有的key，存在问题？如何解决？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">性能问题：性能低下</span><br><span class="line">阻塞问题：阻塞服务器，直到命令执行完成</span><br><span class="line"></span><br><span class="line">为了解决这个问题，可以采用以下几种方式：</span><br><span class="line"></span><br><span class="line">使用 SCAN 命令：SCAN 命令是一个迭代器命令，可以逐步遍历符合给定模式的所有键，它不会像 keys 命令那样阻塞 Redis 服务器，并且可以分批次地获取数据，避免一次性遍历大量数据造成的性能问题。</span><br><span class="line"></span><br><span class="line">避免在生产环境使用：在生产环境中尽量避免使用 keys 命令，特别是在大规模的 Redis 实例中，因为它会对 Redis 服务器造成较大的压力。可以在开发和测试环境中使用 keys 命令进行调试和测试，但不要在生产环境中频繁地使用。</span><br><span class="line"></span><br><span class="line">使用有序集合或哈希表替代：如果需要根据模式查询键值对，可以考虑使用有序集合（Sorted Set）或哈希表（Hash）来存储数据，然后通过范围查询或哈希键查询来获取数据，这样可以更高效地进行查询操作。</span><br></pre></td></tr></table></figure><p>死锁，解决办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">死锁是指两个或多个线程（或进程）相互持有对方所需的资源，并且在等待对方释放资源时都无法继续执行的情况。死锁常常发生在多线程并发执行的情况下，当线程之间竞争资源时，如果不恰当地处理资源获取顺序，就容易导致死锁的发生。</span><br><span class="line"></span><br><span class="line">发生死锁的必要条件包括：</span><br><span class="line"></span><br><span class="line">互斥条件（Mutual Exclusion）：资源只能被一个线程（或进程）占用，当资源被占用时，其他线程无法同时访问该资源。</span><br><span class="line">请求和保持条件（Hold and Wait）：线程持有至少一个资源，并且正在等待获取另一个被其他线程持有的资源。</span><br><span class="line">不可剥夺条件（No Preemption）：线程无法强制从其他线程手中夺取资源，只能通过自愿释放资源来解决资源争用问题。</span><br><span class="line">循环等待条件（Circular Wait）：存在一个资源循环等待链，即线程 A 等待线程 B 持有的资源，线程 B 等待线程 C 持有的资源，...，线程 N 等待线程 A 持有的资源。</span><br><span class="line"></span><br><span class="line">解决：资源分配有序性：尽量避免线程持有多个资源而等待其他线程释放资源的情况发生，</span><br><span class="line">可以采用一种资源分配有序性的策略，例如按照资源的编号顺序来申请资源，</span><br><span class="line">或者尽量减少线程持有的资源数量，以降低发生死锁的概率。</span><br></pre></td></tr></table></figure><p>springboot的starter了解过吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot Starter 是一组依赖的集合，它们打包成一个模块，</span><br><span class="line">通过添加该模块到项目的依赖中，自动引入所需的库和自动配置，简化项目的搭建过程。</span><br><span class="line">常见的就是，web-starter，mybatis-starter等</span><br></pre></td></tr></table></figure><p>Springboot的自动配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot 的自动配置（Auto Configuration）通过扫描类路径中的依赖和应用配置，</span><br><span class="line">根据项目中的类和配置的存在与否自动配置 Spring 应用程序。</span><br><span class="line">它利用 @EnableAutoConfiguration 注解和 META-INF/spring.factories 文件中的配置，</span><br><span class="line">将常见的配置任务自动化。这样，开发者可以省去大量手动配置，只需专注于业务逻辑。</span><br><span class="line">自动配置可以通过 application.properties 文件进行调整和覆盖，</span><br><span class="line">并可通过 @Conditional 注解进行条件性配置。</span><br></pre></td></tr></table></figure><p>数据库连接池，Spring还是mybatis管理的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据库连接池通过预创建和管理一组数据库连接，允许多个线程重复使用这些连接，</span><br><span class="line">从而提高性能和资源利用率。常见的实现包括 HikariCP、C3P0 和 DBCP。</span><br><span class="line">在 Spring 项目中，通常由 Spring 管理连接池，通过配置数据源（DataSource）来集成连接池。</span><br><span class="line">MyBatis 则通过配置文件或 Spring 管理的 DataSource 来使用连接池，从而实现高效的数据库连接管理。</span><br></pre></td></tr></table></figure><p>mybatis怎么将Java对象映射到数据库的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyBatis 通过 XML 配置文件或注解，将 Java 对象与数据库表映射。</span><br><span class="line">它使用 Mapper 接口定义 SQL 操作，通过配置文件中的 SQL 语句或注解中的 SQL 语句来执行数据库操作。</span><br><span class="line">MyBatis 利用反射和动态代理，将查询结果映射为 Java 对象，或将 Java 对象属性映射为 SQL 参数，</span><br><span class="line">从而实现对象与数据库记录的映射和持久化。</span><br></pre></td></tr></table></figure><p>redis最大内存设置了多少，超过了最大内存会怎样？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Redis 的最大内存可以通过 maxmemory 配置项设置。</span><br><span class="line">如果内存使用超过了设置的最大内存，Redis 会根据 maxmemory-policy 配置项决定如何处理。</span><br><span class="line">常见策略包括：移除最近最少使用（LRU）的键、移除最少频繁使用（LFU）的键、</span><br><span class="line">移除即将过期的键、或者不再允许新的写操作（只读模式）。</span><br><span class="line">如果没有合适的策略，可能会导致 Redis 无法正常服务。</span><br></pre></td></tr></table></figure><p>redis持久化有哪些方式，项目中用的哪一种，默认是哪一种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Redis 持久化方式主要有两种：RDB（Redis Database）和 AOF（Append Only File）。</span><br><span class="line">RDB 方式通过周期性快照保存数据，适用于不需要频繁写操作的数据备份。</span><br><span class="line">AOF 方式记录每个写操作日志，更适合需要数据完整性的应用。</span><br><span class="line">默认情况下，Redis 使用 RDB 持久化。</span><br><span class="line">在项目中，根据需求可以选择混合使用 RDB 和 AOF 来兼顾性能和数据安全。</span><br></pre></td></tr></table></figure><p>线程池</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">线程池：管理线程的池子，可以容纳多个线程，省去了频繁创建线程的操作</span><br><span class="line">Java中有几种常见的线程池，都是去实现了ThreadPoolExecutor这个类</span><br><span class="line">用这个类的构造器，去设置参数，核心线程，最大线程，超时时长，任务队列等</span><br><span class="line">可以直接用，然后重写run方法实现的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设计一个线程池嘛</span><br><span class="line">1.创建N个线程</span><br><span class="line">2.把任务提交给线程运行</span><br><span class="line">3.线程满的话，就放入队列</span><br><span class="line">4，空闲时，从队列去除执行</span><br><span class="line"></span><br><span class="line">使用场景：异步处理的时候要用到线程池开启线程，并发处理的时候也需要</span><br></pre></td></tr></table></figure><p>乐观锁和悲观锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">乐观锁和悲观锁是并发控制的两种策略。</span><br><span class="line">乐观锁假设数据不会被同时修改，每次操作前不加锁，</span><br><span class="line">而在更新时比较数据版本号等，若未被修改则更新成功；</span><br><span class="line">悲观锁则假定数据会被其他事务修改，因此在读取和更新数据前先加锁，以防止其他事务修改。</span><br></pre></td></tr></table></figure><p>Tomcat怎么做优化的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tomcat优化包括调整线程池大小、调整内存分配、启用压缩、</span><br><span class="line">使用连接池、启用缓存等。通过调整这些参数可以提高</span><br><span class="line">Tomcat的性能和稳定性，降低资源消耗，提高并发处理能力。</span><br></pre></td></tr></table></figure><p>String是基本类型吗，为什么可以用+操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不是，String是类</span><br><span class="line">基本类型，int,char,boolean short，long，float，double这些</span><br><span class="line">+底层是通过StringBuilder实现的</span><br></pre></td></tr></table></figure><p>RabbitMQ的应用场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1，异步消息的传递，错峰削骨，我项目中的先处理抢购成功的消息，再异步处理订单的消息</span><br><span class="line">2.应用解耦，微服务架构中，各个服务组件需要通信协作，通过消息中间件作为联系</span><br><span class="line">3.任务队列：，用于将任务分发给多个消费者进行处理。这种方式可以实现任务的负载均衡和并行处理，提高了任务处理的效率和可靠性。</span><br><span class="line">4.日志收集：在分布式系统中，需要收集和统计各个节点的日志信息。</span><br><span class="line">通过将日志消息发送到RabbitMQ中，可以集中管理和存储日志数据，</span><br><span class="line">并提供查询和分析功能，帮助监控系统的运行状态。</span><br></pre></td></tr></table></figure><p>RabbitMQ如何保证消息的连续性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，消息确认机制：confirm</span><br><span class="line">手动确认（manual ack）：消费者在处理完消息后手动发送确认消息给RabbitMQ，告诉它可以删除该消息。</span><br><span class="line">自动确认（auto ack）：RabbitMQ在将消息发送给消费者后立即将消息标记为已确认，无需消费者手动确认。</span><br><span class="line">2.持久化消息，确保连续性</span><br><span class="line">在生产者发送消息时，可以将消息标记为持久化（persistent），这样即使RabbitMQ宕机或者重启，消息也不会丢失。</span><br></pre></td></tr></table></figure><p>Spring定时调度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定时调度任务可以通过使用 @Scheduled 注解来实现。</span><br><span class="line">@Scheduled 注解可以用于标注在一个方法上，使其在特定的时间间隔或特定的时间点执行</span><br></pre></td></tr></table></figure><p>基础：<br>1.Java类加载过程<br>2.知道类加载优先级机制吗<br>3.介绍下双亲委派，可以被打破吗<br>4.讲一下HashMap是怎么实现扩容的<br>5.HashMap为什么线程不安全<br>6.为什么头插法改成尾插法<br>7.有线程安全的Map结构吗<br>8.ConcurrentHashMap中CAS加在哪里，Synchronized加在哪里<br>9.ArrayList、LinkedList有哪些区别，在性能上是什么区别<br>10.O(1)级别插入和查询的数据结构<br>11.AQS的原理<br>12.AQS有哪些应用<br>13.用过哪些锁<br>14.了解CountDownLatch吗<br>15.ThreadLocal底层实现是怎样的<br>16.有用过CompletableFuture吗，底层是如何实现的<br>17.线程之间传递参数，有哪几种方式<br>18.线上一个应用进程，突然之间CPU100%了，怎样去定位是哪里出了问题<br>19.Jdk17和1.8的主要区别<br>20.偏向锁原先是被用在哪里的，为什么被废除了<br>21.介绍下索引的底层结构及为什么用<br>22.B+树的高度一般是多少<br>23.有没有遇到过B+树叶分裂的问题<br>24.让你设计一张表，主键一般选择什么数据类型<br>25.Redis的持久化有哪几种方式<br>26.Redis缓存过期策略有哪些<br>27.IOC的实现原理和好处是什么<br>28.IOC底层比较重要的BeanFactory和FactoryBean的关系是什么<br>29.AOP的具体底层是怎么做的<br>30.RocketMQ的底层了解多少<br>31.RocketMQ的工作流程是什么<br>32.你是怎么理解NameServer的<br>33.有用过Dubbo吗，整体架构是怎样的<br>34.算法：快速幂</p><p>作者：景洪<br>链接：<a href="https://www.nowcoder.com/feed/main/detail/d94acc1939864dfaa82e6c7954e8311b?sourceSSR=dynamic">https://www.nowcoder.com/feed/main/detail/d94acc1939864dfaa82e6c7954e8311b?sourceSSR=dynamic</a><br>来源：牛客网</p>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 网易 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 网易 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>携程笔试&amp;面经</title>
      <link href="/2024/06/04/Written%20Examination/xiecheng/"/>
      <url>/2024/06/04/Written%20Examination/xiecheng/</url>
      
        <content type="html"><![CDATA[<h1 id="携程笔试-面经-整理"><a href="#携程笔试-面经-整理" class="headerlink" title="携程笔试&amp;面经 整理"></a>携程笔试&amp;面经 整理</h1><h2 id="面试完没回答上来的"><a href="#面试完没回答上来的" class="headerlink" title="面试完没回答上来的"></a>面试完没回答上来的</h2><p>在并发编程中，如何确保i++的原子性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.一般来说，可以使用syn关键字，将调用i++的方法修饰</span><br><span class="line">2.使用 AtomicInteger 或 AtomicLong</span><br><span class="line">AtomicInteger 和 AtomicLong 提供了原子性操作，适用于高并发环境。</span><br></pre></td></tr></table></figure><p>死锁问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>主键索引和非主键索引的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主键索引列中的值唯一并且不为空，创建表的时候回自动创建</span><br><span class="line">非主键索引：列的值可以为空，需要手动创建，</span><br></pre></td></tr></table></figure><p>创建数据库的时候，主键是怎么设计的，为什么要自增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主键一般选用uuID，自然主键等不会重复的</span><br><span class="line">自增的话就是，简单方便，因为自增的话，主键就不会重复了</span><br></pre></td></tr></table></figure><p>一个数组取前K个较大的元素，说出你的算法思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*优先队列，最小堆</span></span><br><span class="line"><span class="comment">创建一个大小为K的最小堆（优先队列）。</span></span><br><span class="line"><span class="comment">遍历数组：将元素加入堆中，如果堆的大小超过K，则移除堆顶元素（即最小值）。</span></span><br><span class="line"><span class="comment">最终堆中的元素就是前K个最大的元素。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        minHeap.offer(num);</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() &gt; k) &#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(minHeap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String类型的方法，字符串匹配，indexof()底层是怎么实现的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串匹配</span><br><span class="line">获取源字符串和目标子字符串的字符数组及长度。</span><br><span class="line">从源字符串的起始位置开始，逐字符扫描，寻找与目标子字符串首字符匹配的位置。</span><br><span class="line">一旦找到首字符匹配位置，逐字符比较源字符串和目标子字符串的剩余字符。</span><br><span class="line">如果全部字符匹配成功，返回起始匹配位置索引；如果匹配失败，继续扫描源字符串。</span><br><span class="line">若遍历完整个源字符串未找到匹配，返回 -1。</span><br></pre></td></tr></table></figure><p>背包问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二位动态规划</span><br></pre></td></tr></table></figure><p>笔试1：一个正整数，取出所有的值为奇数的数字，按照原有的顺序拼成新的数，计算取模p的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：构建StringBuilder保存奇数字符串，用valueof转为数字，再%取模</span></span><br><span class="line"><span class="keyword">package</span> package6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/05/18 15:32</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : x.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>((c-<span class="string">&#x27;0&#x27;</span>) % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(sb.toString());</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger1</span> <span class="operator">=</span> BigInteger.valueOf(p);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">mod</span> <span class="operator">=</span> bigInteger.mod(bigInteger1);</span><br><span class="line">        System.out.println(mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>笔试2：一个正整数，重排所有数位，不包含前导0，使其变成素数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用HashSet&lt;String&gt; per存储所有可能的排列。</span></span><br><span class="line"><span class="comment">递归调用genarate方法生成所有可能的排列，并将它们添加到per集合中。</span></span><br><span class="line"><span class="comment">遍历per集合，将每个排列转换为整数，并检查它是否是质数。如果找到一个质数，将其赋值给res并跳出循环。</span></span><br><span class="line"><span class="comment">输出找到的最大质数res。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> package6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/05/20 19:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        scanner.close();</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; per = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        genarate(<span class="string">&quot;&quot;</span>,x,per);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(String prem : per)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(prem);</span><br><span class="line">            <span class="keyword">if</span>(isPrime(num))&#123;</span><br><span class="line">                res = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;=<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(num %<span class="number">2</span> == <span class="number">0</span> || num%<span class="number">3</span> ==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i * i &lt;=num; i+=<span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num % i == <span class="number">0</span> || num % (i+<span class="number">2</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prefix：当前已经生成的前缀字符串。</span></span><br><span class="line"><span class="comment">//remaining：剩余未使用的字符组成的字符串。</span></span><br><span class="line"><span class="comment">//per：存储所有排列的集合</span></span><br><span class="line">    <span class="comment">//递归的遍历去找到所有的可能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">genarate</span><span class="params">(String prefix, String remaining, HashSet&lt;String&gt; per)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> remaining.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!prefix.startsWith(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                per.add(prefix);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line">                genarate(prefix+remaining.charAt(i),remaining.substring(<span class="number">0</span>,i)+remaining.substring(i+<span class="number">1</span>,n),per);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>笔试3：合并魔法球，每次合并两个魔力相等的魔法球K，生成一个K+2魔法球，合并到无法合并为止</p><p>输入：第一行n，接下来n行，每行两个数，表示每个球的魔力和数量</p><p>输出：m(表示魔法球最后数量)，pi（魔法球的魔力值，从小到大输出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思路：因为要有序合并，考虑使用一个有序的map集合来保存，先分别将元素和元素个数存放进去</span></span><br><span class="line"><span class="comment">然后，while(tree)循环遍历消除相邻的大于2的，加入k+2的，保存到一个新的treemap中，并更新flag==true</span></span><br><span class="line"><span class="comment">如果没有大于2的，说明没有重复的了，就break退出循环，最后遍历输出即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        TreeMap&lt;Integer, Long&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">magicValue</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> scanner.nextLong();</span><br><span class="line">            map.put(magicValue, map.getOrDefault(magicValue, <span class="number">0L</span>) + count);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">merged</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            TreeMap&lt;Integer, Long&gt; newmap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> key : map.keySet()) &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (value &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">pairs</span> <span class="operator">=</span> value / <span class="number">2</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newKey</span> <span class="operator">=</span> key + <span class="number">2</span>;</span><br><span class="line">                    newmap.put(newKey, newmap.getOrDefault(newKey, <span class="number">0L</span>) + pairs);</span><br><span class="line">                    value = value % <span class="number">2</span>;</span><br><span class="line">                    merged = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">1</span>) &#123;</span><br><span class="line">                    newmap.put(key, newmap.getOrDefault(key, <span class="number">0L</span>) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map = newmap;</span><br><span class="line">            <span class="keyword">if</span> (!merged) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> key : map.keySet()) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                System.out.print(key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔试4：一棵树，每个节点上都有一个小写字母，选择一条路径，使得存在you三种字母，有多少种合法的路径</p><p>无向图，u-&gt;v和v-&gt;u是一样的</p><p>输入描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">yuio</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><p>n，节点数量</p><p>youi字符串</p><p>u v 边链接</p><p>输出描述：合法路径的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：深度优先遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main09</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span>[] letters;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRAGET_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="string">&#x27;y&#x27;</span> - <span class="string">&#x27;a&#x27;</span>) | (<span class="number">1</span> &lt;&lt; (<span class="string">&#x27;o&#x27;</span> - <span class="string">&#x27;a&#x27;</span>)) | (<span class="number">1</span> &lt;&lt; (<span class="string">&#x27;u&#x27;</span> - <span class="string">&#x27;a&#x27;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        <span class="type">String</span> <span class="variable">letterString</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        letters = letterString.toCharArray();</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tree.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> scanner.nextInt() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> scanner.nextInt() - <span class="number">1</span>;</span><br><span class="line">            tree.get(u).add(v);</span><br><span class="line">            tree.get(v).add(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(i, visited, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">boolean</span>[] visited, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[node]) <span class="keyword">return</span>;</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        mask |= <span class="number">1</span> &lt;&lt; (letters[node] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mask &amp; TRAGET_MASK) == TRAGET_MASK) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : tree.get(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                dfs(neighbor, visited, mask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[node] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="牛客上的面经"><a href="#牛客上的面经" class="headerlink" title="牛客上的面经"></a>牛客上的面经</h1><p>1.场景：缓存穿透的时候，写空值到Redis里面，如果我有个缓存穿透的线程，打入数据库（数据库中存在这条记录）的时候超时了，抛出异常，写入空值到缓存里面，用户下次访问拿到空值怎么解决？<br>区分不出这个空值是超时写入的还是不在数据库里面写入的了吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.标记空值的原因：在缓存中写入空值的同时，用时间戳或者状态标记出来</span><br><span class="line">2.使用不同的缓存过期时间：超时短，不存在的长</span><br><span class="line">3.对超时的情况，异步重试</span><br></pre></td></tr></table></figure><p>2.面向对象的三大特性，多态的好处，什么时候用到多态等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">封装继承多态</span><br><span class="line">封装：通过将数据和操作封装在类中，实现了信息隐藏和数据保护；</span><br><span class="line">继承：允许子类继承父类的属性和方法，实现了代码重用和扩展；</span><br><span class="line">多态：允许同一方法在不同对象上表现出不同行为，提高了代码的灵活性和扩展性。</span><br><span class="line"></span><br><span class="line">多态性质：同一操作对不同的对象，有不同的解释，就是多态性（父类的引用指向子类的对象）</span><br><span class="line">通过方法重写 override 或者方法重载</span><br></pre></td></tr></table></figure><p>3.JVM相关知识，在JVM模块整理吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>4.ArrayList和LinkedList</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">都是list接口的实现类</span><br><span class="line">ArrayList底层是数组，linkedList底层是链表</span><br><span class="line">所以ArrayList查找效率高，插入删除效率低</span><br><span class="line">LinkedList查找效率低，插入删除效率高</span><br></pre></td></tr></table></figure><p>5.为什么ArrayList是线程不安全的，设计一个线程安全的ArrayList</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">因为ArrayList里面的add方法在添加的时候没有加锁</span><br><span class="line">允许多个线程同时添加</span><br><span class="line">所以可能会导致底层数组越界</span><br><span class="line">解决方法就是，加锁，使用syconizied关键字修饰</span><br><span class="line">或者使用古老实现类vector</span><br></pre></td></tr></table></figure><p>6.手撕单例模式，（啊？不会）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">确保一个类只有一个实例，并且提供一个全局访问点</span><br></pre></td></tr></table></figure><p>7.volatile如何保证可见性的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volatile 关键字可以确保变量的可见性。</span><br><span class="line">具体来说，当一个线程修改了 volatile 变量的值时，</span><br><span class="line">其他线程能够立即看到这个修改的值，而不会使用缓存中的旧值。</span><br><span class="line">这是因为 volatile 变量的写操作会立即被刷新到主内存中，</span><br><span class="line">而读操作会从主内存中重新读取最新的值，从而确保了可见性。</span><br></pre></td></tr></table></figure><p>8。手撕线程池 （啊？不会）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">线程池：管理线程的池子，可以容纳多个线程，省去了频繁创建线程的操作</span><br><span class="line">Java中有几种常见的线程池，都是去实现了ThreadPoolExecutor这个类</span><br><span class="line">用这个类的构造器，去设置参数，核心线程，最大线程，超时时长，任务队列等</span><br><span class="line">可以直接用，然后重写run方法实现的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设计一个线程池嘛</span><br><span class="line">1.创建N个线程</span><br><span class="line">2.把任务提交给线程运行</span><br><span class="line">3.线程满的话，就放入队列</span><br><span class="line">4，空闲时，从队列去除执行</span><br><span class="line"></span><br><span class="line">使用场景：异步处理的时候要用到线程池开启线程，并发处理的时候也需要</span><br></pre></td></tr></table></figure><p>线程池的参数中最大线程数可以设得比核心线程数小吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">核心线程数是，线程中保持活跃的线程数</span><br><span class="line">最大线程数是，允许的最大的可以扩的线程的数量</span><br><span class="line">所以可以</span><br></pre></td></tr></table></figure><p>9.了解过JIT嘛？（真不了解）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JIT编译：在运行的时候，将字节码编译成本地机器代码的技术</span><br></pre></td></tr></table></figure><p>10.对于数组，怎么查询是否有重复元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以放到集合set或者map中去</span><br></pre></td></tr></table></figure><p>11.HashMap介绍一下，key值可以设置为null吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap是map的实现类，用来存储一对key-value数据</span><br><span class="line">然后底层是数组+链表+红黑树的实现方式</span><br><span class="line">先是创建数组，计算key的hashcode值存放</span><br><span class="line">若存放的位置不为空，用链表存在后面</span><br><span class="line">如果链表长度够长的话，转为红黑树提高查询效率</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 怎么保证线程安全</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap是线程不安全的，因为put方法没有加锁，多线程下会不安全</span><br><span class="line">解决方法就是加锁</span><br><span class="line">如果对整个put方法加锁的话，就锁的颗粒度太大了</span><br><span class="line">性能大大降低</span><br><span class="line">分段锁：对数据结构分段加锁，降低锁的颗粒度</span><br></pre></td></tr></table></figure><p>12.多线程同时操作一个数，有什么问题？怎么解决？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.线程不安全问题，导致数据不一致，脏数据</span><br><span class="line">解决方法：syn或者Lock加锁（syn不需要手动释放，Lock需要）</span><br><span class="line">2.多个线程都等待对付释放资源而无法执行，造成死锁</span><br><span class="line">解决：解决锁死锁，1.一次性锁定所有的资源 2.按顺序加锁</span><br></pre></td></tr></table></figure><p>13.项目中的rabbitmq怎么保证消息一定发出去且收到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.消息持久化</span><br><span class="line">2.生产者确认机制：</span><br><span class="line">生产者可以采用发布确认模式（Publisher Confirm）来确保消息的可靠发送。</span><br><span class="line">就是将信道设置为confirm模式，调用方法</span><br><span class="line">在该模式下，生产者发送消息后，会等待 RabbitMQ 返回确认消息，</span><br><span class="line">如果超时或者没有收到确认消息，则可以进行重发。</span><br></pre></td></tr></table></figure><p>java创建线程的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">继承Thread类，重写run方法，然后start来启动线程</span><br><span class="line">实现runnable接口：重写run方法，start实现</span><br></pre></td></tr></table></figure><p>线程之间的通信方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volatile关键字</span><br><span class="line">JUC工具类</span><br><span class="line">ThreadLocal类</span><br><span class="line">ThreadLocal提供了线程局部变量功能，每个线程拥有独立的副本，解决了线程间共享变量的隔离问题。</span><br><span class="line">实例表明即使多个线程引用同一个ThreadLocal实例，它们各自存储和获取的数据互不影响。</span><br></pre></td></tr></table></figure><p>索引的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单例索引，多例索引，主键索引，唯一索引等</span><br></pre></td></tr></table></figure><p>联合索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">它由多个列组成，可以同时对这些列进行排序和过滤。</span><br><span class="line">联合索引的创建可以基于多个列，而不仅仅是单个列。</span><br><span class="line">CREATE INDEX idx_student_grade ON students (student_id, grade);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反问：进公司要学习什么技术栈，对我的评价和建议</p><p>面试完没回答上来的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 携程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 携程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团笔试&amp;面经</title>
      <link href="/2024/05/24/Written%20Examination/meituan/"/>
      <url>/2024/05/24/Written%20Examination/meituan/</url>
      
        <content type="html"><![CDATA[<h1 id="美团5-22运维"><a href="#美团5-22运维" class="headerlink" title="美团5.22运维"></a>美团5.22运维</h1><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240525012017976.png" alt="image-20240525012017976"></p><p>1.在Nginx配置文件中，alias指令只能写在什么模块中？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias 指令通常用在 location 块中来指定存取静态文件的路径。</span><br></pre></td></tr></table></figure><p>Nginx配置文件结构</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/20201127224131685.PNG" alt="img" style="zoom: 67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nginx配置文件主要分为四个部分：</span><br><span class="line"></span><br><span class="line">main（全局设置）</span><br><span class="line">http ( )</span><br><span class="line">upstream（负载均衡服务器设置）</span><br><span class="line">server（主机设置）</span><br><span class="line">location（URL匹配特点位置的设置）</span><br><span class="line"></span><br><span class="line">server部分的指令主要用于指定主机和端口，</span><br><span class="line">upstream指令主要用于负载均衡和设置一系列的后端服务器，</span><br><span class="line">location部分用于匹配网页位置位置。</span><br><span class="line"></span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;</span><br><span class="line">        server 127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>2.数据库设计的实体类关系的陷阱问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">链接陷阱问题：</span><br><span class="line">两个实体通过第三个实体间接关联时，</span><br><span class="line">而这三个实体之间的关系却没有正确反映这种间接关系的真实情况。</span><br><span class="line">这种陷阱常发生在连续的一对多关系中，</span><br><span class="line">如果在查询中不小心处理这些关系，</span><br><span class="line">可能会导致数据的重复计算或错误的统计结果。</span><br></pre></td></tr></table></figure><p>3.vim的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">：wq        保存退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.Zabbix</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Zabbix 是一个高度集成的开源监控解决方案，</span><br><span class="line">用于监控和跟踪服务器的状态、网络设备、虚拟机</span><br><span class="line">以及其他各种网络服务的性能和可用性</span><br></pre></td></tr></table></figure><p>5.Linux通配符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通配符是用来匹配文件和目录名中的字符的特殊符号。</span><br><span class="line">这些通配符可以在许多命令行工具中使用，</span><br><span class="line">如 ls, cp, mv, rm, grep 等，以简化文件管理和搜索任务</span><br><span class="line">*</span><br><span class="line">？</span><br><span class="line">[]</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="笔试题1："><a href="#笔试题1：" class="headerlink" title="笔试题1："></a>笔试题1：</h2><p>构造长度为n的，仅有小写字母组成的字符串，恰好包含a个mei，b个tuan的子串</p><p>输入：n a b</p><p>输出：字符串，无解输出-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思路：3*a + 4*b &gt; n的时候无解</span></span><br><span class="line"><span class="comment">    先构造a，个mei，b个tuan</span></span><br><span class="line"><span class="comment">    其余长度随便拼接个子串就行*/</span></span><br><span class="line"><span class="keyword">package</span> meituan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> function(n, a, b);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">function</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a * <span class="number">3</span> + b * <span class="number">4</span> &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;mei&quot;</span>);</span><br><span class="line">            a--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;tuan&quot;</span>);</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; sb.length()) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="笔试题2："><a href="#笔试题2：" class="headerlink" title="笔试题2："></a>笔试题2：</h2><p>数组爆炸</p><p>小妹拿到一个数组，每次的爆炸操作为：删除该元素以及其两侧元素</p><p>小妹只能操作两次爆炸</p><p>希望爆炸之后的元素尽可能小</p><p>输入：n（数组长度）</p><p>​n个数组元素</p><p>输出：整数，最小元素和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思路：每次爆炸少三个元素，两次少6个元素，数组长度＜6的直接返回0</span></span><br><span class="line"><span class="comment">因为数组都是正数，要确保和最小，就不能删除首尾的元素，所以数组长度＜6的最小和都为0，其次，使用贪心算法，在第一次找到最小值，删除元素的基础上，再进行第二次爆炸，两次爆炸的代码完全可以复用，只是数组长度不一样了，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//先暴力算法</span></span><br><span class="line"><span class="keyword">package</span> meituan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次爆炸取最小和</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">minSum</span> <span class="operator">=</span> sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> sum - arr[i] - arr[i - <span class="number">1</span>] - arr[i + <span class="number">1</span>];</span><br><span class="line">            minSum = Math.min(temp, minSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在计算两次爆炸后的最小和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> sum - arr[i] - arr[i - <span class="number">1</span>] - arr[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">3</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">temp2</span> <span class="operator">=</span> temp - arr[j] - arr[j - <span class="number">1</span>] - arr[i + <span class="number">1</span>];</span><br><span class="line">                minSum = Math.min(minSum, temp2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(minSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="笔试题3"><a href="#笔试题3" class="headerlink" title="笔试题3"></a>笔试题3</h2><p>小美有一颗n节点的树，根节点为1号节点，数的每个节点是红色或者黑色的，她想知道有多少节点的子树中，同时包含红点和黑点</p><p>输入描述：</p><p>第一行输入n个整数，表示节点的数量</p><p>第二行输入长度为n的字符串表示节点的颜色，第i个节点的颜色表示si，B表示黑色，R表示红色</p><p>接下来，n-1行，输每行输入两个整数，u,v，表示树上的边</p><p>输出描述：输出一个整数表示答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：树的子树表示：包含自身和其后代所有节点</span></span><br><span class="line"><span class="comment">//定义树的结构，，用颜色和，用邻接表表示</span></span><br><span class="line"><span class="comment">//深度优先遍历，从根节点开始，遍历整个树，在遍历的过程中，收集每个节点的子树中的颜色信息</span></span><br><span class="line"><span class="comment">//对于每个节点，我们要知道子树中是否含有红黑色节点，维护两个布尔值，分别记录红黑是否存在</span></span><br><span class="line"><span class="comment">//最后判断，在递归返回的过程中，检查每个节点的字数，如果同时包含，就增加计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    List&lt;Node&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main04</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        <span class="type">String</span> <span class="variable">colors</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="comment">//创建n+1个节点，是为了一一对应</span></span><br><span class="line">        Node[] nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nodes[i] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            nodes[i].color = colors.charAt(i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            nodes[u].children.add(nodes[v]);</span><br><span class="line">            <span class="comment">//nodes[v].children.add(u);</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="comment">//深度遍历</span></span><br><span class="line">        dfs(nodes[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span>[] dfs(Node node) &#123;</span><br><span class="line">        <span class="type">boolean</span>[] contains = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (node.color == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            contains[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            contains[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node child : node.children) &#123;</span><br><span class="line">            <span class="type">boolean</span>[] childContains = dfs(child);</span><br><span class="line">            contains[<span class="number">0</span>] = contains[<span class="number">0</span>] || childContains[<span class="number">0</span>];</span><br><span class="line">            contains[<span class="number">1</span>] = contains[<span class="number">1</span>] || childContains[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (contains[<span class="number">0</span>] &amp;&amp; contains[<span class="number">1</span>]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contains;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="美团牛客面经"><a href="#美团牛客面经" class="headerlink" title="美团牛客面经"></a>美团牛客面经</h2><p>谈谈你对运维的理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我的理解是，运维工程师就是</span><br><span class="line">把开发写好的工程，去部署，发布，维护，监控，事件处理</span><br><span class="line">确保系统的稳定运行</span><br><span class="line">以及应对突发的处理情况</span><br><span class="line">因为一般都是部署在Linux中，</span><br><span class="line">需要对Linux比较了解</span><br><span class="line">还需要对监控软件zabbix</span><br><span class="line">自动化部署k8s等有所了解</span><br></pre></td></tr></table></figure><p>1，介绍OSI七层网络模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应表会传网数物：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层</span><br><span class="line">TCP/IP四层模型：应用层，传输层，网络层，网络接口层</span><br><span class="line"></span><br><span class="line">HTTP协议：基于tcp协议，超文本传输协议，主要用在Web浏览器与服务器之间通信的</span><br><span class="line"></span><br><span class="line">TCP是可靠协议，建立连接需要三次握手，传输后需要释放链接，数据包损坏会重传</span><br><span class="line">UDP是不可靠协议，不需要传输前建立连接，适用于对传输速度和效率要求高且能容忍少量数据丢失的应用，如视频流（直播）、在线游戏</span><br></pre></td></tr></table></figure><p>2.zabbix软件，k8s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zabbix主要用于监控服务器的性能，网路流量，和设备状态</span><br><span class="line">我了解一些，但是没用到过</span><br><span class="line">k8s是kubernetes，用于自动化部署容器，扩展和容器化应用程序</span><br></pre></td></tr></table></figure><p>3.Nginx调度算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">轮询，权重轮询，最少连接数，最短相应时间等</span><br><span class="line">在Nginx的配置文件中的upstream backed修改配置</span><br><span class="line"></span><br><span class="line">我自己布置Nginx的步骤，</span><br><span class="line">主要是启动Nginx然后对Nginx的配置文件的配置</span><br><span class="line">包括监听的端口，</span><br><span class="line">反向代理的地址</span><br><span class="line">还有就是负载均衡分给服务器的端口</span><br><span class="line"></span><br><span class="line">反向代理就是，将客户端的请求，分给多台后端的Web服务器。</span><br><span class="line">提升网站的负载能力和可靠性，代理的是服务器</span><br><span class="line">正向代理就是：就像有个中介代理服务器一样，他代理的是客户端</span><br></pre></td></tr></table></figure><p>4，MySQL的主从，数据库高可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主从复制吗？</span><br><span class="line">主服务器主要负责写操作，insert，delete，update</span><br><span class="line">并且记录所以得写操作到二进制日志，binlog中</span><br><span class="line"></span><br><span class="line">从服务器复制binlog，写入到中继日志中去，</span><br><span class="line">从库的SQL线程读取中继日志的文件</span><br><span class="line">更新服务器的数据</span><br><span class="line"></span><br><span class="line">主从复制的类型：异步复制，半同步复制，同步复制</span><br><span class="line"></span><br><span class="line">数据库高可用就是，数据库系统出现故障的时候，能够保证持续的可用性和可靠性</span><br><span class="line">包括：冗余备份，故障检测，负载均衡，数据备份与恢复，监控警报等</span><br></pre></td></tr></table></figure><p>5.HTTP的状态码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1XX：临时响应</span><br><span class="line">2XX：成功</span><br><span class="line">3XX：重定向，需要后续操作才能</span><br><span class="line">4XX：客户端错误，403拒绝，404找不到</span><br><span class="line">5XX：服务器错误 </span><br></pre></td></tr></table></figure><p>6.长连接和短链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">长连接：完成通信不关闭，保持一段时间，持久连接，HTTP1.1，Web socket</span><br><span class="line">一般请求频率高，场景</span><br><span class="line">短连接：每次都建立新链接，HTTP1.0</span><br><span class="line">请求频率低的场景</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>7.数据库表的设计注意什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">那很多细节了</span><br><span class="line">1,数据库设计的三个范式，每个列，每个非主键都依赖于主键</span><br><span class="line">2.主键的设置</span><br><span class="line">3，外键的设计</span><br><span class="line">4.实体关系图的设计</span><br><span class="line">5.索引的设计</span><br><span class="line">6.合适的数据类型</span><br><span class="line">7.大表的优化，分区分表等</span><br></pre></td></tr></table></figure><p>8.进程和线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个进程中包含很多线程</span><br><span class="line">进程是一个独立运行的程序，</span><br><span class="line">线程是进程内的一个独立的执行单元</span><br><span class="line">一个进程包含多个线程</span><br></pre></td></tr></table></figure><p>9.谈谈你对运维的理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的理解就是，应用系统的发布，维护，监控，事件处理</span><br><span class="line">对相关故障的排查等，对Linux要有比较深入的了解</span><br></pre></td></tr></table></figure><p>10，反问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我知道今天的表现可能不尽如人意</span><br><span class="line">您可以从面试官的角度给我一些后续的建议</span><br><span class="line">或者说规划吗</span><br></pre></td></tr></table></figure><p>11.ELF的链接过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ELF是将分散的目标文件合并成一个可执行文件的过程</span><br><span class="line">1.编译和汇编</span><br><span class="line">2.符号解析</span><br><span class="line">3.定位</span><br><span class="line">4.合并</span><br><span class="line">5.生成可执行文件</span><br></pre></td></tr></table></figure><p>12.PIE是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PIE，位置无关可执行文件，它的代码可以在内存中的任何位置执行，</span><br><span class="line">而不会依赖于特定的内存地址。这种技术在增强安全性和灵活性方面具有重要意义。</span><br></pre></td></tr></table></figure><p>13.对云原生的理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不仅仅是将应用部署在云上，而是用云的特性来优化开发和运营流程</span><br><span class="line">比如说：</span><br><span class="line">容器化，将应用及其依赖环境打包成一个独立的镜像，</span><br><span class="line">运行在容器中，确保在不同的环境中也能一致的运行</span><br><span class="line">微服务架构：将应用拆分成小的，独立部署的服务</span><br><span class="line">每个专注与特定的功能</span><br><span class="line">动态编排：使用编排工具，kubernetes，自动化的管理资源，故障修复，简化管理等</span><br></pre></td></tr></table></figure><p>14，什么样的服务适合在云上跑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">适合在云上运行的服务有以下共同的特征：</span><br><span class="line">需要高弹性和可扩展性，对成本敏感，需要快速部署和调试</span><br></pre></td></tr></table></figure><p>15.有状态服务和无状态服务的差异</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无状态服务：就是每个请求是独立的，服务端不会保存有关客户端的信息</span><br><span class="line">有状态服务：就是，服务器会在会话请求中保存客户端的状态信息</span><br><span class="line">会话跟踪技术就是，cookie，session，jwt</span><br></pre></td></tr></table></figure><p>16.数据库云上，云下区别，（云端部署和本地部署）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">就是数据库部署在本地与云端的区别</span><br><span class="line">本地的话：就是需要自己去购买服务器，自行搭建，云端不会</span><br><span class="line">然后本地的话，本地团队管理，要投入大，云端不会</span><br><span class="line"></span><br><span class="line">性能方面：主要是延迟，这个本地的延迟肯定低</span><br><span class="line">安全方面：本地部署的难免遇到不可抗力，云端有多个服务器，主从，哨兵模式，</span><br><span class="line">挂了，会有其他节点顶上</span><br><span class="line">扩展：本地的难扩展，要买设备，云端的只需要花钱买买买就行了</span><br></pre></td></tr></table></figure><p>17.Linux命令问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索：使用grep搜索</span><br></pre></td></tr></table></figure><p>18.shell的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shell命令是进行系统操作、文件管理、进程管理、网络操作等各种任务的基础</span><br><span class="line">文件操作：ls,ll,pwd,madir,rm,cp,mv,cat</span><br><span class="line">文件权限和所有权：chmod</span><br><span class="line">文件查找：find，grep</span><br><span class="line">系统管理：kill，df,ps,du</span><br><span class="line">网络操作：ping,ipconfig,netset</span><br><span class="line">解压安装：tar</span><br></pre></td></tr></table></figure><p>19.shell脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先去创建一个.sh结尾的文件,nano example.sh</span><br><span class="line">去把一系列的shell指令写进去</span><br><span class="line">运行脚本：./example.sh即可</span><br></pre></td></tr></table></figure><p>20.ls是怎么筛选排序的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认是按照字母的顺序，可以使用一些选项，-l,-r,-t等等可以按照不同的顺序排序</span><br></pre></td></tr></table></figure><p>21.DNS域名解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用域名解析，根据域名解析出相应IP地址</span><br><span class="line">底层是递归解析吧，查询顶级域名，查询权限域名，返回结果</span><br></pre></td></tr></table></figure><p>22.Linux系统的内存结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内核空间：</span><br><span class="line">用户空间：</span><br><span class="line">缓存区和缓冲区：</span><br><span class="line">内存映射区：</span><br><span class="line">呢内存线程栈：</span><br></pre></td></tr></table></figure><p>23.Linux系统如何查看当前CPU占用？内存占用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top查看CPU占用</span><br><span class="line">free查看内存占用</span><br></pre></td></tr></table></figure><p>24.Linux系统的$符号的作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占位符</span><br><span class="line">变量的引用，环境变量的引用，命令的替换</span><br></pre></td></tr></table></figure><p>25.TCP三次握手，四次挥手，为什么挥手最后一次要等待？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">三次握手的过程是为了确保客户端和服务器双方都能够正常发送和接收数据：</span><br><span class="line"></span><br><span class="line">第一次握手：客户端向服务器发送一个带有SYN标志的数据包，请求建立连接。</span><br><span class="line">第二次握手：服务器收到客户端的SYN后，回复一个带有SYN/ACK标志的数据包，表示接受连接请求。</span><br><span class="line">第三次握手：客户端收到服务器的SYN/ACK后，再次回复一个带有ACK标志的数据包，表示连接建立成功。</span><br><span class="line">这样，通过三次握手，客户端和服务器双方都确认了彼此的接收和发送能力，建立了可靠的TCP连接。</span><br><span class="line"></span><br><span class="line">2. 四次挥手（TCP连接终止）</span><br><span class="line">四次挥手的过程是为了确保客户端和服务器双方都能够正确地关闭连接，并且保证数据的完整性：</span><br><span class="line"></span><br><span class="line">第一次挥手：客户端向服务器发送一个带有FIN标志的数据包，表示客户端不再发送数据。</span><br><span class="line">第二次挥手：服务器收到客户端的FIN后，回复一个带有ACK标志的数据包，表示已经收到了客户端的关闭请求。</span><br><span class="line">第三次挥手：服务器向客户端发送一个带有FIN标志的数据包，表示服务器也准备关闭连接。</span><br><span class="line">第四次挥手：客户端收到服务器的FIN后，回复一个带有ACK标志的数据包，表示已经收到了服务器的关闭请求，并且也准备关闭连接。</span><br><span class="line">在四次挥手的最后一次挥手之后，客户端和服务器会进入TIME_WAIT状态，等待一段时间后才会完全关闭连接。这个等待时间是为了确保网络中所有的数据包都能够被正确地传输完成，以防止数据丢失或者重复传输。等待时间结束后，连接才会完全关闭，释放所有资源。</span><br></pre></td></tr></table></figure><p>26，死锁是怎么形成的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多个线程竞争资源导致的阻塞状态，每个线程都在等待其他线程释放资源，</span><br><span class="line">导致所有的参与者都无法访问</span><br></pre></td></tr></table></figure><p>27.文件权限755</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这个是由三种不同的权限标识的数字</span><br><span class="line">分别是，所有者权限，所属者权限，其他用户权限</span><br><span class="line">读权限是：4</span><br><span class="line">写权限是：2</span><br><span class="line">执行权限是：1</span><br><span class="line"></span><br><span class="line">因此，755，就是，所有者有读，写，执行，所属着和其他用户为读+执行</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>28，目录权限和文件权限的执行不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行权限的含义不同：对于文件，执行权限表示是否可以执行该文件；</span><br><span class="line">对于目录，执行权限表示是否可以进入该目录。</span><br><span class="line">写权限的作用不同：对于文件，写权限表示是否可以修改文件内容；</span><br><span class="line">对于目录，写权限表示是否可以修改目录结构，包括创建、删除和重命名文件和子目录。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>29，swap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顾名思义，交换嘛，swap，用于在内存RAM不足的情况下</span><br><span class="line">将swap空间作为虚拟内存的一部分磁盘空间</span><br></pre></td></tr></table></figure><p>30.对Linux异常监控跟踪</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">日志监控：syslog</span><br><span class="line">系统性能监控：top(CPU)，free(内存)</span><br><span class="line">进程监控：ps</span><br><span class="line">网络监控：netstat等</span><br></pre></td></tr></table></figure><p>30.防止巨大流量冲击的防护措施有什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">防火墙，IP封堵黑白名单，cdn加速把静态资源存到全球各地的节点</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 美团 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 美团 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础面试题</title>
      <link href="/2024/05/24/Interviews/JavaSE/"/>
      <url>/2024/05/24/Interviews/JavaSE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis面试题</title>
      <link href="/2024/05/24/Interviews/Mybatis/"/>
      <url>/2024/05/24/Interviews/Mybatis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql面试题</title>
      <link href="/2024/05/24/Interviews/Mysql/"/>
      <url>/2024/05/24/Interviews/Mysql/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ面试题</title>
      <link href="/2024/05/24/Interviews/MQ/"/>
      <url>/2024/05/24/Interviews/MQ/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列面试题"><a href="#消息队列面试题" class="headerlink" title="消息队列面试题"></a>消息队列面试题</h1><p>RabbitMQ的应用场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1，异步消息的传递，错峰削骨，我项目中的先处理抢购成功的消息，再异步处理订单的消息</span><br><span class="line">2.应用解耦，微服务架构中，各个服务组件需要通信协作，通过消息中间件作为联系</span><br><span class="line">3.任务队列：，用于将任务分发给多个消费者进行处理。这种方式可以实现任务的负载均衡和并行处理，提高了任务处理的效率和可靠性。</span><br><span class="line">4.日志收集：在分布式系统中，需要收集和统计各个节点的日志信息。</span><br><span class="line">通过将日志消息发送到RabbitMQ中，可以集中管理和存储日志数据，</span><br><span class="line">并提供查询和分析功能，帮助监控系统的运行状态。</span><br></pre></td></tr></table></figure><p>RabbitMQ如何保证消息的连续性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1，消息确认机制：confirm</span><br><span class="line">手动确认（manual ack）：消费者在处理完消息后手动发送确认消息给RabbitMQ，告诉它可以删除该消息。</span><br><span class="line">自动确认（auto ack）：RabbitMQ在将消息发送给消费者后立即将消息标记为已确认，无需消费者手动确认。</span><br><span class="line">所以一般来说，如果你要确保写RabbitMQ的消息别丢，在生产者那里设置开启confirm模式，</span><br><span class="line">每次写消息都会分配一个唯一id，如果写入了RabbitMQ中，RabbitMQ会给你回传一个ack消息，告诉你说这个消息ok了。</span><br><span class="line">如果RabbitMQ没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。</span><br><span class="line">2.持久化消息，确保连续性</span><br><span class="line">在生产者发送消息时，可以将消息标记为持久化（persistent），这样即使RabbitMQ宕机或者重启，消息也不会丢失。</span><br></pre></td></tr></table></figure><p>为什么要用MQ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">核心：解耦、异步、削峰</span><br><span class="line">解耦：A系统发送数据到BCD三个系统，通过接口调用发送。如果此时E系统也想要这个数据呢？C系统不想要这个数据了呢？A系统的负责人直接崩溃，因为现在A系统跟其他各种乱七八糟的系统严重耦合在了一起。A系统产生了一条比较关键的数据，很多系统都需要A系统将这个数据发送过来。如果使用MQ，A系统将这条数据发送到MQ里去，哪个系统需要数据自己就去MQ里消费，哪个系统不需要这条数据了，就取消对MQ消息的消费。这样下来，A系统就不用去考虑给谁发送数据了，不需要维护这个代码，也不用考虑别的系统是否调用成功、失败超时等情况。核心思想就是舍弃同步调用其他接口，使用MQ异步化解耦。</span><br><span class="line">异步：A系统接收到一个请求，需要在自己本地写库，还需要在BCD三个系统写库。自己本地写库要3ms，BCD三个系统分别写库要300ms、400ms、500ms。最终总延时接近1.2s，给用户的体验极差。用户通过浏览器发起请求，如果使用MQ，假如A系统连续发送3条消息到MQ队列中耗时5ms，那么A系统从接受一个请求到返回响应给用户，总时长是3 + 5 = 8ms</span><br><span class="line">削峰：减少高峰时期对服务器的压力</span><br></pre></td></tr></table></figure><p>MQ优缺点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点上面已经说了：解耦、异步、削峰</span><br><span class="line">缺点如下：</span><br><span class="line">系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了，那么整套系统都崩溃了。</span><br><span class="line">系统复杂度提高：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</span><br><span class="line">一致性问题：A系统处理完了直接返回成功了，用户就真的以为你这个请求成功了。但是问题是：要是BCD三个系统里，BC两个系统写库成功了，D系统写库失败了，那么此时数据就会出现不一致性问题。</span><br></pre></td></tr></table></figure><p>如何保证高可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RabbitMQ是基于主从做高可用性的，RabbitMQ有三种模式：单机模式、普通集群模式、镜像集群模式。</span><br><span class="line">单机模式：就是Demo级别的，一般就是本地启动玩玩儿的，生产环境没人用单机模式</span><br><span class="line">普通集群模式：在多台机器上启动多个RabbitMQ实例，每个机器启动一个。你创建的queue，只会放在一个RabbitMQ实例上，但是每个实例都同步queue的元数据（元数据可以认为是queue的一些配置信息，通过元数据可以找到queue所在实例）。在消费消息的时候，如果连接到了别的RabbitMQ实例，那么这个示例会从queue所在的实例上拉取数据过来。这个方案主要是为了提高吞吐量的，让集群中的多个节点来服务某个queue的读写操作。</span><br><span class="line">镜像集群模式：这种模式才是所谓的RabbitMQ高可用模式。跟普通集群不一样的是，在镜像集群模式下，你创建的queue，无论是元数据还是queue里的消息，都会存在于多个实例上，就是说，每个RabbitMQ节点都有这个queue的完整镜像，包含queue的全部数据。每次写消息到queue的时候，都会自动把消息同步到多个实例的queue上。RabbitMQ的管理控制台可以在后台增加一个集群模式的策略，可以要求数据同步到所有节点，也可以要求同步到指定数量的节点，再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的好处在于，任何一个机器宕机了，其他机器还有包含了这个queue的完整数据，别的消费者可以到其他的节点上去消费数据。坏处在于，1.性能开销太大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重。2. 扩展性差：如果某个 Queue 负载很重，即便加机器，新增的机器也包含了这个 Queue 的所有数据，并没有办法线性扩展你的 Queue。</span><br></pre></td></tr></table></figure><p>如何保证消息的可靠传输，消息丢失怎么办</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先这个消息丢失，有三处都可能发生</span><br><span class="line">生产者丢失：生产者将数据发送到RabbitMQ的时候，由于网络的原因，可能数据半路就丢了。此时可以选择使用RabbitMQ提供的事务功能，就是生产者发送数据之前开启RabbitMQ事务channel.txSelect，然后发送消息，如果消息没有被RabbitMQ接收到，那么生产者会收到异常报错，此时可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。吞吐量会下来，因为太耗性能。所以一般来说，如果你要确保写RabbitMQ的消息别丢，在生产者那里设置开启confirm模式，每次写消息都会分配一个唯一id，如果写入了RabbitMQ中，RabbitMQ会给你回传一个ack消息，告诉你说这个消息ok了。如果RabbitMQ没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间没有接收到这个消息的回调，那么你可以重发。</span><br><span class="line"></span><br><span class="line">MQ中丢失：这种情况必须开启RabbitMQ的持久化，就是消息写入之后会持久化到硬盘，哪怕RabbitMQ自己挂了，恢复之后也会自动读取之前存储的数据，一般数据不会丢失。设置持久化有两个步骤：第一个是创建queue的时候将其设置为持久化，这样可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里的数据。第二个是发送消息的时候，将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ就会将消息持久化到磁盘上去。必须同时设置这两个持久化才行，</span><br><span class="line"></span><br><span class="line">消费端丢失：消费的时候，刚消费到，还没处理，此时服务挂了，服务重启了，那么就尴尬了，RabbitMQ人为你消费了，这数据就丢了。这个时候需要使用RabbitMQ提供的ack机制，简单来说就是，关闭RabbitMQ的自动ack，然后在服务处理消息完毕后再手动ack，这样的话，如果消息还没处理完，那么就不会ack，消息就不会丢了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消息的顺序性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拆分多个 Queue，每个 Queue一个 Consumer；或者就一个 Queue 但是对应一个 Consumer，然后这个 Consumer 内部用内存队列做排队，然后分发给底层不同的 Worker 来处理。</span><br></pre></td></tr></table></figure><h2 id="大量消息在MQ里长时间积压，该如何解决？"><a href="#大量消息在MQ里长时间积压，该如何解决？" class="headerlink" title="大量消息在MQ里长时间积压，该如何解决？"></a>大量消息在MQ里长时间积压，该如何解决？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一般这个时候，只能临时紧急扩容了，具体操作步骤思路如下</span><br><span class="line">先修复consumer的问题，确保其恢复消费速度，然后将现有的consumer都停掉。</span><br><span class="line">新建一个topic，partition是原来的10倍，临时建立好原先10倍的queue数量。</span><br><span class="line">写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue。</span><br><span class="line">接着临时用10倍的机器来部署consumer，每一批consumer消费一个临时queue数据，这样的做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据。</span><br><span class="line">等快速消费完积压数据后，得回复原先部署的架构，重新用原先的consumer机器来消费消息。</span><br></pre></td></tr></table></figure><h2 id="MQ中规定消息过期失效了怎么办？"><a href="#MQ中规定消息过期失效了怎么办？" class="headerlink" title="MQ中规定消息过期失效了怎么办？"></a>MQ中规定消息过期失效了怎么办？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用的是RabbitMQ，RabbitMQ是可以设置过期时间的（TTL）。如果消息在queue中积压超过一定时间就会被RabbitMQ给清理掉，这个数据就没了。此时的问题就不是数据大量积压在MQ里，而是大量的数据会直接搞丢。这个情况下，解决方案就不是增加consumer消费积压的信息了，而是需要批量重导，当大量积压的时候，直接将数据写到数据库，等过了高峰期之后在将这批数据一点一点查出来，重新写入到MQ中，将丢的数据补回来。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题</title>
      <link href="/2024/05/24/Interviews/Redis/"/>
      <url>/2024/05/24/Interviews/Redis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring,springboot面试题</title>
      <link href="/2024/05/24/Interviews/spring/"/>
      <url>/2024/05/24/Interviews/spring/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM面试题</title>
      <link href="/2024/05/24/Interviews/JVM/"/>
      <url>/2024/05/24/Interviews/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM面试题"><a href="#JVM面试题" class="headerlink" title="JVM面试题"></a>JVM面试题</h1><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/p9SowJU.png" alt="img"></p><p><code>内存模型</code>：各个部分的作用，保存哪儿些数据</p><p><code>类加载</code>：双亲委派加载机制，常用加载器分别加载哪儿种类型的类</p><p><code>GC</code>：分带回收的思想依据</p><p><code>性能调优</code>：JVM工具，性能分析工具</p><p><code>执行模式</code>：解释模式，编译模式，混合模式等</p><p><code>编译器优化</code>：javac的变异过程</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom:50%;"><p>线程私有：栈，本地方法栈，程序计数器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">栈</span><br><span class="line">又称方法栈，线程私有的，线程执行方法是都会创建一个栈帧，</span><br><span class="line">用来存储局部变量表、操作栈、动态链接、方法出口等信息。</span><br><span class="line">调用方法时执行入栈，方法返回时执行出栈</span><br><span class="line"></span><br><span class="line">本地方法栈</span><br><span class="line">与栈类似，也是用来保存执行方法的信息，</span><br><span class="line">执行Java方法是使用占，执行Native方法时是使用本地方法栈</span><br><span class="line"></span><br><span class="line">程序计数器</span><br><span class="line">保存当前线程执行的字节码位置，每个线程工作时都有独立的计数器，</span><br><span class="line">值为执行Java方法服务，执行Native方法时，程序计数器为空</span><br></pre></td></tr></table></figure><p>线程共享：堆，方法区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">堆</span><br><span class="line">JVM内存管理最大的一块，堆被线程共享，目的是存放对象的实例，几乎所有对象的实例都会放在这里。</span><br><span class="line">当堆没有可用空间时，会抛出OOM异常(Out of Menory内存溢出)，根据对象的存活周期不同，</span><br><span class="line">JVM把对象进行分代管理，由垃圾回收器进行垃圾的回收管理</span><br><span class="line">新生代内存(Young Generation)</span><br><span class="line">老生代(Old Generation)</span><br><span class="line">永久代(Permanent Generation)、1.8版本：元空间</span><br><span class="line"></span><br><span class="line">方法区</span><br><span class="line">又称非堆区，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器优化后的代码等数据</span><br><span class="line">1.7的永久代和1.8的源空间都是方法区的一种实现</span><br></pre></td></tr></table></figure><p>类的加载和卸载</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240606101850630.png" alt="image-20240606101850630" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">加载：通过类的全限定名，查找此类的字节码文件，利用字节码文件创建Class对象</span><br><span class="line"></span><br><span class="line">链接：分为三个阶段</span><br><span class="line">验证：确保Class文件符合当前虚拟机的要求，不会危害到虚拟机自身安全</span><br><span class="line">准备：进行内存分配，为static修饰的类变量分配内存，并设置初始值(0或null)，</span><br><span class="line">不包含final修饰的静态变量，因为final变量在编译时就分配好了</span><br><span class="line">解析：将常量池中的符号引用替换为直接引用的过程，直接引用为直接指向目标的指针或者相对偏移量等</span><br><span class="line">初始化：主要完成静态块执行以及静态变量的复制，先初始化父类，再初始化当前类。</span><br><span class="line">初始化是懒惰的，只有对类主动使用的时候才会初始化</span><br></pre></td></tr></table></figure><p>加载机制：双亲委派机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加载机制：双亲委派模式</span><br><span class="line">当一个类加载器收到类加载请求时，它首先会将这个请求委托给父类加载器去处理。</span><br><span class="line">如果父类加载器无法加载该类，则该类加载器才会自己去加载这个类。</span><br><span class="line">优点：避免类的重复加载，避免Java的核心API被篡改</span><br></pre></td></tr></table></figure><p>卸载过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类卸载的实现依赖于JVM的垃圾回收机制。当一个类不再被引用时</span><br><span class="line">JVM可能会通过垃圾回收机制将该类的实例回收</span><br></pre></td></tr></table></figure><p>对象的创建过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java对象的创建过程可以概括为以下几个步骤</span><br><span class="line"></span><br><span class="line">类加载：JVM会先检查类是否已经被加载了，如果没有则通过类加载器加载类的class文件，并将类的信息存储到方法区中</span><br><span class="line">内存分配：当类被加载后，JVM会为该类的对象分配内存，根据Java对象的特点，</span><br><span class="line">内存大小是在编译时就已经确定的，因此内存分配可以通过一些简单的算法来实现，例如指针碰撞和空闲列表等</span><br><span class="line">初始化：内存分配完成后，JVM会对对象进行默认初始化，即将对象的成员变量赋上默认值。</span><br><span class="line">基本类型的默认值是0或false，引用类型的默认值是null</span><br><span class="line">构造函数：默认初始化后，JVM会调用该对象的构造函数，进行对象的属性初始化和一些其他操作</span><br><span class="line">返回地址：构造函数执行完毕后，JVM会将对象的引用返回给调用者，此时对象创建过程完毕</span><br></pre></td></tr></table></figure><p>JVM中的垃圾回收机制，大致说一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GC是JVM的垃圾回收机制</span><br><span class="line">首先GC有多种算法：</span><br><span class="line">标记清除：遍历整个堆，清除所有未标记的对象，将其内存空间释放。</span><br><span class="line">标记压缩：将所有存活的对象压缩到堆的一端，保持连续的内存空间，清除端释放未使用的空间。</span><br><span class="line">复制算法：将堆内存分成两部分，活动对象从一个区域复制到另一个区域，不活动的对象直接丢弃</span><br><span class="line">（新生代）</span><br><span class="line">堆内存区域划分：</span><br><span class="line">新生代，老年代，元空间</span><br><span class="line">GC的过程：</span><br><span class="line">minor GC：年轻代满的时候发生，主要复制算法</span><br><span class="line">Full GC：老年代空间不够用的时候</span><br><span class="line"></span><br><span class="line">垃圾收集器</span><br><span class="line">JVM 提供了多种垃圾收集器，不同收集器适用于不同的应用场景：</span><br><span class="line"></span><br><span class="line">Serial 收集器：适用于单线程环境，简单高效。</span><br><span class="line">Parallel 收集器：适用于多线程环境，采用并行的方式进行垃圾回收。</span><br><span class="line">CMS（Concurrent Mark-Sweep）收集器：适用于低停顿时间的应用，主要用于老年代的垃圾回收。</span><br><span class="line">G1（Garbage First）收集器：适用于大内存和高吞吐量的应用，采用分区算法，能够并发和并行回收内存。</span><br></pre></td></tr></table></figure><p>有看过GC日志吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">没看过</span><br><span class="line">调用System.gc()方法后</span><br><span class="line">在IDEA中的application配置那里</span><br><span class="line">输入一个什么命令去查看</span><br><span class="line">-Xlog:gc*:file=&lt;path-to-log-file&gt;:time,uptime:filecount=10,filesize=10M</span><br></pre></td></tr></table></figure><p>如何判断一个对象是垃圾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.没有被引用的指向时候</span><br><span class="line">2，无法通过引用链到达的时候</span><br><span class="line">3,没有重写finalize方法</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路遥-可惜没如果</title>
      <link href="/2024/05/20/life/luyao/"/>
      <url>/2024/05/20/life/luyao/</url>
      
        <content type="html"><![CDATA[<h2 id="9号，你会弹钢琴吗？"><a href="#9号，你会弹钢琴吗？" class="headerlink" title="9号，你会弹钢琴吗？"></a>9号，你会弹钢琴吗？</h2><p><video controls src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/video/luyao.mp4" title="Title" style="max-width: 100%; height: auto;"></video></p><p>全都怪我<br>不该沉默时沉默 该勇敢时软弱<br>如果不是我<br>误会自己洒脱 让我们难过<br>可当初的你和现在的我<br>假如重来过</p><p>倘若那天<br>把该说的话好好说<br>该体谅的不执着<br>如果那天我<br>不受情绪挑拨<br>你会怎么做<br>那么多如果 可能如果我<br>可惜没如果 只剩下结果</p><h2 id="原版MV"><a href="#原版MV" class="headerlink" title="原版MV"></a>原版MV</h2><div align="center" class="aspect-ratio">    <iframe src="https://player.bilibili.com/player.html?bvid=BV1GV4y197fy&&page=1&as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true">     </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路遥 </tag>
            
            <tag> 可惜没如果 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性</title>
      <link href="/2024/05/07/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2024/05/07/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h2 id="Java8新特性的好处"><a href="#Java8新特性的好处" class="headerlink" title="Java8新特性的好处"></a>Java8新特性的好处</h2><ol><li>速度更快</li><li>代码更少（Lambda简化代码书写）</li><li>强大的Stream API（我就是冲着它来的，真滴好用）</li><li>便于并行</li><li>最大化减少空指针异常：Optional</li><li>Nashorn引擎，允许在JVM上运行JS应用</li></ol><h2 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h2><ul><li>并行流就是把一个内容分为多个数据块，并用不同的线程分别处理每个数据块的流，相比较于串行流，可以很大程度上提高程序的执行效率</li><li>Java8中将其进行了优化，我们可以很容易的对数据进行并行操作。</li><li>Stream API 可以声明性地通过parallel()和sequential()在并行流与顺序流之间进行切换</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul><li>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。</li><li>使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，是Java的语言表达能力得到了提升</li></ul><p>Lambda举例</p><ul><li>举例一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你 的 城 市 好 像 不 欢 迎 我&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    runnable01.run();</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable02</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;所 以 我 只 好 转 身 离 开 了&quot;</span>);</span><br><span class="line">    runnable02.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>举例二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator01 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator01.compare(<span class="number">95</span>, <span class="number">27</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator02 = (o1,o2) -&gt; o1.compareTo(o2);</span><br><span class="line">    System.out.println(comparator02.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator03 = Integer::compareTo;</span><br><span class="line">    System.out.println(comparator03.compare(<span class="number">20</span>, <span class="number">77</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda表达式的使用"><a href="#Lambda表达式的使用" class="headerlink" title="Lambda表达式的使用"></a>Lambda表达式的使用</h2><ol><li>举例： (o1,o2) -&gt; Integer.compare(o1,o2);</li><li>格式：<ul><li><code>-&gt;：</code>lambda操作符或箭头操作符</li><li><code>-&gt;左边：</code>lambda<strong>形参列表</strong>（其实就是接口中的抽<strong>象方法的形参列表</strong>）</li><li><code>-&gt;右边：</code>lambda体（其实就是<strong>重写的抽象方法的方法体</strong>）</li></ul></li></ol><p>3.Lambda表达式的使用：六种情况</p><p>总结：</p><p>​-&gt;左边：Lambda形参列表可以省略，如果只有一个参数，也可以省略()</p><p>​-&gt;右边：Lambda体应该使用一对{}包裹，如果只有一条语句，可以省略，返回值return可以省略</p><p>本质：接口的实例。 依赖于函数型接口</p><ol><li><ul><li><code>语法格式一：</code>无参无返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你 的 城 市 好 像 不 欢 迎 我&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    runnable01.run();</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable02</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;所 以 我 只 好 转 身 离 开 了&quot;</span>);</span><br><span class="line">    runnable02.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>语法格式二：</code>Lambda需要一个参数，但是没有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Consumer&lt;String&gt; consumer01 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer01.accept(<span class="string">&quot;其实我存过你照片 也研究过你的星座&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Consumer&lt;String&gt; consumer02 = (String s) -&gt; &#123;System.out.println(s);&#125;;</span><br><span class="line">    consumer02.accept(<span class="string">&quot;你喜欢的歌我也会去听 你喜欢的事物我也会想去了解&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>语法格式三：</code>数据类型可以省略，因为可由<code>类型推断</code>得出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Consumer&lt;String&gt; consumer01 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer01.accept(<span class="string">&quot;我远比表面上更喜欢你&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Consumer&lt;String&gt; consumer02 = (s) -&gt; &#123;System.out.println(s);&#125;;</span><br><span class="line">    consumer02.accept(<span class="string">&quot;但我没有说&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>语法格式四：</code>Lambda若只需要一个参数，参数的小括号可以省略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Consumer&lt;String&gt; consumer01 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer01.accept(<span class="string">&quot;我远比表面上更喜欢你&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Consumer&lt;String&gt; consumer02 = s -&gt; &#123;System.out.println(s);&#125;;</span><br><span class="line">    consumer02.accept(<span class="string">&quot;但我没有说&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>语法格式五：</code>Lambda需要两个或以上参数，多条执行语句，并且有返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator01 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator01.compare(<span class="number">95</span>, <span class="number">27</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator02 = (o1, o2) -&gt; &#123;</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator02.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>语法格式六：</code>当Lambda体只有一条语句时，return与{}若有，则都可以省略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator01 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator01.compare(<span class="number">95</span>, <span class="number">27</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator02 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">    System.out.println(comparator02.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h3 id="函数式接口介绍"><a href="#函数式接口介绍" class="headerlink" title="函数式接口介绍"></a>函数式接口介绍</h3><ul><li>Lambda表达式的本质：作为<strong>函数式接口的实例</strong></li><li>如果在一个接口中，只声明了<strong>一个抽象方法</strong>，则此接口就被称为函数式接口，我们可以在一个接口上使用**@FunctionalInterface注解**来验证该接口是否为函数式接口（如果你在该接口中写了两个方法，则编译期就会报错）</li><li>正是因为抽象方法中只有一个方法，所以我们才可以省略@Override函数声明等内容</li><li>在<code>java.util.function</code>包下定义了Java 8 的丰富的函数式接口</li><li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着Python、Scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程）</li><li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。</li><li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li><li>所以以前用<strong>匿名实现类</strong>表示的现在都可以用Lambda表达式来写。</li></ul><h3 id="Java内置的函数式接口介绍及使用举例"><a href="#Java内置的函数式接口介绍及使用举例" class="headerlink" title="Java内置的函数式接口介绍及使用举例"></a>Java内置的函数式接口介绍及使用举例</h3><table><thead><tr><th align="center">函数式接口</th><th align="center">参数类型</th><th align="center">返回类型</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">Consumer 消费型接口</td><td align="center">T</td><td align="center">void</td><td align="center">对类型为T的对象应用操作，包含方法：void accept(T t)</td></tr><tr><td align="center">Supplier 供给型接口</td><td align="center">无</td><td align="center">T</td><td align="center">返回类型为T的对象，包含方法：T get()</td></tr><tr><td align="center">Function&lt;T, R&gt;函数型接口</td><td align="center">T</td><td align="center">R</td><td align="center">对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t)</td></tr><tr><td align="center">Predicate断定型接口</td><td align="center">T</td><td align="center">boolean</td><td align="center">确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法：boolean test(T t)</td></tr><tr><td align="center">BiFunction&lt;T,U,R&gt;</td><td align="center">T, U</td><td align="center">R</td><td align="center">对类型为T,U参数应用操作，返回R类型的结果。包含方法为：Rapply(T t,U u);</td></tr><tr><td align="center">UnaryOperator(Function子接口)</td><td align="center">T</td><td align="center">T</td><td align="center">对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为：Tapply(T t);</td></tr><tr><td align="center">BinaryOperator(BiFunction子接口)</td><td align="center">T,T</td><td align="center">T</td><td align="center">对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为：Tapply(T t1,T t2);</td></tr><tr><td align="center">BiConsumer&lt;T,U&gt;</td><td align="center">T,U</td><td align="center">void</td><td align="center">对类型为T,U参数应用操作。包含方法为：voidaccept(Tt,Uu)</td></tr><tr><td align="center">BiPredicate&lt;T,U&gt;</td><td align="center">T,U</td><td align="center">boolean</td><td align="center">包含方法为：booleantest(Tt,Uu)</td></tr><tr><td align="center">ToIntFunction</td><td align="center">T</td><td align="center">int</td><td align="center">计算int值的函数</td></tr><tr><td align="center">ToLongFunction</td><td align="center">T</td><td align="center">long</td><td align="center">计算long值的函数</td></tr><tr><td align="center">ToDoubleFunction</td><td align="center">T</td><td align="center">double</td><td align="center">计算double值的函数</td></tr><tr><td align="center">IntFunction</td><td align="center">int</td><td align="center">R</td><td align="center">参数为int类型的函数</td></tr><tr><td align="center">LongFunction</td><td align="center">long</td><td align="center">R</td><td align="center">参数为long类型的函数</td></tr><tr><td align="center">DoubleFunction</td><td align="center">double</td><td align="center">R</td><td align="center">参数为double类型的函数</td></tr></tbody></table><ul><li>消费型接口使用举例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">happyTime</span><span class="params">(<span class="type">double</span> money, Consumer&lt;Double&gt; consumer)</span> &#123;</span><br><span class="line">    consumer.accept(money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    happyTime(<span class="number">1241</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Double&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Double money)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;突然想回一趟成都了，机票花费&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Lambda表达式，将之前的6行代码压缩到了1行</span></span><br><span class="line">    happyTime(<span class="number">648</span>, money -&gt; System.out.println(<span class="string">&quot;学习太累了，奖励自己一发十连，花费&quot;</span> + money));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">突然想回一趟成都了，机票花费1241.0</span></span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="comment">学习太累了，奖励自己一发648，花费648.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>断定型接口使用举例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">filterString</span><span class="params">(List&lt;String&gt; strings, Predicate&lt;String&gt; predicate)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(string))</span><br><span class="line">            res.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;东京&quot;</span>, <span class="string">&quot;西京&quot;</span>, <span class="string">&quot;南京&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;天津&quot;</span>, <span class="string">&quot;中京&quot;</span>);</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    List&lt;String&gt; list = filterString(strings, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s.contains(<span class="string">&quot;京&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 现在的写法，相比较之前的代码优雅了许多</span></span><br><span class="line">    List&lt;String&gt; res = filterString(strings, s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[东京, 西京, 南京, 北京, 中京]</span></span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="comment">[东京, 西京, 南京, 北京, 中京]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h2><ul><li><code>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</code></li><li>方法引用可以看做会Lambda表达式的深层次表达，换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖</li><li>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</li><li>格式：使用操作符<code>::</code>将类或对象与方法名分割开来</li><li>有如下三种使用情况<ol><li>对象::实例方法名</li><li>类::静态方法名</li><li>类::实例方法名</li></ol></li></ul><h3 id="方法引用的使用情况"><a href="#方法引用的使用情况" class="headerlink" title="方法引用的使用情况"></a>方法引用的使用情况</h3><ul><li>方法引用的使用<ol><li>使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</li><li>方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也是函数式接口的实例。</li><li>使用格式： 类(或对象) :: 方法名</li><li>具体分为如下的三种情况：<ul><li>情况1：对象 :: 非静态方法</li><li>情况2：类 :: 静态方法</li><li>情况3：类 :: 非静态方法</li></ul></li><li>方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</li></ol></li><li>先写一个实体类，建议不要加额外的字段，只用这两个字段就够了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">(String name, Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>情况一：</code>对象::非静态方法，<code>抽象方法</code>的<code>形参列表</code>和<code>返回值类型</code>与<code>方法引用</code>的方法的<code>形参列表</code>和<code>返回值类型``相同</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">复制成功</span><br><span class="line"><span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line"><span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line"><span class="comment">//形参列表均为(T t)，返回值均为void，可以使用方法引用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    Consumer&lt;String&gt; consumer01 = s -&gt; System.out.println(s);</span><br><span class="line">    consumer01.accept(<span class="string">&quot;她的手只有我的手四分之三那麼大&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">printStream</span> <span class="operator">=</span> System.out;</span><br><span class="line">    Consumer&lt;String&gt; consumer02 = printStream::println;</span><br><span class="line">    consumer02.accept(<span class="string">&quot;可我還是沒能抓住&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 但貌似也可以这么写</span></span><br><span class="line">    Consumer&lt;String&gt; consumer03 = System.out::println;</span><br><span class="line">    consumer03.accept(<span class="string">&quot;花落下的时候没死 风捡起花 又丢下 花才死了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">她的手只有我的手四分之三那麼大</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">可我還是沒能抓住</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">花落下的时候没死 风捡起花 又丢下 花才死了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><code>情况二：</code>类 :: 静态方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//形参列表均为`(T t1,T t2)`，返回值均为`int`，可以使用方法引用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator01 = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line">    System.out.println(comparator01.compare(<span class="number">20</span>, <span class="number">77</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator02 = Integer::compare;</span><br><span class="line">    System.out.println(comparator02.compare(<span class="number">94</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">//Math中的Long round(Double d)</span></span><br><span class="line"><span class="comment">//返回值和参数列表为泛型，也可以匹配上，可以使用方法引用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    Function&lt;Double,Long&gt; function01 = aDouble -&gt; Math.round(aDouble);</span><br><span class="line">    System.out.println(function01.apply(<span class="number">3.141</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    Function&lt;Double,Long&gt; function02 = Math::round;</span><br><span class="line">    System.out.println(function02.apply(<span class="number">2.717</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><code>情况三：</code>类 :: 实例方法 (有难度)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator中的int comapre(T t1,T t2)</span></span><br><span class="line"><span class="comment">// String中的int t1.compareTo(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator01 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">    System.out.println(comparator01.compare(<span class="number">94</span>, <span class="number">21</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator02 = Integer::compareTo;</span><br><span class="line">    System.out.println(comparator02.compare(<span class="number">43</span>, <span class="number">96</span>));</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line"><span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    BiPredicate&lt;String,String&gt; biPredicate01 = (o1, o2) -&gt; o1.equals(o2);</span><br><span class="line">    System.out.println(biPredicate01.test(<span class="string">&quot;Kyle&quot;</span>, <span class="string">&quot;Kyle&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    BiPredicate&lt;String,String&gt; biPredicate02 = String::equals;</span><br><span class="line">    System.out.println(biPredicate02.test(<span class="string">&quot;Violet&quot;</span>, <span class="string">&quot;Violet&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">// Employee中的String toString();</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Stu</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;Kyle&quot;</span>, <span class="number">9527</span>);</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    Function&lt;Stu,String&gt; function01 = stu -&gt; stu.toString();</span><br><span class="line">    System.out.println(function01.apply(student));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    Function&lt;Stu,String&gt; function02 = Stu::toString;</span><br><span class="line">    System.out.println(function02.apply(student));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Stu&#123;name=&#x27;Kyle&#x27;, id=9527&#125;</span></span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line"><span class="comment">Stu&#123;name=&#x27;Kyle&#x27;, id=9527&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="构造器引用和数组引用的使用"><a href="#构造器引用和数组引用的使用" class="headerlink" title="构造器引用和数组引用的使用"></a>构造器引用和数组引用的使用</h3><ul><li>与函数式接口相结合，自动与函数式接口中方法兼容。</li><li>可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</li></ul><ol><li>构造器引用<ul><li>和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</li><li>抽象方法的返回值类型即为构造器所属的类的类型</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    BiFunction&lt;String, Integer, Stu&gt; function01 = (string, integer) -&gt; <span class="keyword">new</span> <span class="title class_">Stu</span>(string, integer);</span><br><span class="line">    System.out.println(function01.apply(<span class="string">&quot;Kyle&quot;</span>, <span class="number">9527</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 构造器引用</span></span><br><span class="line">    BiFunction&lt;String, Integer, Stu&gt; function02 = Stu::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(function02.apply(<span class="string">&quot;Lucy&quot;</span>, <span class="number">9421</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Stu&#123;name=&#x27;Kyle&#x27;, id=9527&#125;</span></span><br><span class="line"><span class="comment">-------------------------------</span></span><br><span class="line"><span class="comment">Stu&#123;name=&#x27;Lucy&#x27;, id=9421&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>数组引用<ul><li>可以把数组看做是一个特殊的类，则写法与构造器引用一致。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test13</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. Lambda 创建一个指定长度的string数组</span></span><br><span class="line">    Function&lt;Integer, String[]&gt; function01 = (integer -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[integer]);</span><br><span class="line">    System.out.println(Arrays.toString(function01.apply(<span class="number">5</span>)));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 数组引用</span></span><br><span class="line">    Function&lt;Integer, String[]&gt; function02 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(Arrays.toString(function02.apply(<span class="number">7</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[null, null, null, null, null]</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">[null, null, null, null, null, null, null]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="强大的Stream-API"><a href="#强大的Stream-API" class="headerlink" title="强大的Stream API"></a>强大的Stream API</h2><h3 id="Stream-API概述"><a href="#Stream-API概述" class="headerlink" title="Stream API概述"></a>Stream API概述</h3><ul><li>Java8中有两个最为重要的改变，第一个就是Lambda表达式，另外一个则是Stream API</li><li>Stream API(java.util.stream)把真正的函数式编程风格引入到Java中，这是目前为止对Java类库最好的补充，因为Stream API可以极大地提高程序员生产力，让程序员写出高效、简洁的代码</li><li>Stream是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。</li><li>使用<strong>Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询</strong>，也可以使用Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式</li><li>为什么要使用Stream API<ul><li>实际开发中，项目中多数数据源都是来自MySQL、Oracle 等。但现在数据源可以更多了，有MongDB、Redis等，而这些NoSQL的数据就需要Java层面去处理。我就是学完Redis再来补票的..</li><li>Stream 和Collection 集合的区别：<strong>Collection 是一种静态的内存数据结构</strong>，<strong>而Stream 是有关计算的</strong>。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU 实现计算（这也就是为什么一旦执行终止操作之后，Stream 就不能被再次使用，得重新创建一个新的流才行）</li></ul></li><li>小结<ol><li>Stream 关注的是对数据的运算，与CPU 打交道；<br>集合关注的是数据的存储，与内存打交道</li><li>Stream 自己不会存储数据；<br>Stream 不会改变源对象，相反，他们会返回一个持有结果的新Stream<br>Stream 操作是延迟执行的，这意味着他们会等到需要结果的时候才执行</li><li>Stream 执行流程<ul><li>Stream实例化</li><li>一系列中间操作（过滤、映射、…）</li><li>终止操作</li></ul></li><li>说明<ul><li>一系列中间操作链，对数据源的数据进行处理</li><li>一旦执行终止操作，就执行中间操作链，并产生结果，之后，不会再被使用</li></ul></li></ol></li></ul><h3 id="Stream的实例化"><a href="#Stream的实例化" class="headerlink" title="Stream的实例化"></a>Stream的实例化</h3><p>新建测试数据类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供用于测试的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeData</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Employee&gt; <span class="title function_">getEmployees</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;马化腾&quot;</span>, <span class="number">34</span>, <span class="number">6000.38</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>, <span class="string">&quot;马云&quot;</span>, <span class="number">12</span>, <span class="number">9876.12</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1003</span>, <span class="string">&quot;刘强东&quot;</span>, <span class="number">33</span>, <span class="number">3000.82</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1004</span>, <span class="string">&quot;雷军&quot;</span>, <span class="number">26</span>, <span class="number">7657.37</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1005</span>, <span class="string">&quot;李彦宏&quot;</span>, <span class="number">65</span>, <span class="number">5555.32</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1006</span>, <span class="string">&quot;比尔盖茨&quot;</span>, <span class="number">42</span>, <span class="number">9500.43</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1007</span>, <span class="string">&quot;任正非&quot;</span>, <span class="number">26</span>, <span class="number">4333.32</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1008</span>, <span class="string">&quot;扎克伯格&quot;</span>, <span class="number">35</span>, <span class="number">2500.32</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建Stream<code>方式一：</code>通过集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test14</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">//default Stream&lt;E&gt; stream()  返回一个顺序流</span></span><br><span class="line">    Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line">    <span class="comment">//default Stream&lt;E&gt; parallelStream  返回一个并行流</span></span><br><span class="line">    Stream&lt;Employee&gt; employeeStream = employees.parallelStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建Stream<code>方式二：</code>通过数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test15</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="comment">//调用Arrays的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)   返回一个流</span></span><br><span class="line">    <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Employee</span> <span class="variable">kyle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9527</span>, <span class="string">&quot;Kyle&quot;</span>);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">lucy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9421</span>, <span class="string">&quot;Lucy&quot;</span>);</span><br><span class="line">    Employee[] employees = &#123;kyle, lucy&#125;;</span><br><span class="line">    Stream&lt;Employee&gt; stream1 = Arrays.stream(employees);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建Stream<code>方式三：</code>通过Stream的of()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test16</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建Stream<code>方式四：</code>创建无限流<br>如果不用limit限制输出，则会一直输出下去，forEach就相当于是终止操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test17</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">    <span class="comment">// 遍历前10个数</span></span><br><span class="line">    <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">    Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    <span class="comment">// 10个随机数</span></span><br><span class="line">    <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">    Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h3><ul><li>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为<code>惰性求值</code></li></ul><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">filter(Predicate p)</td><td align="center">接收Lambda ，从流中排除某些元素</td></tr><tr><td align="center">distinct()</td><td align="center">筛选，通过流所生成元素的hashCode() 和equals() 去除重复元素</td></tr><tr><td align="center">limit(long maxSize)</td><td align="center">截断流，使其元素不超过给定数量</td></tr><tr><td align="center">skip(long n)</td><td align="center">跳过元素，返回一个扔掉了前n 个元素的流。若流中元素不足n 个，则返回一个空流。与limit(n)互补</td></tr></tbody></table><ul><li>现在我们来练习上表中的四个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test18</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">//1. filter 查询工资大于7000的员工信息</span></span><br><span class="line">    employees.stream().filter(employee -&gt; employee.getSalary() &gt; <span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. limit(n)——截断流，使其元素不超过给定数量。只输出3条员工信息</span></span><br><span class="line">    employees.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//3.  skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line">    employees.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//4. distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9527</span>, <span class="string">&quot;Kyle&quot;</span>, <span class="number">20</span>, <span class="number">9999</span>));</span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9527</span>, <span class="string">&quot;Kyle&quot;</span>, <span class="number">20</span>, <span class="number">9999</span>));</span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9527</span>, <span class="string">&quot;Kyle&quot;</span>, <span class="number">20</span>, <span class="number">9999</span>));</span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9527</span>, <span class="string">&quot;Kyle&quot;</span>, <span class="number">20</span>, <span class="number">9999</span>));</span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9527</span>, <span class="string">&quot;Kyle&quot;</span>, <span class="number">20</span>, <span class="number">9999</span>));</span><br><span class="line">    employees.stream().distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Employee&#123;id=1002, name=&#x27;马云&#x27;, age=12, salary=9876.12&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1004, name=&#x27;雷军&#x27;, age=26, salary=7657.37&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1006, name=&#x27;比尔盖茨&#x27;, age=42, salary=9500.43&#125;</span></span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="comment">Employee&#123;id=1001, name=&#x27;马化腾&#x27;, age=34, salary=6000.38&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1002, name=&#x27;马云&#x27;, age=12, salary=9876.12&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1003, name=&#x27;刘强东&#x27;, age=33, salary=3000.82&#125;</span></span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="comment">Employee&#123;id=1004, name=&#x27;雷军&#x27;, age=26, salary=7657.37&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1005, name=&#x27;李彦宏&#x27;, age=65, salary=5555.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1006, name=&#x27;比尔盖茨&#x27;, age=42, salary=9500.43&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1007, name=&#x27;任正非&#x27;, age=26, salary=4333.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1008, name=&#x27;扎克伯格&#x27;, age=35, salary=2500.32&#125;</span></span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="comment">Employee&#123;id=1001, name=&#x27;马化腾&#x27;, age=34, salary=6000.38&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1002, name=&#x27;马云&#x27;, age=12, salary=9876.12&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1003, name=&#x27;刘强东&#x27;, age=33, salary=3000.82&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1004, name=&#x27;雷军&#x27;, age=26, salary=7657.37&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1005, name=&#x27;李彦宏&#x27;, age=65, salary=5555.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1006, name=&#x27;比尔盖茨&#x27;, age=42, salary=9500.43&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1007, name=&#x27;任正非&#x27;, age=26, salary=4333.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1008, name=&#x27;扎克伯格&#x27;, age=35, salary=2500.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=9527, name=&#x27;Kyle&#x27;, age=20, salary=9999.0&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">map(Function f)</td><td align="center">接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td></tr><tr><td align="center">mapToDouble(ToDoubleFunction f)</td><td align="center">接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。</td></tr><tr><td align="center">mapToInt(ToIntFunction f)</td><td align="center">接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。</td></tr><tr><td align="center">mapToLong(ToLongFunction f)</td><td align="center">接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。</td></tr><tr><td align="center">flatMap(Function f)</td><td align="center">接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table><ul><li>测试Stream中间操作：映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test19</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">//map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class="line">    <span class="comment">// 练习：将字符串转为大写并输出</span></span><br><span class="line">    strings.stream().map(s -&gt; s.toUpperCase()).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">// 练习：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class="line">    <span class="comment">// 获取name流</span></span><br><span class="line">    employees.stream().map(Employee::getName).</span><br><span class="line">            <span class="comment">// 过滤出name长度 &gt; 3的</span></span><br><span class="line">                    filter(name -&gt; name.length() &gt; <span class="number">3</span>).</span><br><span class="line">            <span class="comment">// 遍历输出</span></span><br><span class="line">                    forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">// 练习：将字符串中的多个字符构成的集合转换为对应的Stream实例</span></span><br><span class="line">    strings.stream().map(LambdaTest::formStringToStream).</span><br><span class="line">            forEach(characterStream -&gt;</span><br><span class="line">            characterStream.forEach(System.out::println));</span><br><span class="line">    <span class="comment">// 使用flatMap(Function f)达到同样的效果</span></span><br><span class="line">    <span class="comment">// flatmap将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    strings.stream().flatMap(LambdaTest::formStringToStream).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">formStringToStream</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    ArrayList&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">AA</span></span><br><span class="line"><span class="comment">BB</span></span><br><span class="line"><span class="comment">CC</span></span><br><span class="line"><span class="comment">DD</span></span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"><span class="comment">比尔盖茨</span></span><br><span class="line"><span class="comment">扎克伯格</span></span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">d</span></span><br><span class="line"><span class="comment">d</span></span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">d</span></span><br><span class="line"><span class="comment">d</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">sorted()</td><td align="center">产生一个新流，其中按自然顺序排序</td></tr><tr><td align="center">sorted(Comparator com)</td><td align="center">产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><ul><li>测试方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test20</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; nums = Arrays.asList(<span class="number">13</span>, <span class="number">54</span>, <span class="number">97</span>, <span class="number">52</span>, <span class="number">43</span>, <span class="number">64</span>, <span class="number">27</span>);</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">//自然排序</span></span><br><span class="line">    nums.stream().sorted().forEach(System.out::println);</span><br><span class="line">    <span class="comment">//定制排序，先按照年龄升序排，再按照工资降序排</span></span><br><span class="line">    employees.stream().sorted((o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> Integer.compare(o1.getAge(), o2.getAge());</span><br><span class="line">        <span class="keyword">if</span> (compare != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> compare;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -Double.compare(o1.getSalary(), o2.getSalary());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">27</span></span><br><span class="line"><span class="comment">43</span></span><br><span class="line"><span class="comment">52</span></span><br><span class="line"><span class="comment">54</span></span><br><span class="line"><span class="comment">64</span></span><br><span class="line"><span class="comment">97</span></span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line"><span class="comment">Employee&#123;id=1002, name=&#x27;马云&#x27;, age=12, salary=9876.12&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1004, name=&#x27;雷军&#x27;, age=26, salary=7657.37&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1007, name=&#x27;任正非&#x27;, age=26, salary=4333.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1003, name=&#x27;刘强东&#x27;, age=33, salary=3000.82&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1001, name=&#x27;马化腾&#x27;, age=34, salary=6000.38&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1008, name=&#x27;扎克伯格&#x27;, age=35, salary=2500.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1006, name=&#x27;比尔盖茨&#x27;, age=42, salary=9500.43&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1005, name=&#x27;李彦宏&#x27;, age=65, salary=5555.32&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a>匹配与查找</h3><ul><li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void 。</li><li>流进行了终止操作后，不能再次使用。</li></ul><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">allMatch(Predicate p)</td><td align="center">检查是否匹配所有元素</td></tr><tr><td align="center">anyMatch(Predicate p)</td><td align="center">检查是否至少匹配一个元素</td></tr><tr><td align="center">noneMatch(Predicate p)</td><td align="center">检查是否没有匹配所有元素</td></tr><tr><td align="center">findFirst()</td><td align="center">返回第一个元素</td></tr><tr><td align="center">findAny()</td><td align="center">返回当前流中的任意元素</td></tr><tr><td align="center">count()</td><td align="center">返回流中元素总数</td></tr><tr><td align="center">max(Comparator c)</td><td align="center">返回流中最大值</td></tr><tr><td align="center">min(Comparator c)</td><td align="center">返回流中最小值</td></tr><tr><td align="center">forEach(Consumer c)</td><td align="center">内部迭代(使用Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)</td></tr></tbody></table><ul><li>测试方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test21</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">// allMatch(Predicate p)——检查是否匹配所有元素。</span></span><br><span class="line">    <span class="comment">// 练习：是否所有的员工的工资是否都大于5000</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是否所有的员工的工资是否都大于5000：&quot;</span>+employees.stream().allMatch(employee -&gt; employee.getSalary() &gt; <span class="number">5000</span>));</span><br><span class="line">    <span class="comment">// anyMatch(Predicate p)——检查是否至少匹配一个元素。</span></span><br><span class="line">    <span class="comment">// 练习：是否存在员工年龄小于15</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是否存在员工年龄小于15：&quot;</span>+employees.stream().anyMatch(employee -&gt; employee.getAge() &lt; <span class="number">15</span>));</span><br><span class="line">    <span class="comment">// noneMatch(Predicate p)——检查是否没有匹配的元素。</span></span><br><span class="line">    <span class="comment">// 练习：是否不存在员工姓“马”</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是否不存在员工姓马：&quot;</span>+employees.stream().noneMatch(employee -&gt; employee.getName().startsWith(<span class="string">&quot;马&quot;</span>)));</span><br><span class="line">    <span class="comment">//findFirst——返回第一个元素</span></span><br><span class="line">    System.out.println(<span class="string">&quot;返回第一个元素：&quot;</span>+employees.stream().findFirst());</span><br><span class="line">    <span class="comment">//findAny——返回当前流中的任意元素</span></span><br><span class="line">    System.out.println(<span class="string">&quot;返回当前流中的任意元素&quot;</span>+employees.stream().findAny());</span><br><span class="line">    <span class="comment">//count——返回流中元素的总个数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;返回元素总数：&quot;</span>+employees.stream().count());</span><br><span class="line">    <span class="comment">//max(Comparator c)——返回流中最大值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;返回最高工资：&quot;</span>+employees.stream().map(Employee::getSalary).max(Double::compare));</span><br><span class="line">    <span class="comment">//min(Comparator c)——返回流中最小值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;返回最小年龄：&quot;</span>+employees.stream().map(Employee::getAge).min(Integer::compare));</span><br><span class="line">    <span class="comment">//forEach(Consumer c)——内部迭代</span></span><br><span class="line">    employees.stream().forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">    <span class="comment">////使用集合的遍历操作</span></span><br><span class="line">    employees.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">是否所有的员工的工资是否都大于5000：false</span></span><br><span class="line"><span class="comment">是否存在员工年龄小于15：true</span></span><br><span class="line"><span class="comment">是否不存在员工姓马：false</span></span><br><span class="line"><span class="comment">返回第一个元素：Optional[Employee&#123;id=1001, name=&#x27;马化腾&#x27;, age=34, salary=6000.38&#125;]</span></span><br><span class="line"><span class="comment">返回当前流中的任意元素Optional[Employee&#123;id=1001, name=&#x27;马化腾&#x27;, age=34, salary=6000.38&#125;]</span></span><br><span class="line"><span class="comment">返回元素总数：8</span></span><br><span class="line"><span class="comment">返回最高工资：Optional[9876.12]</span></span><br><span class="line"><span class="comment">返回最小年龄：Optional[12]</span></span><br><span class="line"><span class="comment">Employee&#123;id=1001, name=&#x27;马化腾&#x27;, age=34, salary=6000.38&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1002, name=&#x27;马云&#x27;, age=12, salary=9876.12&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1003, name=&#x27;刘强东&#x27;, age=33, salary=3000.82&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1004, name=&#x27;雷军&#x27;, age=26, salary=7657.37&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1005, name=&#x27;李彦宏&#x27;, age=65, salary=5555.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1006, name=&#x27;比尔盖茨&#x27;, age=42, salary=9500.43&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1007, name=&#x27;任正非&#x27;, age=26, salary=4333.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1008, name=&#x27;扎克伯格&#x27;, age=35, salary=2500.32&#125;</span></span><br><span class="line"><span class="comment">-------------</span></span><br><span class="line"><span class="comment">Employee&#123;id=1001, name=&#x27;马化腾&#x27;, age=34, salary=6000.38&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1002, name=&#x27;马云&#x27;, age=12, salary=9876.12&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1003, name=&#x27;刘强东&#x27;, age=33, salary=3000.82&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1004, name=&#x27;雷军&#x27;, age=26, salary=7657.37&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1005, name=&#x27;李彦宏&#x27;, age=65, salary=5555.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1006, name=&#x27;比尔盖茨&#x27;, age=42, salary=9500.43&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1007, name=&#x27;任正非&#x27;, age=26, salary=4333.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1008, name=&#x27;扎克伯格&#x27;, age=35, salary=2500.32&#125;</span></span><br><span class="line"><span class="comment">*/</span>    </span><br></pre></td></tr></table></figure><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">reduce(T iden, BinaryOperator b)</td><td align="center">可以将流中元素反复结合起来，得到一个值。返回T</td></tr><tr><td align="center">reduce(BinaryOperator b)</td><td align="center">可以将流中元素反复结合起来，得到一个值。返回Optional</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test22</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; nums = Arrays.asList(<span class="number">13</span>, <span class="number">32</span>, <span class="number">23</span>, <span class="number">31</span>, <span class="number">94</span>, <span class="number">20</span>, <span class="number">77</span>, <span class="number">21</span>, <span class="number">17</span>);</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">// reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class="line">    <span class="comment">// 练习1：计算1-10的自然数的和</span></span><br><span class="line">    System.out.println(nums.stream().reduce(<span class="number">0</span>, Integer::sum));</span><br><span class="line">    <span class="comment">//reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class="line">    <span class="comment">// 练习2：计算公司所有员工工资总和</span></span><br><span class="line">    System.out.println(employees.stream().map(Employee::getSalary).reduce((o1, o2) -&gt; o1 + o2));</span><br><span class="line">    <span class="comment">// 别的写法，计算年龄总和</span></span><br><span class="line">    System.out.println(employees.stream().map(Employee::getAge).reduce(Integer::sum));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">328</span></span><br><span class="line"><span class="comment">Optional[48424.08]</span></span><br><span class="line"><span class="comment">Optional[273]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">collect(Collector c)</td><td align="center">将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test23</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line">    <span class="comment">// 练习1：查找工资大于6000的员工，结果返回为一个List</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    List&lt;Employee&gt; list = employees.stream().filter(employee -&gt; employee.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">    <span class="comment">// 练习2：查找年龄大于20的员工，结果返回为一个List</span></span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9527</span>,<span class="string">&quot;Kyle&quot;</span>,<span class="number">21</span>,<span class="number">9999</span>));</span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9527</span>,<span class="string">&quot;Kyle&quot;</span>,<span class="number">21</span>,<span class="number">9999</span>));</span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9527</span>,<span class="string">&quot;Kyle&quot;</span>,<span class="number">21</span>,<span class="number">9999</span>));</span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">9527</span>,<span class="string">&quot;Kyle&quot;</span>,<span class="number">21</span>,<span class="number">9999</span>));</span><br><span class="line">    Set&lt;Employee&gt; set = employees.stream().filter(employee -&gt; employee.getAge() &gt; <span class="number">20</span>).collect(Collectors.toSet());</span><br><span class="line">    set.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Employee&#123;id=1001, name=&#x27;马化腾&#x27;, age=34, salary=6000.38&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1002, name=&#x27;马云&#x27;, age=12, salary=9876.12&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1004, name=&#x27;雷军&#x27;, age=26, salary=7657.37&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1006, name=&#x27;比尔盖茨&#x27;, age=42, salary=9500.43&#125;</span></span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"><span class="comment">Employee&#123;id=1001, name=&#x27;马化腾&#x27;, age=34, salary=6000.38&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1007, name=&#x27;任正非&#x27;, age=26, salary=4333.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1008, name=&#x27;扎克伯格&#x27;, age=35, salary=2500.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1006, name=&#x27;比尔盖茨&#x27;, age=42, salary=9500.43&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1005, name=&#x27;李彦宏&#x27;, age=65, salary=5555.32&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1003, name=&#x27;刘强东&#x27;, age=33, salary=3000.82&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=9527, name=&#x27;Kyle&#x27;, age=21, salary=9999.0&#125;</span></span><br><span class="line"><span class="comment">Employee&#123;id=1004, name=&#x27;雷军&#x27;, age=26, salary=7657.37&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。</li><li>Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240507162038425.png" alt="image-20240507162038425"></p><table><thead><tr><th>方法</th><th>返回类型</th><th>作用</th></tr></thead><tbody><tr><td>toList</td><td>List<T></T></td><td>把流中元素收集到List</td></tr><tr><td>List<Employee> emps&#x3D; list.stream().collect(Collectors.toList());</Employee></td><td></td><td></td></tr><tr><td>toSet</td><td>List<T></T></td><td>把流中元素收集到List</td></tr><tr><td>Set<Employee> emps&#x3D; list.stream().collect(Collectors.toSet());</Employee></td><td></td><td></td></tr><tr><td>toCollection</td><td>Collection<T></T></td><td>把流中元素收集到创建的集合</td></tr><tr><td>Collection<Employee> emps &#x3D;list.stream().collect(Collectors.toCollection(ArrayList::new));</Employee></td><td></td><td></td></tr><tr><td>counting</td><td>Long</td><td>计算流中元素的个数</td></tr><tr><td>long count &#x3D; list.stream().collect(Collectors.counting());</td><td></td><td></td></tr><tr><td>summinglnt</td><td>Integer</td><td>对流中元素的整数属性求和</td></tr><tr><td>int total&#x3D;list.stream().collect(Collectors.summingInt(Employee::getSalary));</td><td></td><td></td></tr><tr><td>averagingInt</td><td>Double</td><td>计算流中元素Integer属性的平均值</td></tr><tr><td>double avg &#x3D; list.stream().collect(Collectors.averagingInt(Employee::getSalary));</td><td></td><td></td></tr><tr><td>summarizinglnt</td><td>IntSummaryStatistics</td><td>收集流中Integer属性的统计值。如:平均值</td></tr><tr><td>int SummaryStatisticsiss&#x3D;list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</td><td></td><td></td></tr><tr><td>joining</td><td>String</td><td>连接流中每个字符串</td></tr><tr><td>String str&#x3D; list.stream().map(Employee::getName).collect(Collectors.joining());</td><td></td><td></td></tr><tr><td>maxBy</td><td>Optional<T></T></td><td>根据比较器选择最大值</td></tr><tr><td>optional<Emp>max&#x3D;list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary));</Emp></td><td></td><td></td></tr><tr><td>minBy</td><td>Optional<T></T></td><td>根据比较器选择最小值</td></tr><tr><td>Optional<Emp>min &#x3D; list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary));</Emp></td><td></td><td></td></tr><tr><td>reducing</td><td>归约产生的类型</td><td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td></tr><tr><td>int total&#x3D;list.stream().collect(Collectors.reducing(0, Employe::getSalar, Integer::sum));</td><td></td><td></td></tr><tr><td>collectingAndThen</td><td>转换函数返回的类型</td><td>包裹另一个收集器，对其结果转换函数</td></tr><tr><td>int how&#x3D; list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</td><td></td><td></td></tr><tr><td>groupingBy</td><td>Map&lt;K, List<T>&gt;</T></td><td>根据某属性值对流分组，属性为K,结果为V</td></tr><tr><td>Map&lt;Emp.Status, List<Emp>&gt;map&#x3D; list.stream().collect(Collectors.groupingBy(Employee::getStatus));</Emp></td><td></td><td></td></tr><tr><td>partitioningBy</td><td>Map&lt;Boolean,List<T>&gt;</T></td><td>根据true或false进行分区</td></tr><tr><td>Map&lt;Boolean,List<Emp>&gt;vd&#x3D;list.stream().collect(Collectors.partitioningBy(Employee::getManage));</Emp></td><td></td><td></td></tr></tbody></table><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p></li><li><p>Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null 表示一个值不存在，现在Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p></li><li><p>Optional类的Javadoc描述如下：<strong>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</strong></p></li><li><p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p></li><li><p>创建Optional类对象的方法：</p><ul><li>Optional.of(T t): 创建一个Optional 实例，t必须非空；</li><li>Optional.empty() : 创建一个空的Optional 实例</li><li>Optional.ofNullable(T t)：t可以为null</li></ul></li><li><p>判断Optional容器中是否包含对象：</p><ul><li>boolean isPresent() : 判断是否包含对象</li><li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</li></ul></li><li><p>获取Optional容器的对象：</p><ul><li>T get(): 如果调用对象包含值，返回该值，否则抛异常</li><li>T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。</li><li>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</li><li>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</li></ul></li><li><p>Boy类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Girl girl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(Girl girl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.girl = girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Girl <span class="title function_">getGirl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGirl</span><span class="params">(Girl girl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.girl = girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Boy&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;girl=&quot;</span> + girl +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Girl类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Girl&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类<ul><li>Optional类：为了在程序中避免出现空指针异常而创建的。</li><li>常用的方法<ul><li>ofNullable(T t)</li><li>orElse(T t)</li><li>Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</li><li>Optional.empty() : 创建一个空的 Optional 实例</li><li>Optional.ofNullable(T t)：t可以为null</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">    <span class="comment">// girl = null;</span></span><br><span class="line">    <span class="comment">// of(T t):保证t是非空的</span></span><br><span class="line">    Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test25</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">    <span class="comment">// girl = null;</span></span><br><span class="line">    <span class="comment">// ofNullable(T t)：t可以为null</span></span><br><span class="line">    Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class="line">    System.out.println(optionalGirl);</span><br><span class="line">    <span class="comment">// orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.</span></span><br><span class="line">    <span class="comment">// 如果内部的t是空的，则返回orElse()方法中的参数t1.</span></span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl1</span> <span class="operator">=</span> optionalGirl.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    System.out.println(girl1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><ul><li>测试方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test26</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">    boy = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">girlName</span> <span class="operator">=</span> getGirlName(boy);</span><br><span class="line">    System.out.println(girlName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getGirlName</span><span class="params">(Boy boy)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> boy.getGirl().getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化以后的getGirlName():</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getGirlName1</span><span class="params">(Boy boy)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(boy != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> boy.getGirl();</span><br><span class="line">        <span class="keyword">if</span>(girl != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> girl.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test27</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">    boy = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">girlName</span> <span class="operator">=</span> getGirlName1(boy);</span><br><span class="line">    System.out.println(girlName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Optional类的getGirlName():</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getGirlName2</span><span class="params">(Boy boy)</span>&#123;</span><br><span class="line"></span><br><span class="line">    Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">    <span class="comment">//此时的boy1一定非空</span></span><br><span class="line">    <span class="type">Boy</span> <span class="variable">boy1</span> <span class="operator">=</span> boyOptional.orElse(<span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;樱岛麻衣&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> boy1.getGirl();</span><br><span class="line"></span><br><span class="line">    Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">    <span class="comment">//girl1一定非空</span></span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl1</span> <span class="operator">=</span> girlOptional.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;喜多川海梦&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> girl1.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test28</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    boy = <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">    boy = <span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;Lucy&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">girlName</span> <span class="operator">=</span> getGirlName2(boy);</span><br><span class="line">    System.out.println(girlName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Optional其实用的并不多，我们稍作了解即可，部分底层源码可能会用到Optional</li></ul><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>在Redis中学到的一些使用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        List&lt;User&gt; users = userService.listByIds(ids);</span><br><span class="line">        List&lt;UserDTO&gt; userDTOS = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(User u : users)&#123;</span><br><span class="line">            <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(u, UserDTO.class);</span><br><span class="line">            userDTOS.add(userDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stream流，将List&lt;User&gt; users 复制转为 List&lt;UserDTO&gt; userDTOS</span></span><br><span class="line"><span class="comment">//        List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids)</span></span><br><span class="line"><span class="comment">//                .stream()</span></span><br><span class="line"><span class="comment">//                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span></span><br><span class="line"><span class="comment">//                .collect(Collectors.toList());</span></span><br></pre></td></tr></table></figure><p>用map做一个映射，括号中写出映射规则</p><p>collect接受汇总，为List集合再返回</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Java8新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周杰伦演唱会</title>
      <link href="/2024/04/24/life/zhoujielun/"/>
      <url>/2024/04/24/life/zhoujielun/</url>
      
        <content type="html"><![CDATA[<h1 id="周杰伦杭州演唱会2024-4-21场"><a href="#周杰伦杭州演唱会2024-4-21场" class="headerlink" title="周杰伦杭州演唱会2024.4.21场"></a>周杰伦杭州演唱会2024.4.21场</h1><p>08年春晚周董的一句<br>“天青色等烟雨，而我在等你~”</p><p>我开始听他的歌，终于去现场啦！<br>“童年的纸飞机，现在终于飞到我手里~”</p><p>呜呜呜没时间写小作文啦，把我三小时录的视频端上来吧</p><div align="center" class="aspect-ratio">    <iframe src="https://player.bilibili.com/player.html?bvid=BV1Ur421G72H&&page=1&as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true">     </iframe></div>https://www.bilibili.com/video/BV1Ur421G72H<div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/9295121db616285218c9f351b5ea4fbb.webp","alt":"9295121db616285218c9f351b5ea4fbb"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/cbcda8d2b9b33c2c4c63b23ec74e7f13.webp","alt":"cbcda8d2b9b33c2c4c63b23ec74e7f13"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/9fc68b12d2addc75318051aed1e8e9b6.webp","alt":"9fc68b12d2addc75318051aed1e8e9b6"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/%7B8160A6DE-9493-4247-966A-6E9C04D02344%7D.webp","alt":"{8160A6DE-9493-4247-966A-6E9C04D02344}"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/%7B1AB0607B-99F4-42ad-9842-7AA4AE904E90%7D.webp","alt":"{1AB0607B-99F4-42ad-9842-7AA4AE904E90}"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/1d05ae0ce8c241470359b5ab9547fdc8.webp","alt":"1d05ae0ce8c241470359b5ab9547fdc8"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/1f027125663fca8418b2703d23935c59.webp","alt":"1f027125663fca8418b2703d23935c59"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/58845c61cd6b99746508592ce2613dd2.webp","alt":"58845c61cd6b99746508592ce2613dd2"}]</div>      <div class="gallery-items">      </div>    </div><div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/4b31835f26c308a8696762bf829d41f8.webp","alt":"4b31835f26c308a8696762bf829d41f8"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/027971751a26c064dc4b60c2d5d4f68f.webp","alt":"027971751a26c064dc4b60c2d5d4f68f"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/c8f25372f0c3cc4852d1b1100f818fc7.webp","alt":"c8f25372f0c3cc4852d1b1100f818fc7"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/c254be30fdacdb6dcfcef8bbcfd56fac.webp","alt":"c254be30fdacdb6dcfcef8bbcfd56fac"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/c493ef7e83049f0640c51635f7d46588.webp","alt":"c493ef7e83049f0640c51635f7d46588"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/c258880c0681889566e0861f77c38bff.webp","alt":"c258880c0681889566e0861f77c38bff"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/cbcda8d2b9b33c2c4c63b23ec74e7f13.webp","alt":"cbcda8d2b9b33c2c4c63b23ec74e7f13"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/d949ba717a180acff5ef50cd9ebe8180.webp","alt":"d949ba717a180acff5ef50cd9ebe8180"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/e21447fefcceae1035060c316499196e.webp","alt":"e21447fefcceae1035060c316499196e"}]</div>      <div class="gallery-items">      </div>    </div><div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/f374d5804968677a5cb81b39b224e4e9.webp","alt":"f374d5804968677a5cb81b39b224e4e9"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/fe02e7ea94dc93254c5b93e0c04cde2c.webp","alt":"fe02e7ea94dc93254c5b93e0c04cde2c"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/24c8cc6e07afb6930c9327eaa7347ddd.webp","alt":"24c8cc6e07afb6930c9327eaa7347ddd"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/34a1ebfc7e5d11d5508b3efd7b03c6dc.webp","alt":"34a1ebfc7e5d11d5508b3efd7b03c6dc"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/73e23d9ad7c16b7f89c9b27bfb61f804.webp","alt":"73e23d9ad7c16b7f89c9b27bfb61f804"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/309b0b1ca294310f55053c4bd53d33d6.webp","alt":"309b0b1ca294310f55053c4bd53d33d6"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/630acaf59926b904670669a923db02e6.webp","alt":"630acaf59926b904670669a923db02e6"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/671c5867877d4d7b6ab333e3f0bf9536.webp","alt":"671c5867877d4d7b6ab333e3f0bf9536"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/756addf9e72d5344a2f56ae92718074e.webp","alt":"756addf9e72d5344a2f56ae92718074e"}]</div>      <div class="gallery-items">      </div>    </div><div class="gallery-container" data-type="data" data-button>      <div class="gallery-data">[{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/770e4ca2b952ce91f079450c12ed1b12.webp","alt":"770e4ca2b952ce91f079450c12ed1b12"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/991d7212dd4ef3dc7f7d40679b83aab4.webp","alt":"991d7212dd4ef3dc7f7d40679b83aab4"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/8485b7b650e08c75008b7c9056b40769.webp","alt":"8485b7b650e08c75008b7c9056b40769"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/58845c61cd6b99746508592ce2613dd2.webp","alt":"58845c61cd6b99746508592ce2613dd2"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/849431b46e4aecdb1f4c99cc6bb856f7.webp","alt":"849431b46e4aecdb1f4c99cc6bb856f7"},{"url":"https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/9295121db616285218c9f351b5ea4fbb.webp","alt":"9295121db616285218c9f351b5ea4fbb"}]</div>      <div class="gallery-items">      </div>    </div><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/9295121db616285218c9f351b5ea4fbb.webp" alt="9295121db616285218c9f351b5ea4fbb"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/cbcda8d2b9b33c2c4c63b23ec74e7f13.webp" alt="cbcda8d2b9b33c2c4c63b23ec74e7f13"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/9fc68b12d2addc75318051aed1e8e9b6.webp" alt="9fc68b12d2addc75318051aed1e8e9b6"></p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/1a55de58c120c02f5294c6d8f447ae5a.webp" alt="1a55de58c120c02f5294c6d8f447ae5a" style="zoom:50%;"><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/%7B8160A6DE-9493-4247-966A-6E9C04D02344%7D.webp" alt="{8160A6DE-9493-4247-966A-6E9C04D02344}"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/%7B1AB0607B-99F4-42ad-9842-7AA4AE904E90%7D.webp" alt="{1AB0607B-99F4-42ad-9842-7AA4AE904E90}"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/1d05ae0ce8c241470359b5ab9547fdc8.webp" alt="1d05ae0ce8c241470359b5ab9547fdc8"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/1f027125663fca8418b2703d23935c59.webp" alt="1f027125663fca8418b2703d23935c59"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/58845c61cd6b99746508592ce2613dd2.webp" alt="58845c61cd6b99746508592ce2613dd2"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/4b31835f26c308a8696762bf829d41f8.webp" alt="4b31835f26c308a8696762bf829d41f8"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/027971751a26c064dc4b60c2d5d4f68f.webp" alt="027971751a26c064dc4b60c2d5d4f68f"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/c8f25372f0c3cc4852d1b1100f818fc7.webp" alt="c8f25372f0c3cc4852d1b1100f818fc7"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/c254be30fdacdb6dcfcef8bbcfd56fac.webp" alt="c254be30fdacdb6dcfcef8bbcfd56fac"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/c493ef7e83049f0640c51635f7d46588.webp" alt="c493ef7e83049f0640c51635f7d46588"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/c258880c0681889566e0861f77c38bff.webp" alt="c258880c0681889566e0861f77c38bff"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/cbcda8d2b9b33c2c4c63b23ec74e7f13.webp" alt="cbcda8d2b9b33c2c4c63b23ec74e7f13"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/d949ba717a180acff5ef50cd9ebe8180.webp" alt="d949ba717a180acff5ef50cd9ebe8180"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/e21447fefcceae1035060c316499196e.webp" alt="e21447fefcceae1035060c316499196e"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/f374d5804968677a5cb81b39b224e4e9.webp" alt="f374d5804968677a5cb81b39b224e4e9"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/fe02e7ea94dc93254c5b93e0c04cde2c.webp" alt="fe02e7ea94dc93254c5b93e0c04cde2c"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/24c8cc6e07afb6930c9327eaa7347ddd.webp" alt="24c8cc6e07afb6930c9327eaa7347ddd"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/34a1ebfc7e5d11d5508b3efd7b03c6dc.webp" alt="34a1ebfc7e5d11d5508b3efd7b03c6dc"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/73e23d9ad7c16b7f89c9b27bfb61f804.webp" alt="73e23d9ad7c16b7f89c9b27bfb61f804"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/309b0b1ca294310f55053c4bd53d33d6.webp" alt="309b0b1ca294310f55053c4bd53d33d6"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/630acaf59926b904670669a923db02e6.webp" alt="630acaf59926b904670669a923db02e6"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/671c5867877d4d7b6ab333e3f0bf9536.webp" alt="671c5867877d4d7b6ab333e3f0bf9536"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/756addf9e72d5344a2f56ae92718074e.webp" alt="756addf9e72d5344a2f56ae92718074e"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/770e4ca2b952ce91f079450c12ed1b12.webp" alt="770e4ca2b952ce91f079450c12ed1b12"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/991d7212dd4ef3dc7f7d40679b83aab4.webp" alt="991d7212dd4ef3dc7f7d40679b83aab4"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/8485b7b650e08c75008b7c9056b40769.webp" alt="8485b7b650e08c75008b7c9056b40769"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/58845c61cd6b99746508592ce2613dd2.webp" alt="58845c61cd6b99746508592ce2613dd2"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/849431b46e4aecdb1f4c99cc6bb856f7.webp" alt="849431b46e4aecdb1f4c99cc6bb856f7"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/zhoujielun/9295121db616285218c9f351b5ea4fbb.webp" alt="9295121db616285218c9f351b5ea4fbb"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
            <tag> 周杰伦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试总结</title>
      <link href="/2024/04/20/Interviews/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/04/20/Interviews/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h1><p> STAR 法则。对于面试，你可以将这个法则用在自己的简历以及和面试官沟通交流的过程中。</p><p>STAR 法则由下面 4 个单词组成（STAR 法则的名字就是由它们的首字母组成）：</p><ul><li><strong>Situation：</strong> 情景。 事情是在什么情况下发生的？</li><li><strong>Task：</strong> 任务。你的任务是什么？</li><li><strong>Action：</strong> 行动。你做了什么？</li><li><strong>Result：</strong> 结果。最终的结果怎样？</li></ul><h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">面试官您好，我叫方圆，目前是杭州电子科技大学通信工程专业研二的学生，</span><br><span class="line">本科也是杭电通信工程，在学校的学习期间呢，对通信和计算机的相关专业课程都有所涉及，</span><br><span class="line">熟悉Java语言，对spring boot进行web开发有一定的实践。</span><br><span class="line"></span><br><span class="line">读研期间呢，参与了老师的一个横向课题，参与了数梦工厂消息中心项目，</span><br><span class="line">负责开发其中的一个模块，我主要负责的是平台侧消息模板的创建和管理，</span><br><span class="line">还有用户侧消息的管理，包括搜索，查看，标记已读删除等，消息推送等</span><br><span class="line"></span><br><span class="line">后来项目结束后，为了丰富自己web开发的相关知识，去学习了Redis缓存的相关知识，</span><br><span class="line">开发了一个类似大众点评的单体web应用，</span><br><span class="line">并且在结束后用Docker部署在自己的虚拟机中，用nginx做了负载均衡的配置</span><br><span class="line"></span><br><span class="line">同时呢，我也习惯于整理和分享自己的所学知识，为此我基于hexo 搭建了自己的网站，</span><br><span class="line">主要分享技术学习经历，还有一些日常和遇到的bug问题。</span><br><span class="line">目前记录字数已经超过20W字</span><br><span class="line"></span><br><span class="line">因为直接在学习的过程中用到过的云业务比较多，</span><br><span class="line">比如，域名服务，对象存储服务，还有短信服务，当然云端的业务还有很多，</span><br><span class="line">还有我上届的师兄师姐也在华为云部门，我认为以后大家的使用的云端都很多，</span><br><span class="line">会有很大的发展空间，期待能获得这次实习的机会。</span><br></pre></td></tr></table></figure><p>为什么学通信的，却转转码开发？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先呢，我高考报专业第一志愿就是计算机，但是差了一两分没去成</span><br><span class="line">1.职业兴趣问题</span><br><span class="line">在通信专业就读时候，发现自己对软件开发等互联网技术有着兴趣，</span><br><span class="line">2.职业发展空间</span><br><span class="line">而且计算机相较于传统通信有着较大的职业发展空间</span><br><span class="line">3.技能转换的自然性质</span><br><span class="line">通信也离不开计算机，同样也学习过很多相同的和专业课，在学习的过程中不会有什么阻碍</span><br></pre></td></tr></table></figure><h1 id="DTphere消息中心"><a href="#DTphere消息中心" class="headerlink" title="DTphere消息中心"></a>DTphere消息中心</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">这个消息中心的项目，分为平台侧（管理的人去看的）和用户侧（用户去看的）</span><br><span class="line">在平台侧呢</span><br><span class="line">消息的管理</span><br><span class="line"></span><br><span class="line">模版管理</span><br><span class="line"> --对不同的渠道，钉钉，微信，短信，邮件设计不同的消息模版</span><br><span class="line"> --设计实体关系图，一张表维护不同的消息模版Id</span><br><span class="line"> --每个Id作为外键关联一张模板表</span><br><span class="line"> </span><br><span class="line">渠道管理</span><br><span class="line"> --渠道管理负责去配置各个渠道的信息，短信，邮件，企业微信，钉钉机器人等</span><br><span class="line"> --引入钉钉，微信等相关依赖，配置用户名密码服务器去做测试链接</span><br><span class="line">用户侧：</span><br><span class="line">全部类型消息的查看</span><br><span class="line">--搜索，查看，批量标记已读未读，删除消息，全部已读等</span><br><span class="line">告警消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line">系统消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line">审批消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line">产品消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line"></span><br><span class="line">对需要删除的消息：用AOP日志记录</span><br><span class="line">使用yapi.pro那个平台编写接口文档，做接口文档的开发</span><br></pre></td></tr></table></figure><p>这个消息中心的项目，分为平台侧（管理的人去看的）和用户侧（用户去看的）</p><h2 id="平台侧"><a href="#平台侧" class="headerlink" title="平台侧"></a>平台侧</h2><ul><li>消息的管理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--绑定管理，将产品与消息模板绑定，当前产品对应的消息模板</span><br><span class="line">--这里是新建一张绑定关系表，将产品Id和模板Id对应起来</span><br><span class="line">查询模版、查询产品消息、绑定、回显</span><br></pre></td></tr></table></figure><ul><li>模版管理</li></ul><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240513091758796.png" alt="image-20240513091758796" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> --对不同的渠道，钉钉，微信，短信，邮件设计不同的消息模版</span><br><span class="line"> --设计实体关系图，一张表维护不同的消息模版Id，</span><br><span class="line"> --每个Id作为外键关联一张模板表</span><br><span class="line"> --我在开始数据库中创建了五张模板表，分别对应五种消息</span><br><span class="line"> --（后来就是五张表维护起来太麻烦了，每次增删改查还要在不同表里</span><br><span class="line">  还要创建一个模版表去记录创建好的所有Id）</span><br><span class="line"> --优化就是：因为模版表有很多相同的字段，创建一张表整合所有字段，</span><br><span class="line"> 没有设置的字段，就默认为null</span><br><span class="line"> 然后再新建五个vo类作为返回给前端的消息实体类，去封装对应模版的信息</span><br><span class="line"> </span><br><span class="line"> 不同的消息模板有不同的字段，我根据它们提供的图去在数据库中创建模板</span><br><span class="line"> 这里是参照了它们官方提供的开发手册</span><br><span class="line"> 定义字段的时候，选择合适的字段内容来建标</span><br><span class="line">字符串就结合存储的内容来使用char  或者varchar</span><br><span class="line">用户名称邮箱类型的可变，使用varchar</span><br><span class="line">文章内容使用text</span><br><span class="line">邮编长度使用char等等</span><br><span class="line">模版类型这里，因为只有几个嘛，开始用的int，后来该改的tinyint</span><br><span class="line"></span><br><span class="line">优化这里</span><br><span class="line">1.分页和摘要</span><br><span class="line">因为text字段过大，表里只存放指针，MySQL还需要二次查询</span><br><span class="line">会影响查询性能，所以我们做了一个分表</span><br><span class="line">将text列分离到单独的扩展表中，用ID字段做一个关联</span><br><span class="line">然后，创建一个varchar（255）字段，来记录text的前255个字符作为摘要</span><br><span class="line">这样在分页查询的时候，文章内容我们就只需要查询这个varchar字段就行</span><br><span class="line">点进去具体查询的时候，就需要关联text表查询text字段了</span><br><span class="line"></span><br><span class="line">2.联合索引</span><br><span class="line">因为我们每次查询的未读消息的SQL语句，的where条件是</span><br><span class="line">where user_id = ? and is_read = fasle</span><br><span class="line">所以我们对这表中的两个字段添加复合索引</span><br><span class="line">CREATE INDEX idx_user_id_is_read ON messages (user_id, is_read);</span><br><span class="line">增加查询的效率</span><br><span class="line"></span><br><span class="line">3.过期策略</span><br><span class="line">用户去查找太久远的消息的几率不大</span><br><span class="line">所以就去做一个分表，定期将历史消息归档在历史表中</span><br><span class="line">可以按照季度或者月份归档</span><br><span class="line">我们前端点击查看历史消息的时候，才会去访问这张表</span><br></pre></td></tr></table></figure><ul><li>渠道管理</li></ul><p>​下图只是举例，</p><p>​我们是：邮件、短信、企业微信、钉钉机器人、钉钉联系人等（字段也不同）</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240513095713632.png" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--渠道管理负责去配置各个渠道的信息，短信，邮件，企业微信，钉钉机器人等</span><br><span class="line">--引入钉钉，微信等相关依赖，配置用户名密码服务器等</span><br><span class="line"></span><br><span class="line">我们负责测试，前端同学将这些参数封装在json中传递</span><br><span class="line">我们后端负责接受这些参数，然后在后台调用依赖</span><br><span class="line">尝试去获取消息，获取成功就测试成功</span><br><span class="line"></span><br><span class="line">邮件的话：我们是链接163邮箱，配置服务器，端口，这里是去163官网查看了相关demo</span><br><span class="line">短信：引入它们自己的api,提供的了网关插件地址，去做测试链接</span><br><span class="line">钉钉机器人、联系人、企业微信：都是去官方调用官方API</span><br><span class="line">看它们的示例demo，去做配置</span><br><span class="line">引入了第三方的依赖，去做测试链接</span><br></pre></td></tr></table></figure><ul><li>消息分类统计展示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从不同维度统计及展示消息发送情况</span><br><span class="line">例如根据消息的通知渠道、来源产品、消息分类(告警类型、工单提醒、license提醒)等。</span><br></pre></td></tr></table></figure><h2 id="用户侧"><a href="#用户侧" class="headerlink" title="用户侧"></a>用户侧</h2><p>主要是对站内信的处理（从它们数据库中获取）</p><ul><li>全部类型消息–  告警消息、系统消息、审批消息、产品消息</li><li>未读消息</li><li>已读消息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">这个就是对站内消息的处理</span><br><span class="line">文档中给的需求是，查看，搜索，标记已读，删除，分页查找，批量删除等</span><br><span class="line">并没有给我们接口文档。我们就先在实现的时候，根据功能编写接口文档</span><br><span class="line">我们找了yapi.pro去编写</span><br><span class="line"></span><br><span class="line">我们自己定义的规范就是，基于RESTful API定义的</span><br><span class="line">用户侧就/user开头</span><br><span class="line">说明请求参数，路径参数或者是实体参数开头的</span><br><span class="line">定义Result返回值对象，返回标准的响应值（响应码，响应信息，响应数据data等）</span><br><span class="line">数据库的实体参数作为DTO类，响应给前端的不一定是全部的字段</span><br><span class="line">所以创建一个vo实体类，封装专门响应给前端的信息</span><br><span class="line">（这里就用到了Hutul工具类的拷贝方法，不用一行一行复制很麻烦）</span><br><span class="line"></span><br><span class="line">在删除的时候，因为涉及到数据库的操作，所以需要记录日志</span><br><span class="line">（这里自定义了@logo注解和切面类@Aspect，用AOP的相关知识）</span><br><span class="line">自定义注解@log和切面类@ASpect</span><br><span class="line">注解表示在切面类中使用切面表达式，@Around，@Before前置循环后置，将注解引入进来</span><br><span class="line">并写入插入数据库的逻辑</span><br><span class="line">这样只需要在方法中加入自定义注解就可以实现记录日志操作的过程</span><br><span class="line"></span><br><span class="line">难点：未读消息的推送：</span><br><span class="line">我们一开始这里写的是，轮询</span><br><span class="line">前端写一个定时器，定时的去请求后端未读消息的字段</span><br><span class="line">去遍历数据库去查询，去查询未读的字段</span><br><span class="line"></span><br><span class="line">轮询的话其实性能不是太好</span><br><span class="line">后来考虑过其他消息推送的方法</span><br><span class="line">websocket和SSE</span><br><span class="line">websocket是双向通信，但我们不需要客户端向服务端通信</span><br><span class="line">所以选用SSE轻量级的推送</span><br><span class="line"></span><br><span class="line">具体的做法就是</span><br><span class="line">客户端去建立连接</span><br><span class="line">服务端创建一个seeEmitter对象</span><br><span class="line">seeEmitter对象实现向客户端主动推送消息</span><br><span class="line">把查询到的消息分页放在一个List集合去做的</span><br><span class="line">客户端收到推送的消息后</span><br><span class="line">刷新页面显示等</span><br><span class="line">（后续详细写一遍博客吧）</span><br></pre></td></tr></table></figure><h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><p>以及每种数据类型的使用场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">String类型：Redis最常见的数据结构，可以存储任何数据，字符串，整形，浮点型都可以，</span><br><span class="line">不管用哪儿种方式，底层都是以字节数组的形式存储的，适用于绝大多数场景</span><br><span class="line"></span><br><span class="line">列表List：相当于Java中的linkedList，列表是链表结构，</span><br><span class="line">可以做简单的消息队列功能,但一般不用Redis消息队列</span><br><span class="line"></span><br><span class="line">集合分为集合和有序集合，</span><br><span class="line"></span><br><span class="line">集合set：没有重复元素的集合嘛，一般用于点赞，我们维护一张点赞的表，</span><br><span class="line">每次用户请求点赞的时候，我们先用StringRedisTemplete.opsForSet()</span><br><span class="line">得到操作Redis中set集合的接口，</span><br><span class="line">调用其中的isMember()，去判断点赞是否存在，</span><br><span class="line">不存在就用add加入，再跟新到数据库，存在就返回已经点赞</span><br><span class="line"></span><br><span class="line">共同好友也是，在关注的时候，把当前ID的关注列表以set形式存储到Redis中，</span><br><span class="line">然后，用set求交集的interset()</span><br><span class="line">就可以求得共同的好友交集，</span><br><span class="line"></span><br><span class="line">有序集合sorted set：相对于集合set，是有顺序的，</span><br><span class="line">每个元素都会关联一个权重，按照权重进行排序，</span><br><span class="line">我主要用在点赞的排行傍等，使用的权重是时间，点赞时间早的会排序在前面，</span><br><span class="line">用ZSET的range(key，0,4)方法得到排行前几的，</span><br><span class="line">当然不同的排行傍会有不同的权重，可以是分数或者其他，使用权重排序的方式是不变的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">哈希hash：键值对，适合缓存对象的存储，</span><br><span class="line">因为我们Redis本来就是以键值对key-value的形式存储的，</span><br><span class="line">一般hash存储用在value属性中，value属性存储的也是一对键值对</span><br><span class="line"></span><br><span class="line">位图bigMap：用于存储二进制数据，可以位运算，统计用户签到比较方便</span><br><span class="line"></span><br><span class="line">地理位置GEO：用于存储地理位置的数据结构，我们在数据库中将存放地理位置坐标的位置信息用stringRedisTemplete.opsForGeo接口的add方法存储到Redis中</span><br><span class="line">，再调用Geodistance查找距离，GeoRadius查询一定范围内的餐厅</span><br><span class="line">（这个需要先把商铺位置数据存储到Redis中去）</span><br><span class="line"></span><br><span class="line">HyperLogLog:基于基数的数据结构，支持对大量元素的去重统计，占用和误差很小，</span><br><span class="line">用于网站的访问统计等，底层是概率估算，</span><br><span class="line">我们首先要在线程池里获得当前用户的唯一标识，</span><br><span class="line">针对访客数，和访问量选取不同的标识</span><br><span class="line">针对访客数，因为是不可重复的，可以选用唯一账户ID等</span><br><span class="line">针对访问量，可以重复，当前线程中拿到的cookie即可</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="项目具体功能的实现逻辑"><a href="#项目具体功能的实现逻辑" class="headerlink" title="项目具体功能的实现逻辑"></a>项目具体功能的实现逻辑</h2><p>1.短信验证码的发送，登录、注册、校验</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">发送短信验证码：对手机号进行格式校验，然后随机生成验证码，</span><br><span class="line">引用阿里云的依赖并做配置文件的配置，然后响应给前端</span><br><span class="line"></span><br><span class="line">登录：得到手机号和验证码之后，去判断验证码是否正确，正确就登录成功，</span><br><span class="line">再去数据库中判断是否存在，不存在就创建一个用户，保存到数据库中，</span><br><span class="line">同时用uuid生成一个唯一的token作为key去在Redis中存放用户数据，设置一个过期时间</span><br><span class="line"></span><br><span class="line">校验登录状态是：设置一个拦截器prehandle，去拦截登录请求，</span><br><span class="line">获取token，去Redis中判断token是否存在，如果存在的话，就保存当前用户到线程池当中，</span><br><span class="line">这样我们后续在其他地方获取当前用户信息就只需要在线程池中获取即可</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cookie和session会话跟踪技术，去管理用户的状态，因为HTTP响应是无状态的，</span><br><span class="line">每次请求都是独立的，下次的请求不会携带上次的数据，所以需要会话跟踪技术</span><br><span class="line">cookie是客户端会话跟踪技术，存储数据在客户端浏览器中</span><br><span class="line"></span><br><span class="line">session是服务端会话跟踪技术，数据存储在服务端中</span><br><span class="line">底层通过cookie发送，只需要发送JessieId就可以了，在服务端就可以找到对应Id所在的当前数据</span><br><span class="line">相比于cookie会更安全一些</span><br></pre></td></tr></table></figure><p>2.Redis分布式锁的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透：就是大量请求的数据在缓存和数据库中都不存在，就会造成给数据库请求压力大的情况</span><br><span class="line"></span><br><span class="line">解决方法有：</span><br><span class="line">缓存空对象在缓存中</span><br><span class="line">布隆过滤：就是在Redis和客户端之间再加了一层布隆过滤器，存在则通过，不存在则拒绝，</span><br><span class="line">布隆过滤器是用hash思想实现的，它底层是一个庞大的二进制数组</span><br><span class="line">来了一个key之后对这个key取模存入数组</span><br><span class="line">再来就可以判断它key是否存在了</span><br><span class="line">当然有hash的地方就不可避免有hash冲突，但因为它底层数组够大，冲突不超过5%</span><br><span class="line"></span><br><span class="line">缓存击穿：缓存击穿就是，热点击穿嘛，热点key失效，很多线程来重建key，造成数据库的压力</span><br><span class="line">解决方法就是</span><br><span class="line">1.互斥锁，最先来的线程获取锁，去执行key的重建，其他的线程就会被阻塞</span><br><span class="line">2.逻辑过期：就是存储一个过期的时间的字段到缓存中，但我们并不设置过期时间</span><br><span class="line">当请求达到的时候，从缓存中获取数据，去判断一下这个过期字段，若过期则认为失效</span><br><span class="line">失效的时候，就开启另外一个线程，去更新缓存的逻辑过期时间</span><br><span class="line">当前线程就返回旧的数据</span><br><span class="line">利弊：互斥锁保证了数据的一致性，但是会收到锁竞争的影响，考虑死锁的问题</span><br><span class="line">逻辑过期保证了高的可用性，但是可能会出现数据不一致的问题</span><br><span class="line"></span><br><span class="line">缓存雪崩：就是我们设置key的时候，设置了一样的过期时间，导致一起失效，数据直接打到数据库的时候</span><br><span class="line">缓存雪崩与击穿不同的是，击穿是一个热点key失效，雪崩是很多key通用失效</span><br><span class="line">解决方法就是：在原有的失效时间的基础上，随机增加几分钟的随机值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">分布式锁的实现：简单来说就是用setnx这个方法，去在Redis中设置锁，</span><br><span class="line">如果插入key成功别人就获取不到，相当于加锁</span><br><span class="line">setex获取锁的过期时间，最后在完成业务逻辑之后，再去删除释放锁</span><br><span class="line"></span><br><span class="line">因为执行逻辑和删除是有时间差的，为了确保锁的一致性，防止极端宕机情况，</span><br><span class="line">最好使用lua脚本去执行锁的创建和删除</span><br><span class="line">lua脚本在Redis中执行是单线程的，所以一定会确保执行的时候的原子性</span><br><span class="line"></span><br><span class="line">当然自己实现的还是会有很多考虑不到的地方，比如可重入啊，可靠啊等等</span><br><span class="line">后面都是引入Redis依赖，用redisson的分布式锁实现的</span><br><span class="line">底层会有看门口机制解决死锁的问题，死锁就是业务逻辑异常导致锁无法释放的问题</span><br><span class="line">看门狗机制会在获取锁成功后启动任务，更新锁的过期时间，避免死锁的发生</span><br><span class="line"></span><br><span class="line">乐观锁和悲观锁：</span><br><span class="line">悲观锁：假定一定会发生多线程的问题，就只允许单线程执行，比如Synchronized关键字</span><br><span class="line">乐观锁：允许多线程，但是会有一个版本号，只是在更新数据的时候，</span><br><span class="line"> 判断是否其他线程对数据进行了修改，是的话重试即可</span><br></pre></td></tr></table></figure><p>3.lua脚本实现高并发环境下的一人一单和线程安全问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">就是在lua脚本中去定义本地的处理逻辑</span><br><span class="line">检查本地的数量是否足够</span><br><span class="line">判断用户是否已经下单</span><br><span class="line">再去减库存</span><br><span class="line">返回操作结果</span><br><span class="line"></span><br><span class="line">rabbitMQ消息队列：</span><br><span class="line">生产者去创建一个交换机，交换机负责投递消息到哪儿一个队列，队列再把消息传给消费者处理</span><br><span class="line">用注解@RabbitListener去配置</span><br></pre></td></tr></table></figure><p>4.点赞，共同关注，排行榜</p><p>5.地理位置下的店铺查询</p><p>6.统计访问量和访客量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">集合分为集合和有序集合，</span><br><span class="line"></span><br><span class="line">集合set：没有重复元素的集合嘛，一般用于点赞，我们维护一张点赞的表，</span><br><span class="line">每次用户请求点赞的时候，我们先用StringRedisTemplete.opsForSet()</span><br><span class="line">得到操作Redis中set集合的接口，调用其中的isMember()，</span><br><span class="line">去判断点赞是否存在，不存在就用add加入，再跟新到数据库，存在就返回已经点赞</span><br><span class="line"></span><br><span class="line">共同好友也是，在关注的时候，把当前ID的关注列表以set形式存储到Redis中，</span><br><span class="line">然后，用set求交集的interset()</span><br><span class="line">就可以求得共同的好友交集，</span><br><span class="line"></span><br><span class="line">有序集合sorted set：相对于集合set，是有顺序的，</span><br><span class="line">每个元素都会关联一个权重，按照权重进行排序，</span><br><span class="line">我主要用在点赞的排行傍等，使用的权重是时间，</span><br><span class="line">点赞时间早的会排序在前面，用ZSET的range(key，0,4)方法得到排行前几的，</span><br><span class="line">当然不同的排行傍会有不同的权重，可以是分数或者其他，使用权重排序的方式是不变的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">哈希hash：键值对，适合缓存对象的存储，</span><br><span class="line">因为我们Redis本来就是以键值对key-value的形式存储的，</span><br><span class="line">一般hash存储用在value属性中，value属性存储的也是一对键值对</span><br><span class="line"></span><br><span class="line">位图bigMap：用于存储二进制数据，可以位运算，统计用户签到比较方便</span><br><span class="line"></span><br><span class="line">地理位置GEO：用于存储地理位置的数据结构，</span><br><span class="line">我们在数据库中将存放地理位置坐标的位置信息用</span><br><span class="line">stringRedisTemplete.opsForGeo接口的add方法存储到Redis中，</span><br><span class="line">再调用Geodistance查找距离，GeoRadius查询一定范围内的餐厅</span><br><span class="line">（这个需要先把商铺位置数据存储到Redis中去）</span><br><span class="line"></span><br><span class="line">HyperLogLog:基于基数的数据结构，支持对大量元素的去重统计，占用和误差很小，</span><br><span class="line">用于网站的访问统计等，底层是概率估算，</span><br><span class="line">我们首先要在线程池里获得当前用户的唯一标识，</span><br><span class="line">针对访客数，和访问量选取不同的标识</span><br><span class="line">针对访客数，因为是不可重复的，可以选用唯一账户ID等</span><br><span class="line">针对访问量，可以重复，当前线程中拿到的cookie即可</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始使用了session做登录校验，从当前线程里获取到session但是session在分布式中不能共享，所以</span><br><span class="line">集成阿里云的短信服务，就是引入了阿里云的依赖，先是对，做了配置文件的配置，</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Redis的相关面试题</p><p>Redis和MySQL如何做读写一致性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.缓存过期嘛，定期的从sql中加载最新的数据</span><br><span class="line">2.做数据更改时候，不直接更新Redis而是删除缓存，下次访问时候未命中再更新</span><br><span class="line">3.最终一致性：使用消息队列异步处理</span><br></pre></td></tr></table></figure><p>Redis持久化是怎么做的呢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">两种持久化方案：</span><br><span class="line">1.快照文件，把Redis存储的数据保存到磁盘上，方便宕机的时候做数据恢复</span><br><span class="line">2.追加文件，Redis操作写操作的时候，会存储到这个文件中去</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Redis的数据过期策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">惰性删除：一般不管，我们使用到key后，如果判断过期再删除</span><br><span class="line">定期删除：每隔一段时间对key进行检查，定期清理</span><br><span class="line">一般Redis中的过期删除策略，是结合这两部分来的</span><br></pre></td></tr></table></figure><p>Redis淘汰策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">很多，一把用LRU，对最近少使用的key淘汰</span><br></pre></td></tr></table></figure><p>Redis集群</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主从复制：数据从一个主节点复制到其他节点</span><br><span class="line">哨兵模式：哨兵作为独立的节点监控集群，发生故障时候执行故障转移</span><br><span class="line">分片模式：将数据分片到多个节点上</span><br></pre></td></tr></table></figure><p>Linux常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用Redis和</span><br><span class="line">文件操作：ls,ll,</span><br><span class="line">进入目录：cd..  cd/  cd</span><br><span class="line">显示路径：pwd</span><br><span class="line">创建目录 mkdir</span><br><span class="line">删除：rf</span><br><span class="line">复制：cp</span><br><span class="line">移动：mv</span><br><span class="line"></span><br><span class="line">tar -zxvf解压</span><br><span class="line">ping</span><br><span class="line">ipconfig</span><br><span class="line">sudo</span><br><span class="line">等等</span><br></pre></td></tr></table></figure><p>项目部署docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">使用docker，我们需要将项目打个包为镜像，镜像包含应用的本身，也包含运行的环境依赖等等</span><br><span class="line">docker在运行的时候会创建一个容器，运行我们的镜像文件</span><br><span class="line"></span><br><span class="line">使用docker很方便</span><br><span class="line">我用docker在我的虚拟机中创建运行了</span><br><span class="line">MySQL</span><br><span class="line">Redis</span><br><span class="line">rabbitmq</span><br><span class="line">openjdk</span><br><span class="line">nginx</span><br><span class="line">注意的是：Redis和MySQL需要进行目录的挂载</span><br><span class="line">将容器内的目录映射到外边来</span><br><span class="line">这样我们删除创建容器的时候，数据不会丢失</span><br><span class="line"></span><br><span class="line">并且将自己的项目文件用Maven打包，构建dockerFile构建镜像</span><br><span class="line">然后再执行构建镜像即可</span><br></pre></td></tr></table></figure><p>nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">启动nginx，在配置文件中修改参数</span><br><span class="line">监听我程序运行的端口80</span><br><span class="line">然后反向代理给启动的两个服务：8080和8081</span><br><span class="line">选择负载均衡的方法有：轮询，最少连接，哈希等</span><br></pre></td></tr></table></figure><h1 id="数据库MySQL"><a href="#数据库MySQL" class="headerlink" title="数据库MySQL"></a>数据库MySQL</h1><p>数据库事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一系列的数据库操作被当作一个单独的逻辑单元，要么全部执行，要么全部回滚</span><br><span class="line">数据库事务是为了确保事务的完整性和一致性</span><br><span class="line">数据库事务由四个属性组成ACID</span><br><span class="line">原子性：要么全部执行，要么全部回滚</span><br><span class="line">一致性：事务执行前后，数据库的数据处于一致状态</span><br><span class="line">隔离性：每个事务独立于其他事务</span><br><span class="line">持久性：事务执行成功，就是持久的</span><br><span class="line"></span><br><span class="line">在sql中使用 start Transaction作为事务的开启，rollback回滚，commit提交</span><br><span class="line">在spring框架中，在service层使用注解@Transactional开启事务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">索引是一种特殊的数据结构，用于加快数据库中数据的查询速度</span><br><span class="line">类似于书中的目录，可以帮助快速查找目录</span><br><span class="line"></span><br><span class="line">使用create index ...去为字段创建索引</span><br><span class="line">一般来讲是where子句中频繁出现的列，在表的特定列上创建索引</span><br><span class="line"></span><br><span class="line">主键是会自动创建索引的</span><br><span class="line">索引的底层是通过B+树来存放的，我们创建索引时候</span><br><span class="line">会将当前字段插入B+树</span><br><span class="line">B+树是一个多路平衡查找树，</span><br><span class="line">所有叶子节点包含全部的键相互连接，方便查找</span><br><span class="line">非叶子节点只做索引，不含实际数据</span><br></pre></td></tr></table></figure><p>锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在并发访问时候，解决数据一致性和有效性的机制</span><br><span class="line">全局锁：对整个数据库加锁，在备份的时候加锁 flush tables with readlock</span><br><span class="line">表级锁：锁表 lock tables..</span><br><span class="line">行级锁：锁行 lock </span><br></pre></td></tr></table></figure><p>sql优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.建标的时候选择合适的类型</span><br><span class="line">2.使用索引</span><br><span class="line">3.sql语句的编写</span><br><span class="line">尽量避免select*的情况，查询具体的字段</span><br><span class="line">    尽量少用子查询，用join关联查询代替</span><br><span class="line">尽量不使用or，导致索引失效，分开几条sql写</span><br><span class="line">执行的时候，批量插入，而不是一条一条插入，分批删除</span><br><span class="line">避免索引失效的写法</span><br><span class="line">4.主从复制</span><br><span class="line">5.读写分离</span><br><span class="line"></span><br><span class="line">建标选择合适的类型</span><br><span class="line">参考的是阿里云的开发手册，定义字段的时候，选择合适的字段内容来建标</span><br><span class="line">字符串就结合存储的内容来使用char  或者varchar</span><br><span class="line">用户名称邮箱类型的，使用varchar</span><br><span class="line">文章内容使用text</span><br><span class="line">邮编长度使用char等等</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sql的执行顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select * from where groupby having orderby limit</span><br><span class="line"></span><br><span class="line">先执行from语句，查询确定查的表</span><br><span class="line">再是链接条件，join on</span><br><span class="line">再是where 过滤符合条件的</span><br><span class="line">再groupby分组</span><br><span class="line">having分组后过滤</span><br><span class="line">最后排序，limit输出</span><br><span class="line"></span><br><span class="line">where是分组前过滤，having是分组后过滤</span><br></pre></td></tr></table></figure><h1 id="spring-Web框架"><a href="#spring-Web框架" class="headerlink" title="spring Web框架"></a>spring Web框架</h1><p>spring框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring是Java开发的框架，有很多模块</span><br><span class="line">spring框架的web开发模块，就是springMVC</span><br><span class="line">springMVC + spring framework + Mybatis 就是俗称SSM</span><br><span class="line">springboot整合了ssm，快速开发</span><br></pre></td></tr></table></figure><p>IOC控制反转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是一种设计模式，将原本在程序中手动创建对象的控制权，交给spring框架来管理</span><br><span class="line">IOC容器就是工厂一样，当我们需要创建一个对象的时候</span><br><span class="line">只需要用注解@Autowired，而不需要考虑对象是如何创建出来的</span><br><span class="line"></span><br><span class="line">Bean指的是被IOC容器所管理的对象</span><br></pre></td></tr></table></figure><p>AOP面相切面编程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AOP是spring的核心框架之一，它在程序运行时动态将额外的行为</span><br><span class="line">比如记录日志操作，事务处理，方法运行时间等功能，额外的插入到代码中</span><br><span class="line"></span><br><span class="line">它是通过动态代理的方式实现的</span><br><span class="line">实现proxy类的方法，生成代理对象，在其他地方通过去通过代理对象调用方法</span><br><span class="line"></span><br><span class="line">我在项目中用AOP的实现过程，对数据库修改操作的日志记录的实现过程</span><br><span class="line">创建操作日志的表格嘛，操作人Id，时间方法参数等</span><br><span class="line">根据表格创建实体类</span><br><span class="line">自定义注解@log和切面类@ASpect</span><br><span class="line">注解表示在切面类中使用切面表达式，@Around，@Before前置循环后置，将注解引入进来</span><br><span class="line">并写入插入数据库的逻辑</span><br><span class="line">这样只需要在方法中加入自定义注解就可以实现记录日志操作的过程</span><br></pre></td></tr></table></figure><p>spring框架用到了哪儿些设计模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单例模式：spring中的bean是单例的，通过IOC容器对Bean管理，保证整个应用只有一个Bean实例</span><br><span class="line">工厂模式：springIOC负责容器的创建和管理实例，可以将IOC看做是一个工厂</span><br><span class="line">我们不需要知道对象是如何创建的</span><br><span class="line">只需要用注解直接注入对象就行</span><br><span class="line"></span><br><span class="line">代理模式：spring的AOP面相切面编程就用到了代理模式</span><br><span class="line">实现proxy类的方法，生成代理对象，在其他地方通过代理对象去调用方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>spring事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Trancsacyional注解</span><br><span class="line">事务的传播，如果当前有事务，就加入该事务，如果没有，就创建新的事务</span><br></pre></td></tr></table></figure><p>spring的常用注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">最先就是启动注解@SpringBootApplication了，里面包含三个注解</span><br><span class="line">然后就是三层架构的</span><br><span class="line">@RestController @Service @MApper</span><br><span class="line"></span><br><span class="line">在controller层</span><br><span class="line">去处理请求HTTP相关的注解</span><br><span class="line">@GetMapping @PostMapping @DeleteMapping等</span><br><span class="line">传值相关的注解</span><br><span class="line">@RequestBody @PathVariable @RequestParam等</span><br><span class="line">mapper层的数据库注解</span><br><span class="line">@Insert @Select @Delete 等等</span><br><span class="line"></span><br><span class="line">还要通用的 @AutWired @configuration @Transcactional等等</span><br></pre></td></tr></table></figure><p>mybatis 和mybatisPlus的联系区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mybatis是用Java操作数据的的持久层框架，主要使用xml或者注解来配置sql语句</span><br><span class="line">使用时，会创建数据库连接池，解决了资源重用，提示响应</span><br><span class="line"></span><br><span class="line">MP内置了增删改查，通过扫描实体类，基于反射获取实体类的信息，作为数据库的信息表</span><br><span class="line">一般来讲，单表的增删改查就有MP实现</span><br><span class="line">多表的联合查询就没法用MP了，用mybatis去写</span><br><span class="line"></span><br><span class="line">MP自带了分页查询插件，不用去引入第三方的依赖，很方便</span><br><span class="line">创建一个Page&lt;&gt;对象，然后调用selectPage（）方法</span><br></pre></td></tr></table></figure><h2 id="Java基础："><a href="#Java基础：" class="headerlink" title="Java基础："></a>Java基础：</h2><p>Java虚拟机</p><p>是运行Java字节码的运行环境，它使得Java具有跨平台的能力</p><p>Java从源代码到运行的过程如下：Java文件通过编译成.class 文件，然后交给JVM，字节码文件包含JVM的可运行指令集合，JVM在运行的时候，会判断是否是热点代码，是的话使用JIT编译器，JIT是运行时编译器，会将字节码对应的机器码保存起来，下次可以直接使用</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/java-code-to-machine-code-with-jit.png" alt="Java程序转变为机器代码的过程"></p><p><strong>编译型</strong>：<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80">编译型语言open in new window</a> 会通过<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器open in new window</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</p><p><strong>解释型</strong>：<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80">解释型语言open in new window</a>会通过<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器open in new window</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</p><h3 id="Java和c-c-的区别"><a href="#Java和c-c-的区别" class="headerlink" title="Java和c,c++ 的区别"></a>Java和c,c++ 的区别</h3><p><strong>相同：</strong>都是面向对象的语言，封装继承多态</p><p><code>封装</code>：将对象和属性都封装在一个类中，影藏内部复杂性，提供公共的get，set方法来设置，高内聚，低耦合，</p><p><code>继承</code>：extends，子类可以继承父类的方法和属性，不修改父类方法的情况下，添加自己的新成员方法，子类可以通过super关键字调用父类的方法</p><p><code>多态</code>：同一操作对不同的对象，有不同的解释，就是多态，编译型多态，重载，运行时多态，重写</p><p><strong>不同：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java 是解释性的语言，运行过程为：java 编译后生成字节码文件，然后在 java 虚拟机 JVM 中解释运行，</span><br><span class="line"></span><br><span class="line">C++ 编译型语言，编译后直接生成二进制的字节码文件，所以 C++ 运行速度快，但是 java 可以移植</span><br><span class="line"></span><br><span class="line">java 中没有指针，提供了数组和集合这样的类和方法去操作，使得程序更加安全</span><br><span class="line"></span><br><span class="line">java 中没法实现多重继承，只能实现多个接口来达到与 C++ 中多重继承的作用</span><br><span class="line"></span><br><span class="line">C++ 中，经常需要去 malloc 去分配和释放内存，java 中有垃圾回收机制，会自动释放内存</span><br><span class="line"></span><br><span class="line">C++ 支持运算符的重载，java 不支持</span><br><span class="line"></span><br><span class="line">C++ 更接近底层，允许更多的底层控制，java 隐藏了更多的底层细节，提供了丰富的库和内置功能</span><br></pre></td></tr></table></figure><p><strong>位移</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`&lt;&lt;` :左移运算符，向左移若干位，高位丢弃，低位补零。`x &lt;&lt; 1`,相当于 x 乘以 2(不溢出的情况下)。</span><br><span class="line"></span><br><span class="line">`&gt;&gt;` :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x &gt;&gt; 1`,相当于 x 除以 2。</span><br><span class="line"></span><br><span class="line">`&gt;&gt;&gt;` :无符号右移，忽略符号位，空位都以 0 补齐。</span><br></pre></td></tr></table></figure><p><strong>包装类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使基本数据类型有类的特征，而构建的包装类，每个基本数据类型都有包装类，我们可以将基本数据类型转为对象使用，在Java中，自动装箱和拆箱机制使得基本数据类型和其对应的包装类可以自动转换，使得程序编写更加便捷。</span><br></pre></td></tr></table></figure><p><strong>浮点数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">精度丢失：计算器底层是用二进制表示小数的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</span><br></pre></td></tr></table></figure><p><strong>静态变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">就是被static修饰的变量，可以被所有的类所有的实例所共享，就是只会被分配一次内存，可以节省内存空间，</span><br><span class="line"></span><br><span class="line">public修饰的静态变量可以通过类的名称.来访问，</span><br><span class="line"></span><br><span class="line">静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</span><br></pre></td></tr></table></figure><p><strong>可变长参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用方法可循允许在传入不定长度的参数，底层是通过数组来接受</span><br><span class="line"></span><br><span class="line">方法重载的时候，会优先匹配固定参数的，再匹配可变参数的</span><br></pre></td></tr></table></figure><p><strong>抽象类和接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">抽象类是一个类，只能被继承，不能被实现，类似于is-a的关系</span><br><span class="line"></span><br><span class="line">接口中的方法都是抽象的，abstract只不过被省略了，实现接口必须提供具体的实现方法，类似于has-a关系</span><br><span class="line"></span><br><span class="line">抽象类中可以包含具体的方法，也可以包含抽象的方法</span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;和equals()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型来说，==比较的是值</span><br><span class="line"></span><br><span class="line">引用数据类型来说，==比较的是内存的地址</span><br><span class="line"></span><br><span class="line">一般类会重写equals()方法，比较的是对象的属性是否相等，而不是地址值</span><br><span class="line"></span><br><span class="line">`String` 中的 `equals` 方法是被重写过的，比较的是 String 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。</span><br></pre></td></tr></table></figure><p><strong>hashcode()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为什么要有hashcode（）：我们把对象加入hashset或者HashMap，会先计算对象的hashcode值来判断插入的位置，一般来说是取模的操作，如果没有相同的哈希值，就直接插入，如果有相同的hash值，会调用equals去比较对象是否相等，如果相同，不插入，这样做的好处是，大大减少了equals比较的次数，提高效率</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果重写equals时候，没有重写hashcode，就会导致两个相等的对象，hash值不相等，造成set或者map中村子相等元素，</span><br></pre></td></tr></table></figure><p><strong>String，StringBuffer，StringBuilder</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String不可变字符串：底层被final修饰</span><br><span class="line"></span><br><span class="line">StringBuffer：被synchronized修饰，线程安全</span><br><span class="line"></span><br><span class="line">StringBuilder：线程不安全</span><br><span class="line"></span><br><span class="line">**+**</span><br><span class="line"></span><br><span class="line">底层是通过StringBuilder.append().toString()实现的</span><br><span class="line"></span><br><span class="line">字符串常量池</span><br><span class="line"></span><br><span class="line">是Java虚拟机JVM为了减少内存消耗针对String类开辟的区域，主要为了避免字符串重复创建</span><br><span class="line"></span><br><span class="line">**唯一性**：字符串常量池中的字符串对象是唯一的，即相同内容的字符串在常量池中只有一个实例。</span><br><span class="line"></span><br><span class="line">使用 `new` 关键字创建的字符串对象会被保存在堆内存中的普通对象区域，不会放入字符串常量池。</span><br></pre></td></tr></table></figure><p><strong>异常</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java类中，所有的异常都有一个祖先，Throwable类，有两个子类，Exception和Error类</span><br><span class="line"></span><br><span class="line">常用异常：runtimeException等</span><br><span class="line"></span><br><span class="line">全局异常处理器：在Springboot中，使用@ControllerAdvice表示是全局异常处理器</span><br><span class="line"></span><br><span class="line">使用@ExceptionHandler，表示统一补货的异常</span><br></pre></td></tr></table></figure><p><strong>泛型</strong></p><p>ArrayList<Integer> list &#x3D; new ArrayList&lt;&gt;();</Integer></p><p>表示ArrayList对象只能传入Integer类型的对象，传其他的会报错</p><p>泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化泛型类</span></span><br><span class="line">Generic&lt;Integer&gt; g = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><p>泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现泛型接口，不指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现泛型接口，指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">   &#123;</span><br><span class="line">         <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>项目里哪儿里用到泛型</p><p>自定义返回结果Result<T> 通过参数T，具体的返回指定的数据结构类型</T></p><p><strong>反射</strong></p><p>反射是指，在运行时，动态的获取类的信息以及操作类的属性，方法，和构造函数的能力</p><p>通过反射，我们可以在运行时检查类，实例化对象，调用方法，访问字段等，</p><p>而不需要在编译的时候，获取类的具体信息，</p><p>反射提供了一种很强大的机制，来操作类和对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">反射是Java中提供的一种强大的操控类和对象的机制</span><br><span class="line">我们不需要再编译的时候去获取类的相关信息</span><br><span class="line">而是在程序运行的时候</span><br><span class="line">通过获取Class对象</span><br><span class="line">动态的获取类的信息，比如他的属性，方法，成员变量，字段等等</span><br><span class="line">我们可以去实例化对象，调用方法，访问字段等等</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">平时写业务代码一般用不到反射，但是Spring框架里大量用到反射机制</span><br><span class="line"></span><br><span class="line">注解：用反射来读取类，方法，字段上面的**注解**，并且根据注解定义执行的逻辑等</span><br><span class="line"></span><br><span class="line">依赖注入DI：通过注解@Autowired，使用反射，来创建并且实例化对象</span><br><span class="line">AOP面向切面编程：使用反射来生成代理对象，并通过反射调用原始方法，实现比如，事务管理，日志记录，消耗时间检测等</span><br></pre></td></tr></table></figure><p>具体怎样调用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">获取类的大Class对象，Class对象将一个类的全部方法，变量等信息告诉我，再调用Class的对象的方法来创建对象</span><br><span class="line">想要使用反射，我先要得到class文件对象，其实也就是得到Class类的对象</span><br><span class="line">Class类主要API：</span><br><span class="line">        成员变量  - Field</span><br><span class="line">        成员方法  - Constructor</span><br><span class="line">        构造方法  - Method</span><br><span class="line">获取class文件对象的方式：</span><br><span class="line">        1：Object类的getClass()方法</span><br><span class="line">        2：数据类型的静态属性class</span><br><span class="line">        3：Class类中的静态方法：public static Class ForName(String className)</span><br><span class="line">--------------------------------  </span><br><span class="line">获取成员变量并使用</span><br><span class="line">        1: 获取Class对象</span><br><span class="line">        2：通过Class对象获取Constructor对象</span><br><span class="line">        3：Object obj = Constructor.newInstance()创建对象</span><br><span class="line">        4：Field field = Class.getField(&quot;指定变量名&quot;)获取单个成员变量对象</span><br><span class="line">        5：field.set(obj,&quot;&quot;) 为obj对象的field字段赋值</span><br><span class="line">如果需要访问私有或者默认修饰的成员变量</span><br><span class="line">        1:Class.getDeclaredField()获取该成员变量对象</span><br><span class="line">        2:setAccessible() 暴力访问  </span><br><span class="line">---------------------------------          </span><br><span class="line">通过反射调用成员方法</span><br><span class="line">        1：获取Class对象</span><br><span class="line">        2：通过Class对象获取Constructor对象</span><br><span class="line">        3：Constructor.newInstance()创建对象</span><br><span class="line">        4：通过Class对象获取Method对象  ------getMethod(&quot;方法名&quot;);</span><br><span class="line">        5: Method对象调用invoke方法实现功能</span><br><span class="line">如果调用的是私有方法那么需要暴力访问</span><br><span class="line">        1: getDeclaredMethod()</span><br><span class="line">        2: setAccessiable();</span><br></pre></td></tr></table></figure><p><strong>动态代理</strong></p><p>简单来说就是：<code>编写InvocationHandler实现类、调用Proxy.newProxyInstance()方法生成代理对象，代理对象在方法调用时会委托给InvocationHandler实现类中的invoke()方法处理额外逻辑。</code></p><p>再简单：编写实现类，new生成一个代理对象，调用调离对象的invoke（）实现原有方法的逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.定义接口：首先需要定义一个接口，它定义了需要被代理类所实现的方法。</span><br><span class="line">2.编写实际类：实现上述接口的一个或多个实际类。</span><br><span class="line">3.编写InvocationHandler实现类：创建一个实现InvocationHandler接口的类，该类将负责拦截对代理对象方法的调用，并在必要时执行额外的逻辑。</span><br><span class="line">4.调用Proxy.newProxyInstance()方法：使用Proxy.newProxyInstance()方法来创建动态代理对象。这个方法接受三个参数：ClassLoader，需要代理的接口数组以及一个InvocationHandler对象。</span><br><span class="line">5.动态生成代理类：在调用Proxy.newProxyInstance()方法时，Java会动态生成一个代理类，并在运行时创建一个代理对象。这个代理类会实现所提供的接口，并在方法被调用时，将调用委托给InvocationHandler实现类中的invoke()方法。</span><br><span class="line">6.调用代理对象方法：最后，通过调用代理对象的方法来触发InvocationHandler实现类中的invoke()方法，从而执行额外的逻辑。</span><br></pre></td></tr></table></figure><p><strong>序列化和反序列化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">序列化：就是将数据结构对象--&gt;转换成二进制的文件字节流的过程</span><br><span class="line"></span><br><span class="line">返序列化：二进制字节流--&gt;转换成数据结构对象的过程</span><br><span class="line"></span><br><span class="line">Spring中使用的是Java原生的序列化和反序列化，</span><br><span class="line"></span><br><span class="line">我们一般引入JSON依赖，试用的是JSON的序列化和反序列化</span><br></pre></td></tr></table></figure><p><strong>IO流</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IO：输入、输出流</span><br><span class="line"></span><br><span class="line">Java IO流的类都是从四个类派生出来的</span><br><span class="line"></span><br><span class="line">- InputStream：字节输入流</span><br><span class="line">- OutputStream：字节输出流</span><br><span class="line">- Reader：字符输入流</span><br><span class="line">- Writer：字符输出流</span><br><span class="line"></span><br><span class="line">基本用到的Filereader和FileWriter</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Reader 常用方法：</span><br><span class="line">read() : 从输入流读取一个字符。</span><br><span class="line">read(char[] cbuf) : 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，等价于 read(cbuf, 0, cbuf.length) 。</span><br><span class="line">read(char[] cbuf, int off, int len)：在read(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。</span><br><span class="line">skip(long n)：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</span><br><span class="line">close() : 关闭输入流并释放相关的系统资源。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Writer 常用方法：</span><br><span class="line">write(int c) : 写入单个字符。</span><br><span class="line">write(char[] cbuf)：写入字符数组 cbuf，等价于write(cbuf, 0, cbuf.length)。</span><br><span class="line">write(char[] cbuf, int off, int len)：在write(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。</span><br><span class="line">write(String str)：写入字符串，等价于 write(str, 0, str.length()) 。</span><br><span class="line">write(String str, int off, int len)：在write(String str) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。</span><br><span class="line">append(CharSequence csq)：将指定的字符序列附加到指定的 Writer 对象并返回该 Writer 对象。append(char c)：将指定的字符附加到指定的 Writer 对象并返回该 Writer 对象。flush()：刷新此输出流并强制写出所有缓冲的输出字符。</span><br><span class="line">close():关闭输出流释放相关的系统资源。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>字节缓冲流</strong></p><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p><p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象，字节缓冲环流</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">//字符缓冲流</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;tokens.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p><p><strong>随机访问流</strong></p><p>支持随意跳转到文件的任意位置进行读写的 <code>RandomAccessFile</code> 。</p><p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p><h2 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h2><h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><p>java 虚拟机在在程序的运行过程中，会把它管理的内存划分为不同的区域，包括<code>线程私有</code>的和<code>线程共享</code>的</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom: 67%;"><p>线程共享的有：堆，字符串常量池，</p><p>线程私有的：程序计数器，虚拟机栈，本地方法栈等</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可以看做是当前线程所执行的字节码的行号指令器，字节码解释器工作的时候需要改变这个计数器来执行下一条字节码的指令</span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line"></span><br><span class="line">字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</span><br><span class="line"></span><br><span class="line">在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</span><br><span class="line"></span><br><span class="line">它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</span><br></pre></td></tr></table></figure><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于存储方法的局部变量，部分计算结果以及调用方法的状态，每个线程在运行的时候，都会创建一个独立的Java虚拟机栈</span><br><span class="line"></span><br><span class="line">栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。</span><br></pre></td></tr></table></figure><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/stack-area.png" alt="Java 虚拟机栈" style="zoom:67%;"><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul><li><pre><code>堆是Java虚拟机中掌管内存的最大一块，是所有线程都共享的一块内存区域，主要用来存放对象实例， 这些对象无需要手动释放内存，交给JVM的垃圾回收机制自动管理堆的结构：- 年轻代：新生成的对象，很快会消失- 老年代：在年轻代足够长后，会移动到老年代，存储长生命周期对象- 元空间：永久存储，使用本地内存，存储在本地<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 方法区</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 字符串常量池</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 对象创建过程</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Java虚拟机中会对类加载检查，确保所需要的类被夹在，然后，JVM为对象分配内存，初始化为0，设置对象头的信息，并且调用构造函数来初始化对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**内存的分配机制有两种**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  - 指针碰撞：用过的整合在一边，没用的在另一边，用分界指针，只需要向没用过的地方分配即可</span><br><span class="line">  - 空闲列表：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</span><br><span class="line">  </span><br><span class="line">  **分配内存的并发问题**</span><br><span class="line">  </span><br><span class="line">  创建对象是很频繁的事情，所以的过程必须是线程安全的，</span><br><span class="line">  </span><br><span class="line">  虚拟机采用两种方式保证线程安全：</span><br><span class="line">  </span><br><span class="line">  CAS+失败重试：CAS是一种乐观锁的实现方式，所谓`乐观锁`就是假定没用冲突去完成，有冲突了就重试直到成功为止</span><br><span class="line">  </span><br><span class="line">  TLAB：</span><br><span class="line">  </span><br><span class="line">  为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</span><br></pre></td></tr></table></figure><h3 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。</span><br><span class="line"></span><br><span class="line">堆的内存空间被分为三个区域，新生代，老年代，永久代</span><br><span class="line"></span><br><span class="line">**内存分配和回收原则**</span><br><span class="line"></span><br><span class="line">一般对象优先在新生代分配</span><br><span class="line"></span><br><span class="line">大对象直接进入老年代</span><br><span class="line"></span><br><span class="line">长期存活的对象进入老年代</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</span><br><span class="line"></span><br><span class="line">大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</span><br><span class="line"></span><br><span class="line">对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">部分收集 (Partial GC)：</span><br><span class="line"></span><br><span class="line">- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</span><br><span class="line">- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</span><br><span class="line">- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</span><br><span class="line"></span><br><span class="line">整堆收集 (Full GC)：收集整个 Java 堆和方法区。</span><br></pre></td></tr></table></figure><h4 id="死亡对象的判断方法"><a href="#死亡对象的判断方法" class="headerlink" title="死亡对象的判断方法"></a>死亡对象的判断方法</h4><p><strong>引用计数法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给对象中添加一个引用计数器：</span><br><span class="line"></span><br><span class="line">- 每当有一个地方引用它，计数器就加 1；</span><br><span class="line">- 当引用失效，计数器就减 1；</span><br><span class="line">- 任何时候计数器为 0 的对象就是不可能再被使用的。</span><br><span class="line"></span><br><span class="line">这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</span><br></pre></td></tr></table></figure><p><strong>可达性分析算法</strong>：</p><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li><pre><code>- 虚拟机栈(栈帧中的局部变量表)中引用的对象- 本地方法栈(Native 方法)中引用的对象- 方法区中类静态属性引用的对象- 方法区中常量引用的对象- 所有被同步锁持有的对象- JNI（Java Native Interface）引用的对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 引用类型总结</span><br><span class="line"></span><br><span class="line">将引用分为强引用、软引用、弱引用、虚引用四种</span><br><span class="line"></span><br></pre></td></tr></table></figure>1．强引用（StrongReference）以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</code></pre></li></ul><p>2．软引用（SoftReference）<br>如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p>3．弱引用（WeakReference）<br>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p>4．虚引用（PhantomReference）<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 垃圾收集算法</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  #### 标记清除算法</span><br><span class="line">  </span><br><span class="line">  首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</span><br><span class="line">  </span><br><span class="line">  1. **效率问题**：标记和清除两个过程效率都不高。</span><br><span class="line">  2. **空间问题**：标记清除后会产生大量不连续的内存碎片</span><br><span class="line">  </span><br><span class="line">  #### 复制算法</span><br><span class="line">  </span><br><span class="line">  为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。在垃圾回收时，将活动对象复制到未使用的那块内存中，然后清理正在使用的内存块。这种方式适用于年轻代，因为它可以快速清理大量的短命对象。</span><br><span class="line">  </span><br><span class="line">  - **可用内存变小**：可用内存缩小为原来的一半。</span><br><span class="line">  - **不适合老年代**：如果存活对象数量比较大，复制性能会变得很差。</span><br><span class="line">  </span><br><span class="line">  #### 标记整理算法</span><br><span class="line">  </span><br><span class="line">  在标记阶段后，不是简单地清除未标记对象，而是将所有存活的对象压缩到内存的一端，减少碎片并清理剩余空间。由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</span><br><span class="line">  </span><br><span class="line">  #### 分代收集算法</span><br><span class="line">  </span><br><span class="line">  当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</span><br><span class="line">  </span><br><span class="line">  比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</span><br><span class="line">  </span><br><span class="line">  #### 垃圾收集器</span><br><span class="line">  </span><br><span class="line">  **如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**</span><br><span class="line">  </span><br><span class="line">  Java提供了多种垃圾回收器，每种回收器都适用于不同类型和负载的应用场景：</span><br><span class="line">  </span><br><span class="line">  - **串行回收器（Serial GC）**：单线程回收，适用于小型堆和单核处理器。</span><br><span class="line">  - **并行回收器（Parallel GC）**：多线程回收，适用于增加吞吐量的需求，如在多CPU环境下。</span><br><span class="line">  - **CMS回收器（Concurrent Mark Sweep）**：减少停顿时间，适用于需要低延迟的应用。</span><br><span class="line">  - **G1回收器（Garbage-First GC）**：一种服务器端垃圾回收器，旨在用于多处理器机器和大内存环境，能够更好地预测停顿时间。</span><br></pre></td></tr></table></figure><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><em>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设计模式是解决待定问题的成熟模版，Springboot中用到了多种模式</span><br><span class="line"></span><br><span class="line">单例模式：在Spring中，Bean默认是单例的，提供了一个全局访问点来访问该实例，确保一致性和性能，避免对象重复创建的开销</span><br><span class="line">工厂模式：</span><br><span class="line">代理模式：aop</span><br><span class="line">模版方法模式：</span><br></pre></td></tr></table></figure><p>单例模式：它确保一个类只有一个实例，并提供了一个全局的访问点来访问该实例，这个模式特别适用于管理共享资源的情况，比如Spring框架中的Bean容器，和数据库连接池或配置管理器。使用单例模式可以避免对象的多次实例化，保持资源使用的一致性。</p><p>工厂模式：提供了一种创建对象的方式，而无需指定具体的实现类</p><p>“工厂模式主要分为两种：简单工厂模式和工厂方法模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### 简单工厂</span><br><span class="line"></span><br><span class="line">它有一个中央的工厂类，负责创建所有类型的对象，通常通过接收一个参数来判断应该创建哪一种类型的对象。虽然简单工厂模式可以减少代码中的重复和提高内聚性，但它的主要缺点是，如果添加新的产品类型，就需要修改工厂类，这违反了开闭原则。</span><br><span class="line"></span><br><span class="line">### 工厂方法模式</span><br><span class="line"></span><br><span class="line">工厂方法模式在简单工厂的基础上进行了改进，定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。这样的设计让工厂方法在类的结构中创建所需的对象，它通过让子类实现一个工厂接口来移除了类中的硬编码依赖关系。每个生成的工厂都可以生成一种具体类型的对象，这种模式利于程序的扩展，并且遵守开闭原则。</span><br><span class="line"></span><br><span class="line">### 抽象工厂模式</span><br><span class="line"></span><br><span class="line">抽象工厂就是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">准备换工作面试，来复习下。先看了单例和工厂。只是举些例子，方便记忆和理解。</span><br><span class="line"></span><br><span class="line">1:单例，最常见就是spring中的bean都是单例的。比如你连接池datasource不采用单例模式，你每次使用连接池的地方都new个新对象，浪费资源。但是单例有时候会导致并发不安全，特别是一些喜欢在服务类里放成员变量的同志。</span><br><span class="line"></span><br><span class="line">2.工厂模式的话，视频里很多都是啥if else,实际上有很多解决办法。比如spring自动注入个map，或者自己通过反射实现再或者写个枚举，通过enum.values()，放在map里面。</span><br><span class="line"></span><br><span class="line">简单工厂，很多用的都是静态工厂方法，除非工厂依赖于其他对象，那就没办法静态了。说白了就是一个要有抽象的意识，不要只会CV。否则到时候改起需求来痛苦死你。</span><br><span class="line"></span><br><span class="line">工厂方法的话，我自己代码里没有映像是否用过，我觉得在封装第三方包或者使用第三方依赖是可以用到。当你发现别人的类已经无法满足你的需求，你可以自己实现个factory然后注入到容器里，然后创建你自己需要的bean。比如说mybatis里的sqlSessionFactory？里面我没怎么细看。但应该是一种扩展第三方包功能的思路</span><br><span class="line"></span><br><span class="line">抽象工厂,我本来想举个不同媒介的存储服务的例子，但我突然发现抽象工厂是一个很重的用法，因为抽象工厂更关注的是所创建的对象。但我们实际开发中突出的是服务的概念，也就是一种方法的实现，所以完全可以把对象中我们真正要用的方法抽成接口，然后用简单工厂就好了。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">### 代理模式</span><br><span class="line"></span><br><span class="line">代理模式是一种设计模式，属于结构型模式的一种。它的主要目的是通过引入一个代理对象来控制对另一个对象的访问。这个代理对象可以为被代理的对象提供额外的功能，比如访问控制、延迟初始化、日志记录、安全检查、缓存等，而不改变被代理对象的代码。</span><br><span class="line"></span><br><span class="line">包括</span><br><span class="line"></span><br><span class="line">静态代理：在编码的时候，就创建好了代理类和目标对象的关系</span><br></pre></td></tr></table></figure><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240507164056743.png" alt="image-20240507164056743" style="zoom:50%;"><p>动态代理：在运行的时候，动态代理，通过实现proxy类的方法，再调用invoke方法实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">### 策略模式</span><br><span class="line"></span><br><span class="line">在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。</span><br><span class="line"></span><br><span class="line">创建一个定义活动的 *Strategy* 接口和实现了 *Strategy* 接口的实体策略类。*Context* 是一个使用了某种策略的类。</span><br><span class="line"></span><br><span class="line">*StrategyPatternDemo*，我们的演示类使用 *Context* 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。</span><br></pre></td></tr></table></figure><h1 id="消息中心"><a href="#消息中心" class="headerlink" title="消息中心"></a>消息中心</h1><p>其他消息中心的框架</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/v2-6e106b2f315cbcbfaade5cdf3549c6cb_1440w.webp" alt="img"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/v2-86fd1d11849ffcac20facdfe9b2ea2da_r.jpg" alt="img"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/f9272b1d53494032aada49baf7241c6c.png" alt="img"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240428225844257.png" alt="image-20240428225844257"></p><p>在校期间呢，参与了老师的一个校企合作项目—-数梦工厂的消息中心，学习了Java以及Spring，Mybatis的相关知识，消息中心主要基于Spring和mybatisPlus实现数据库的操作和Web接口服务，我主要负责了模版表的设计优化，以及用户侧代码的编写</p><h1 id="面试总结-1"><a href="#面试总结-1" class="headerlink" title="面试总结"></a>面试总结</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">面试官您好，我叫方圆，目前是杭州电子科技大学通信工程专业研二的学生，</span><br><span class="line">本科也是杭电通信工程，在学校的学习期间呢，对通信和计算机的相关专业课程都有所涉及，</span><br><span class="line">熟悉Java语言，对spring boot进行web开发有一定的实践。</span><br><span class="line"></span><br><span class="line">读研期间呢，参与了老师的一个横向课题，参与了数梦工厂消息中心项目，</span><br><span class="line">负责开发其中的一个模块，我主要负责的是平台侧消息模板的创建和管理，</span><br><span class="line">还有用户侧消息的管理，包括搜索，查看，标记已读删除等，消息推送等</span><br><span class="line"></span><br><span class="line">后来项目结束后，为了丰富自己web开发的相关知识，去学习了Redis缓存的相关知识，</span><br><span class="line">开发了一个类似大众点评的单体web应用，</span><br><span class="line">并且在结束后用Docker部署在自己的虚拟机中，用nginx做了负载均衡的配置</span><br><span class="line"></span><br><span class="line">同时呢，我也习惯于整理和分享自己的所学知识，为此我基于hexo 搭建了自己的网站，</span><br><span class="line">主要分享技术学习经历，还有一些日常和遇到的bug问题。</span><br><span class="line"></span><br><span class="line">因为直接在学习的过程中用到过的云业务比较多，</span><br><span class="line">比如，域名服务，对象存储服务，还有短信服务，当然云端的业务还有很多，</span><br><span class="line">还有我上届的师兄师姐也在华为云部门，我认为以后大家的使用的云端都很多，</span><br><span class="line">会有很大的发展空间，期待能获得这次实习的机会。</span><br></pre></td></tr></table></figure><h1 id="DTphere消息中心-1"><a href="#DTphere消息中心-1" class="headerlink" title="DTphere消息中心"></a>DTphere消息中心</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">这个消息中心的项目，分为平台侧（管理的人去看的）和用户侧（用户去看的）</span><br><span class="line">在平台侧呢</span><br><span class="line">消息的管理</span><br><span class="line"></span><br><span class="line">模版管理</span><br><span class="line"> --对不同的渠道，钉钉，微信，短信，邮件设计不同的消息模版</span><br><span class="line"> --设计实体关系图，一张表维护不同的消息模版Id</span><br><span class="line"> --每个Id作为外键关联一张模板表</span><br><span class="line"> </span><br><span class="line">渠道管理</span><br><span class="line"> --渠道管理负责去配置各个渠道的信息，短信，邮件，企业微信，钉钉机器人等</span><br><span class="line"> --引入钉钉，微信等相关依赖，配置用户名密码服务器去做测试链接</span><br><span class="line">用户侧：</span><br><span class="line">全部类型消息的查看</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line">告警消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line">系统消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line">审批消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line">产品消息</span><br><span class="line">--搜索，查看，标记已读未读，删除消息等</span><br><span class="line"></span><br><span class="line">对需要删除的消息：用AOP日志记录</span><br><span class="line">使用yapi.pro那个平台编写接口文档，做接口文档的开发</span><br></pre></td></tr></table></figure><p>这个消息中心的项目，分为平台侧（管理的人去看的）和用户侧（用户去看的）</p><h2 id="平台侧-1"><a href="#平台侧-1" class="headerlink" title="平台侧"></a>平台侧</h2><ul><li>消息的管理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--绑定管理，将产品与消息模板绑定，当前产品对应的消息模板</span><br><span class="line">--这里是新建一张绑定关系表，将产品Id和模板Id对应起来</span><br><span class="line">查询模版、查询产品消息、绑定、回显</span><br></pre></td></tr></table></figure><ul><li>模版管理</li></ul><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240513091758796.png" alt="image-20240513091758796" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> --对不同的渠道，钉钉，微信，短信，邮件设计不同的消息模版</span><br><span class="line"> --设计实体关系图，一张表维护不同的消息模版Id，</span><br><span class="line"> --每个Id作为外键关联一张模板表</span><br><span class="line"> --我在开始数据库中创建了五张模板表，分别对应五种消息</span><br><span class="line"> --（后来就是五张表维护起来太麻烦了，每次增删改查还要在不同表里</span><br><span class="line">  还要创建一个模版表去记录创建好的所有Id）</span><br><span class="line"> --优化就是：因为模版表有很多相同的字段，创建一张表整合所有字段，</span><br><span class="line"> 没有设置的字段，就默认为null</span><br><span class="line"> 然后再新建五个vo类作为返回给前端的消息实体类，去封装对应模版的信息</span><br><span class="line"> </span><br><span class="line"> 不同的消息模板有不同的字段，我根据它们提供的图去在数据库中创建模板</span><br><span class="line"> 这里是参照了它们官方提供的开发手册</span><br><span class="line"> 定义字段的时候，选择合适的字段内容来建标</span><br><span class="line">字符串就结合存储的内容来使用char  或者varchar</span><br><span class="line">用户名称邮箱类型的可变，使用varchar</span><br><span class="line">文章内容使用text</span><br><span class="line">邮编长度使用char等等</span><br><span class="line">模版类型这里，因为只有几个嘛，开始用的int，后来该改的tinyint</span><br><span class="line"></span><br><span class="line">优化这里：针对test过大的问题，在数据库中做了垂直分割</span><br><span class="line">就是将表中除了text的字段和其他字段分割，用</span><br><span class="line">将text字段放在另一张表中，只需要在详细时访问</span><br></pre></td></tr></table></figure><ul><li>渠道管理</li></ul><p>​下图只是举例，</p><p>​我们是：邮件、短信、企业微信、钉钉机器人、钉钉联系人等（字段也不同）</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240513095713632.png" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--渠道管理负责去配置各个渠道的信息，短信，邮件，企业微信，钉钉机器人等</span><br><span class="line">--引入钉钉，微信等相关依赖，配置用户名密码服务器等</span><br><span class="line"></span><br><span class="line">我们负责测试，前端同学将这些参数封装在json中传递</span><br><span class="line">我们后端负责接受这些参数，然后在后台调用依赖</span><br><span class="line">尝试去获取消息，获取成功就测试成功</span><br><span class="line"></span><br><span class="line">邮件的话：我们是链接163邮箱，配置服务器，端口，这里是去163官网查看了相关demo</span><br><span class="line">短信：引入它们自己的api,提供的了网关插件地址，去做测试链接</span><br><span class="line">钉钉机器人、联系人、企业微信：都是去官方调用官方API</span><br><span class="line">看它们的示例demo，去做配置</span><br><span class="line">引入了第三方的依赖，去做测试链接</span><br></pre></td></tr></table></figure><ul><li>消息分类统计展示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从不同维度统计及展示消息发送情况</span><br><span class="line">例如根据消息的通知渠道、来源产品、消息分类(告警类型、工单提醒、license提醒)等。</span><br></pre></td></tr></table></figure><h2 id="用户侧-1"><a href="#用户侧-1" class="headerlink" title="用户侧"></a>用户侧</h2><p>主要是对站内信的处理（从它们数据库中获取）</p><ul><li>全部类型消息–  告警消息、系统消息、审批消息、产品消息</li><li>未读消息</li><li>已读消息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">这个就是对站内消息的处理</span><br><span class="line">文档中给的需求是，查看，搜索，标记已读，删除，分页查找，批量删除等</span><br><span class="line">并没有给我们接口文档。我们就先在实现的时候，根据功能编写接口文档</span><br><span class="line">我们找了yapi.pro去编写</span><br><span class="line"></span><br><span class="line">我们自己定义的规范就是，基于RESTful API定义的</span><br><span class="line">用户侧就/user开头</span><br><span class="line">说明请求参数，路径参数或者是实体参数开头的</span><br><span class="line">定义Result返回值对象，返回标准的响应值（响应码，响应信息，响应数据data等）</span><br><span class="line">数据库的实体参数作为DTO类，响应给前端的不一定是全部的字段</span><br><span class="line">所以创建一个vo实体类，封装专门响应给前端的信息</span><br><span class="line">（这里就用到了Hutul工具类的拷贝方法，不用一行一行复制很麻烦）</span><br><span class="line"></span><br><span class="line">在删除的时候，因为涉及到数据库的操作，所以需要记录日志</span><br><span class="line">（这里自定义了@logo注解和切面类@Aspect，用AOP的相关知识）</span><br><span class="line"></span><br><span class="line">难点：未读消息的推送：</span><br><span class="line">我们一开始这里写的是，去遍历数据库去查询，去查询未读的字段</span><br><span class="line">（这样做性能不是很高，但是先实现了功能，后来它们测试让我们修改）</span><br><span class="line">后来我们对是否已读字段加了索引，提高查询的效率</span><br><span class="line">用web socket去代替传统的轮询，实现主动的消息推送</span><br><span class="line">引入了web socket依赖  </span><br><span class="line">创建消息处理器，来控制和发送接受消息</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redis的数据类型-1"><a href="#Redis的数据类型-1" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><p>以及每种数据类型的使用场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String类型：Redis最常见的数据结构，可以存储任何数据，字符串，整形，浮点型都可以，不管用哪儿种方式，底层都是以字节数组的形式存储的，适用于绝大多数场景</span><br><span class="line"></span><br><span class="line">列表List：相当于Java中的linkedList，列表是链表结构，可以做简单的消息队列功能,但一般不用Redis消息队列</span><br><span class="line"></span><br><span class="line">集合分为集合和有序集合，</span><br><span class="line"></span><br><span class="line">集合set：没有重复元素的集合嘛，一般用于点赞，我们维护一张点赞的表，每次用户请求点赞的时候，我们先用StringRedisTemplete.opsForSet()得到操作Redis中set集合的接口，调用其中的isMember()，去判断点赞是否存在，不存在就用add加入，再跟新到数据库，存在就返回已经点赞</span><br><span class="line"></span><br><span class="line">共同好友也是，在关注的时候，把当前ID的关注列表以set形式存储到Redis中，然后，用set求交集的interset()</span><br><span class="line">就可以求得共同的好友交集，</span><br><span class="line"></span><br><span class="line">有序集合sorted set：相对于集合set，是有顺序的，每个元素都会关联一个权重，按照权重进行排序，</span><br><span class="line">我主要用在点赞的排行傍等，使用的权重是时间，点赞时间早的会排序在前面，用ZSET的range(key，0,4)方法得到排行前几的，</span><br><span class="line">当然不同的排行傍会有不同的权重，可以是分数或者其他，使用权重排序的方式是不变的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">哈希hash：键值对，适合缓存对象的存储，因为我们Redis本来就是以键值对key-value的形式存储的，一般hash存储用在value属性中，value属性存储的也是一对键值对</span><br><span class="line"></span><br><span class="line">位图bigMap：用于存储二进制数据，可以位运算，统计用户签到比较方便</span><br><span class="line"></span><br><span class="line">地理位置GEO：用于存储地理位置的数据结构，我们在数据库中将存放地理位置坐标的位置信息用stringRedisTemplete.opsForGeo接口的add方法存储到Redis中，再调用Geodistance查找距离，GeoRadius查询一定范围内的餐厅（这个需要先把商铺位置数据存储到Redis中去）</span><br><span class="line"></span><br><span class="line">HyperLogLog:基于基数的数据结构，支持对大量元素的去重统计，占用和误差很小，</span><br><span class="line">用于网站的访问统计等，底层是概率估算，</span><br><span class="line">我们首先要在线程池里获得当前用户的唯一标识，</span><br><span class="line">针对访客数，和访问量选取不同的标识</span><br><span class="line">针对访客数，因为是不可重复的，可以选用唯一账户ID等</span><br><span class="line">针对访问量，可以重复，当前线程中拿到的cookie即可</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="项目具体功能的实现逻辑-1"><a href="#项目具体功能的实现逻辑-1" class="headerlink" title="项目具体功能的实现逻辑"></a>项目具体功能的实现逻辑</h2><p>1.短信验证码的发送，登录、注册、校验</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">发送短信验证码：对手机号进行格式校验，然后随机生成验证码，引用阿里云的依赖并做配置文件的配置，然后响应给前端</span><br><span class="line"></span><br><span class="line">登录：得到手机号和验证码之后，去判断验证码是否正确，正确就登录成功，再去数据库中判断是否存在，不存在就创建一个用户，保存到数据库中，同时用uuid生成一个唯一的token作为key去在Redis中存放用户数据，设置一个过期时间</span><br><span class="line"></span><br><span class="line">校验登录状态是：设置一个拦截器prehandle，去拦截登录请求，获取token，去Redis中判断token是否存在，如果存在的话，就保存当前用户到线程池当中，这样我们后续在其他地方获取当前用户信息就只需要在线程池中获取即可</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cookie和session会话跟踪技术，去管理用户的状态，因为HTTP响应是无状态的，每次请求都是独立的，下次的请求不会携带上次的数据，所以需要会话跟踪技术</span><br><span class="line">cookie是客户端会话跟踪技术，存储数据在客户端浏览器中</span><br><span class="line"></span><br><span class="line">session是服务端会话跟踪技术，数据存储在服务端中</span><br><span class="line">底层通过cookie发送，只需要发送JessieId就可以了，在服务端就可以找到对应Id所在的当前数据</span><br><span class="line">相比于cookie会更安全一些</span><br></pre></td></tr></table></figure><p>2.Redis分布式锁的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透：就是大量请求的数据在缓存和数据库中都不存在，就会造成给数据库请求压力大的情况</span><br><span class="line"></span><br><span class="line">解决方法有：</span><br><span class="line">缓存空对象在缓存中</span><br><span class="line">布隆过滤：就是在Redis和客户端之间再加了一层布隆过滤器，存在则通过，不存在则拒绝，</span><br><span class="line">布隆过滤器是用hash思想实现的，它底层是一个庞大的二进制数组</span><br><span class="line">来了一个key之后对这个key取模存入数组</span><br><span class="line">再来就可以判断它key是否存在了</span><br><span class="line">当然有hash的地方就不可避免有hash冲突，但因为它底层数组够大，冲突不超过5%</span><br><span class="line"></span><br><span class="line">缓存击穿：缓存击穿就是，热点击穿嘛，热点key失效，很多线程来重建key，造成数据库的压力</span><br><span class="line">解决方法就是</span><br><span class="line">1.互斥锁，最先来的线程获取锁，去执行key的重建，其他的线程就会被阻塞</span><br><span class="line">2.逻辑过期：就是存储一个过期的时间的字段到缓存中，但我们并不设置过期时间</span><br><span class="line">当请求达到的时候，从缓存中获取数据，去判断一下这个过期字段，若过期则认为失效</span><br><span class="line">失效的时候，就开启另外一个线程，去更新缓存的逻辑过期时间</span><br><span class="line">当前线程就返回旧的数据</span><br><span class="line">利弊：互斥锁保证了数据的一致性，但是会收到锁竞争的影响，考虑死锁的问题</span><br><span class="line">逻辑过期保证了高的可用性，但是可能会出现数据不一致的问题</span><br><span class="line"></span><br><span class="line">缓存雪崩：就是我们设置key的时候，设置了一样的过期时间，导致一起失效，数据直接打到数据库的时候</span><br><span class="line">缓存雪崩与击穿不同的是，击穿是一个热点key失效，雪崩是很多key通用失效</span><br><span class="line">解决方法就是：在原有的失效时间的基础上，随机增加几分钟的随机值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">分布式锁的实现：简单来说就是用setnx这个方法，去在Redis中设置锁，如果插入key成功别人就获取不到，相当于加锁</span><br><span class="line">setex获取锁的过期时间，最后在完成业务逻辑之后，再去删除释放锁</span><br><span class="line"></span><br><span class="line">因为执行逻辑和删除是有时间差的，为了确保锁的一致性，防止极端宕机情况，最好使用lua脚本去执行锁的创建和删除</span><br><span class="line">lua脚本在Redis中执行是单线程的，所以一定会确保执行的时候的原子性</span><br><span class="line"></span><br><span class="line">当然自己实现的还是会有很多考虑不到的地方，比如可重入啊，可靠啊等等</span><br><span class="line">后面都是引入Redis依赖，用redisson的分布式锁实现的</span><br><span class="line">底层会有看门口机制解决死锁的问题，死锁就是业务逻辑异常导致锁无法释放的问题</span><br><span class="line">看门狗机制会在获取锁成功后启动任务，更新锁的过期时间，避免死锁的发生</span><br><span class="line"></span><br><span class="line">乐观锁和悲观锁：</span><br><span class="line">悲观锁：假定一定会发生多线程的问题，就只允许单线程执行，比如Synchronized关键字</span><br><span class="line">乐观锁：允许多线程，但是会有一个版本号，只是在更新数据的时候，</span><br><span class="line"> 判断是否其他线程对数据进行了修改，是的话重试即可</span><br></pre></td></tr></table></figure><p>3.lua脚本实现高并发环境下的一人一单和线程安全问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">就是在lua脚本中去定义本地的处理逻辑</span><br><span class="line">检查本地的数量是否足够</span><br><span class="line">判断用户是否已经下单</span><br><span class="line">再去减库存</span><br><span class="line">返回操作结果</span><br><span class="line"></span><br><span class="line">rabbitMQ消息队列：</span><br><span class="line">生产者去创建一个交换机，交换机负责投递消息到哪儿一个队列，队列再把消息传给消费者处理</span><br><span class="line">用注解@RabbitListener去配置</span><br></pre></td></tr></table></figure><p>4.点赞，共同关注，排行榜</p><p>5.地理位置下的店铺查询</p><p>6.统计访问量和访客量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始使用了session做登录校验，从当前线程里获取到session但是session在分布式中不能共享，所以</span><br><span class="line">集成阿里云的短信服务，就是引入了阿里云的依赖，先是对，做了配置文件的配置，</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Redis的相关面试题</p><p>Redis和MySQL如何做读写一致性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.缓存过期嘛，定期的从sql中加载最新的数据</span><br><span class="line">2.做数据更改时候，不直接更新Redis而是删除缓存，下次访问时候未命中再更新</span><br><span class="line">3.最终一致性：使用消息队列异步处理</span><br></pre></td></tr></table></figure><p>Redis持久化是怎么做的呢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">两种持久化方案：</span><br><span class="line">1.快照文件，把Redis存储的数据保存到磁盘上，方便宕机的时候做数据恢复</span><br><span class="line">2.追加文件，Redis操作写操作的时候，会存储到这个文件中去</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Redis的数据过期策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">惰性删除：一般不管，我们使用到key后，如果判断过期再删除</span><br><span class="line">定期删除：每隔一段时间对key进行检查，定期清理</span><br><span class="line">一般Redis中的过期删除策略，是结合这两部分来的</span><br></pre></td></tr></table></figure><p>Redis淘汰策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">很多，一把用LRU，对最近少使用的key淘汰</span><br></pre></td></tr></table></figure><p>Redis集群</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主从复制：数据从一个主节点复制到其他节点</span><br><span class="line">哨兵模式：哨兵作为独立的节点监控集群，发生故障时候执行故障转移</span><br><span class="line">分片模式：将数据分片到多个节点上</span><br></pre></td></tr></table></figure><p>Linux常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用Redis和</span><br><span class="line">文件操作：ls,ll,</span><br><span class="line">进入目录：cd..  cd/  cd</span><br><span class="line">显示路径：pwd</span><br><span class="line">创建目录 mkdir</span><br><span class="line">删除：rf</span><br><span class="line">复制：cp</span><br><span class="line">移动：mv</span><br><span class="line"></span><br><span class="line">tar -zxvf解压</span><br><span class="line">ping</span><br><span class="line">ipconfig</span><br><span class="line">sudo</span><br><span class="line">等等</span><br></pre></td></tr></table></figure><p>项目部署docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">使用docker，我们需要将项目打个包为镜像，镜像包含应用的本身，也包含运行的环境依赖等等</span><br><span class="line">docker在运行的时候会创建一个容器，运行我们的镜像文件</span><br><span class="line"></span><br><span class="line">使用docker很方便</span><br><span class="line">我用docker在我的虚拟机中创建运行了</span><br><span class="line">MySQL</span><br><span class="line">Redis</span><br><span class="line">rabbitmq</span><br><span class="line">openjdk</span><br><span class="line">nginx</span><br><span class="line">注意的是：Redis和MySQL需要进行目录的挂载</span><br><span class="line">将容器内的目录映射到外边来</span><br><span class="line">这样我们删除创建容器的时候，数据不会丢失</span><br><span class="line"></span><br><span class="line">并且将自己的项目文件用Maven打包，构建dockerFile构建镜像</span><br><span class="line">然后再执行构建镜像即可</span><br></pre></td></tr></table></figure><p>nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">启动nginx，在配置文件中修改参数</span><br><span class="line">监听我程序运行的端口80</span><br><span class="line">然后反向代理给启动的两个服务：8080和8081</span><br><span class="line">选择负载均衡的方法有：轮询，最少连接，哈希等</span><br></pre></td></tr></table></figure><h1 id="数据库MySQL-1"><a href="#数据库MySQL-1" class="headerlink" title="数据库MySQL"></a>数据库MySQL</h1><p>数据库事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一系列的数据库操作被当作一个单独的逻辑单元，要么全部执行，要么全部回滚</span><br><span class="line">数据库事务是为了确保事务的完整性和一致性</span><br><span class="line">数据库事务由四个属性组成ACID</span><br><span class="line">原子性：要么全部执行，要么全部回滚</span><br><span class="line">一致性：事务执行前后，数据库的数据处于一致状态</span><br><span class="line">隔离性：每个事务独立于其他事务</span><br><span class="line">持久性：事务执行成功，就是持久的</span><br><span class="line"></span><br><span class="line">在sql中使用 start Transaction作为事务的开启，rollback回滚，commit提交</span><br><span class="line">在spring框架中，在service层使用注解@Transactional开启事务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">索引是一种特殊的数据结构，用于加快数据库中数据的查询速度</span><br><span class="line">类似于书中的目录，可以帮助快速查找目录</span><br><span class="line"></span><br><span class="line">使用create index ...去为字段创建索引</span><br><span class="line">一般来讲是where子句中频繁出现的列，在表的特定列上创建索引</span><br><span class="line"></span><br><span class="line">主键是会自动创建索引的</span><br><span class="line">索引的底层是通过B+树来存放的，我们创建索引时候</span><br><span class="line">会将当前字段插入B+树</span><br><span class="line">B+树是一个多路平衡查找树，</span><br><span class="line">所有叶子节点包含全部的键相互连接，方便查找</span><br><span class="line">非叶子节点只做索引，不含实际数据</span><br></pre></td></tr></table></figure><p>锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在并发访问时候，解决数据一致性和有效性的机制</span><br><span class="line">全局锁：对整个数据库加锁，在备份的时候加锁 flush tables with readlock</span><br><span class="line">表级锁：锁表 lock tables..</span><br><span class="line">行级锁：锁行 lock </span><br></pre></td></tr></table></figure><p>sql优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.建标的时候选择合适的类型</span><br><span class="line">2.使用索引</span><br><span class="line">3.sql语句的编写</span><br><span class="line">尽量避免select*的情况，查询具体的字段</span><br><span class="line">    尽量少用子查询，用join关联查询代替</span><br><span class="line">尽量不使用or，导致索引失效，分开几条sql写</span><br><span class="line">执行的时候，批量插入，而不是一条一条插入，分批删除</span><br><span class="line">避免索引失效的写法</span><br><span class="line">4.主从复制</span><br><span class="line">5.读写分离</span><br><span class="line"></span><br><span class="line">建标选择合适的类型</span><br><span class="line">参考的是阿里云的开发手册，定义字段的时候，选择合适的字段内容来建标</span><br><span class="line">字符串就结合存储的内容来使用char  或者varchar</span><br><span class="line">用户名称邮箱类型的，使用varchar</span><br><span class="line">文章内容使用text</span><br><span class="line">邮编长度使用char等等</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sql的执行顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select * from where groupby having orderby limit</span><br><span class="line"></span><br><span class="line">先执行from语句，查询确定查的表</span><br><span class="line">再是链接条件，join on</span><br><span class="line">再是where 过滤符合条件的</span><br><span class="line">再groupby分组</span><br><span class="line">having分组后过滤</span><br><span class="line">最后排序，limit输出</span><br><span class="line"></span><br><span class="line">where是分组前过滤，having是分组后过滤</span><br></pre></td></tr></table></figure><h1 id="spring-Web框架-1"><a href="#spring-Web框架-1" class="headerlink" title="spring Web框架"></a>spring Web框架</h1><p>spring框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring是Java开发的框架，有很多模块</span><br><span class="line">spring框架的web开发模块，就是springMVC</span><br><span class="line">springMVC + spring framework + Mybatis 就是俗称SSM</span><br><span class="line">springboot整合了ssm，快速开发</span><br></pre></td></tr></table></figure><p>IOC控制反转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是一种设计模式，将原本在程序中手动创建对象的控制权，交给spring框架来管理</span><br><span class="line">IOC容器就是工厂一样，当我们需要创建一个对象的时候</span><br><span class="line">只需要用注解@Autowired，而不需要考虑对象是如何创建出来的</span><br><span class="line"></span><br><span class="line">Bean指的是被IOC容器所管理的对象</span><br></pre></td></tr></table></figure><p>AOP面相切面编程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AOP是spring的核心框架之一，它在程序运行时动态将额外的行为</span><br><span class="line">比如记录日志操作，事务处理，方法运行时间等功能，额外的插入到代码中</span><br><span class="line"></span><br><span class="line">它是通过动态代理的方式实现的</span><br><span class="line">实现proxy类的方法，生成代理对象，在其他地方通过去通过代理对象调用方法</span><br><span class="line"></span><br><span class="line">我在项目中用AOP的实现过程，对数据库修改操作的日志记录的实现过程</span><br><span class="line">创建操作日志的表格嘛，操作人Id，时间方法参数等</span><br><span class="line">根据表格创建实体类</span><br><span class="line">自定义注解@log和切面类@ASpect</span><br><span class="line">注解表示在切面类中使用切面表达式，@Around，@Before前置循环后置，将注解引入进来</span><br><span class="line">并写入插入数据库的逻辑</span><br><span class="line">这样只需要在方法中加入自定义注解就可以实现记录日志操作的过程</span><br></pre></td></tr></table></figure><p>spring框架用到了哪儿些设计模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单例模式：spring中的bean是单例的，通过IOC容器对Bean管理，保证整个应用只有一个Bean实例</span><br><span class="line">工厂模式：springIOC负责容器的创建和管理实例，可以将IOC看做是一个工厂</span><br><span class="line">我们不需要知道对象是如何创建的</span><br><span class="line">只需要用注解直接注入对象就行</span><br><span class="line"></span><br><span class="line">代理模式：spring的AOP面相切面编程就用到了代理模式</span><br><span class="line">实现proxy类的方法，生成代理对象，在其他地方通过代理对象去调用方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>spring事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Trancsacyional注解</span><br><span class="line">事务的传播，如果当前有事务，就加入该事务，如果没有，就创建新的事务</span><br></pre></td></tr></table></figure><p>spring的常用注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">最先就是启动注解@SpringBootApplication了，里面包含三个注解</span><br><span class="line">然后就是三层架构的</span><br><span class="line">@RestController @Service @MApper</span><br><span class="line"></span><br><span class="line">在controller层</span><br><span class="line">去处理请求HTTP相关的注解</span><br><span class="line">@GetMapping @PostMapping @DeleteMapping等</span><br><span class="line">传值相关的注解</span><br><span class="line">@RequestBody @PathVariable @RequestParam等</span><br><span class="line">mapper层的数据库注解</span><br><span class="line">@Insert @Select @Delete 等等</span><br><span class="line"></span><br><span class="line">还要通用的 @AutWired @configuration @Transcactional等等</span><br></pre></td></tr></table></figure><p>mybatis 和mybatisPlus的联系区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mybatis是用Java操作数据的的持久层框架，主要使用xml或者注解来配置sql语句</span><br><span class="line">使用时，会创建数据库连接池，解决了资源重用，提示响应</span><br><span class="line"></span><br><span class="line">MP内置了增删改查，通过扫描实体类，基于反射获取实体类的信息，作为数据库的信息表</span><br><span class="line">一般来讲，单表的增删改查就有MP实现</span><br><span class="line">多表的联合查询就没法用MP了，用mybatis去写</span><br><span class="line"></span><br><span class="line">MP自带了分页查询插件，不用去引入第三方的依赖，很方便</span><br><span class="line">创建一个Page&lt;&gt;对象，然后调用selectPage（）方法</span><br></pre></td></tr></table></figure><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/p9SowJU.png" alt="img" style="zoom: 67%;"><p>汇总</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">其中内存模型、类加载机制、GC是重点方面，性能调优部分更偏向应用，重点突出实践能力，编译器优化和执行模式部分偏向于理论，重点掌握知识点</span><br><span class="line">需了解内存模型各部分作用，保存哪些数据</span><br><span class="line">类加载：双亲委派机加载机制，常用加载器分别加载哪种类型的类</span><br><span class="line">GC分代回收的思想和依据，以及不同垃圾回收算法的回收思路和适合场景</span><br><span class="line">性能调优：常用JVM优化参数作用、参数调优的依据、常用的JVM分析工具能分析哪些问题以及使用方法</span><br><span class="line">执行模式：解释、编译、混合模式的优缺点，Java7提供的分层编译技术、JIT即时编译技术、OSR栈上替换、C1/C2编译器针对的场景</span><br><span class="line">编译器优化：javac的编译过程、ast抽象语法树、编译器优化和运行期优化</span><br></pre></td></tr></table></figure><p>详解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JVM内存模型</span><br><span class="line">线程独占：栈、本地方法栈、程序计数器</span><br><span class="line">线程共享：堆、方法区</span><br><span class="line">栈</span><br><span class="line">又称方法栈，线程私有的，线程执行方法是都会创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈</span><br><span class="line">本地方法栈</span><br><span class="line">与栈类似，也是用来保存执行方法的信息，执行Java方法是使用占，执行Native方法时是使用本地方法栈</span><br><span class="line">程序计数器</span><br><span class="line">保存当前线程执行的字节码位置，每个线程工作时都有独立的计数器，值为执行Java方法服务，执行Native方法时，程序计数器为空</span><br><span class="line">堆</span><br><span class="line">JVM内存管理最大的一块，堆被线程共享，目的是存放对象的实例，几乎所有对象的实例都会放在这里。当堆没有可用空间时，会抛出OOM异常(Out of Menory内存溢出)，根据对象的存活周期不同，JVM把对象进行分代管理，由垃圾回收器进行垃圾的回收管理</span><br><span class="line">方法区</span><br><span class="line">又称非堆区，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器优化后的代码等数据</span><br><span class="line">1.7的永久代和1.8的源空间都是方法区的一种实现</span><br><span class="line">JVM内存可见性</span><br><span class="line">JMM是定义程序中变量的访问规则，线程对变量的操作只能在自己的工作内存中进行，而不能直接对主内存操作，由于指令重排，可能会导致读写的顺序被打乱，因此JMM需要提供原子性、可见性、有序性保证</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMq</title>
      <link href="/2024/04/15/Java/RabbitMQ/"/>
      <url>/2024/04/15/Java/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="初始MQ"><a href="#初始MQ" class="headerlink" title="初始MQ"></a>初始MQ</h1><p>高性能异步通信组件</p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。</p><p>所以，如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="同步调用："><a href="#同步调用：" class="headerlink" title="同步调用："></a>同步调用：</h2><p>拓展性差</p><p>性能下降</p><p>级联失败</p><h2 id="异步调用："><a href="#异步调用：" class="headerlink" title="异步调用："></a>异步调用：</h2><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。<br>这样，发送消息的人和接收消息的人就完全解耦了。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240416004035913.png" alt="image-20240416004035913"></p><p>综上，异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li><li>缓存消息，流量削峰填谷</li></ul><p>当然，异步通信也并非完美无缺，它存在下列缺点：</p><ul><li><p>不能立即得到结果，时效性差</p></li><li><p>不确定下游业务是否成功</p></li><li><p>完全依赖于Broker（消息代理）的可靠性、安全性和性能</p></li><li><p>架构复杂，后期维护和调试麻烦</p></li></ul><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.<br>目比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般（十万）</td><td>差</td><td>高</td><td>非常高（百万）</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ<br>追求可靠性：RabbitMQ、RocketMQ<br>追求吞吐能力：RocketMQ、Kafka<br>追求消息低延迟：RabbitMQ、Kafka</p><p>据统计，目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此我们课堂上选择RabbitMQ来学习。</p><h1 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：<br><a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>还去学了docker，傻瓜式安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=fangyuan\</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123456\</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>RabbitMQ对应的架构图</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240416205811053.png" alt="image-20240416205811053"></p><p>其中包含几个概念：</p><ul><li><code>**publisher**</code>：生产者，也就是发送消息的一方</li><li><code>**consumer**</code>：消费者，也就是消费消息的一方</li><li><code>**queue**</code>：<code>队列，存储消息</code>。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><code>**exchange**</code>：<code>交换机，负责消息路由</code>。生产者发送的消息由交换机决定投递到哪个队列。</li><li><code>**virtual host**</code>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p>上述这些东西都可以在RabbitMQ的管理控制台来管理</p><h2 id="收发消息"><a href="#收发消息" class="headerlink" title="收发消息"></a>收发消息</h2><p>我们打开Exchanges选项卡，可以看到已经存在很多<code>交换机</code>：<br><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1687137953880-08aa9694-6a1e-4337-8bde-5757ec3c33f8.png" alt="image.png"><br>我们点击任意交换机，即可进入交换机详情页面。</p><p><strong>队列queue</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240416214509390.png" alt="image-20240416214509390"></p><p><strong>绑定关系</strong></p><p>只有交换机绑定了相应的队列，才知道如何发送消息，给谁发送消息</p><p><strong>数据隔离</strong></p><p>不同的用户可以创建不同的虚拟主机，不同的虚拟主机之间是隔离的</p><h1 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h1><p><strong>AMQP</strong> ：Advanced Message Queuing Protocol</p><p>由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。<br>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>不过有时候为了测试方便，我们也可以直接向队列发送消息，跳过交换机。<br>在入门案例中，我们就演示这样的简单模型，如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687261777988-23fff732-dcfa-499a-a8a1-a66328fe05e7.jpeg"><br>也就是：</p><ul><li>publisher直接发送消息到队列</li><li>消费者监听并处理队列中的消息</li></ul><p>:::warning<br><strong>注意</strong>：这种模式一般测试使用，很少在生产中使用。<br>:::</p><h2 id="配置MQ地址："><a href="#配置MQ地址：" class="headerlink" title="配置MQ地址："></a><strong>配置MQ地址：</strong></h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.239</span><span class="number">.129</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">fangyuan</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><h2 id="消息发送："><a href="#消息发送：" class="headerlink" title="消息发送："></a>消息发送：</h2><p>在测试类中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQ</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;hello.queue1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mes</span> <span class="operator">=</span> <span class="string">&quot;hello,amqp!&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName,mes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqListener</span> &#123;</span><br><span class="line">    <span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;hello.queue1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listensSimpleQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者收到了hello.queue1的消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong>，接收成功</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417001725072.png" alt="image-20240417001725072"></p><h2 id="WorkQueues模型"><a href="#WorkQueues模型" class="headerlink" title="WorkQueues模型"></a>WorkQueues模型</h2><p>Work queues，任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1687261956699-4b3c9999-ee86-4dda-a795-1ea5f4f9eef3.jpeg"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。<br>此时就可以使用work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>接下来，我们就来模拟这样的场景。</p><p><strong>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这两消费者，都设置了<code>Thead.sleep</code>，模拟任务耗时：</p><ul><li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li><li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li></ul><p>测试结果：发现是轮循，一人处理一个</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。没有充分利用每一个消费者的能力，最终消息处理的耗时远远超过了1秒。这样显然是有问题的</p><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>再次测试，发现结果如下：</p><p>消费者1的处理结果是2的十倍了，符合我们设置的延时效果。提升了效率</p><h1 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h1><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><h2 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。<br>在广播模式下，消息发送流程是这样的：<br><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1687181415478-ea4bb17b-48bf-4303-9242-27703efb39d8.png" alt="image.png"></p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><p>@RabbitListener(queues &#x3D; “fanout.queue1”)</p><p>这个注解里面不仅可以指定，队列的名称，也可以指定交换机的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h2><p>但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417005741490.png" alt="image-20240417005741490"></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p>rabbitTemplate.convertAndSend(exchangeName, “路由key”, message);</p><p><strong>总结：</strong></p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><h2 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h2><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。<br>只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>BindingKey</code> 的时候使用通配符！</p><p><code>BindingKey</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如： <code>item.insert</code></p><p><code>通配符规则：</code></p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配不多不少恰好1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></li><li><code>item.*</code>：只能匹配<code>item.spu</code></li></ul><p>图示：<br><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1687183148068-ad50ba76-0024-460b-9b24-3cf7a0fe172e.png" alt="image.png"><br>假如此时publisher发送的消息使用的<code>RoutingKey</code>共有四种：</p><ul><li><code>china.news </code>代表有中国的新闻消息；</li><li><code>china.weather</code> 代表中国的天气消息；</li><li><code>japan.news</code> 则代表日本新闻</li><li><code>japan.weather</code> 代表日本的天气消息；</li></ul><p>解释：</p><ul><li><code>topic.queue1</code>：绑定的是<code>china.#</code> ，凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到，包括：<ul><li><code>china.news</code></li><li><code>china.weather</code></li></ul></li><li><code>topic.queue2</code>：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括:<ul><li><code>china.news</code></li><li><code>japan.news</code></li></ul></li></ul><h1 id="声明队列和交换机"><a href="#声明队列和交换机" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h1><p>在config中声明一个配置类，用@Configuration注解声明为配置类，@Bean表示在声明时候就加载在Bean对象中</p><p>SpringAMQP提供了一个Queue类，用来创建队列：</p><p>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明交换机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;hmall.fanout&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第1个队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定队列和交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 第2个队列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="direct实例"><a href="#direct实例" class="headerlink" title="direct实例"></a>direct实例</h2><p>direct模式由于要绑定多个KEY，会非常麻烦，每一个Key都要编写一个binding：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Direct类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithRed</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithBlue</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>绑定交换机和队列的时候，key参数一次只能用with传递一次。太麻烦</p><h2 id="基于注解声明"><a href="#基于注解声明" class="headerlink" title="基于注解声明"></a>基于注解声明</h2><p>注解的嵌套，人嘛了，记不住再回来看</p><p><strong>在注解@RabbitListener()中使用@Queuebinding（）声明队列，交换机，和绑定参数</strong></p><p>导包别导错了，全是注解类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h1><p>Spring的消息发送代码接收的消息体是一个Object：</p><p>而在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<br>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><h2 id="配置JSON转换器"><a href="#配置JSON转换器" class="headerlink" title="配置JSON转换器"></a>配置JSON转换器</h2><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。</p><p>配置消息转换器，在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转换器中添加的messageId可以便于我们将来做幂等性判断。</p><h2 id="对之前的Redis业务改造"><a href="#对之前的Redis业务改造" class="headerlink" title="对之前的Redis业务改造"></a>对之前的Redis业务改造</h2><p>把以前放入阻塞队列的消息，放入消息队列RabbitMQ中</p><p>引入依赖，注入RabbitTemplate对象</p><p>其中，convertAndSend的传入的参数为，交换机，关键字，和对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="comment">/*.......*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//放入消息队列RabbitMQ</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;voucherOrder.topic&quot;</span>,<span class="string">&quot;secKill.success&quot;</span>,voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AmqpException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，用户ID：&#123;&#125;&quot;</span>,voucherOrder.getUserId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放进阻塞队列</span></span><br><span class="line">        <span class="comment">//orderTasks.add(voucherOrder);</span></span><br></pre></td></tr></table></figure><p>新建一个Listener包，定义MQListener类，用于监听消息</p><p>注入之前的service层对象，直接调用其方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> VoucherOrderServiceImpl voucherOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;hello.queue1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listensSimpleQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者收到了hello.queue1的消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;voucherOrder.queue&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;voucherOrder.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = &quot;secKill.success&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">voucherOrderListener</span><span class="params">(VoucherOrder voucherOrder)</span>&#123;</span><br><span class="line">        <span class="comment">//TODO 消费者拿到消息队列的消息，的处理方法</span></span><br><span class="line">        <span class="comment">//voucherOrderService.handleVoucherOrder(voucherOrder);</span></span><br><span class="line">        voucherOrderService.createVoucherOrder(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;voucherOrder.queue&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;voucherOrder.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">        key = &quot;secKill.success&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br></pre></td></tr></table></figure><p>使用注解嵌套注解的方式，来实现</p><p>具体解释如下：</p><ol><li><code>@RabbitListener</code>: 这是一个监听器注解，用于声明一个方法作为 RabbitMQ 的消息消费者。当 RabbitMQ 中有消息到达时，被注解的方法将被调用。</li><li><code>bindings</code>: 这是 <code>@RabbitListener</code> 注解的一个属性，用于指定<strong>队列和交换机之间的绑定关系</strong>。在这里，通过 <code>@QueueBinding</code> 注解指定了队列与交换机之间的绑定关系。</li><li><code>@Queue</code>: 在 <code>@QueueBinding</code> 注解中，<code>@Queue</code> 用于声明一个队列，并设置队列的属性。在这里，使用了 <code>name</code> 属性指定了队列的名称为 “voucherOrder.queue”。</li><li><code>@Exchange</code>: 在 <code>@QueueBinding</code> 注解中，<code>@Exchange</code> 用于声明一个交换机，并设置交换机的属性。在这里，使用了 <code>name</code> 属性指定了交换机的名称为 “voucherOrder.topic”，<code>type</code> 属性指定了交换机的类型为 “topic”。</li><li><code>key</code>: 在 <code>@QueueBinding</code> 注解中，<code>key</code> 属性<strong>用于指定路由键</strong>，表示消息从交换机发送到队列时所需匹配的路由规则。在这里，设置了 “secKill.success” 作为路由键。</li></ol><p>综上所述，这段代码的作用是声明了一个 RabbitMQ 的消息监听器，监听名为 “voucherOrder.topic” 的交换机上的 “secKill.success” 路由键对应的队列 “voucherOrder.queue”，当有消息通过该路由键到达时，会触发被注解的方法进行消费。</p><p>来，上压力测试，好快啊，平均26ms</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417155424199.png" alt="image-20240417155424199"></p><p>来三轮求取平均值 82ms</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417160106573.png" alt="image-20240417160106573"></p><p>第三轮68ms</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417160716270.png" alt="image-20240417160716270"></p><p>好像用了lua脚本后，就确保了一人一单不会被抢了，加Redisson分布式锁还有没有用了？</p><p>加锁，也是给后续写入数据库的操作加锁，感觉会没用，试试</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417161256215.png" alt="image-20240417161256215"></p><p>果然，平均只有1s了</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级篇</title>
      <link href="/2024/04/15/Java/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/04/15/Java/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java高级编程"><a href="#Java高级编程" class="headerlink" title="Java高级编程"></a>Java高级编程</h1><h2 id="8-多线程"><a href="#8-多线程" class="headerlink" title="8_多线程"></a>8_多线程</h2><h3 id="程序、进程、线程的理解"><a href="#程序、进程、线程的理解" class="headerlink" title="程序、进程、线程的理解"></a>程序、进程、线程的理解</h3><ol><li><p>程序(programm)</p><p>概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段<strong>静态的代码</strong>。</p></li><li><p>进程(process)</p><ol><li>概念：程序的一次执行过程，或是<strong>正在运行的一个程序</strong>。</li><li>说明：<strong>进程作为资源分配的单位</strong>，系统在运行时会为每个进程分配不同的内存区域</li></ol></li><li><p>线程(thread)</p><ol><li>概念：进程可进一步细化为线程，是一个程序内部的一条执行路径。</li><li>说明：<strong>线程作为调度和执行的单位</strong>，每个线程拥独立的运行**栈和程序计数器(pc)**，线程切换的开销小。</li></ol><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211128143627109.png" alt="image-20211128143627109"></p></li><li><p>补充：内存结构</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211128143702214.png" alt="image-20211128143702214"></p><ol><li>进程可以细化为多个线程。</li><li>每个线程，拥有自己独立的：栈、程序计数器</li><li>多个线程，共享同一个进程中的结构：方法区、堆。</li></ol></li></ol><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ol><li>单核CPU与多核CPU的理解<ol><li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费。）但是因为CPU时间单元特别短，因此感觉不出来。</li><li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li><li>一个Java应用程序java.exe，其实至少三个线程：<strong>main()主线程，gc()垃圾回收线程，异常处理线程</strong>。当然如果发生异常，会影响主线程。</li></ol></li><li>并行与并发的理解<ol><li><strong>并行</strong>：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</li><li><strong>并发</strong>：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</li></ol></li></ol><h3 id="创建多线程的两种方式"><a href="#创建多线程的两种方式" class="headerlink" title="创建多线程的两种方式"></a>创建多线程的两种方式</h3><ol><li><p>方式一：继承Thread类的方式：</p><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li><li>创建Thread类的子类的对象</li><li>通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()</li></ol><p>说明两个问题：</p><ul><li>问题一：我们启动一个线程，必须调用start()，不能调用run()的方式启动线程。</li><li>问题二：如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start().</li></ul></li><li><p>方式二：实现Runnable接口的方式：</p><ol><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中的抽象方法：run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()</li></ol></li><li><p>两种方式的对比：</p><ol><li><p>开发中：优先选择：实现Runnable接口的方式。原因：</p><ol><li>实现的方式没有类的单继承性的局限性</li><li>实现的方式更适合来处理多个线程有共享数据的情况。</li></ol></li><li><p>联系：public class Thread implements Runnable</p></li><li><p>相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p><p>目前两种方式，要想启动线程，都是调用的Thread类中的start()。</p></li></ol></li></ol><h3 id="Thread类中的常用方法"><a href="#Thread类中的常用方法" class="headerlink" title="Thread类中的常用方法"></a>Thread类中的常用方法</h3><ol><li>常用方法<ol><li>start():启动当前线程；调用当前线程的run()</li><li>run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li><li>currentThread():静态方法，返回执行当前代码的线程</li><li>getName():获取当前线程的名字</li><li>setName():设置当前线程的名字</li><li>yield():释放当前cpu的执行权</li><li>join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</li><li>stop():已过时。当执行此方法时，强制结束当前线程。</li><li>sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</li><li>isAlive():判断当前线程是否存活</li></ol></li><li>线程的优先级：<ol><li>优先级<ol><li>MAX_PRIORITY：10</li><li>MIN _PRIORITY：1</li><li>NORM_PRIORITY：5  –&gt;默认优先级</li></ol></li><li>如何获取和设置当前线程的优先级：<ol><li>getPriority():获取线程的优先级</li><li>setPriority(int p):设置线程的优先级</li></ol></li><li>说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</li></ol></li><li>线程通信：wait() &#x2F; notify() &#x2F; notifyAll() :此三个方法定义在Object类中的。</li><li>补充：线程的分类<ol><li>守护线程</li><li>用户线程</li></ol></li></ol><h3 id="Thread的生命周期"><a href="#Thread的生命周期" class="headerlink" title="Thread的生命周期"></a>Thread的生命周期</h3><ol><li><p>图示：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211128144604759.png" alt="image-20211128144604759"></p></li><li><p>说明：</p><ol><li>生命周期关注两个概念：状态、相应的方法</li><li>关注：<ol><li>状态a–&gt;状态b:哪些方法执行了（回调方法）</li><li>某个方法主动调用：状态a–&gt;状态b</li></ol></li><li>阻塞：临时状态，不可以作为最终状态</li><li>死亡：最终状态。</li></ol></li></ol><h3 id="线程的同步机制"><a href="#线程的同步机制" class="headerlink" title="线程的同步机制"></a>线程的同步机制</h3><ol><li><p>背景</p><p>例子：创建三个窗口卖票，总票数为100张.使用实现Runnable接口的方式</p><ol><li>问题：卖票过程中，出现了重票、错票 –&gt;出现了线程的安全问题</li><li>问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。</li><li>如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。</li></ol></li><li><p>Java解决方案：同步机制</p><p>在Java中，我们通过同步机制，来解决线程的安全问题。</p><ol><li><p>方式一：同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">     <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>操作共享数据的代码，即为需要被同步的代码。  –&gt;不能包含代码多了，也不能包含代码少了。</li><li>共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。</li><li>同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。</li><li>要求：多个线程必须要共用同一把锁。</li><li>补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</li></ol></li><li><p>方式二：同步方法</p><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p><ol><li><p>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</p></li><li><p>非静态的同步方法，同步监视器是：this</p><p>静态的同步方法，同步监视器是：当前类本身</p></li></ol></li><li><p>方式三：Lock锁  — JDK5.0新增</p></li></ol><ul><li>使用的优先顺序：Lock —&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) —&gt; 同步方法（在方法体之外)</li></ul></li><li><p>利弊</p><ol><li>好处：同步的方式，解决了线程的安全问题。</li><li>弊端：操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。</li></ol></li><li><p>面试题：</p><ol><li><p>Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同</p></li><li><p>synchronized和Lock方式解决线程安全问题的对比</p><p>相同：二者都可以解决线程安全问题</p><p>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器；Lock需要手动的启动同步(lock())，同时结束同步也需要手动的实现(unlock())</p></li></ol></li></ol><h4 id="线程安全的单例模式-懒汉式"><a href="#线程安全的单例模式-懒汉式" class="headerlink" title="线程安全的单例模式(懒汉式)"></a>线程安全的单例模式(懒汉式)</h4><p>使用同步机制将单例模式中的懒汉式改写为线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//方式一：效率稍差</span></span><br><span class="line"><span class="comment">//        synchronized (Bank.class) &#123;</span></span><br><span class="line"><span class="comment">//            if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                instance = new Bank();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            return instance;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式二：效率更高</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>面试题：写一个线程安全的单例模式。<ul><li>饿汉式。</li><li>懒汉式：上面提供的。</li></ul></li></ul><h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><ol><li><p>死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p></li><li><p>说明：</p><ol><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li><li>我们使用同步时，要避免出现死锁。</li></ol></li><li><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line"></span><br><span class="line">                s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(s1);</span><br><span class="line">                    System.out.println(s2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line"></span><br><span class="line">                s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(s1);</span><br><span class="line">                    System.out.println(s2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ol><li><p>线程通信涉及到的三个方法：</p><ol><li>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</li><li>notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。</li><li>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</li></ol></li><li><p>说明：</p><ol><li>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。</li><li>wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常</li><li>wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</li></ol></li><li><p>面试题：面试题：sleep() 和 wait()的异同？</p><ol><li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</li><li>不同点：<ol><li>两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li><li>调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</li><li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</li></ol></li></ol></li><li><p>小结</p><ol><li><p>小结释放锁的操作：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211128150049487.png" alt="image-20211128150049487"></p></li><li><p>小结不会释放锁的操作：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211128150054346.png" alt="image-20211128150054346"></p></li></ol></li></ol><h3 id="JDK5-0新增线程创建的方式"><a href="#JDK5-0新增线程创建的方式" class="headerlink" title="JDK5.0新增线程创建的方式"></a>JDK5.0新增线程创建的方式</h3><ol><li><p>新增方式一：实现Callable接口。 — JDK 5.0新增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</p><ol><li>call()可以返回值的。</li><li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li><li>Callable是支持泛型的</li></ol></li><li><p>新增方式二：使用线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：好处</p><ol><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理<ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没任务时最多保持多长时间后会终止</li></ul></li></ol></li><li><p>面试题：Java中多线程的创建有几种方式？四种。</p></li></ol><h2 id="9-Java常用类"><a href="#9-Java常用类" class="headerlink" title="9_Java常用类"></a>9_Java常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>java.lang.String类的使用</p><ol><li><p>概述</p><p>String:字符串，使用一对””引起来表示。</p><ol><li><p>String声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。</p><p>实现了Comparable接口：表示String可以比较大小</p></li><li><p>String内部定义了final char[] value用于存储字符串数据</p></li><li><p>通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)。</p></li><li><p>字符串常量池中是不会存储相同内容(使用String类的equals()比较，返回true)的字符串的。</p></li></ol></li><li><p>String的不可变性</p><ol><li><p>说明</p><ol><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ol></li><li><p>代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//比较s1和s2的地址值</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1);<span class="comment">//hello</span></span><br><span class="line">System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s3 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">System.out.println(s3);<span class="comment">//abcdef</span></span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">System.out.println(s4);<span class="comment">//abc</span></span><br><span class="line">System.out.println(s5);<span class="comment">//mbc</span></span><br></pre></td></tr></table></figure></li><li><p>图示</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211128150727913.png" alt="image-20211128150727913"></p></li></ol></li><li><p>String实例化的不同方式</p><ol><li><p>方式说明</p><ol><li>方式一：通过字面量定义的方式</li><li>方式二：通过new + 构造器的方式</li></ol></li><li><p>代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="comment">//通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p>面试题：String s &#x3D; new String(“abc”);方式创建对象，在内存中创建了几个对象？</p><p>答案：两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p></li><li><p>图示</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211128150842221.png" alt="image-20211128150842221"></p></li></ol></li><li><p>字符串拼接方式赋值的对比</p><ol><li><p>说明</p><ol><li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</li><li>只要其中一个是变量，结果就在堆中。</li><li>如果拼接的结果调用intern()方法，返回值就在常量池中</li></ol></li><li><p>代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();<span class="comment">//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”</span></span><br><span class="line">System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">****************************</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>：返回字符串的长度： <span class="keyword">return</span> value.length</span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>： 返回某索引处的字符<span class="keyword">return</span> value[index]</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>：判断是否是空字符串：<span class="keyword">return</span> value.length == <span class="number">0</span></span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所字符转换为小写</span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所字符转换为大写</span><br><span class="line">String <span class="title function_">trim</span><span class="params">()</span>：返回字符串的副本，忽略前导空白和尾部空白</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span><br><span class="line">String <span class="title function_">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”</span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串的大小</span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>：</span><br><span class="line">    返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> ：</span><br><span class="line">    返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix, <span class="type">int</span> toffset)</span>：</span><br><span class="line">    测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="type">char</span> 值序列时，返回 <span class="literal">true</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>：</span><br><span class="line">    返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>：</span><br><span class="line">    返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span><br><span class="line"></span><br><span class="line">注：indexOf和lastIndexOf方法如果未找到都是返回-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">替换：</span><br><span class="line">String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar, <span class="type">char</span> newChar)</span>：</span><br><span class="line">    返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。</span><br><span class="line">String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：</span><br><span class="line">    使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。</span><br><span class="line">String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span>：</span><br><span class="line">    使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。</span><br><span class="line">String <span class="title function_">replaceFirst</span><span class="params">(String regex, String replacement)</span>：</span><br><span class="line">    使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span><br><span class="line">匹配:</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。</span><br><span class="line">切片：</span><br><span class="line">String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line">String[] split(String regex, <span class="type">int</span> limit)：根据匹配给定的正则表达式来拆分此字符串，</span><br><span class="line">    最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>String与其它结构的转换</p><ol><li><p>与基本数据类型、包装类之间的转换</p><ol><li><p>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</p></li><li><p>基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//        int num = (int)str1;//错误的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(num);<span class="comment">//&quot;123&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> num + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 == str3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>与字符数组之间的转换</p><ol><li><p>String –&gt; char[]:调用String的toCharArray()</p></li><li><p>char[] –&gt; String:调用String的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;  <span class="comment">//题目： a21cb3</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] charArray = str1.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">        System.out.println(charArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>与字节数组之间的转换</p><ol><li>编码：String –&gt; byte[]:调用String的getBytes()</li><li>解码：byte[] –&gt; String:调用String的构造器</li></ol><ul><li><p>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)</p></li><li><p>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂</p></li><li><p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123中国&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = str1.getBytes();<span class="comment">//使用默认的字符集，进行编码。</span></span><br><span class="line">    System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk字符集进行编码。</span></span><br><span class="line">    System.out.println(Arrays.toString(gbks));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">//使用默认的字符集，进行解码。</span></span><br><span class="line">    System.out.println(str2);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);</span><br><span class="line">    System.out.println(str3);<span class="comment">//出现乱码。原因：编码集和解码集不一致！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    System.out.println(str4);<span class="comment">//没出现乱码。原因：编码集和解码集一致！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>与StringBuffer、StringBuilder之间的转换</p><ol><li>String –&gt;StringBuffer、StringBuilder:调用StringBuffer、StringBuilder构造器</li><li>StringBuffer、StringBuilder –&gt;String:①调用String构造器；②StringBuffer、StringBuilder的toString()</li></ol></li></ol></li><li><p>JVM中字符串常量池存放位置说明：</p><ol><li>jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区（永久区）</li><li>jdk 1.7:字符串常量池存储在堆空间</li><li>jdk 1.8:字符串常量池存储在方法区（元空间）</li></ol></li><li><p>常见算法题目的考查：</p><ol><li><p>模拟一个trim方法，去除字符串两端的空格。</p></li><li><p>将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”</p></li><li><p>获取一个字符串在另一个字符串中出现的次数。<br>  比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数</p></li><li><p>获取两个字符串中最大相同子串。比如：<br>   str1 &#x3D; “abcwerthelloyuiodef“;str2 &#x3D; “cvhellobnm”</p><p>提示：将短的那个串进行长度依次递减的子串与较长的串比较。</p></li><li><p>对字符串中字符进行自然顺序排序。</p><p>提示：</p><ol><li>字符串变成字符数组。</li><li>对数组排序，择，冒泡，Arrays.sort();</li><li>将排序后的数组变成字符串。</li></ol></li></ol></li></ol><h3 id="StringBuffer、StringBuilder"><a href="#StringBuffer、StringBuilder" class="headerlink" title="StringBuffer、StringBuilder"></a>StringBuffer、StringBuilder</h3><ol><li><p>String、StringBuffer、StringBuilder三者的对比</p><ol><li>String:不可变的字符序列；底层使用char[]存储</li><li>StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储</li><li>StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</li></ol></li><li><p>StringBuffer与StringBuilder的内存解析</p><p>以StringBuffer为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="comment">//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line"></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//问题1. System.out.println(sb2.length());//3</span></span><br><span class="line"><span class="comment">//问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</span></span><br><span class="line">         默认情况下，扩容为原来容量的<span class="number">2</span>倍 + <span class="number">2</span>，同时将原数组中的元素复制到新的数组中。</span><br><span class="line"></span><br><span class="line">指导意义：开发中建议大家使用：StringBuffer(<span class="type">int</span> capacity) 或 StringBuilder(<span class="type">int</span> capacity)</span><br></pre></td></tr></table></figure></li><li><p>对比String、StringBuffer、StringBuilder三者的执行效率</p><p>从高到低排列：StringBuilder &gt; StringBuffer &gt; String</p></li><li><p>StringBuffer、StringBuilder中的常用方法</p><ul><li>增：append(xxx)</li><li>删：delete(int start,int end)</li><li>改：setCharAt(int n ,char ch) &#x2F; replace(int start, int end, String str)</li><li>查：charAt(int n )</li><li>插：insert(int offset, xxx)</li><li>长度：length();</li><li>遍历：for() + charAt() &#x2F; toString()</li></ul></li></ol><h3 id="JDK-8之前日期时间API"><a href="#JDK-8之前日期时间API" class="headerlink" title="JDK 8之前日期时间API"></a>JDK 8之前日期时间API</h3><ol><li><p>获取系统当前时间：System类中的currentTimeMillis()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line"><span class="comment">//称为时间戳</span></span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure></li><li><p>java.util.Date类与java.sql.Date类</p><p>java.util.Date类</p><p>​|—java.sql.Date类</p><ol><li><p>两个构造器的使用</p><ol><li>构造器一：Date()：创建一个对应当前时间的Date对象</li><li>构造器二：创建指定毫秒数的Date对象</li></ol></li><li><p>两个方法的使用</p><ol><li>toString():显示当前的年、月、日、时、分、秒</li><li>getTime():获取当前Date对象对应的毫秒数。（时间戳）</li></ol></li><li><p>java.sql.Date对应着数据库中的日期类型的变量</p><ol><li>如何实例化</li><li>如何将java.util.Date对象转换为java.sql.Date对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date1.toString());<span class="comment">//Sat Feb 16 16:35:31 GMT+08:00 2019</span></span><br><span class="line"></span><br><span class="line">        System.out.println(date1.getTime());<span class="comment">//1550306204104</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">155030620410L</span>);</span><br><span class="line">        System.out.println(date2.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">35235325345L</span>);</span><br><span class="line">        System.out.println(date3);<span class="comment">//1971-02-13</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">        <span class="comment">//情况一：</span></span><br><span class="line"><span class="comment">//        Date date4 = new java.sql.Date(2343243242323L);</span></span><br><span class="line"><span class="comment">//        java.sql.Date date5 = (java.sql.Date) date4;</span></span><br><span class="line">        <span class="comment">//情况二：</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">date7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date6.getTime());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>java.text.SimpleDataFormat类</p><p>SimpleDateFormat对日期Date类的格式化和解析</p><ol><li><p>两个操作：</p><ol><li>格式化：日期 —&gt;字符串</li><li>解析：格式化的逆过程，字符串 —&gt; 日期</li></ol></li><li><p>SimpleDateFormat的实例化:new + 构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************照指定的方式格式化和解析：调用带参的构造器*****************</span></span><br><span class="line"><span class="comment">//        SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;);</span></span><br><span class="line"><span class="comment">        SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span></span><br><span class="line"><span class="comment">        //格式化</span></span><br><span class="line"><span class="comment">        String format1 = sdf1.format(date);</span></span><br><span class="line"><span class="comment">        System.out.println(format1);//2019-02-18 11:48:27</span></span><br><span class="line"><span class="comment">        //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),</span></span><br><span class="line"><span class="comment">        //否则，抛异常</span></span><br><span class="line"><span class="comment">        Date date2 = sdf1.parse(&quot;2020-02-18 11:48:27&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(date2);</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure></li><li><p>小练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习一：字符串&quot;2020-09-08&quot;转换为java.sql.Date</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    练习二：&quot;天打渔两天晒网&quot;   1990-01-01  xxxx-xx-xx 打渔？晒网？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    举例：2020-09-08 ？ 总天数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    总天数 % 5 == 1,2,3 : 打渔</span></span><br><span class="line"><span class="comment">    总天数 % 5 == 4,0 : 晒网</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    总天数的计算？</span></span><br><span class="line"><span class="comment">    方式一：( date2.getTime() - date1.getTime()) / (1000 * 60 * 60 * 24) + 1</span></span><br><span class="line"><span class="comment">    方式二：1990-01-01  --&gt; 2019-12-31  +  2020-01-01 --&gt;2020-09-08</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testExer</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="string">&quot;2020-09-08&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf1.parse(birth);</span><br><span class="line"><span class="comment">//        System.out.println(date);</span></span><br><span class="line"></span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">birthDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date.getTime());</span><br><span class="line">        System.out.println(birthDate);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Calendar类：日历类、抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.实例化</span></span><br><span class="line">        <span class="comment">//方式一：创建其子类（GregorianCalendar的对象</span></span><br><span class="line">        <span class="comment">//方式二：调用其静态方法getInstance()</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//        System.out.println(calendar.getClass());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.常用方法</span></span><br><span class="line">        <span class="comment">//get()</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_YEAR));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//set()</span></span><br><span class="line">        <span class="comment">//calendar可变性</span></span><br><span class="line">         calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add()</span></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getTime():日历类---&gt; Date</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//setTime():Date ---&gt; 日历类</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        calendar.setTime(date1);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="JDK8中新日期时间API"><a href="#JDK8中新日期时间API" class="headerlink" title="JDK8中新日期时间API"></a>JDK8中新日期时间API</h3><ol><li><p>日期时间API的迭代：</p><ol><li>第一代：jdk 1.0 Date类</li><li>第二代：jdk 1.1 Calendar类，一定程度上替换Date类</li><li>第三代：jdk 1.8 提出了新的一套API</li></ol></li><li><p>前两代存在的问题举例：</p><ol><li>可变性：像日期和时间这样的类应该是不可变的。</li><li>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</li><li>格式化：格式化只对Date用，Calendar则不行。</li><li>此外，它们也不是线程安全的；不能处理闰秒等。</li></ol></li><li><p>java 8 中新的日期时间API涉及到的包</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129090710926.png" alt="image-20211129090710926"></p></li><li><p>本地日期、本地时间、本地日期时间的使用：LocalDate &#x2F; LocalTime &#x2F; LocalDateTime</p><ol><li><p>说明：</p><ol><li>分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</li><li>LocalDateTime相较于LocalDate、LocalTime，使用频率要高</li><li>类似于Calendar</li></ol></li><li><p>常用方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129090811575.png" alt="image-20211129090811575"></p></li></ol></li><li><p>时间点：Instant</p><ol><li><p>说明：</p><ol><li>时间线上的一个瞬时点。 概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC开始的秒数。）</li><li>类似于 java.util.Date类</li></ol></li><li><p>常用方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129090842611.png" alt="image-20211129090842611"></p></li></ol></li><li><p>日期时间格式化类：DateTimeFormatter</p><ol><li><p>说明：</p><ol><li>格式化或解析日期、时间</li><li>类似于SimpleDateFormat</li></ol></li><li><p>常用方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129091037317.png" alt="image-20211129091037317"></p><ul><li><p>预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</p></li><li><p>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</p></li><li><p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  重点：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter3</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> formatter3.format(LocalDateTime.now());</span><br><span class="line">System.out.println(str4);<span class="comment">//2019-02-18 03:52:09</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> formatter3.parse(<span class="string">&quot;2019-02-18 03:52:09&quot;</span>);</span><br><span class="line">System.out.println(accessor);</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p>其它API的使用 （不讲）</p><ol><li><p>带时区的日期时间：ZonedDateTime &#x2F; ZoneId<br>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZoneId:类中包含了所的时区信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//getAvailableZoneIds():获取所的ZoneId</span></span><br><span class="line">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line"><span class="keyword">for</span>(String s : zoneIds)&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取“Asia/Tokyo”时区对应的时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ZonedDateTime:带时区的日期时间</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//now():获取本时区的ZonedDateTime对象</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">System.out.println(zonedDateTime);</span><br><span class="line"><span class="comment">//now(ZoneId id):获取指定时区的ZonedDateTime对象</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime1</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">System.out.println(zonedDateTime1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>时间间隔：Duration–用于计算两个“时间”间隔，以秒和纳秒为基准</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129091228463.png" alt="image-20211129091228463"></p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime1</span> <span class="operator">=</span> LocalTime.of(<span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">//between():静态方法，返回Duration对象，表示两个时间的间隔</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localTime1, localTime);</span><br><span class="line">System.out.println(duration);</span><br><span class="line"></span><br><span class="line">System.out.println(duration.getSeconds());</span><br><span class="line">System.out.println(duration.getNano());</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration1</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime);</span><br><span class="line">System.out.println(duration1.toDays());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>日期间隔：Period –用于计算两个“日期”间隔，以年、月、日衡量</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129091310779.png" alt="image-20211129091310779"></p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2028</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate, localDate1);</span><br><span class="line">System.out.println(period);</span><br><span class="line"></span><br><span class="line">System.out.println(period.getYears());</span><br><span class="line">System.out.println(period.getMonths());</span><br><span class="line">System.out.println(period.getDays());</span><br><span class="line"></span><br><span class="line"><span class="type">Period</span> <span class="variable">period1</span> <span class="operator">=</span> period.withYears(<span class="number">2</span>);</span><br><span class="line">System.out.println(period1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>日期时间校正器：TemporalAdjuster举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//获取当前日期的下一个周日是哪天？</span></span><br><span class="line"><span class="type">TemporalAdjuster</span> <span class="variable">temporalAdjuster</span> <span class="operator">=</span> TemporalAdjusters.next(DayOfWeek.SUNDAY);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now().with(temporalAdjuster);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下一个工作日是哪天？</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now().with(<span class="keyword">new</span> <span class="title class_">TemporalAdjuster</span>()&#123;</span><br><span class="line">      </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Temporal <span class="title function_">adjustInto</span><span class="params">(Temporal temporal)</span> &#123;</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> (LocalDate)temporal;</span><br><span class="line"><span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.FRIDAY))&#123;</span><br><span class="line"><span class="keyword">return</span> date.plusDays(<span class="number">3</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.SATURDAY))&#123;</span><br><span class="line"><span class="keyword">return</span> date.plusDays(<span class="number">2</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> date.plusDays(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;下一个工作日是：&quot;</span> + localDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h3><ol><li><p>Java比较器的使用背景：</p><ol><li>Java中的对象，正常情况下，只能进行比较：&#x3D;&#x3D;  或  !&#x3D; 。不能使用 &gt; 或 &lt; 的<br>但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</li><li>如何实现？使用两个接口中的任何一个：Comparable 或 Comparator</li></ol></li><li><p>自然排序：使用Comparable接口</p><ol><li><p>说明</p><ol><li>像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</li><li>像String、包装类重写compareTo()方法以后，进行了从小到大的排列</li><li>重写compareTo(obj)的规则：<ol><li>如果当前对象this大于形参对象obj，则返回正整数，</li><li>如果当前对象this小于形参对象obj，则返回负整数，</li><li>如果当前对象this等于形参对象obj，则返回零。</li></ol></li><li>对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序</li></ol></li><li><p>自定义类代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span>  <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:照价格从低到高排序,再照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">               <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line"><span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// getter、setter、toString()、构造器：省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>定制排序：使用Comparator接口</p><ol><li><p>说明</p><ol><li>背景：当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序</li><li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：<ul><li>如果方法返回正整数，则表示o1大于o2；</li><li>如果返回0，表示相等；</li><li>返回负整数，表示o1小于o2。</li></ul></li></ol></li><li><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods)o1;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods)o2;</span><br><span class="line">            <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">Arrays.sort(goods,com);</span><br><span class="line">Collections.sort(coll,com);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>两种排序方式对比</p><ol><li>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li><li>Comparator接口属于临时性的比较。</li></ol></li></ol><h3 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h3><ol><li><p>System类</p><ol><li>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</li><li>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</li><li>方法：<ol><li>native long currentTimeMillis()</li><li>void exit(int status)</li><li>void gc()</li><li>String getProperty(String key)</li></ol></li></ol></li><li><p>Math类：java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p></li><li><p>BigInteger类、BigDecimal类</p><ol><li><p>说明：</p><ol><li>java.math包的BigInteger可以表示不可变的任意精度的整数。</li><li>要求数字精度比较高，用到java.math.BigDecimal类</li></ol></li><li><p>代码举例：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129092157612.png" alt="image-20211129092157612"></p></li></ol></li></ol><h2 id="10-枚举类和注解"><a href="#10-枚举类和注解" class="headerlink" title="10_枚举类和注解"></a>10_枚举类和注解</h2><h3 id="枚举类的使用"><a href="#枚举类的使用" class="headerlink" title="枚举类的使用"></a>枚举类的使用</h3><ol><li><p>枚举类的说明：</p><ol><li>枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</li><li>当需要定义一组常量时，强烈建议使用枚举类</li><li>如果枚举类中只一个对象，则可以作为单例模式的实现方式。</li></ol></li><li><p>如何自定义枚举类？步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>jdk 5.0 新增使用enum定义枚举类。步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> &#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用enum定义枚举类之后，枚举类常用方法：（继承于java.lang.Enum类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line">        <span class="comment">//toString():返回枚举类对象的名称</span></span><br><span class="line">        System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(Season1.class.getSuperclass());</span></span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">        <span class="comment">//values():返回所的枚举类对象构成的数组</span></span><br><span class="line">        Season1[] values = Season1.values();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">            System.out.println(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">        Thread.State[] values1 = Thread.State.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values1.length; i++) &#123;</span><br><span class="line">            System.out.println(values1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line">        <span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">        <span class="comment">//如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line"><span class="comment">//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line">        System.out.println(winter);</span><br></pre></td></tr></table></figure></li><li><p>使用enum定义枚举类之后，如何让枚举类对象分别实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><ol><li><p>注解的理解</p><ol><li><p>jdk 5.0 新增的功能</p></li><li><p>Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。</p></li><li><p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p><p><strong>框架 &#x3D; 注解 + 反射机制 + 设计模式</strong></p></li></ol></li><li><p>注解的使用示例</p><ol><li>示例一：生成文档相关的注解</li><li>示例二：在编译时进行格式检查(JDK内置的个基本注解)<ol><li><p>@Override: 限定重写父类方法, 该注解只能用于方法</p></li><li><p>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择</p></li><li><p>@SuppressWarnings: 抑制编译器警告</p></li></ol></li><li>示例三：跟踪代码依赖性，实现替代配置文件功能</li></ol></li><li><p>如何自定义注解：参照@SuppressWarnings定义</p><ol><li><p>注解声明为：@interface</p></li><li><p>内部定义成员，通常使用value表示</p></li><li><p>可以指定成员的默认值，使用default定义</p></li><li><p>如果自定义注解没成员，表明是一个标识作用。</p></li><li><p>说明：</p><ul><li>如果注解有成员，在使用注解时，需要指明成员的值。</li><li>自定义注解必须配上注解的信息处理流程(使用反射)才意义。</li><li>自定义注解通过都会指明两个元注解：Retention、Target</li></ul></li><li><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>元注解 ：对现有的注解进行解释说明的注解。</p><p>jdk 提供的4种元注解：</p><ol><li><p>Retention：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为\RUNTIME<br>   只声明为RUNTIME生命周期的注解，才能通过反射获取。</p></li><li><p>Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p><p><em><strong><strong><strong>出现的频率较低</strong></strong></strong></em></p></li><li><p>Documented:表示所修饰的注解在被javadoc解析时，保留下来。</p></li><li><p>Inherited:被它修饰的 Annotation 将具继承性。</p></li></ol><p>—&gt;类比：元数据的概念：String name &#x3D; “Tom”;</p></li><li><p>如何获取注解信息:通过发射来进行获取、调用。</p><p>前提：要求此注解的元注解Retention中声明的生命周期状态为：RUNTIME.</p></li><li><p>JDK8中注解的新特性：可重复注解、类型注解</p><ol><li>可重复注解：<ol><li><p>在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</p></li><li><p>MyAnnotation的Target和Retention等元注解与MyAnnotations相同。</p></li></ol></li><li>类型注解：<ol><li>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明。</li><li>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</li></ol></li></ol></li></ol><h2 id="11-Java集合"><a href="#11-Java集合" class="headerlink" title="11_Java集合"></a>11_Java集合</h2><h3 id="数组与集合"><a href="#数组与集合" class="headerlink" title="数组与集合"></a>数组与集合</h3><ol><li>集合与数组存储数据概述：<ol><li>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</li><li>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中)</li></ol></li><li>数组存储的特点：<ol><li>一旦初始化以后，其长度就确定了。</li><li>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。<ul><li><pre><code>  比如：String[] arr;int[] arr1;Object[] arr2;</code></pre></li></ul></li></ol></li><li>数组存储的弊端：<ol><li>一旦初始化以后，其长度就不可修改。</li><li>数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li><li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li></ol></li><li>集合存储的优点：解决数组存储数据方面的弊端。</li></ol><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><ol><li><p>单列集合框架结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">*          |----List接口：存储序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">*              |----ArrayList、LinkedList、Vector</span><br><span class="line">*</span><br><span class="line">*          |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span><br><span class="line">*              |----HashSet、LinkedHashSet、TreeSet</span><br></pre></td></tr></table></figure><p>对应图示：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129093716899.png" alt="image-20211129093716899"></p></li><li><p>Collection接口常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(Object obj),addAll(Collection coll),size(),isEmpty(),clear();</span><br><span class="line">contains(Object obj),containsAll(Collection coll),remove(Object obj),removeAll(Collection coll),retainsAll(Collection coll),equals(Object obj);</span><br><span class="line">hasCode(),toArray(),iterator();</span><br></pre></td></tr></table></figure></li><li><p>Collection集合与数组间的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合 ---&gt;数组：toArray()</span></span><br><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList(T ... t)</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//2</span></span><br></pre></td></tr></table></figure></li><li><p>使用Collection集合存储对象，要求对象所属的类满足：向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().</p></li><li><p>本章节对大家的要求：</p><ol><li>层次一：选择合适的集合类去实现数据的保存，调用其内部的相关方法。</li><li>层次二：不同的集合类底层的数据结构为何？如何实现数据的操作的：增删改查等。</li></ol></li></ol><h3 id="Iterator接口与foreach循环"><a href="#Iterator接口与foreach循环" class="headerlink" title="Iterator接口与foreach循环"></a>Iterator接口与foreach循环</h3><ol><li><p>遍历Collection的两种方式：</p><ol><li>使用迭代器Iterator  </li><li>foreach循环（或增强for循环）</li></ol></li><li><p>java.utils包下定义的迭代器接口：Iterator</p><ol><li><p>说明：</p><ol><li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</li><li>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</li></ol></li><li><p>作用：遍历集合Collectiton元素</p></li><li><p>如何获取实例：coll.iterator()返回一个迭代器实例</p></li><li><p>遍历的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="comment">//hasNext():判断是否还下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>图示说明：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129093956649.png" alt="image-20211129093956649"></p></li><li><p>remove()的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试Iterator中的remove()</span></span><br><span class="line"><span class="comment">//如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。</span></span><br><span class="line"><span class="comment">//内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"><span class="comment">//            iterator.remove();</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line"><span class="comment">//                iterator.remove();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        iterator = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>jdk5.0新特性–增强for循环：(foreach循环)</p><ol><li><p>遍历集合举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：<br>内部仍然调用了迭代器。</p></li><li><p>遍历数组举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="Collection子接口：List接口"><a href="#Collection子接口：List接口" class="headerlink" title="Collection子接口：List接口"></a>Collection子接口：List接口</h3><ol><li><p>存储的数据特点：存储序的、可重复的数据。</p></li><li><p>常用方法：(记住)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">增：add(Object obj)</span><br><span class="line">删：remove(<span class="type">int</span> index) / remove(Object obj)</span><br><span class="line">改：set(<span class="type">int</span> index, Object ele)</span><br><span class="line">查：get(<span class="type">int</span> index)</span><br><span class="line">插：add(<span class="type">int</span> index, Object ele)</span><br><span class="line">长度：size()</span><br><span class="line">遍历：① Iterator迭代器方式</span><br><span class="line">     ② 增强<span class="keyword">for</span>循环</span><br><span class="line">     ③ 普通的循环</span><br></pre></td></tr></table></figure></li><li><p>常用实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line"> |----List接口：存储序的、可重复的数据。  --&gt;“动态”数组,替换原的数组</span><br><span class="line">  |----ArrayList：作为List接口的主要实现类；线程不安全，效率高；底层使用Object[]elementData存储</span><br><span class="line">  |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span><br><span class="line">  |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span><br></pre></td></tr></table></figure></li><li><p>源码分析(难点)</p><ol><li><p>ArrayList的源码分析：</p><ol><li><p>jdk 7情况下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line"> ...</span><br><span class="line">list.add(<span class="number">11</span>);<span class="comment">//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line">默认情况下，扩容为原来的容量的<span class="number">1.5</span>倍，同时需要将原有数组中的数据复制到新的数组中。</span><br><span class="line">*</span><br><span class="line">结论：建议开发中使用带参的构造器：<span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="type">int</span> capacity)</span><br></pre></td></tr></table></figure></li><li><p>jdk 8中ArrayList的变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;.并没创建长度为10的数组</span></span><br><span class="line">*</span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">*      ...</span><br><span class="line">后续的添加和扩容操作与jdk <span class="number">7</span> 无异。</span><br></pre></td></tr></table></figure></li><li><p>小结：</p><ol><li>jdk7中的ArrayList的对象的创建类似于单例的饿汉式</li><li>jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</li></ol></li></ol></li><li><p>LinkedList的源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(); 内部声明了Node类型的first和last属性，默认值为<span class="literal">null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"></span><br><span class="line">其中，Node定义为：体现了LinkedList的双向链表的说法</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">   E item;</span><br><span class="line">   Node&lt;E&gt; next;</span><br><span class="line">   Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">   Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">   <span class="built_in">this</span>.item = element;</span><br><span class="line">   <span class="built_in">this</span>.next = next;</span><br><span class="line">   his.prev = prev;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Vector的源码分析：</p><p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。<br>在扩容方面，默认扩容为原来的数组长度的2倍。</p></li></ol></li><li><p>存储的元素的要求：添加的对象，所在的类要重写equals()方法</p></li><li><p>[面试题]ArrayList、LinkedList、Vector者的异同？</p><ol><li>同：三个类都是实现了List接口，存储数据的特点相同：存储序的、可重复的数据</li><li>不同：见上</li></ol></li></ol><h3 id="Collection子接口：Set接口"><a href="#Collection子接口：Set接口" class="headerlink" title="Collection子接口：Set接口"></a>Collection子接口：Set接口</h3><ol><li><p>存储的数据特点：无序的、不可重复的元素</p><p>具体的：以HashSet为例说明：</p><ol><li>无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</li><li>不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</li></ol></li><li><p>元素添加过程：(以HashSet为例)</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，</span><br><span class="line">此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置，判断</span><br><span class="line">数组此位置上是否已经元素：</span><br><span class="line">    如果此位置上没其他元素，则元素a添加成功。 ---&gt;情况1</span><br><span class="line">    如果此位置上其他元素b(或以链表形式存在的多个元素，则比较元素a与元素b的hash值：</span><br><span class="line">        如果hash值不相同，则元素a添加成功。---&gt;情况2</span><br><span class="line">        如果hash值相同，进而需要调用元素a所在类的equals()方法：</span><br><span class="line">               equals()返回true,元素a添加失败</span><br><span class="line">               equals()返回false,则元素a添加成功。---&gt;情况3</span><br><span class="line"></span><br><span class="line">对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</span><br><span class="line">jdk 7 :元素a放到数组中，指向原来的元素。</span><br><span class="line">jdk 8 :原来的元素在数组中，指向元素a</span><br><span class="line">总结：七上八下</span><br><span class="line"></span><br><span class="line">HashSet底层：数组+链表的结构。（前提：jdk7)</span><br></pre></td></tr></table></figure></li><li><p>常用方法：Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法。</p></li><li><p>常用实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">|----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span><br><span class="line">|----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储<span class="literal">null</span>值</span><br><span class="line">|----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</span><br><span class="line">                 在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。                   对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">|----TreeSet：可以照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure></li><li><p>存储对象所在类的要求：</p><p>HashSet&#x2F;LinkedHashSet:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</span><br><span class="line"></span><br><span class="line">要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</span><br><span class="line">重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</span><br></pre></td></tr></table></figure><p>TreeSet:</p><ol><li>自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().</li><li>定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</li></ol></li><li><p>TreeSet的使用</p><ol><li><p>使用说明:</p><ol><li>向TreeSet中添加的数据，要求是相同类的对象。</li><li>两种排序方式：自然排序（实现Comparable接口 和 定制排序（Comparator）</li></ol></li><li><p>常用的排序方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自然排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//失败：不能添加不同类的对象</span></span><br><span class="line"><span class="comment">//        set.add(123);</span></span><br><span class="line"><span class="comment">//        set.add(456);</span></span><br><span class="line"><span class="comment">//        set.add(&quot;AA&quot;);</span></span><br><span class="line"><span class="comment">//        set.add(new User(&quot;Tom&quot;,12));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//举例一：</span></span><br><span class="line"><span class="comment">//        set.add(34);</span></span><br><span class="line"><span class="comment">//        set.add(-34);</span></span><br><span class="line"><span class="comment">//        set.add(43);</span></span><br><span class="line"><span class="comment">//        set.add(11);</span></span><br><span class="line"><span class="comment">//        set.add(8);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例二：</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：定制排序</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="comment">//照年龄从小到大排列</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mary&quot;</span>,<span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>双列集合框架：Map</p><ol><li><p>常用实现类结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">|----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储<span class="literal">null</span>的key和value</span><br><span class="line">|----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。</span><br><span class="line">              原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">              对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">|----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然或定制排序</span><br><span class="line">底层使用红黑树</span><br><span class="line">|----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储<span class="literal">null</span>的key和value</span><br><span class="line">|----Properties:常用来处理配置文件。key和value都是String类型</span><br></pre></td></tr></table></figure><p>HashMap的底层：数组+链表  （jdk7及之前)</p><p>​数组+链表+红黑树 （jdk 8)</p><p>[面试题]</p><ol><li>HashMap的底层实现原理？</li><li>HashMap 和 Hashtable的异同？</li><li>CurrentHashMap 与 Hashtable的异同？（暂时不讲)</li></ol></li><li><p>存储结构的理解：</p><ol><li><p>Map中的key:无序的、不可重复的，使用Set存储所的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)</p></li><li><p>Map中的value:无序的、可重复的，使用Collection存储所有的value</p><p>value所在的类要重写equals()</p></li><li><p>一个键值对：key-value构成了一个Entry对象。</p></li><li><p>Map中的entry:无序的、不可重复的，使用Set存储所的entry</p><p>图示：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129101834318.png" alt="image-20211129101834318"></p></li></ol></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 添加：put(Object key,Object value)</span><br><span class="line">* 删除：remove(Object key)</span><br><span class="line">* 修改：put(Object key,Object value)</span><br><span class="line">* 查询：get(Object key)</span><br><span class="line">* 长度：size()</span><br><span class="line">* 遍历：keySet() / values() / entrySet()</span><br></pre></td></tr></table></figure></li><li><p>内存结构说明：（难点）</p><ol><li><p>HashMap在jdk7中实现原理：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = new HashMap():</span><br><span class="line">在实例化以后，底层创建了长度是16的一维数组Entry[] table。</span><br><span class="line">...可能已经执行过多次put...</span><br><span class="line">map.put(key1,value1):首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</span><br><span class="line">如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1</span><br><span class="line">如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：</span><br><span class="line">如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2</span><br><span class="line">如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</span><br><span class="line">如果equals()返回false:此时key1-value1添加成功。----情况3</span><br><span class="line">如果equals()返回true:使用value1替换value2。</span><br><span class="line"></span><br><span class="line">补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</span><br><span class="line"></span><br><span class="line">在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。</span><br></pre></td></tr></table></figure></li><li><p>HashMap在jdk8中相较于jdk7在底层实现方面的不同：</p><ol><li>new HashMap():底层没创建一个长度为16的数组</li><li>jdk 8底层的数组是：Node[],而非Entry[]</li><li>首次调用put()方法时，底层创建长度为16的数组</li><li>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</li><li>形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li><li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li></ol></li><li><p>HashMap底层典型属性的属性的说明：</p><ol><li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</li><li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</li><li>threshold：扩容的临界值，&#x3D;容量*填充因子：16 * 0.75 &#x3D;&gt; 12</li><li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</li><li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</li></ol></li><li><p>LinkedHashMap的底层实现原理(了解)</p><ol><li><p>LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap.</p></li><li><p>区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node.</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129102303272.png" alt="image-20211129102303272"></p></li></ol></li></ol></li><li><p>TreeMap的使用</p><ol><li>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象</li><li>因为要照key进行排序：自然排序 、定制排序</li></ol></li><li><p>使用Properties读取配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Properties:常用来处理配置文件。key和value都是String类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        pros.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="Collections工具类的使用"><a href="#Collections工具类的使用" class="headerlink" title="Collections工具类的使用"></a>Collections工具类的使用</h3><ol><li><p>作用：操作Collection和Map的工具类</p></li><li><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reverse(List)：反转 List 中元素的顺序</span><br><span class="line">shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序</span><br><span class="line">sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">swap(List，<span class="type">int</span>， <span class="type">int</span>)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br><span class="line">Object <span class="title function_">max</span><span class="params">(Collection)</span>：根据元素的自然顺序，返回给定集合中的最大元素</span><br><span class="line">Object <span class="title function_">max</span><span class="params">(Collection，Comparator)</span>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span><br><span class="line">Object <span class="title function_">min</span><span class="params">(Collection)</span></span><br><span class="line">Object <span class="title function_">min</span><span class="params">(Collection，Comparator)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection，Object)</span>：返回指定集合中指定元素的出现次数</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List dest,List src)</span>：将src中的内容复制到dest中</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List list，Object oldVal，Object newVal)</span>：使用新值替换 List 对象的所旧值</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129102433478.png" alt="image-20211129102433478"></p><p>说明：ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程的。<br>使用synchronizedList(List list） 和 synchronizedMap(Map map）</p></li><li><p>面试题：Collection 和 Collections的区别？</p></li></ol><h3 id="数据结构简述"><a href="#数据结构简述" class="headerlink" title="数据结构简述"></a>数据结构简述</h3><ol><li><p>数据结构概述</p><p>数据结构（Data Structure是一门和计算机硬件与软件都密切相关的学科，它的研究重点是在计算机的程序设计领域中探讨如何在计算机中组织和存储数据并进行高效率的运用，<strong>涉及的内容包含：数据的逻辑关系、数据的存储结构、排序算法（Algorithm）、查找（或搜索）等。</strong></p></li><li><p>数据结构与算法的理解</p><p>程序能否快速而高效地完成预定的任务，取决于是否选对了数据结构，而程序是否能清楚而正确地把问题解决，则取决于算法。</p><p>所以大家认为：“Algorithms + Data Structures &#x3D; Programs”（出自：Pascal之父Nicklaus Wirth）</p><p>总结：<strong>算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。</strong></p></li><li><p>数据结构的研究对象</p><ol><li><p>数据间的逻辑结构</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129102620506.png" alt="image-20211129102620506"></p><p><img src="/2024/04/15/Java/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20211129102630361.png" alt="image-20211129102630361"></p><p>​    集合结构            一对一：线性结构</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129102644497.png" alt="image-20211129102644497"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129102648930.png" alt="image-20211129102648930"></p><p>一对多：树形结构      多对多：图形结构</p></li><li><p>数据的存储结构：</p><ol><li><p>线性表（顺序表、链表、栈、队列）</p></li><li><p>树</p></li><li><p>图</p><p>说明：</p><ol><li><p>习惯上把顺序表和链表看做基本数据结构（或真实数据结构）</p></li><li><p>习惯上把栈、队列、树、图看做抽象数据类型，简称ADT</p></li></ol></li></ol></li></ol></li></ol><h2 id="12-泛型"><a href="#12-泛型" class="headerlink" title="12_泛型"></a>12_泛型</h2><h3 id="泛型的理解"><a href="#泛型的理解" class="headerlink" title="泛型的理解"></a>泛型的理解</h3><ol><li><p>泛型的概念：所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返<br>回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、<br>创建对象时确定（即传入实际的类型参数，也称为类型实参）。</p></li><li><p>泛型的引入背景</p><p>集合容器类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时<strong>把元素的类型设计成一个参数，这个类型参数叫做泛型</strong>。Collection<E>，List<E>，ArrayList<E>   这个<E>就是类型参数，即泛型。</E></E></E></E></p></li></ol><h3 id="泛型在集合中的使用"><a href="#泛型在集合中的使用" class="headerlink" title="泛型在集合中的使用"></a>泛型在集合中的使用</h3><ol><li><p>在集合中使用泛型之前的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//需求：存放学生的成绩</span></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">76</span>);</span><br><span class="line">        list.add(<span class="number">89</span>);</span><br><span class="line">        list.add(<span class="number">88</span>);</span><br><span class="line">        <span class="comment">//问题一：类型不安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Object score : list)&#123;</span><br><span class="line">            <span class="comment">//问题二：强转时，可能出现ClassCastException</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) score;</span><br><span class="line"></span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129102925593.png" alt="image-20211129102925593"></p></li><li><p>在集合中使用泛型例子1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">87</span>);</span><br><span class="line">        list.add(<span class="number">99</span>);</span><br><span class="line">        list.add(<span class="number">65</span>);</span><br><span class="line">        <span class="comment">//编译时，就会进行类型检查，保证数据的安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//        for(Integer score : list)&#123;</span></span><br><span class="line"><span class="comment">//            //避免了强转操作</span></span><br><span class="line"><span class="comment">//            int stuScore = score;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            System.out.println(stuScore);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129102951926.png" alt="image-20211129102951926"></p></li><li><p>在集合中使用泛型例子2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在集合中使用泛型的情况：以HashMap为例</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</span></span><br><span class="line">        <span class="comment">//jdk7新特性：类型推断</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">87</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">87</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">67</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        map.put(123,&quot;ABC&quot;);</span></span><br><span class="line">        <span class="comment">//泛型的嵌套</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>集合中使用泛型总结：</p><ol><li>集合接口或集合类在jdk5.0时都修改为带泛型的结构。</li><li>在实例化集合类时，可以指明具体的泛型类型</li><li>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。<ul><li>比如：add(E e)  —&gt;实例化以后：add(Integer e)</li></ul></li><li>注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</li><li>如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型。</li></ol></li></ol><h3 id="自定义泛型类、泛型接口、泛型方法"><a href="#自定义泛型类、泛型接口、泛型方法" class="headerlink" title="自定义泛型类、泛型接口、泛型方法"></a>自定义泛型类、泛型接口、泛型方法</h3><ol><li><p>举例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">【Order.java】</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt; &#123;</span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="type">int</span> orderId;</span><br><span class="line">    <span class="comment">//类的内部结构就可以使用类的泛型</span></span><br><span class="line">    T orderT;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        T[] arr = new T[10];</span></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String orderName,<span class="type">int</span> orderId,T orderT)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如下的个方法都不是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, orderT=&quot;</span> + orderT +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法中不能使用类的泛型。</span></span><br><span class="line"><span class="comment">//    public static void show(T orderT)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(orderT);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        try&#123;</span></span><br><span class="line"><span class="comment">//        &#125;catch(T t)&#123;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系。</span></span><br><span class="line">    <span class="comment">//换句话说，泛型方法所属的类是不是泛型类都没关系。</span></span><br><span class="line">    <span class="comment">//泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt;  List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span>&#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(E e : arr)&#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【SubOrder.java】</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubOrder</span> <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;Integer&gt; &#123;<span class="comment">//SubOrder:不是泛型类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] arr)</span>&#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(E e : arr)&#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化时，如下的代码是错误的</span></span><br><span class="line">SubOrder&lt;Integer&gt; o = <span class="keyword">new</span> <span class="title class_">SubOrder</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">【SubOrder1.java】</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubOrder1</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;T&gt; &#123;<span class="comment">//SubOrder1&lt;T&gt;:仍然是泛型类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【测试】</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型</span></span><br><span class="line">        <span class="comment">//要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setOrderT(<span class="number">123</span>);</span><br><span class="line">        order.setOrderT(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">        <span class="comment">//建议：实例化时指明类的泛型</span></span><br><span class="line">        Order&lt;String&gt; order1 = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;String&gt;(<span class="string">&quot;orderAA&quot;</span>,<span class="number">1001</span>,<span class="string">&quot;order:AA&quot;</span>);</span><br><span class="line">        order1.setOrderT(<span class="string">&quot;AA:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SubOrder</span> <span class="variable">sub1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubOrder</span>();</span><br><span class="line">        <span class="comment">//由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。</span></span><br><span class="line">        sub1.setOrderT(<span class="number">1122</span>);</span><br><span class="line">        SubOrder1&lt;String&gt; sub2 = <span class="keyword">new</span> <span class="title class_">SubOrder1</span>&lt;&gt;();</span><br><span class="line">        sub2.setOrderT(<span class="string">&quot;order2...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//泛型不同的引用不能相互赋值。</span></span><br><span class="line"><span class="comment">//        list1 = list2;</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        p1 = p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试泛型方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        Order&lt;String&gt; order = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;();</span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">//泛型方法在调用时，指明泛型参数的类型。</span></span><br><span class="line">        List&lt;Integer&gt; list = order.copyFromArrayToList(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>注意点：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129103323217.png" alt="image-20211129103323217"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129103329436.png" alt="image-20211129103329436"></p></li><li><p>应用场景举例：</p><ol><li><p>【DAO.java】:定义了操作数据库中的表的通用操作。   ORM思想(数据库中的表和Java中的类对应)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAO</span>&lt;T&gt; &#123;<span class="comment">//表的共性操作的DAO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一条记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改一条记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index,T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询一条记录</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询多条记录</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getForList</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="comment">//举例：获取表中一共有多少条记录？获取最大的员工入职时间？</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; E <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>【CustomerDAO.java】:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDAO</span> <span class="keyword">extends</span> <span class="title class_">DAO</span>&lt;Customer&gt;&#123;<span class="comment">//只能操作某一个表的DAO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【StudentDAO.java】:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDAO</span> <span class="keyword">extends</span> <span class="title class_">DAO</span>&lt;Student&gt; &#123;<span class="comment">//只能操作某一个表的DAO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a>泛型在继承上的体现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 泛型在继承方面的体现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      虽然类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       补充：类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        obj = str;</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">        String[] arr2 = <span class="literal">null</span>;</span><br><span class="line">        arr1 = arr2;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        Date date = new Date();</span></span><br><span class="line"><span class="comment">//        str = date;</span></span><br><span class="line">        List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//此时的list1和list2的类型不具子父类关系</span></span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        list1 = list2;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反证法：</span></span><br><span class="line"><span class="comment">        假设list1 = list2;</span></span><br><span class="line"><span class="comment">           list1.add(123);导致混入非String的数据。出错。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        show(list1);</span><br><span class="line">        show1(list2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(List&lt;Object&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        AbstractList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list3 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        list1 = list3;</span><br><span class="line">        list2 = list3;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ol><li><p>通配符的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通配符的使用</span></span><br><span class="line"><span class="comment">       通配符：?</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没关系的，二者共同的父类是：G&lt;?&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        list = list1;</span><br><span class="line">        list = list2;</span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line"><span class="comment">//        print(list1);</span></span><br><span class="line"><span class="comment">//        print(list2);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        list3.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        list = list3;</span><br><span class="line">        <span class="comment">//添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。</span></span><br><span class="line">        <span class="comment">//除了添加null之外。</span></span><br><span class="line"><span class="comment">//        list.add(&quot;DD&quot;);</span></span><br><span class="line"><span class="comment">//        list.add(&#x27;?&#x27;);</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line">        Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>涉及通配符的集合的数据的写入和读取:见上</p></li><li><p>有限制条件的通配符的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    限制条件的通配符的使用。</span></span><br><span class="line"><span class="comment">        ? extends A:</span></span><br><span class="line"><span class="comment">                G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ? super A:</span></span><br><span class="line"><span class="comment">                G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">        List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">        List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">        list1 = list3;</span><br><span class="line">        list1 = list4;</span><br><span class="line"><span class="comment">//        list1 = list5;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        list2 = list3;</span></span><br><span class="line">        list2 = list4;</span><br><span class="line">        list2 = list5;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据：</span></span><br><span class="line">        list1 = list3;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="comment">//Student s = list1.get(0);</span></span><br><span class="line"></span><br><span class="line">        list2 = list4;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">////编译不通过</span></span><br><span class="line"><span class="comment">//        Person obj = list2.get(0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据：</span></span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        list1.add(new Student());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">        list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line"></span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure></li></ol><h2 id="13-IO流"><a href="#13-IO流" class="headerlink" title="13_IO流"></a>13_IO流</h2><h3 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h3><ol><li><p>File类的理解</p><ol><li>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</li><li>File类声明在java.io包下</li><li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li><li>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”.</li></ol></li><li><p>File的实例化</p><ol><li><p>常用构造器</p><ol><li>File(String filePath)</li><li>File(String parentPath,String childPath)</li><li>File(File parentFile,String childPath)</li></ol></li><li><p>路径的分类</p><ol><li><p>相对路径：相较于某个路径下，指明的路径。</p></li><li><p>绝对路径：包含盘符在内的文件或文件目录的路径</p></li><li><p>说明：</p><ol><li><p>IDEA中：</p><ol><li>如果大家开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下。</li><li>如果大家使用main()测试，相对路径即为当前的Project下。</li></ol></li><li><p>Eclipse中：</p><p>​不管使用单元测试方法还是使用main()测试，相对路径都是当前的Project下。</p></li></ol></li></ol></li><li><p>路径分隔符</p><ol><li>windows和DOS系统默认使用“\”来表示</li><li>UNIX和URL使用“&#x2F;”来表示</li></ol></li></ol></li><li><p>File类的常用方法</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129104017505.png" alt="image-20211129104017505"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129104023286.png" alt="image-20211129104023286"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129104029287.png" alt="image-20211129104029287"></p></li></ol><h3 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h3><ol><li><p>流的分类</p><ol><li>操作数据单位：字节流、字符流</li><li>数据的流向：输入流、输出流</li><li>流的角色：节点流、处理流</li></ol><p>图示：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129104202182.png" alt="image-20211129104202182"></p></li><li><p>流的体系结构</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129104224300.png" alt="image-20211129104224300"></p><p>说明：红框对应的是IO流中的4个抽象基类。</p><p>蓝框的流需要大家重点关注。</p></li><li><p>重点说明的几个流结构</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129104317123.png" alt="image-20211129104317123"></p></li><li><p>输入、输出的标准化过程</p><ol><li>输入过程<ol><li>创建File类的对象，指明读取的数据的来源。（要求此文件一定要存在）</li><li>创建相应的输入流，将File类的对象作为参数，传入流的构造器中</li><li>具体的读入过程：创建相应的byte[] 或 char[]。</li><li>关闭流资源<br>说明：程序中出现的异常需要使用try-catch-finally处理。</li></ol></li><li>输出过程<ol><li>创建File类的对象，指明写出的数据的位置。（不要求此文件一定要存在）</li><li>创建相应的输出流，将File类的对象作为参数，传入流的构造器中</li><li>具体的写出过程：<br>write(char[]&#x2F;byte[] buffer,0,len)</li><li>关闭流资源<br>说明：程序中出现的异常需要使用try-catch-finally处理。</li></ol></li></ol></li></ol><h3 id="节点流（或文件流）"><a href="#节点流（或文件流）" class="headerlink" title="节点流（或文件流）"></a>节点流（或文件流）</h3><ol><li><p>FileReader&#x2F;FileWriter的使用：</p><ol><li><p>FileReader的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将day09下的hello.txt文件内容读入程序中，并输出到控制台</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明点：</span></span><br><span class="line"><span class="comment">1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</span></span><br><span class="line"><span class="comment">2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">3. 读入的文件一定要存在，否则就会报FileNotFoundException。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.File类的实例化</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.读入的操作</span></span><br><span class="line">            <span class="comment">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">            <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//方式一：</span></span><br><span class="line">                <span class="comment">//错误的写法</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; cbuf.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                <span class="comment">//正确的写法</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; len;i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                <span class="comment">//方式二：</span></span><br><span class="line">                <span class="comment">//错误的写法,对应着方式一的错误的写法</span></span><br><span class="line"><span class="comment">//                String str = new String(cbuf);</span></span><br><span class="line"><span class="comment">//                System.out.print(str);</span></span><br><span class="line">                <span class="comment">//正确的写法</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//4.资源的关闭</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>FileWriter的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从内存中写出数据到硬盘的文件里。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">1. 输出操作，对应的File可以不存在的。并不会报异常</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">     File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</span></span><br><span class="line"><span class="comment">     File对应的硬盘中的文件如果存在：</span></span><br><span class="line"><span class="comment">           如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原文件的覆盖</span></span><br><span class="line"><span class="comment">           如果流使用的构造器是：FileWriter(file,true):不会对原文件覆盖，而是在原文件基础上追加内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>文本文件的复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不能使用字符流来处理图片等字节数据</span></span><br><span class="line"><span class="comment">//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span></span><br><span class="line"><span class="comment">//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.创建输入流和输出流的对象</span></span><br><span class="line">             fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.数据的读入和写出操作</span></span><br><span class="line">            <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;<span class="comment">//记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//每次写出len个字符</span></span><br><span class="line">                fw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关闭流资源</span></span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                if(fw != null)</span></span><br><span class="line"><span class="comment">//                    fw.close();</span></span><br><span class="line"><span class="comment">//            &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;finally&#123;</span></span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    if(fr != null)</span></span><br><span class="line"><span class="comment">//                        fr.close();</span></span><br><span class="line"><span class="comment">//                &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                    fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                    fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>FileInputStream &#x2F; FileOutputStream的使用：</p><ol><li><p>对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</p></li><li><p>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现对图片的复制操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>【注意】相对路径在IDEA和Eclipse中使用的区别？</p><ol><li>IDEA:<ol><li>如果使用单元测试方法，相对路径基于当前的Module的。</li><li>如果使用main()测试，相对路径基于当前Project的。</li></ol></li><li>Eclipse:单元测试方法还是main(),相对路径都是基于当前Project的。</li></ol></li></ol><h3 id="缓冲流的使用"><a href="#缓冲流的使用" class="headerlink" title="缓冲流的使用"></a>缓冲流的使用</h3><ol><li><p>缓冲流涉及到的类：</p><ul><li>BufferedInputStream</li><li>BufferedOutputStream</li><li>BufferedReader</li><li>BufferedWriter</li></ul></li><li><p>作用：提供流的读取、写入的速度</p><p>提高读写速度的原因：内部提供了一个缓冲区。默认情况下是8kb</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129121012675.png" alt="image-20211129121012675"></p></li><li><p>典型代码</p><ol><li><p>使用BufferedInputStream和BufferedOutputStream:处理非文本文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现文件复制的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.造文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">            <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">            <span class="comment">//2.造流</span></span><br><span class="line">            <span class="comment">//2.1 造节点流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">            <span class="comment">//2.2 造缓冲流</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.复制的细节：读取、写入</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源关闭</span></span><br><span class="line">            <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">            <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span></span><br><span class="line"><span class="comment">//        fos.close();</span></span><br><span class="line"><span class="comment">//        fis.close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用BufferedReader和BufferedWriter：处理文本文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件和相应的流</span></span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">            bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读写操作</span></span><br><span class="line">            <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line"><span class="comment">//            char[] cbuf = new char[1024];</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line"><span class="comment">//    //            bw.flush();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式二：使用String</span></span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//方法一：</span></span><br><span class="line"><span class="comment">//                bw.write(data + &quot;\n&quot;);//data中不包含换行符</span></span><br><span class="line">                <span class="comment">//方法二：</span></span><br><span class="line">                bw.write(data);<span class="comment">//data中不包含换行符</span></span><br><span class="line">                bw.newLine();<span class="comment">//提供换行的操作</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="转换流的使用"><a href="#转换流的使用" class="headerlink" title="转换流的使用"></a>转换流的使用</h3><ol><li><p>转换流涉及到的类：属于字符流</p><ol><li><p>InputStreamReader：将一个字节的输入流转换为字符的输入流</p><p>解码：字节、字节数组  —&gt;字符数组、字符串</p></li><li><p>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</p><p>编码：字符数组、字符串 —&gt; 字节、字节数组</p></li><li><p>说明：编码决定了解码的方式</p><p>&#x2F;&#x2F;文件编码的方式（比如：GBK），决定了解析时使用的字符集（也只能是GBK）。</p></li></ol></li><li><p>作用：提供字节流与字符流之间的转换</p></li><li><p>图示：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129121229736.png" alt="image-20211129121229736"></p></li><li><p>典型实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line"><span class="comment">//        InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集</span></span><br><span class="line">        <span class="comment">//参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//使用系统默认的字符集</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此时处理异常的话，仍然应该使用try-catch-finally</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">综合使用InputStreamReader和OutputStreamWriter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.造文件、造流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读写过程</span></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.关闭资源</span></span><br><span class="line">    isr.close();</span><br><span class="line">    osw.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="编码集"><a href="#编码集" class="headerlink" title="编码集"></a>编码集</h4><ol><li><p>常见的编码表</p><ol><li>ASCII：美国标准信息交换码。<br>用一个字节的7位可以表示。</li><li>ISO8859-1：拉丁码表。欧洲码表<br>用一个字节的8位表示。</li><li>GB2312：中国的中文编码表。最多两个字节编码所有字符</li><li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</li><li>Unicode：国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li><li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</li></ol></li><li><p>对后面学习的启示</p><ol><li>客户端&#x2F;浏览器端    &lt;—-&gt;  后台(java,GO,Python,Node.js,php)   &lt;—-&gt; 数据库</li><li>要求前前后后使用的字符集都要统一：UTF-8.</li></ol></li></ol><h3 id="其它的流的使用"><a href="#其它的流的使用" class="headerlink" title="其它的流的使用"></a>其它的流的使用</h3><ol><li><p>标准的输入输出流：</p><ol><li>System.in:标准的输入流，默认从键盘输入</li><li>System.out:标准的输出流，默认从控制台输出</li><li>修改默认的输入和输出行为：System类的setIn(InputStream is) &#x2F; setOut(PrintStream ps)方式重新指定输入和输出的流。</li></ol></li><li><p>打印流：PrintStream 和PrintWriter</p><ol><li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li><li>System.out返回的是PrintStream的实例</li></ol></li><li><p>数据流：<br>DataInputStream 和 DataOutputStream</p><ol><li><p>作用：<br>用于读取或写出基本数据类型的变量或字符串</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">练习：将内存中的字符串、基本数据类型的变量写出到文件中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：处理异常的话，仍然应该使用try-catch-finally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    dos.writeUTF(<span class="string">&quot;刘建辰&quot;</span>);</span><br><span class="line">    dos.flush();<span class="comment">//刷新操作，将内存中的数据写入文件</span></span><br><span class="line">    dos.writeInt(<span class="number">23</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    dos.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">    System.out.println(<span class="string">&quot;isMale = &quot;</span> + isMale);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    dis.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="对象流的使用"><a href="#对象流的使用" class="headerlink" title="对象流的使用"></a>对象流的使用</h3><ol><li><p>对象流： ObjectInputStream 和 ObjectOutputStream</p></li><li><p>作用：</p><ol><li>ObjectOutputStream:内存中的对象—&gt;存储中的文件、通过网络传输出去：序列化过程</li><li>ObjectInputStream:存储中的文件、通过网络接收过来 —&gt;内存中的对象：反序列化过程</li></ol></li><li><p>对象的序列化机制：对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘<br>上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的<br>Java对象</p></li><li><p>序列化代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush();<span class="comment">//刷新操作</span></span><br><span class="line"></span><br><span class="line">         oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王铭&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张学良&quot;</span>,<span class="number">23</span>,<span class="number">1001</span>,<span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反序列化代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现序列化的对象所属的类需要满足：</p><ol><li>需要实现接口：Serializable</li><li>当前类提供一个全局常量：serialVersionUID</li><li>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</li><li>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</li></ol></li></ol><h3 id="RandomAccessFile的使用"><a href="#RandomAccessFile的使用" class="headerlink" title="RandomAccessFile的使用"></a>RandomAccessFile的使用</h3><ol><li><p>随机存取文件流：RandomAccessFile</p></li><li><p>使用说明：</p><ol><li>RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口</li><li>RandomAccessFile既可以作为一个输入流，又可以作为一个输出流</li><li>如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖）</li><li>可以通过相关的操作，实现RandomAccessFile“插入”数据的效果。seek(int pos)</li></ol></li><li><p>典型代码1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf2.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">    <span class="comment">//保存指针3后面的所数据到StringBuilder中</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调回指针，写入“xyz”</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);</span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将StringBuilder中的数据写入到文件中</span></span><br><span class="line">    raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">    raf1.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思考：将StringBuilder替换为ByteArrayOutputStream</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Path、Paths、Files的使用"><a href="#Path、Paths、Files的使用" class="headerlink" title="Path、Paths、Files的使用"></a>Path、Paths、Files的使用</h3><ol><li><p>NIO的使用说明：</p><ol><li>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java<br>IO API。</li><li>NIO与原来的IO同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于<br>通道的IO操作。</li><li><strong>NIO将以更加高效的方式进行文件的读写操作。</strong></li><li>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。</li></ol></li><li><p>Path的使用 —jdk7提供</p><ol><li><p>Path的说明：Path替换原有的File类。</p></li><li><p>如何实例化：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129122228546.png" alt="image-20211129122228546"></p></li><li><p>常用方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129122238238.png" alt="image-20211129122238238"></p></li></ol></li><li><p>Files工具类 —jdk7提供</p><ol><li><p>作用：<br>操作文件或文件目录的工具类</p></li><li><p>常用方法</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129122311124.png" alt="image-20211129122311124"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129122315352.png" alt="image-20211129122315352"></p></li></ol></li></ol><h2 id="14-网络编程"><a href="#14-网络编程" class="headerlink" title="14_网络编程"></a>14_网络编程</h2><h3 id="InetAddress类的使用"><a href="#InetAddress类的使用" class="headerlink" title="InetAddress类的使用"></a>InetAddress类的使用</h3><ol><li><p>实现网络通信需要解决的两个问题</p><ol><li>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</li><li>找到主机后如何可靠高效地进行数据传输</li></ol></li><li><p>网络通信的两个要素：</p><ol><li>对应问题一：IP和端口号</li><li>对应问题二：提供网络通信协议：TCP&#x2F;IP参考模型（应用层、传输层、网络层、物理+数据链路层）</li></ol></li><li><p>通信要素一：IP和端口号</p><ol><li><p>IP的理解</p><ol><li><p>IP:唯一的标识 Internet 上的计算机（通信实体）</p></li><li><p>在Java中使用InetAddress类代表IP</p></li><li><p>IP分类：IPv4 和 IPv6 ; 万维网 和 局域网</p></li><li><p>域名:   <a href="http://www.baidu.com/">www.baidu.com</a>   <a href="http://www.mi.com/">www.mi.com</a>  <a href="http://www.sina.com/">www.sina.com</a>  <a href="http://www.jd.com/">www.jd.com</a></p><p>域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。 ——-域名解析</p></li><li><p>本地回路地址：127.0.0.1 对应着：localhost</p></li></ol></li><li><p>InetAddress类:此类的一个对象就代表着一个具体的IP地址</p><ol><li>实例化:getByName(String host) 、 getLocalHost()</li><li>常用方法:getHostName() &#x2F; getHostAddress()</li></ol></li><li><p>端口号：正在计算机上运行的进程。</p><ol><li>要求：不同的进程不同的端口号</li><li>范围：被规定为一个 16 位的整数 0~65535。</li></ol><p>端口号与IP地址的组合得出一个网络套接字：<strong>Socket</strong></p></li></ol></li><li><p>通信要素二：网络通信协议</p><ol><li><p>分型模型</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129123458561.png" alt="image-20211129123458561"></p></li><li><p>TCP和UDP的区别</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129123507792.png" alt="image-20211129123507792"></p></li><li><p>TCP三次握手和四次挥手</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129123518762.png" alt="image-20211129123518762"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129123522815.png" alt="image-20211129123522815"></p></li></ol></li></ol><h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><p>代码示例1：客户端发送信息给服务端，服务端将数据显示在控制台上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.14.100&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet,<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.写出数据的操作</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端mm&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            <span class="comment">//3.获取输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不建议这样写，可能会乱码</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">//        int len;</span></span><br><span class="line"><span class="comment">//        while((len = is.read(buffer)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//            String str = new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">//            System.out.print(str);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自于：&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(baos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//5.关闭资源</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ss != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码示例2：客户端发送文件给服务端，服务端将文件保存在本地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    fis.close();</span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty1.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    ss.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭数据的输出</span></span><br><span class="line">    socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.接收来自于服务器端的数据，并显示到控制台上</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">byte</span>[] bufferr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len1;</span><br><span class="line">    <span class="keyword">while</span>((len1 = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        baos.write(buffer,<span class="number">0</span>,len1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    fis.close();</span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    baos.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty2.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;图片传输完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.服务器端给予客户端反馈</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    os.write(<span class="string">&quot;你好，美女，照片我已收到，非常漂亮！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.</span></span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    ss.close();</span><br><span class="line">    os.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是UDP方式发送的导弹&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>,data.length,inet,<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">    socket.send(packet);</span><br><span class="line"></span><br><span class="line">    socket.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line"></span><br><span class="line">    socket.receive(packet);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line"></span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="URL编程"><a href="#URL编程" class="headerlink" title="URL编程"></a>URL编程</h3><ol><li><p>URL(Uniform Resource Locator)的理解:<br>统一资源定位符，对应着互联网的某一资源地址</p></li><li><p>URL的5个基本结构：</p><p><a href="http://localhost:8080/examples/beauty.jpg?username=Tom">http://localhost:8080/examples/beauty.jpg?username=Tom</a></p><p>协议   主机名    端口号  资源地址           参数列表</p></li><li><p>如何实例化:</p><p><code>URL url = new URL(&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;);</code></p></li><li><p>常用方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129123826018.png" alt="image-20211129123826018"></p></li><li><p>可以读取、下载对应的url资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">        urlConnection.connect();</span><br><span class="line"></span><br><span class="line">        is = urlConnection.getInputStream();</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;day10\\beauty3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(urlConnection != <span class="literal">null</span>)&#123;</span><br><span class="line">            urlConnection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="15-Java反射机制"><a href="#15-Java反射机制" class="headerlink" title="15_Java反射机制"></a>15_Java反射机制</h2><h3 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h3><ol><li><p>本章的主要内容</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129123911661.png" alt="image-20211129123911661"></p></li><li><p>关于反射的理解:Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何<br>类的内部信息，并能直接操作任意对象的内部属性及方法。</p><p>框架 &#x3D; 反射 + 注解 + 设计模式。</p></li><li><p>体会反射机制的“动态性”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//体会反射的动态性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);<span class="comment">//0,1,2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">&quot;com.atguigu.java.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getInstance(classPath);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个指定类的对象。</span></span><br><span class="line"><span class="comment">classPath:指定类的全类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span>  Class.forName(classPath);</span><br><span class="line">   <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>反射机制能提供的功能</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129124016535.png" alt="image-20211129124016535"></p></li><li><p>相关API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Class:反射的源头</span><br><span class="line">java.lang.reflect.Method</span><br><span class="line">java.lang.reflect.Field</span><br><span class="line">java.lang.reflect.Constructor</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li></ol><h3 id="Class类的理解与获取Class的实例"><a href="#Class类的理解与获取Class的实例" class="headerlink" title="Class类的理解与获取Class的实例"></a>Class类的理解与获取Class的实例</h3><ol><li><p>Class类的理解</p><ol><li>类的加载过程：程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。<br>接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件<br>加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此<br>运行时类，就作为Class的一个实例。</li><li>换句话说，Class的实例就对应着一个运行时类。</li><li>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式<br>来获取此运行时类。</li></ol></li><li><p>获取Class实例的几种方式：（前三种方式需要掌握）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        System.out.println(clazz1);</span><br><span class="line">        <span class="comment">//方式二：通过运行时类的对象,调用getClass()</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line">        System.out.println(clazz2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">//        clazz3 = Class.forName(&quot;java.lang.String&quot;);</span></span><br><span class="line">        System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line">        System.out.println(clazz1 == clazz3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式四：使用类的加载器：ClassLoader  (了解)</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectionTest.class.getClassLoader();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz4</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">        System.out.println(clazz4);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz1 == clazz4);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>总结：创建类的对象的方式?</p><ol><li>方式一：new + 构造器</li><li>方式二：要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有<br>静态方法的存在。可以调用其静态方法，创建Xxx对象。</li><li>方式三：通过反射</li></ol></li><li><p>Class实例可以是哪些结构的说明</p><p><img src="/2024/04/15/Java/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20211129124227257.png" alt="image-20211129124227257"></p></li></ol><h3 id="了解ClassLoader"><a href="#了解ClassLoader" class="headerlink" title="了解ClassLoader"></a>了解ClassLoader</h3><ol><li><p>类的加载过程—-了解</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129124249502.png" alt="image-20211129124249502"></p></li><li><p>类的加载器的作用</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129124304756.png" alt="image-20211129124304756"></p></li><li><p>类的加载器的分类</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129124314971.png" alt="image-20211129124314971"></p></li><li><p>Java类编译、运行的执行的流程</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129124325393.png" alt="image-20211129124325393"></p></li><li><p><strong>使用Classloader加载src目录下的配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//此时的文件默认在当前的module下。</span></span><br><span class="line">        <span class="comment">//读取配置文件的方式一：</span></span><br><span class="line"><span class="comment">//        FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);</span></span><br><span class="line"><span class="comment">//        FileInputStream fis = new FileInputStream(&quot;src\\jdbc1.properties&quot;);</span></span><br><span class="line"><span class="comment">//        pros.load(fis);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">        <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">        pros.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot;,password = &quot;</span> + password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="反射应用一：创建运行时类的对象"><a href="#反射应用一：创建运行时类的对象" class="headerlink" title="反射应用一：创建运行时类的对象"></a>反射应用一：创建运行时类的对象</h3><ol><li><p>代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure></li><li><p>说明:newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</p><p>要想此方法正常的创建运行时类的对象，要求：</p><ol><li>运行时类必须提供空参的构造器</li><li>空参的构造器的访问权限得够。通常，设置为public。</li></ol><p>在javabean中要求提供一个public的空参构造器。原因：</p><ol><li>便于通过反射，创建运行时类的对象</li><li>便于子类继承此运行时类时，默认调用super()时，保证父类此构造器</li></ol></li></ol><h3 id="反射应用二：获取运行时类的完整结构"><a href="#反射应用二：获取运行时类的完整结构" class="headerlink" title="反射应用二：获取运行时类的完整结构"></a>反射应用二：获取运行时类的完整结构</h3><p>我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。。。。</p><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取属性结构</span></span><br><span class="line">    <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所属性。（不包含父类中声明的属性</span></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getMethods():获取当前运行时类及其所父类中声明为public权限的方法</span></span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所方法。（不包含父类中声明的方法</span></span><br><span class="line">    Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : declaredMethods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取构造器结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">        <span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器</span></span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor c : constructors)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//getDeclaredConstructors():获取当前运行时类中声明的所的构造器</span></span><br><span class="line">        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor c : declaredConstructors)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> clazz.getSuperclass();</span><br><span class="line">        System.out.println(superclass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        System.out.println(genericSuperclass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    代码：逻辑性代码  vs 功能性代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">        <span class="comment">//获取泛型类型</span></span><br><span class="line">        Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line"><span class="comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span></span><br><span class="line">        System.out.println(((Class)actualTypeArguments[<span class="number">0</span>]).getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类实现的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">        Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c : interfaces1)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取运行时类所在的包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Package</span> <span class="variable">pack</span> <span class="operator">=</span> clazz.getPackage();</span><br><span class="line">        System.out.println(pack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取运行时类声明的注解</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annos : annotations)&#123;</span><br><span class="line">            System.out.println(annos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="反射应用三：调用运行时类的指定结构"><a href="#反射应用三：调用运行时类的指定结构" class="headerlink" title="反射应用三：调用运行时类的指定结构"></a>反射应用三：调用运行时类的指定结构</h3><ol><li><p>调用指定的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testField1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>调用指定的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建运行时类的对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">        show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> show.invoke(p,<span class="string">&quot;CHN&quot;</span>); <span class="comment">//String nation = p.show(&quot;CHN&quot;);</span></span><br><span class="line">        System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*************如何调用静态方法*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// private static void showDesc()</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">        showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//如果调用的运行时类中的方法没返回值，则此invoke()返回null</span></span><br><span class="line"><span class="comment">//        Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> showDesc.invoke(Person.class);</span><br><span class="line">        System.out.println(returnVal);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>调用指定的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.获取指定的构造器</span></span><br><span class="line"><span class="comment">    getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="反射应用四：动态代理"><a href="#反射应用四：动态代理" class="headerlink" title="反射应用四：动态代理"></a>反射应用四：动态代理</h3><ol><li><p>代理模式的原理：使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 </p></li><li><p>静态代理</p><ol><li><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口的方法创建多线程。</span></span><br><span class="line">Class MyThread <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;&#125; <span class="comment">//相当于被代理类</span></span><br><span class="line">Class Thread <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;&#125; <span class="comment">//相当于代理类</span></span><br><span class="line">main()&#123;</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">thread.start();<span class="comment">//启动线程；调用线程的run()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态代理的缺点：</p><ol><li>代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。</li><li>每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</li></ol></li></ol></li><li><p>动态代理的特点：动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对<br>象。</p></li><li><p>动态代理的实现</p><ol><li><p>需要解决的两个主要问题：</p><ol><li>问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。<br>（通过Proxy.newProxyInstance()实现）</li><li>问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。<br>(通过InvocationHandler接口的实现类及其方法invoke())</li></ol></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 动态代理的举例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019 上午 10:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span>&#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanUtil</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================通用方法一====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================通用方法二====================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回一个代理类的对象。解决问题一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span>&#123;<span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanUtil</span> <span class="variable">util</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanUtil</span>();</span><br><span class="line">        util.method1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(obj,args);</span><br><span class="line"></span><br><span class="line">        util.method2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">        <span class="comment">//proxyInstance:代理类的对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">belief</span> <span class="operator">=</span> proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;四川麻辣烫&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">NikeClothFactory</span> <span class="variable">nikeClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ClothFactory</span> <span class="variable">proxyClothFactory</span> <span class="operator">=</span> (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>体会：反射的动态性。</strong></p></li></ol></li></ol><h2 id="16-Java8的其它新特性"><a href="#16-Java8的其它新特性" class="headerlink" title="16_Java8的其它新特性"></a>16_Java8的其它新特性</h2><h3 id="Java8新特性概述"><a href="#Java8新特性概述" class="headerlink" title="Java8新特性概述"></a>Java8新特性概述</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129125029856.png" alt="image-20211129125029856"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129125034325.png" alt="image-20211129125034325"></p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ol><li><p>Lambda表达式使用前后的对比：</p><ol><li><p>举例一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    r1.run();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;我爱北京故宫&quot;</span>);</span><br><span class="line"></span><br><span class="line">    r2.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>举例二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com1.compare(<span class="number">12</span>,<span class="number">21</span>);</span><br><span class="line">    System.out.println(compare1);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line">    <span class="comment">//Lambda表达式的写法</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare2</span> <span class="operator">=</span> com2.compare(<span class="number">32</span>,<span class="number">21</span>);</span><br><span class="line">    System.out.println(compare2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line">    <span class="comment">//方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare3</span> <span class="operator">=</span> com3.compare(<span class="number">32</span>,<span class="number">21</span>);</span><br><span class="line">    System.out.println(compare3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Lambda表达式的基本语法：</p><ol><li>举例： (o1,o2) -&gt; Integer.compare(o1,o2);</li><li>格式：<ol><li>-&gt; :lambda操作符 或 箭头操作符</li><li>-&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表</li><li>-&gt;右边：lambda体 （其实就是重写的抽象方法的方法体</li></ol></li></ol></li><li><p>如何使用：分为六种情况</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129125408541.png" alt="image-20211129125408541"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129125413572.png" alt="image-20211129125413572"></p><p>总结六种情况：</p><ul><li>-&gt; 左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只一个参数，其一对()也可以省略</li><li>-&gt; 右边：lambda体应该使用一对{}包裹；如果lambda体只一条执行语句（可能是return语句，省略这一对{}和return关键字</li></ul></li></ol><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ol><li><p>函数式接口的使用说明</p><ol><li>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。</li><li>我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。</li><li>Lambda表达式的本质：作为函数式接口的实例</li></ol></li><li><p>Java8中关于Lambda表达式提供的4个基本的函数式接口：具体使用：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129125538650.png" alt="image-20211129125538650"></p></li><li><p>总结</p><ol><li><p>何时使用lambda表达式？</p><p>当需要对一个函数式接口实例化的时候，可以使用lambda表达式。</p></li><li><p>何时使用给定的函数式接口？</p><p>如果我们开发中需要定义一个函数式接口，首先看看在已有的jdk提供的函数式接口是否提供了<br>能满足需求的函数式接口。如果有，则直接调用即可，不需要自己再自定义了。</p></li></ol></li></ol><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><ol><li><p>理解：方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法。</p></li><li><p>使用情境：当要传递给Lambda体的操作，已经实现的方法了，可以使用方法引用！</p></li><li><p>格式：类(或对象) :: 方法名</p></li><li><p>分为如下的三种情况：</p><ol><li>情况1     对象 :: 非静态方法</li></ol><ul><li><p>情况2     类 :: 静态方法</p></li><li><p>情况3     类 :: 非静态方法</p></li></ul></li><li><p>要求：</p><ol><li>要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</li><li>当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数(或无参数)时：ClassName::methodName（针对于情况3）</li></ol></li><li><p>使用建议：如果给函数式接口提供实例，恰好满足方法引用的使用情境，大家就可以考虑使用方法引用给函数式接口提供实例。如果大家不熟悉方法引用，那么还可以使用lambda表达式。</p></li><li><p>使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一：对象 :: 实例方法</span></span><br><span class="line"><span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line"><span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">con1.accept(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> System.out;</span><br><span class="line">Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">con2.accept(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Supplier中的T get()</span></span><br><span class="line"><span class="comment">//Employee中的String getName()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>,<span class="number">5600</span>);</span><br><span class="line"></span><br><span class="line">Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">Supplier&lt;String&gt; sup2 = emp::getName;</span><br><span class="line">System.out.println(sup2.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二：类 :: 静态方法</span></span><br><span class="line"><span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class="line">System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">System.out.println(com2.compare(<span class="number">12</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">//Math中的Long round(Double d)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">Function&lt;Double,Long&gt; func = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double d)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Math.round(d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">System.out.println(func1.apply(<span class="number">12.3</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Double,Long&gt; func2 = Math::round;</span><br><span class="line">System.out.println(func2.apply(<span class="number">12.6</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况：类 :: 实例方法  (难度)</span></span><br><span class="line"><span class="comment">// Comparator中的int comapre(T t1,T t2)</span></span><br><span class="line"><span class="comment">// String中的int t1.compareTo(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class="line">System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">System.out.println(com2.compare(<span class="string">&quot;abd&quot;</span>,<span class="string">&quot;abm&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line"><span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class="line">System.out.println(pre1.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">BiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class="line">System.out.println(pre2.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">// Employee中的String getName();</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="number">23</span>, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class="line">System.out.println(func1.apply(employee));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class="line">System.out.println(func2.apply(employee));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="构造器引用与数组引用"><a href="#构造器引用与数组引用" class="headerlink" title="构造器引用与数组引用"></a>构造器引用与数组引用</h3><ol><li><p>构造器引用格式：类名::new</p></li><li><p>构造器引用使用要求：和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型</p></li><li><p>构造器引用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Supplier中的T get()</span></span><br><span class="line">   <span class="comment">//Employee的空参构造器：Employee()</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">       Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">       System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Supplier&lt;Employee&gt;  sup2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">       System.out.println(sup2.get());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">       Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id);</span><br><span class="line">       <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> func1.apply(<span class="number">1001</span>);</span><br><span class="line">       System.out.println(employee);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Function&lt;Integer,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">       <span class="type">Employee</span> <span class="variable">employee1</span> <span class="operator">=</span> func2.apply(<span class="number">1002</span>);</span><br><span class="line">       System.out.println(employee1);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiFunction中的R apply(T t,U u)</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">       BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id,name);</span><br><span class="line">       System.out.println(func1.apply(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">       BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">       System.out.println(func2.apply(<span class="number">1002</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>数组引用格式：数组类型[] :: new</p></li><li><p>数组引用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">    String[] arr1 = func1.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Integer,String[]&gt; func2 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">    String[] arr2 = func2.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><ol><li><p>Stream API的理解：</p><ol><li>Stream关注的是对数据的运算，与CPU打交道<br>集合关注的是数据的存储，与内存打交道</li><li>java8提供了一套api,使用这套api可以对内存中的数据进行过滤、排序、映射、归约等操作。类似于sql对数据库中表的相关操作。</li></ol></li><li><p>注意点：</p><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol></li><li><p>Stream的使用流程：</p><ol><li>Stream的实例化</li><li>一系列的中间操作（过滤、映射、…)</li><li>终止操作</li></ol></li><li><p>使用流程的注意点：</p><ol><li>一个中间操作链，对数据源的数据进行处理</li><li>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</li></ol></li><li><p>步骤一：Stream实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 Stream方式一：通过集合</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        default Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class="line">        Stream&lt;Employee&gt; parallelStream = employees.parallelStream();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式二：通过数组</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line">        <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>,<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Employee[] arr1 = <span class="keyword">new</span> <span class="title class_">Employee</span>[]&#123;e1,e2&#125;;</span><br><span class="line">        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建 Stream方式三：通过Stream的of()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式四：创建无限流</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      迭代</span></span><br><span class="line"><span class="comment">//      public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">        <span class="comment">//遍历前10个偶数</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      生成</span></span><br><span class="line"><span class="comment">//      public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>步骤二：中间操作</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129144053418.png" alt="image-20211129144053418"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129144057919.png" alt="image-20211129144057919"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129144101495.png" alt="image-20211129144101495"></p></li><li><p>步骤三：终止操作</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129144113249.png" alt="image-20211129144113249"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129144117317.png" alt="image-20211129144117317"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129144122002.png" alt="image-20211129144122002"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129144127387.png" alt="image-20211129144127387"></p><p>Collector需要使用Collectors提供实例。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211129144145871.png" alt="image-20211129144145871"></p></li></ol><h3 id="Optional类的使用"><a href="#Optional类的使用" class="headerlink" title="Optional类的使用"></a>Optional类的使用</h3><p>java.util.Optional类</p><ol><li><p>理解：为了解决java中的空指针问题而生！</p><p>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null<br>，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避<br>免空指针异常。</T></p></li><li><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//empty():创建的Optional对象内部的value = null</span></span><br><span class="line">        Optional&lt;Object&gt; op1 = Optional.empty();</span><br><span class="line">        <span class="keyword">if</span>(!op1.isPresent())&#123;<span class="comment">//Optional封装的数据是否包含数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(op1);</span><br><span class="line">        System.out.println(op1.isPresent());</span><br><span class="line">        <span class="comment">//如果Optional封装的数据value为空，则get()报错。否则，value不为空时，返回value.</span></span><br><span class="line"><span class="comment">//        System.out.println(op1.get());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//        str = null;</span></span><br><span class="line">        <span class="comment">//of(T t):封装数据t生成Optional对象。要求t非空，否则报错。</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.of(str);</span><br><span class="line">        <span class="comment">//get()通常与of()方法搭配使用。用于获取内部的封装的数据value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> op1.get();</span><br><span class="line">        System.out.println(str1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line">        str = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//ofNullable(T t) ：封装数据t赋给Optional内部的value。不要求t非空</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.ofNullable(str);</span><br><span class="line">        <span class="comment">//orElse(T t1):如果Optional内部的value非空，则返回此value值。如果</span></span><br><span class="line">        <span class="comment">//value为空，则返回t1.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> op1.orElse(<span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(str2);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>典型练习：<br>能保证如下的方法执行中不会出现空指针的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Optional类的getGirlName():</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getGirlName2</span><span class="params">(Boy boy)</span>&#123;</span><br><span class="line"></span><br><span class="line">    Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">    <span class="comment">//此时的boy1一定非空</span></span><br><span class="line">    <span class="type">Boy</span> <span class="variable">boy1</span> <span class="operator">=</span> boyOptional.orElse(<span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;迪丽热巴&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> boy1.getGirl();</span><br><span class="line"></span><br><span class="line">    Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">    <span class="comment">//girl1一定非空</span></span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl1</span> <span class="operator">=</span> girlOptional.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;古力娜扎&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> girl1.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    boy = <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">    boy = <span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;苍老师&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">girlName</span> <span class="operator">=</span> getGirlName2(boy);</span><br><span class="line">    System.out.println(girlName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Java高级篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Java高级篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为笔试&amp;面经</title>
      <link href="/2024/04/10/Written%20Examination/bishi/"/>
      <url>/2024/04/10/Written%20Examination/bishi/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客上一些笔试题"><a href="#牛客上一些笔试题" class="headerlink" title="牛客上一些笔试题"></a>牛客上一些笔试题</h1><h2 id="1-最高分是多少"><a href="#1-最高分是多少" class="headerlink" title="1.最高分是多少"></a>1.最高分是多少</h2><p>注释了一些调试信息</p><p>这题就熟悉输入输出流程</p><p>还有就是单元 测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意类名必须为 Main, 不要有任何 package xxx 信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 注意 hasNext 和 hasNextLine 的区别</span></span><br><span class="line">        <span class="keyword">while</span> (in.hasNextInt()) &#123; <span class="comment">// 注意 while 处理多个 case</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> [] score = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="comment">//            System.out.println();</span></span><br><span class="line"><span class="comment">//            System.out.println(N+&quot; &quot;+M);</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N ; i++) &#123;</span><br><span class="line">                score[i] = in.nextInt();</span><br><span class="line">                <span class="comment">//System.out.print(score[i] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; M ; j++) &#123;</span><br><span class="line">                c = in.next();</span><br><span class="line">                A = in.nextInt();</span><br><span class="line">                B = in.nextInt();</span><br><span class="line">                <span class="comment">//System.out.print(&quot;修改前：&quot; + Arrays.toString(score));</span></span><br><span class="line">                process(c, A, B, score);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String c, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>[] score)</span> &#123;</span><br><span class="line">        <span class="type">int</span> begin, end;</span><br><span class="line">        <span class="keyword">if</span> (c.equals(<span class="string">&quot;Q&quot;</span>)) &#123;</span><br><span class="line">            begin = Math.min(a, b) - <span class="number">1</span>;</span><br><span class="line">            end = Math.max(a, b);</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> score[begin];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin ; i &lt; end; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (max &lt; score[i]) &#123;</span><br><span class="line">                    max = score[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println();</span></span><br><span class="line">            System.out.println(max);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.equals(<span class="string">&quot;U&quot;</span>)) &#123;</span><br><span class="line">            score[a - <span class="number">1</span>] = b;</span><br><span class="line">            <span class="comment">//System.out.print(&quot;修改后：&quot; + Arrays.toString(score));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-简单错误记录"><a href="#2-简单错误记录" class="headerlink" title="2.简单错误记录"></a>2.简单错误记录</h2><p>HashMap中的根据value排序，还要重写compare算法，醉了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 注意类名必须为 Main, 不要有任何 package xxx 信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            <span class="comment">//System.out.println(str);</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> str.lastIndexOf(<span class="string">&quot;\\&quot;</span>);</span><br><span class="line">            str = str.substring(lastIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (str.length() &gt; <span class="number">16</span>) &#123;</span><br><span class="line">                str = str.substring(str.length() - <span class="number">16</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(str);</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(str)) &#123;</span><br><span class="line">                map.put(str, map.get(str) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(str, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">ArrayList</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet()); <span class="comment">//转换为list</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1,</span></span><br><span class="line"><span class="params">                               Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; mapping : list) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; map.keySet().size() - <span class="number">8</span>) &#123;</span><br><span class="line">                System.out.println(mapping.getKey() + <span class="string">&quot; &quot;</span> + mapping.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-扑克牌消除"><a href="#3-扑克牌消除" class="headerlink" title="3.扑克牌消除"></a>3.扑克牌消除</h2><p>从一副扑克牌中随机抽取n张牌组成一个序列，规定连续3张相同牌号的卡牌可以消除，剩余卡牌按照当前顺序里新合井成新的序列后继续消除，重奥以上步票直到无法消除，最后清输出结束后剩余的卡牌序列，注:存在连续4张相同牌号的情况，消除后剩余一张</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">card</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        scan.nextLine();</span><br><span class="line">        String [] s = scan.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(s));</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size()-<span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(Objects.equals(list.get(i), list.get(i + <span class="number">1</span>)) &amp;&amp; Objects.equals(list.get(i), list.get(i + <span class="number">2</span>)))&#123;</span><br><span class="line">                    list.remove(i);</span><br><span class="line">                    list.remove(i);</span><br><span class="line">                    list.remove(i);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(list.size() &lt; <span class="number">3</span> || !flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String s1 : list)&#123;</span><br><span class="line">            System.out.print(s1+ <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是，暴力，转为List集合，外层死循环while（true）</p><p>内层for（）判断三个相等就删跳出for循环</p><p>对新集合继续for（）</p><p>没被删除过，或者集合长度小于3，break跳出while（true</p><h2 id="4-计算云服务的DI值"><a href="#4-计算云服务的DI值" class="headerlink" title="4.计算云服务的DI值"></a>4.计算云服务的DI值</h2><p>现有一批云服务树，已给出云服务树各节点的问题数量，请通过计算输出风险云服务的个数。计算公式: DI值&lt;&#x3D;5<em>严重问题数+2</em>一般问题数，其中每个节点的不同级别问题数量需要将该节点及该节点为根节点的所有子节点的相应级别问题数量求和。</p><p> 输入：第一行输入M和N，表示云服务阈值N，和接下来的N行数据        </p><p> 剩下N行输入为N<em>4矩阵，行内使用空格分隔，第一列为服务节点，第二列为父节点（如果没有父节点用</em>代替），第三列为问题（0表示严重问题，1表示一般问题），第四列表示当前问题的数量</p><p> 输出：计算输出风险云服务的DI值 </p><p>例如：输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2 5</span><br><span class="line">a * 0 2</span><br><span class="line">a * 1 2 </span><br><span class="line">b a 0 2 </span><br><span class="line">c b 0 2</span><br><span class="line">d * 0 2 </span><br></pre></td></tr></table></figure><p>输出：2（表示有2个风险云服务,分别为a,d）</p><p>解释： a为云服务节点,有两个严重，两个一般问题，b为a的子节点,有两个严重问题，c为b的子节点，有两个严重问题，a服务器一共有6个严重问题，两个一般问题，DI值为：6<em>5+2</em>2&#x3D;32&gt;2。是风险云服务 </p><p>d云服务节点，有2个严重，0个一般，DI值为2*2&#x3D;4&gt;2，是风险云服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    List&lt;TreeNode&gt; children;</span><br><span class="line">    <span class="type">int</span> severeProblems;</span><br><span class="line">    <span class="type">int</span> minorProblems;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.severeProblems = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.minorProblems = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加问题数据</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addProblems</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123; <span class="comment">// 严重问题</span></span><br><span class="line">            <span class="built_in">this</span>.severeProblems += count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) &#123; <span class="comment">// 一般问题</span></span><br><span class="line">            <span class="built_in">this</span>.minorProblems += count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算包括所有子节点的问题总数</span></span><br><span class="line">    <span class="type">int</span>[] getTotalProblems() &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSevere</span> <span class="operator">=</span> severeProblems;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalMinor</span> <span class="operator">=</span> minorProblems;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode child : children) &#123;</span><br><span class="line">            <span class="type">int</span>[] childProblems = child.getTotalProblems();</span><br><span class="line">            totalSevere += childProblems[<span class="number">0</span>];</span><br><span class="line">            totalMinor += childProblems[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;totalSevere, totalMinor&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, TreeNode&gt; nodeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取并构建树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] parts = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> parts[<span class="number">0</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">parentNode</span> <span class="operator">=</span> parts[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">problemType</span> <span class="operator">=</span> Integer.parseInt(parts[<span class="number">2</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">problemCount</span> <span class="operator">=</span> Integer.parseInt(parts[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeMap.getOrDefault(nodeName, <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nodeName));</span><br><span class="line">            node.addProblems(problemType, problemCount);</span><br><span class="line">            nodeMap.put(nodeName, node);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!parentNode.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> nodeMap.getOrDefault(parentNode, <span class="keyword">new</span> <span class="title class_">TreeNode</span>(parentNode));</span><br><span class="line">                <span class="keyword">if</span> (!parent.children.contains(node)) &#123;</span><br><span class="line">                    parent.children.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">                nodeMap.put(parentNode, parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算风险云服务</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">riskServiceCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode node : nodeMap.values()) &#123;</span><br><span class="line">            <span class="type">int</span>[] totalProblems = node.getTotalProblems();</span><br><span class="line">            <span class="type">int</span> <span class="variable">diValue</span> <span class="operator">=</span> <span class="number">5</span> * totalProblems[<span class="number">0</span>] + <span class="number">2</span> * totalProblems[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (diValue &gt; threshold) &#123;</span><br><span class="line">                riskServiceCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(riskServiceCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-球队射门能力"><a href="#5-球队射门能力" class="headerlink" title="5.球队射门能力"></a>5.球队射门能力</h2><p>球队有n个足球队员参与m次射门训练，每次射门进球用1表示，射失则用0表示，依据如下规则对该n个队员的射门能力做排序 </p><p>1、进球总数更多的队员射门能力更强</p><p> 2、若进球总数一样多，则比较最多一次连续进球的个数，最多的队员能力更游</p><p> 3、若最多一次连续进球的个数一样多，则比较第一次射失的先后顺序，其中后射失的队员更强，若第一次射失顺序相同，则按继续比较第二次射失的顺序，后丢球的队员能力更强，依次类推</p><p>4、若前3个规则排序后还能力相等，则队员编号更小的能力更强</p><p> 输入：第1行，足球队员数n，射门训练次数m。(队员编号从1开始，依次递增)第2行，第1-n个队员从第1到m次训练的进球情况，每个队员进球情况为连续的1和0的组合，不同队员用空格分隔n和m均为正整数，0xn&lt;&#x3D;10个3，0&lt;m&lt;&#x3D;10^3</p><p> 输出： 射门能力从强到弱的队员编号，用空格分隔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FootballPlayerRanking</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 读取球员数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 读取射门次数</span></span><br><span class="line">        scanner.nextLine(); <span class="comment">// 跳过行尾</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 读取所有球员的射门结果</span></span><br><span class="line">        String[] allResults = line.split(<span class="string">&quot; &quot;</span>); <span class="comment">// 按球员分割射门结果</span></span><br><span class="line"></span><br><span class="line">        List&lt;Player&gt; players = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            players.add(<span class="keyword">new</span> <span class="title class_">Player</span>(i + <span class="number">1</span>, allResults[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据规则对球员进行排序</span></span><br><span class="line">        Collections.sort(players);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出球员编号</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; players.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) output.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            output.append(players.get(i).id);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(output.toString());</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Player</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Player&gt; &#123;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">int</span> goals;</span><br><span class="line">        <span class="type">int</span> maxConsecutiveGoals;</span><br><span class="line">        List&lt;Integer&gt; misses;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Player</span><span class="params">(<span class="type">int</span> id, String shootingResults)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.goals = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.maxConsecutiveGoals = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.misses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentStreak</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; shootingResults.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shootingResults.charAt(i) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    currentStreak++;</span><br><span class="line">                    <span class="built_in">this</span>.goals++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.misses.add(i);</span><br><span class="line">                    <span class="keyword">if</span> (currentStreak &gt; <span class="built_in">this</span>.maxConsecutiveGoals) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.maxConsecutiveGoals = currentStreak;</span><br><span class="line">                    &#125;</span><br><span class="line">                    currentStreak = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentStreak &gt; <span class="built_in">this</span>.maxConsecutiveGoals) &#123;</span><br><span class="line">                <span class="built_in">this</span>.maxConsecutiveGoals = currentStreak;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Player other)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.goals != other.goals) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(other.goals, <span class="built_in">this</span>.goals);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.maxConsecutiveGoals != other.maxConsecutiveGoals) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(other.maxConsecutiveGoals, <span class="built_in">this</span>.maxConsecutiveGoals);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(<span class="built_in">this</span>.misses.size(), other.misses.size()); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.misses.get(i).equals(other.misses.get(i))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(other.misses.get(i), <span class="built_in">this</span>.misses.get(i));  <span class="comment">// 修改比较射失顺序，使其正确比较</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.misses.size() != other.misses.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(other.misses.size(), <span class="built_in">this</span>.misses.size());  <span class="comment">// 若misses数量不同，则比较数量</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.id, other.id);  <span class="comment">// 最后比较ID</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>理解问题</strong></li></ol><p>首先，需要完全理解题目的要求和所有排序规则。这个问题要求我们根据足球队员在多次射门训练中的表现来排序。排序的依据有四个层级：</p><ol><li><p>总进球数（多的优先）。</p></li><li><p>最大连续进球次数（多的优先）。</p></li><li><p>射失的顺序（射失越晚越好）。</p></li><li><p>队员编号（编号小的优先）。</p></li><li><p><strong>解析输入</strong></p></li></ol><p>从输入中读取球员数量和射门次数，然后读取所有球员的射门结果。每个球员的射门结果都是一个由 ‘1’（进球）和 ‘0’（未进球）组成的字符串。</p><ol start="3"><li><strong>设计数据结构</strong></li></ol><p>为了方便管理和排序球员的射门数据，我定义了一个 <code>Player</code> 类，包括：</p><ul><li><code>id</code>：球员的编号。</li><li><code>goals</code>：总进球数。</li><li><code>maxConsecutiveGoals</code>：最大连续进球数。</li><li><code>misses</code>：记录每次未进球的具体位置，以便比较射失顺序。</li></ul><ol start="4"><li><strong>计算排序关键值</strong></li></ol><p>对每个球员，解析其射门结果字符串，计算总进球数和最大连续进球数。同时，记录所有射失（即 ‘0’ 的位置）的索引，这些索引后续用于比较射失顺序。</p><ol start="5"><li><strong>实现比较逻辑</strong></li></ol><p>在 <code>Player</code> 类中实现 <code>Comparable</code> 接口，具体比较逻辑按照题目要求的四个层级顺序：</p><ul><li>首先比较总进球数。</li><li>若进球数相同，比较最大连续进球数。</li><li>若最大连续进球数也相同，依次比较每次射失的顺序。</li><li>若所有射失顺序也相同，最后比较球员编号。</li></ul><ol start="6"><li><strong>排序和输出</strong></li></ol><p>使用 <code>Collections.sort</code> 根据定义好的比较逻辑对球员列表进行排序。最后，输出排序后的球员编号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> goals;</span><br><span class="line">    <span class="type">int</span> maxStreak;</span><br><span class="line">    List&lt;Integer&gt; missTimes; <span class="comment">// 存储每次失误的时间点</span></span><br><span class="line"></span><br><span class="line">    Player(<span class="type">int</span> id, String record) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.goals = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.maxStreak = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.missTimes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">streak</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; record.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record.charAt(i) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                goals++;</span><br><span class="line">                streak++;</span><br><span class="line">                maxStreak = Math.max(maxStreak, streak);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                streak = <span class="number">0</span>;</span><br><span class="line">                missTimes.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 读取玩家数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 读取比赛次数，虽然这个值没有直接用途</span></span><br><span class="line">        sc.nextLine();</span><br><span class="line">        Player[] players = <span class="keyword">new</span> <span class="title class_">Player</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            players[i] = <span class="keyword">new</span> <span class="title class_">Player</span>(i + <span class="number">1</span>, sc.next());</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(players, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Player&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Player p1, Player p2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p1.goals != p2.goals) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p2.goals - p1.goals;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p1.maxStreak != p2.maxStreak) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p2.maxStreak - p1.maxStreak;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 比较最早的失误时间点</span></span><br><span class="line">                <span class="keyword">if</span> (!p1.missTimes.isEmpty() &amp;&amp; !p2.missTimes.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">minSize</span> <span class="operator">=</span> Math.min(p1.missTimes.size(), p2.missTimes.size());</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; minSize; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (p1.missTimes.get(i) != p2.missTimes.get(i)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> p2.missTimes.get(i) - p1.missTimes.get(i); <span class="comment">// 修改比较方式，最早失误的排在后面</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> p1.missTimes.size() - p2.missTimes.size(); <span class="comment">// 较少失误次数的排前面</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p1.id - p2.id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(players[i].id);</span><br><span class="line">            <span class="keyword">if</span> (i != n - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对上述代码修改，用Lambda表达式代替匿名实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：排序的四个层级</span></span><br><span class="line"><span class="comment">1.总进球数（越多越好）</span></span><br><span class="line"><span class="comment">2，最大连续进球数（越多越好）</span></span><br><span class="line"><span class="comment">3.射失的顺序（后射失越好）</span></span><br><span class="line"><span class="comment">4.队员编号（越小越好）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据结构：定义Player类</span></span><br><span class="line"><span class="comment">字段包括：ID：编号 int</span></span><br><span class="line"><span class="comment">        goals：总进球数 int</span></span><br><span class="line"><span class="comment">        goalsNumber:连续进球数 int</span></span><br><span class="line"><span class="comment">        misses :丢球的具体位置，List&lt;Integer&gt;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> goals;</span><br><span class="line">    <span class="type">int</span> goalsNumber;</span><br><span class="line">    List&lt;Integer&gt; misses;</span><br><span class="line"></span><br><span class="line">    Player(<span class="type">int</span> id, String record) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.goals = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.goalsNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.misses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//记录临时的连续进球最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; record.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record.charAt(i) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                goals++;</span><br><span class="line">                temp++;</span><br><span class="line">                goalsNumber = Math.max(temp, goalsNumber);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                misses.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        Player[] players = <span class="keyword">new</span> <span class="title class_">Player</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            players[i] = <span class="keyword">new</span> <span class="title class_">Player</span>(i + <span class="number">1</span>, scanner.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*在Java中，当使用Comparator接口来定制排序时，compare方法需要返回三种类型的值来指示两个元素的相对顺序：</span></span><br><span class="line"><span class="comment">            返回一个负数，表示第一个参数应该排在第二个参数之前。</span></span><br><span class="line"><span class="comment">            返回零，表示两个参数相等。</span></span><br><span class="line"><span class="comment">            返回一个正数，表示第一个参数应该排在第二个参数之后。</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Arrays.sort(players, (p1, p2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.goals != p2.goals) &#123;</span><br><span class="line">                <span class="comment">//降序排序</span></span><br><span class="line">                <span class="keyword">return</span> p2.goals - p1.goals;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1.goalsNumber != p2.goalsNumber) &#123;</span><br><span class="line">                <span class="keyword">return</span> p2.goalsNumber - p1.goalsNumber;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//都一样的情况下，比较最小的失误点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; p1.misses.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p1.misses.get(i) != p2.misses.get(i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p2.misses.get(i) - p1.misses.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后比较ID，ID小的排在前面</span></span><br><span class="line">            <span class="keyword">return</span> p1.id - p2.id;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(players[i].id);</span><br><span class="line">            <span class="keyword">if</span> (i != n - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="面经笔试题"><a href="#面经笔试题" class="headerlink" title="面经笔试题"></a>面经笔试题</h1><h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409.最长回文串"></a>409.最长回文串</h2><p>给定一个包含大写字母和小写字母的字符串 <code>s</code> ，返回 <em>通过这些字母构造成的 <strong>最长的回文串</strong></em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路，用set集合，去重，偶数的必能组成回文，基数的加1即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(c)) &#123;</span><br><span class="line">                set.remove(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> l - set.size();</span><br><span class="line">        <span class="keyword">if</span> (set.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h3><p>判断一个数字是否是回文数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：反过来求，判断两个数是否相等</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = x;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            a = a * <span class="number">10</span> + b % <span class="number">10</span>;</span><br><span class="line">            b /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用StringBuffer的reverse函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s1).reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> s1.equals(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674.最长连续递增序列"></a>674.最长连续递增序列</h3><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：两层暴力循环，找到，count++，找不到，跳出循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; l; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">// 排序后将String作为key，List&lt;String&gt;作为value</span></span><br><span class="line">        <span class="comment">// 寻找相同的String，添加到List&lt;String&gt;中，最后返回map中的List集合即可</span></span><br><span class="line">        <span class="comment">// 相等于用，map去重</span></span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            List&lt;String&gt; value = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            value.add(s);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1019-链表下一个更大的节点"><a href="#1019-链表下一个更大的节点" class="headerlink" title="1019.链表下一个更大的节点"></a>1019.链表下一个更大的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        current = head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> current.next;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextBigger</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next.val &gt; current.val) &#123;</span><br><span class="line">                    nextBigger = next.val;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                next = next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[index++] = nextBigger;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="53，最大子序和"><a href="#53，最大子序和" class="headerlink" title="53，最大子序和"></a>53，最大子序和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力模拟，超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ; j &lt; l; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                ans = sum &gt; ans ? sum : ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
          <category> 华为 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 华为 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2024/04/07/Java/Docker/"/>
      <url>/2024/04/07/Java/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>快速构建，运行，管理应用的工具</p><p>Docker是一种用于开发、交付和运行应用程序的开放平台。它基于容器化技术，可以将应用程序及其依赖项打包到容器中，并在任何环境中快速、可靠地运行。</p><p>​当我们利用Docker安装应用时候，Docker会自动搜索并且下载<strong>镜像（image）</strong>这个镜像不仅包含应用本身，还包含应用所需要的环境，配置，系统函数库。Docker会在运行的时候，创建一个隔离环境，称为<strong>容器（container）</strong></p><h2 id="Linux环境准备"><a href="#Linux环境准备" class="headerlink" title="Linux环境准备"></a>Linux环境准备</h2><p><strong>Linux环境的准备</strong></p><h3 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a><strong>VMware安装</strong></h3><h3 id="CentOS安装"><a href="#CentOS安装" class="headerlink" title="CentOS安装"></a><strong>CentOS安装</strong></h3><p>​：网卡地址改为静态IP，这样可以避免每次启动虚拟机IP都变化。</p><p>​：设置虚拟机快照，方便退回到之前的版本</p><h3 id="SSH客户端："><a href="#SSH客户端：" class="headerlink" title="SSH客户端："></a><strong>SSH客户端：</strong></h3><p>​Xshell：方便远程连接虚拟机</p><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><h3 id="1-卸载旧版"><a href="#1-卸载旧版" class="headerlink" title="1.卸载旧版"></a>1.卸载旧版</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine</span><br></pre></td></tr></table></figure><p>2.配置Docker的yum库</p><h2 id="2-配置Docker的yum库"><a href="#2-配置Docker的yum库" class="headerlink" title="2.配置Docker的yum库"></a>2.配置Docker的yum库</h2><p>首先要安装一个yum工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>安装成功后，执行命令，配置Docker的yum源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3.安装Docker"></a>3.安装Docker</h2><p>最后，执行命令，安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h2 id="4-启动和校验"><a href="#4-启动和校验" class="headerlink" title="4.启动和校验"></a>4.启动和校验</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止Docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h2 id="5-配置镜像加速"><a href="#5-配置镜像加速" class="headerlink" title="5.配置镜像加速"></a>5.配置镜像加速</h2><p>这里以阿里云镜像加速为例。</p><p>阿里云开通镜像服务</p><p>在首页的产品中，找到阿里云的<strong>容器镜像服务</strong>：</p><p>配置镜像加速器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://q9dfdql1.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="1-部署MySQL"><a href="#1-部署MySQL" class="headerlink" title="1.部署MySQL"></a>1.部署MySQL</h2><p>首先，我们利用Docker来安装一个MySQL软件，大家可以对比一下之前传统的安装方式，看看哪个效率更高一些。</p><p>如果是利用传统方式部署MySQL，大概的步骤有：</p><ul><li>搜索并下载MySQL安装包</li><li>上传至Linux环境</li><li>编译和配置环境</li><li>安装</li></ul><p>而使用Docker安装，仅仅需要一步即可，在命令行输入下面的命令（建议采用CV大法）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>要知道，<strong>不同操作系统下其安装包、运行环境是都不相同的</strong>！如果是<strong>手动安装，必须手动解决安装包不同、环境不同的、配置不同的问题</strong>！</p><p>而使用Docker，这些完全不用考虑。就是因为Docker会自动搜索并下载MySQL。注意：这里下载的不是安装包，而是<strong>镜像。</strong>镜像中不仅包含了MySQL本身，还包含了其运行所需要的环境、配置、系统级函数库。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为<strong>容器</strong>。</p><p>说明：</p><ul><li>镜像：英文是image</li><li>容器：英文是container</li></ul><p>镜像仓库：存储和管理镜像的平台，Docker官方维护了一个公共仓库，Docker Hub</p><p><a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240407200802137.png" alt="image-20240407200802137"></p><p><strong>总结：Docker本身包含了一个后台服务，使用Docker命令告诉Docker服务，帮助我们快速部署指定的应用。</strong></p><p><strong>Docker部署服务应用的时候，首先要去搜索并且下载应用对应的镜像，然后根据镜像创建并且在容器里部署， 应用就部署完成了，甚至可以通过不同的端口，部署多个应用</strong></p><h2 id="2-命令解读"><a href="#2-命令解读" class="headerlink" title="2.命令解读"></a>2.命令解读</h2><p>利用Docker快速的安装了MySQL，非常的方便，不过我们执行的命令到底是什么意思呢？</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li><li><code>--name mysql </code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将<strong><strong>宿主机</strong></strong>端口****映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="2-1-1-命令介绍"><a href="#2-1-1-命令介绍" class="headerlink" title="2.1.1.命令介绍"></a>2.1.1.命令介绍</h3><p>其中，比较常见的命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240407204232729.png" alt="image-20240407204232729"></p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>容器是隔离环境，容器内的程序的文件，配置，运行产生的容器都在容器内部，我们要读写容器内的文件不容易。</p><ul><li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让Nginx代理我的静态资源怎么办？</li></ul><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器****解耦</strong>。</p><p>数据卷是一个虚拟目录，是容器内部目录与宿主目录之间映射的桥梁</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240416121304068.png" alt="image-20240416121304068"></p><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p><h2 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h2><p>数据卷的相关命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     <span class="number">29524</span>ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html</span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br></pre></td></tr></table></figure><h3 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h3><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql <span class="comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span></span><br><span class="line">-v ./mysql:/var/lib/mysql <span class="comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span></span><br></pre></td></tr></table></figure><p><strong>教学演示</strong>，删除并重新创建mysql容器，并完成本地目录挂载：</p><ul><li>挂载<code>/root/mysql/data</code>到容器内的<code>/var/lib/mysql</code>目录</li><li>挂载<code>/root/mysql/init</code>到容器内的<code>/docker-entrypoint-initdb.d</code>目录（初始化的SQL脚本目录）</li><li>挂载<code>/root/mysql/conf</code>到容器内的<code>/etc/mysql/conf.d</code>目录（这个是MySQL配置文件目录）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">  -v /home/mysql/data:/var/lib/mysql \</span><br><span class="line">  -v /home/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v /home/mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>直接挂载在本地目录， 持久化保存数据的时候也方便</p><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><p>前面我们一直在使用别人准备好的镜像，那如果我要部署一个Java项目，把它打包为一个镜像该怎么做呢？</p><h2 id="2-3-1-镜像结构"><a href="#2-3-1-镜像结构" class="headerlink" title="2.3.1.镜像结构"></a>2.3.1.镜像结构</h2><p>要想自己构建镜像，必须先了解镜像的结构。</p><p>之前我们说过，镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的<code>系统函数库、环境、配置、依赖。</code></p><p>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>举个例子，我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240416154506421.png" alt="image-20240416154506421"></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p><p>就很麻烦，要从0开始</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>以后我们会有很多很多java项目需要打包为镜像，他们都需要<code>Linux系统环境、JDK环境</code>这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。</p><p>所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>是不是简单多了。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：<ul><li><pre><code class="Bash"># 直接指定Dockerfile目录docker build -t docker-demo:1.0 /root/demo<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因为我们的程序是根据Java环境来的，首先要构建基础镜像</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">docker pull openjdk</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240416164326945.png" alt="image-20240416164326945"></p><p>尝试运行镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost demo]<span class="comment"># docker run -d --name dd -p 8080:8080 docker-demo</span></span><br><span class="line">c6bd6488c5c0cbefab23058eec945b6530d5eadb3b4b8e775c7fb7f7a8fe2a17</span><br><span class="line">[root@localhost demo]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                   CREATED          STATUS          PORTS                                                  NAMES</span><br><span class="line">c6bd6488c5c0   docker-demo   <span class="string">&quot;java -jar /app.jar&quot;</span>      14 seconds ago   Up 12 seconds   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp              <span class="built_in">dd</span></span><br><span class="line">d61b3e3b0e1e   mysql         <span class="string">&quot;docker-entrypoint.s…&quot;</span>   58 minutes ago   Up 58 minutes   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再去浏览器访问：192.168.239.129:8080&#x2F;hello&#x2F;count</p><p>成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop dd 停止好的时间</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><code>镜像的结构</code>：镜像中包含了应用程序所需要的运行环境，函数库，配置，以及应用本身的各种文件，这些文件分层打包而成</p><p><code>Dockerfile</code>是做什么的：利用固定的指令来描述镜像和构建的过程</p><p><code>构建镜像的命令</code>：<strong>docker build -t 镜像名 .</strong></p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>而Java项目往往需要访问其它各种中间件，例如MySQL、Redis等。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240416170030468.png" alt="image-20240416170030468"></p><p>发现可以互联，没有问题。</p><p>但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p><p>所以，我们必须借助于docker的网络功能来解决这个问题，官方文档：</p><p><a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><p>常见命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   hmall     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240416171559947.png" alt="image-20240416171559947"></p><h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><p>打包-&gt;和dockerfile配置一起，扔进虚拟机里，-&gt;构建镜像-&gt; docker run部署应用</p><p>将<code>hm-service</code>目录下的<code>Dockerfile</code>和<code>hm-service/target</code>目录下的<code>hm-service.jar</code>一起上传到虚拟机的<code>root</code>目录：</p><p>部署项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.构建项目镜像，不指定tag，则默认为latest</span></span><br><span class="line">docker build -t hmall .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">hmall         latest    0bb07b2c34b9   43 seconds ago   362MB</span><br><span class="line">docker-demo   1.0       49743484da68   24 hours ago     327MB</span><br><span class="line">nginx         latest    605c77e624dd   16 months ago    141MB</span><br><span class="line">mysql         latest    3218b38490ce   17 months ago    516MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.创建并运行容器，并通过--network将其加入hmall网络，这样才能通过容器名访问mysql</span></span><br><span class="line"><span class="comment"># network默认</span></span><br><span class="line">docker run -d --name hmall  -p 8080:8080 hmall</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试，通过浏览器访问：http:&#x2F;&#x2F;你的虚拟机地址:8080&#x2F;search&#x2F;list</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418004451631.png" alt="image-20240418004451631"></p><p>报错显示未登录，但是是可以访问到的</p><h2 id="3-2-部署前端"><a href="#3-2-部署前端" class="headerlink" title="3.2.部署前端"></a>3.2.部署前端</h2><p><code>hmall-portal</code>和<code>hmall-admin</code>是前端代码，需要基于nginx部署。在课前资料中已经给大家提供了nginx的部署目录：</p><p>其中：</p><ul><li><code>html</code>是静态资源目录，我们需要把<code>hmall-portal</code>以及<code>hmall-admin</code>都复制进去</li><li><code>nginx.conf</code>是nginx的配置文件，主要是完成对<code>html</code>下的两个静态资源目录做代理</li></ul><p>我们现在要做的就是把整个nginx目录上传到虚拟机的<code>/root</code>目录下：</p><p>然后创建nginx容器并完成两个挂载：</p><ul><li>把<code>/root/nginx/nginx.conf</code>挂载到<code>/etc/nginx/nginx.conf</code></li><li>把<code>/root/nginx/html</code>挂载到<code>/usr/share/nginx/html</code></li></ul><p>由于需要让nginx同时代理hmall-portal和hmall-admin两套前端资源，因此我们需要暴露两个端口：</p><ul><li>18080：对应hmall-portal</li><li>18081：对应hmall-admin</li></ul><p>命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name nginx \</span><br><span class="line">  -p 18080:18080 \</span><br><span class="line">  -p 18081:18081 \</span><br><span class="line">  -v /root/nginx/html:/usr/share/nginx/html \</span><br><span class="line">  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">  --network hmall \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><p>测试，通过浏览器访问：http:&#x2F;&#x2F;你的虚拟机ip:18080</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418005044444.png" alt="image-20240418005044444"></p><h2 id="3-3-DockerCompose"><a href="#3-3-DockerCompose" class="headerlink" title="3.3.DockerCompose"></a>3.3.DockerCompose</h2><p>大家可以看到，我们部署一个简单的java项目，其中包含3个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了。</p><p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><h3 id="3-3-1-基本语法"><a href="#3-3-1-基本语法" class="headerlink" title="3.3.1.基本语法"></a>3.3.1.基本语法</h3><p>docker-compose.yml文件的基本语法可以参考官方文档：</p><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th align="left"><strong>docker run 参数</strong></th><th align="left"><strong>docker compose 指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">–name</td><td align="left">container_name</td><td align="left">容器名称</td></tr><tr><td align="left">-p</td><td align="left">ports</td><td align="left">端口映射</td></tr><tr><td align="left">-e</td><td align="left">environment</td><td align="left">环境变量</td></tr><tr><td align="left">-v</td><td align="left">volumes</td><td align="left">数据卷配置</td></tr><tr><td align="left">–network</td><td align="left">networks</td><td align="left">网络</td></tr></tbody></table><p>明白了其中的对应关系，相信编写<code>docker-compose</code>文件应该难不倒大家。</p><p>黑马商城部署文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以部署项目了。常见的命令：</p><p><a href="https://docs.docker.com/compose/reference/">https://docs.docker.com/compose/reference/</a></p><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure><p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td><td align="left"></td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left">down</td><td align="left">停止并移除所有容器、网络</td><td align="left"></td></tr><tr><td align="left">ps</td><td align="left">列出所有启动的容器</td><td align="left"></td></tr><tr><td align="left">logs</td><td align="left">查看指定容器的日志</td><td align="left"></td></tr><tr><td align="left">stop</td><td align="left">停止容器</td><td align="left"></td></tr><tr><td align="left">start</td><td align="left">启动容器</td><td align="left"></td></tr><tr><td align="left">restart</td><td align="left">重启容器</td><td align="left"></td></tr><tr><td align="left">top</td><td align="left">查看运行的进程</td><td align="left"></td></tr><tr><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td><td align="left"></td></tr></tbody></table><p>教学演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除hmall镜像</span></span><br><span class="line">docker rmi hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动所有, -d 参数是后台启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network hmall    Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container hmall  Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZE</span><br><span class="line">hmall               root-hmall          latest              32eebee16acd        362MB</span><br><span class="line">mysql               mysql               latest              3218b38490ce        516MB</span><br><span class="line">nginx               nginx               latest              605c77e624dd        141MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTS</span><br><span class="line">hmall               root-hmall          <span class="string">&quot;java -jar /app.jar&quot;</span>     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp</span><br><span class="line">mysql               mysql               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp</span><br><span class="line">nginx               nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp</span><br></pre></td></tr></table></figure><p>打开浏览器，访问：<a href="http://yourip:8080/">http://yourIp:8080</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2024/04/07/Java/Redis/"/>
      <url>/2024/04/07/Java/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="理论Redis"><a href="#理论Redis" class="headerlink" title="理论Redis"></a>理论Redis</h1><h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p> Redis是一种键值型的NoSql数据库</p><ul><li><p>键值型：以key，value形式存储</p></li><li><p>Nosql:</p></li></ul><h2 id="Nosql：非关系型数据库"><a href="#Nosql：非关系型数据库" class="headerlink" title="Nosql：非关系型数据库"></a>Nosql：非关系型数据库</h2><h3 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a><strong>结构化与非结构化</strong></h3><ul><li><p>传统的关系型数据库，每一张表都有严格的约束信息：字段，字段数，阻断类型等</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240407220028661.png" alt="image-20240407220028661"></p></li><li><p>Nosql则对数据库格式没有严格的约束，往往形式松散自由</p></li></ul><p>​可以是键值型key-value，文档型Document，图形Graph等</p><h3 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h3><p>传统的数据库表之际，往往存在外键，进行关联</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240407215900787.png" alt="image-20240407215900787"></p><p>而非关系型数据库不存在关联关系，维护要么靠代码中的业务实现逻辑，要么靠数据之间的耦合</p><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>传统的查询方式：基于SQL查询</p><p>不同的非关系型数据库，查询方法五花八门</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240407220420128.png" alt="image-20240407220420128"></p><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>传统的数据库能满足事物的四个特性：原子性，一致性，隔离性，持久性</p><p>非关系型：不支持事物，只能实现基本的一致性</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240407220804368.png" alt="image-20240407220804368"></p><p>扩展性</p><ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul><h1 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h1><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><p><strong>作者</strong>：Antirez</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><h2 id="1-Linux下安装"><a href="#1-Linux下安装" class="headerlink" title="1.Linux下安装"></a>1.Linux下安装</h2><p>麻烦，但是跟着教程学一遍</p><h2 id="1-3-安装Redis"><a href="#1-3-安装Redis" class="headerlink" title="1.3.安装Redis"></a>1.3.安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><h3 id="1-3-1-依赖库"><a href="#1-3-1-依赖库" class="headerlink" title="1.3.1.依赖库"></a>1.3.1.依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><h3 id="1-3-2-上传安装包并解压"><a href="#1-3-2-上传安装包并解压" class="headerlink" title="1.3.2.上传安装包并解压"></a>1.3.2.上传安装包并解压</h3><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/SyjanS5.png"></p><p>例如，我放到了&#x2F;usr&#x2F;local&#x2F;src 目录：</p><p>解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><p>进入redis目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h3 id="1-3-3-启动"><a href="#1-3-3-启动" class="headerlink" title="1.3.3.启动"></a>1.3.3.启动</h3><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h3 id="1-3-4-默认启动"><a href="#1-3-4-默认启动" class="headerlink" title="1.3.4.默认启动"></a>1.3.4.默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/v7xWsqC.png"></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="1-3-5-指定配置启动"><a href="#1-3-5-指定配置启动" class="headerlink" title="1.3.5.指定配置启动"></a>1.3.5.指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20211211082225509.png" alt="image-20211211082225509"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure><h3 id="1-3-6-开机自启"><a href="#1-3-6-开机自启" class="headerlink" title="1.3.6.开机自启"></a>1.3.6.开机自启</h3><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h2 id="2-Docker镜像安装"><a href="#2-Docker镜像安装" class="headerlink" title="2.Docker镜像安装"></a>2.Docker镜像安装</h2><p>傻瓜式一键安装，但怕出问题，按教程走一遍</p><h2 id="安装遇到的问题"><a href="#安装遇到的问题" class="headerlink" title="安装遇到的问题"></a>安装遇到的问题</h2><p><strong>问题</strong>：Xftp7想Linux内传输文件的时候，传输报错</p><p><strong>解决</strong>：我已经sudo按照root用户登陆了，不知道为什么还是没有权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 777 /usr/local/src</span><br></pre></td></tr></table></figure><p>解释：charGpt</p><ul><li><code>sudo</code>: 以超级用户权限执行命令。</li><li><code>chmod</code>: 是 change mode 的缩写，用于修改文件或文件夹的权限。</li><li><code>777</code>: 权限表示法，其中每个数字代表一组用户：第一个数字表示所有者的权限，第二个数字表示所属组的权限，第三个数字表示其他用户的权限。每个数字可以取值范围是 0 到 7，其中 0 表示没有权限，1 表示执行权限，2 表示写权限，4 表示读权限。而数字 7 表示读、写、执行权限的组合，因此 <code>777</code> 表示所有用户都拥有读、写、执行的权限。</li><li><code>/usr/local/src</code>: 指定要修改权限的文件夹路径。</li></ul><p><strong>问题</strong>：使用图像化界面Resp连接Linux，Redis的时候，连接不成功</p><p><strong>解决：</strong>端口被防火墙阻止了。关闭防火墙或者开放这个6379端口即可</p><p>命令顾名思义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"><span class="comment">#（--permanent永久生效，没有此参数重启后失效）</span></span><br><span class="line"><span class="comment">#注：可以是一个端口范围，如1000-2000/tcp</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent    </span><br><span class="line">firewall-cmd --list-port</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，value包含很多不同的数据类型</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408084656979.png" alt="image-20240408084656979"></p><h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>部分通用数据类型，都可以使用的指令</p><ul><li>KEYS：查看符合模板的所有的key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给key设置一个有效期，到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><p><strong>2.2.1.String的常见命令</strong></p><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h2 id="key结构"><a href="#key结构" class="headerlink" title="key结构"></a>key结构</h2><p>通过给key添加前缀加以区分</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>hash类型，散列，value是一个无序列表，类似于HashMap</p><p>即：key里面存的value，又是一个key-value</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/x2zDBjf.png"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/VF2EPt0.png"></p><p>Hash的常见命令有：</p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的类型与Java中的LinkedList类似，可以看做是一个双向链表，可以正向检索，也可以反向检索</p><p>特点也与LinkedList相似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入删除快</li><li>查询一般</li></ul><p>List的常见命令有：</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><strong>思考：如何用List模拟一个栈？</strong></p><p>​入口和出口在同一边，只用LPUSH和LPOP</p><p><strong>如何用List模拟一个队列？</strong></p><p>​入口出口在不同边，LPUSH，RPOP  或者  RPUSH，LPOP</p><p><strong>如何用List模拟一个阻塞队列？</strong></p><p>​入口出口在不同边，出队采用BLPOP，BRPOP</p><h2 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h2><p>与Java中的HashSet类似，可以看做一个value为null的HashMap，也是hash表，具备和HashSet类似的特性：</p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集，并集，差集的等功能</p></li></ul><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2…：求差集</li><li>SUNION key1 key2…：就并集</li></ul><p>例如两个集合：s1和s2:</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/ha8x86R.png"></p><p>求交集：SINTER s1 s2</p><p>求s1与s2的不同：SDIFF s1 s2</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/L9vTv2X.png"></p><h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现<strong>排行榜</strong>这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p></li></ul><h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408103756796.png" alt="image-20240408103756796"></p><p>标记为*的就是推荐使用的java客户端，包括：</p><ul><li><strong>Jedis和Lettuce</strong>：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而<strong>SpringDataRedis</strong>又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li><strong>Redisson</strong>：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h2 id="Jedis客户端"><a href="#Jedis客户端" class="headerlink" title="Jedis客户端"></a>Jedis客户端</h2><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建jedis对象，建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.239.129&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">set</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;FangYuan&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + set);</span><br><span class="line">    <span class="comment">//获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(jedis != <span class="literal">null</span>)&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用Redis的命令去操作jedis</p><p>释放资源</p><h2 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h2><p>jedis是线程不安全的，频繁创建和销毁连接会有性能的损耗，因此，使用jedis线程连接池的方式，代替上面的jedis直连方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.jedis.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//最大连接</span></span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//最大空闲连接</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//最小连接</span></span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//设置最长等待时间，ms</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;192.168.239.129&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//静态获取jedis工具类</span></span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了<strong>RedisTemplate工具类</strong>，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/UFlNIV0.png"></p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置Redis</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure><p>再去@Autowired自动注入<strong>RedisTemplate</strong>即可</p><h2 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h2><p>RedisTemplate可以接收任意Object作为值写入Redis</p><p>但是写入的时候，<strong>RedisTemplate会把Object序列化，写入Redis</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408152103748.png" alt="image-20240408152103748"></p><p>只不过，默认采用的是JDk序列化，我们写入的汉字会转成这样</p><p>可读性差，并且内存占用大</p><p><strong>这就需要我们自定义RedisTemplate的序列化方式</strong></p><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><p>自定义Redisconfig类，添加@Configuration标记为配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用了<strong>JSON序列化来代替默认的JDK序列化方式</strong>。最终结果如图：<img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408152706738.png" alt="image-20240408152706738"></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。</p><p><strong>不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</strong></p><h2 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a><strong>StringRedisTemplate</strong></h2><p>为了节省内存空间，我们可以不使用JSON序列化来处理value，而使用统一的String序列化器，要求只能存储String类型的key和value，当我们要存储Java对象的时候，<strong>手动完成对象的序列化和反序列化</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408153418445.png" alt="image-20240408153418445"></p><p>如图所示，先用mapper或者fastJSON手动吧对对象序列化为JSON字符串，存入Redis</p><p>读取结果是JSON字符串，在手动反序列化，放入对象中</p><p><strong>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了</strong>。</p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">// JSON序列化工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实战篇Redis"><a href="#实战篇Redis" class="headerlink" title="实战篇Redis"></a>实战篇Redis</h1><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240408154408431.png" alt="image-20240408154408431"></p><ul><li>短信登陆：Redis共享session来实现</li><li>商户缓存查询：了解缓存击穿，缓存穿透，缓存雪崩问题</li><li><strong>优惠券秒杀</strong>：Redis的计数功能，结合Lua完成高性能的Redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</li><li>附近的商户：使用Redis的GEOHash来完成对地理坐标的操作</li><li>UV统计：主要使用Redis来实现计数功能</li><li>用户签到：使用Redis的BitMap数据统计功能</li><li>好友关注：基于Set集合的关注，关注取消，共同关注等功能</li><li>达人探店：基于List完成点赞列表的操作，同时基于SortedSet来完成点赞排行傍的功能</li></ul><h2 id="导入项目框架"><a href="#导入项目框架" class="headerlink" title="导入项目框架"></a>导入项目框架</h2><p><strong>问题1：mysql建表错误</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tb_seckill_voucher`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_seckill_voucher`  (</span><br><span class="line">  `voucher_id` <span class="type">bigint</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;关联的优惠券的id&#x27;</span>,</span><br><span class="line">  `stock` <span class="type">int</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `begin_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;生效时间&#x27;</span>,</span><br><span class="line">  `end_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;失效时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`voucher_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;秒杀优惠券表，与优惠券是一对一关系&#x27;</span> ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p>错误分析：</p><p>错误分析：<br>DEFAULT ‘0000-00-00 00:00:00’（零时间戳），这不满足sql_mode中的NO_ZERO_DATE而报错。</p><p>注：sql_mode有两种，一种是空值，一种是严格模式，会给出很多默认设置。在MySQL5.7之后默认使用严格模式。</p><p>解决方式：1.修改不为0时间戳，</p><p>2.或者在mysql安装目录下，打开my.ini文件，修改配置文件，去除sql_mode下的NO_ZERO_DATE</p><p>(不建议2，我修改配置文件后，MySQL80直接重启失败了，吓我一身冷汗，以为又要重装MySQL了)</p><p><strong>问题2：导入别人初始框架的时候</strong></p><p><strong>JDK9~17+Springboot3 @Resource常见问题和解决方案</strong></p><p>因为JDK版本升级的改动，在Jdk9~17环境下，搭建Springboot项目，会出现原有@Resource（javax.annotation.Resource）不存在的问题，导致项目从<a href="https://so.csdn.net/so/search?q=Jdk8&spm=1001.2101.3001.7020">Jdk8</a>迁移到高版本时遇到的问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java EE 即 java Enterprise Edition，企业级应用，目标是制定一系列企业级应用的标准服务。常见的 javax.servlet, javax.annotation。</span><br><span class="line"></span><br><span class="line">Oracle 收购了创造 java 的 SUN 公司，Oracle 又不想发展 java EE 了，</span><br><span class="line">就把 java EE 交给 Eclipse 社区了，但是又因为不知名的原因，禁止社区使用 javax 这个名字。</span><br><span class="line">所以，javax.servlet 就变成了 jakarta.servlet, jakarta.annotation。api无法向前兼容。</span><br><span class="line"></span><br><span class="line"> java ee 的最后一个版本也是 8，以后就再也没有 java ee 的新版本</span><br></pre></td></tr></table></figure><p>解决：使用Jakarta包下的类</p><h1 id="1-短信登陆"><a href="#1-短信登陆" class="headerlink" title="1.短信登陆"></a>1.短信登陆</h1><h2 id="基于session的流程"><a href="#基于session的流程" class="headerlink" title="基于session的流程"></a>基于session的流程</h2><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409073742479.png" alt="image-20240409073742479"></p><p>基于session的实现流程:</p><p><strong>我看不懂的地方全部写满了注释</strong>！！！</p><p><strong>发送验证码接口：&#x2F;user&#x2F;code</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//校验手机号,调用工具类中的正则表达式</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">//不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成验证码,使用radom生成</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存验证码到session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">//保存验证码到Redis</span></span><br><span class="line">    <span class="comment">//通过 opsForValue() 方法获取到一个用于操作字符串类型的 Redis 操作对象，</span></span><br><span class="line">    <span class="comment">// 然后使用 set() 方法将验证码 code 存储在 Redis 中，并设置了过期时间为 2 分钟</span></span><br><span class="line">    <span class="comment">//stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY +phone,code,5, TimeUnit.MINUTES);</span></span><br><span class="line">    <span class="comment">//发送验证码 假设发送成功了</span></span><br><span class="line">    <span class="comment">// TODO 调用阿里云的第三方接口依赖服务去实现</span></span><br><span class="line">    log.info(<span class="string">&quot;验证码发送成功，验证码：&#123;&#125;&quot;</span>,code);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>短信认证接口：&#x2F;user&#x2F;login</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//校验手机号，校验验证码,不一致的话，报错</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">        <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">code</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">loginFormCode</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">        <span class="keyword">if</span>(code == <span class="literal">null</span> || !code.toString().equals(loginFormCode))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*     一致的话，根据用户查询手机号,select * from tb_user where phone = #&#123;phone&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         这行代码使用了MyBatis-Plus框架提供的条件构造器 query() 方法</span></span><br><span class="line"><span class="comment">         它用于创建一个查询条件构造器对象。然后使用 eq(&quot;phone&quot;, phone) 方法，</span></span><br><span class="line"><span class="comment">         该方法表示等值查询，用于添加一个查询条件，</span></span><br><span class="line"><span class="comment">         要求查询的表中的 phone 字段的值等于变量 phone 的值。</span></span><br><span class="line"><span class="comment">         最后调用 one() 方法表示只查询符合条件的结果中的第一条数据，并返回一个 User 对象。*/</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户是否存在,不存在的话，创建新用户，并且把用户数据保存到session中</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            user = createWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存用户信息到session中,去除敏感信息，只返回VO前端需要的信息</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user,UserDTO.class);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>,userDTO);</span><br><span class="line">        <span class="comment">//登陆成功</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>校验登录状态：</p><ul><li><p>设置一个登录拦截器，loginInterceptor，实现HandlerInterceptor类中的preHandle(前置拦截)</p></li><li><p>并且再设置一个webConfig类去配置拦截器的拦截范围，配置类用@Configuration标注，告诉spring在启动时加载配置，在配置类中将拦截器的对象@Autowired，再去配置拦截的过滤属性即可</p></li></ul><p><strong>Interception</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拦截器在session中获取用户信息，再存储到线程池</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//获取session</span></span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">    <span class="comment">//获取session用户</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="comment">//判断用户是否存在，不存在的话，拦截或者抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        response.setStatus(<span class="number">401</span>);</span><br><span class="line">        <span class="comment">// TODO 设置全局异常处理器去拦截</span></span><br><span class="line">        <span class="comment">//throw new Exception()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在的话，保存用户信息到线程</span></span><br><span class="line">    UserHolder.saveUser((UserDTO) user);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>webconfig</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RefreshTokenInterceptor refreshTokenInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 登录拦截器,排除不需要的拦截逻辑，固定代码</span></span><br><span class="line">    registry.addInterceptor(loginInterceptor)</span><br><span class="line">            .excludePathPatterns(</span><br><span class="line">                    <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">            ).order(<span class="number">1</span>);<span class="comment">//数字越小，优先级越高</span></span><br><span class="line">    <span class="comment">// token刷新的拦截器,先拦截所有请求，保存当前</span></span><br><span class="line">    registry.addInterceptor(refreshTokenInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程ThreadLocal"><a href="#线程ThreadLocal" class="headerlink" title="线程ThreadLocal"></a>线程ThreadLocal</h2><h3 id="Tomcat运行原理"><a href="#Tomcat运行原理" class="headerlink" title="Tomcat运行原理"></a>Tomcat运行原理</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409152613464.png" alt="image-20240409152613464"></p><ul><li>Tomcat是一个开源的运行Java应用程序的Web服务器，springboot自带Tomcat服务器，我们启动Web服务就会自带</li><li>当用户发起请求的时候，会访问我们Tomcat注册的端口</li><li>当监听线程直到用户想与Tomcat建立链接的时候，会由监听线程创建socket链接</li><li>socket都是成对出现的，用户通过socket相互传送数据</li><li>当Tomcat中的socket接受到数据后，此时监听线程会从Tomcat的线程池取出一个线程来执行用户的请求</li><li>线程会找到我们用户想要访问的工程，用这个线程转到工程中测controller，service，mapper层，并访问数据库完成相应的操作</li><li>执行完毕后，再统一返回，找到Tomcat端的socket，将数据写会到用户端的socket，完成请求相应</li></ul><p>我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><p><strong>温馨小贴士：关于threadlocal</strong></p><p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p><h2 id="session共享的问题"><a href="#session共享的问题" class="headerlink" title="session共享的问题"></a>session共享的问题</h2><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p><p>但是这种方案具有两个大问题</p><p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p><p>2、session拷贝数据时，可能会出现延迟</p><p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p><h2 id="Redis的实现思路"><a href="#Redis的实现思路" class="headerlink" title="Redis的实现思路"></a>Redis的实现思路</h2><p><strong>1.设计存储的key和value的结构</strong></p><p>key用字串，value用map&lt;k，v&gt;结构</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409154552378.png" alt="image-20240409154552378" style="zoom:50%;"><p>在设计这个key的时候，我们之前讲过需要满足两点</p><p>1、key要具有唯一性</p><p>2、key要方便携带</p><p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p><p><strong>整体的访问流程</strong></p><p>发送短信验证码端不变，短信登录注册端和登录校验端，有变化，拦截器优化</p><ul><li>主要是涉及到从session中获取数据，到Redis中获取存入和获取数据</li><li>当注册完成后， 用户登录会去校验手机号和验证码，</li><li>如果一致，用MB查询用户信息，不存在则创建，</li><li>最后将用户信息保存到Redis中，并且生成随机token，作为Redis的key，设置key的有效期</li><li>当我们拦截器校验用户是否登录的时候，前端会携带token去访问</li><li>拦截器1拦截所有，从Redis中取出token对应的value，判断是否有这个数据</li><li>直接将其保存到ThreadLocal线程当中，刷新token有效期，再放行到拦截器2</li><li>拦截器2，拦截校验请求，判断ThreadLocal之中是否有用户，没有拦截，有则放行</li></ul><p><strong>我敲了一遍，主要的难点在于，使用stringRedisTemplate访问Redis的api不熟悉</strong></p><p><strong>将实体类转为hash用的工具类不熟悉</strong></p><p><strong>敲多了就熟悉了</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409164244140.png" alt="image-20240409164244140"></p><p><strong>短信验证码的登录</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">     <span class="comment">//1.校验手机号，校验验证码,不一致的话，报错</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">     <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//2.从Redis中获取验证码</span></span><br><span class="line">     <span class="comment">//opsForValue() 方法获取到一个用于操作字符串类型的 Redis 操作对象</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">     <span class="type">String</span> <span class="variable">loginFormCode</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">     <span class="keyword">if</span> (code == <span class="literal">null</span> || !code.equals(loginFormCode)) &#123;</span><br><span class="line">         <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3，一致,MP查询用户</span></span><br><span class="line">     <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//4.判断用户是否存在,不存在的话，创建新用户，并且把用户数据保存到数据库中</span></span><br><span class="line">     <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">         user = createWithPhone(phone);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//5.保存用户信息到Redis中</span></span><br><span class="line">     <span class="comment">//6.随机生成token，作为登陆令牌</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">     <span class="comment">//7.将user转为Hash存储。调用工具类</span></span><br><span class="line">     <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">     Map&lt;String, Object&gt; usermap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">             CopyOptions.create()</span><br><span class="line">                     .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                     .setFieldValueEditor((Name, Value) -&gt; Value.toString())</span><br><span class="line">     );</span><br><span class="line">     <span class="comment">//8.存储到Redis中，并且设置token有效期</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">     stringRedisTemplate.opsForHash().putAll(tokenKey,usermap);</span><br><span class="line">     stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br><span class="line">     <span class="comment">//9.返回token</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(token);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">createWithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//保存到数据库中</span></span><br><span class="line">        save(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409165657548.png" alt="image-20240409165657548"></p><p><strong>interceptor1</strong>：拦截所有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>interceptor2</strong>：拦截校验请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//拦截前执行，返回true，放行</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截器在Redis中获取用户信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-商品查询缓存"><a href="#2-商品查询缓存" class="headerlink" title="2.商品查询缓存"></a>2.商品查询缓存</h1><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>:Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); 本地用于高并发</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>:<span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存</span><br><span class="line"></span><br><span class="line">例<span class="number">3</span>:Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>(); 本地缓存</span><br></pre></td></tr></table></figure><p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效;</p><p>吗</p><h2 id="添加商品缓存"><a href="#添加商品缓存" class="headerlink" title="添加商品缓存"></a>添加商品缓存</h2><p>标准的操作方式，是我们再查询商户信息的时候，直接从数据库中去查询，比较慢，所以添加缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//这里是直接查询数据库</span></span><br><span class="line">    <span class="keyword">return</span> shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存的思路：</strong>在查数据库之前，如果缓存存在，则直接从缓存中返回，如果不存在，则查询数据库，然后再将缓存写入Redis</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240409210411503.png" alt="image-20240409210411503"></p><p><strong>service层实现逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopMapper, Shop&gt; <span class="keyword">implements</span> <span class="title class_">IShopService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//不为空，直接返回给controller</span></span><br><span class="line">        <span class="keyword">if</span>(!StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不为空，则根据ID查询数据库</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查到后，写入Redis,将shop转为JSON格式</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习：给店铺类型查询业务添加缓存"><a href="#练习：给店铺类型查询业务添加缓存" class="headerlink" title="练习：给店铺类型查询业务添加缓存"></a>练习：给店铺类型查询业务添加缓存</h2><p>比较：只是由单个的String字符串在Redis中的查取，转为了list链表在Redis中的查取</p><p>解决：多记几个api函数（无奈！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;cache:shop:type:key&quot;</span>;</span><br><span class="line">        <span class="comment">//先从Redis中查.获取索引为0到-1(最后一个元素)的列表</span></span><br><span class="line">        List&lt;String&gt; shopTtpes = stringRedisTemplate.opsForList().range(key, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!shopTtpes.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将集合元素转为，ShopType类型的对象</span></span><br><span class="line">            ArrayList&lt;ShopType&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String s : shopTtpes)&#123;</span><br><span class="line">                <span class="type">ShopType</span> <span class="variable">type</span> <span class="operator">=</span> JSONUtil.toBean(s, ShopType.class);</span><br><span class="line">                list.add(type);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有则去数据库查</span></span><br><span class="line">        List&lt;ShopType&gt; list = query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺类型不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数据库中查到的，转为JSON，存入Redis</span></span><br><span class="line">        <span class="keyword">for</span>(ShopType s : list)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> JSONUtil.toJsonStr(s);</span><br><span class="line">            shopTtpes.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForList().leftPushAll(key,shopTtpes);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shopTtpes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Redis缓存更新策略"><a href="#Redis缓存更新策略" class="headerlink" title="Redis缓存更新策略"></a>Redis缓存更新策略</h2><p>内存数据宝贵，我们向Redis插入太多数据，可能会导致缓存中的数据过多，多以Redis对部分数据更新，删除</p><p><strong>内存淘汰</strong>：Redis自动进行，当内存达到设定的max-memory后,会自动触发淘汰机制,淘汰一些不重要的数据</p><p><strong>超时剔除</strong>: 当我们给Redis中的数据插入过期时间ttl后，Redis会把过期的数据删除，方便继续有空间使用缓存</p><p><strong>主动更新</strong>：我们可以设置手动调用的方式 ，通常用于解决，缓存和数据库数据不一致的问题</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410144258576.png" alt="image-20240410144258576"></p><p><strong>数据缓存不一致解决方案</strong></p><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410151745879.png" alt="image-20240410151745879"></p><p><strong>方案一</strong>：手动调用更新缓存，需要自己去编写代码开发，但是一致性好</p><p><strong>方案二</strong>：调用服务，想维护比较复杂，找不到现成这样的服务</p><p><strong>方案三</strong>：简化调用者的开发，只关心缓存，由一个线程异步将缓存数据持久化到数据库中去，批量从缓存中插入数据库，保存最终一致，一致性差</p><p>使用方案一问题：</p><p><strong>1.更新缓存还是删除缓存？</strong></p><ul><li>更新缓存：每次更新数据库都更新缓存的话，不读取缓存，无效的写入缓存过多了</li><li>删除缓存：更新数据库的时候，让缓存失效，查询的时候，再去更新缓存</li></ul><p><strong>2.如何保证缓存与数据库操作的同时成功或者失败</strong></p><ul><li>单体系统，@Transaction，事物</li><li>分布式系统，利用TTC等分布式事物解决方案</li></ul><p><strong>3.先操作缓存还是先操作数据库？</strong></p><p>应当先操作数据库，再删除缓存</p><p>如下图所示，原因是，写入缓存的数据快，而写入数据库的数据慢，这就导致先删后写的空间大，容易被其他线程操作，而带来数据的不一致，所以需要先操作数据库，再删除缓存</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410160140150.png" alt="image-20240410160140150"></p><h2 id="实现商铺缓存与数据库缓存双写一致"><a href="#实现商铺缓存与数据库缓存双写一致" class="headerlink" title="实现商铺缓存与数据库缓存双写一致"></a>实现商铺缓存与数据库缓存双写一致</h2><p>核心思路如下：</p><p>修改ShopController中的业务逻辑，满足下面的需求：</p><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + shop.getId();</span><br><span class="line">    <span class="comment">//更新数据库</span></span><br><span class="line">    updateById(shop);</span><br><span class="line">    <span class="comment">//如果是分布式系统，这里需要用MQ去异步的通知对方</span></span><br><span class="line">    <span class="comment">//删除缓存</span></span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>缓存穿透</strong>：客户端请求的数据在数据库和缓存中都不存在，这样缓存永远都不会说生效，这写请求都会传到数据库中</p><p>​如果恶意用户通过查询一个数据库中不存在的数据去直接访问数据库，导致缓存无效，直接打在数据库中，从而达到给数据库造成巨大压力的情况</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，<strong>通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在</strong>，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410163212126.png" alt="image-20240410163212126"></p><h2 id="编码解决缓存穿透问题"><a href="#编码解决缓存穿透问题" class="headerlink" title="编码解决缓存穿透问题"></a>编码解决缓存穿透问题</h2><p>核心思路如下：</p><p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p><p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410163505694.png" alt="image-20240410163505694"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="comment">//存在，直接返回给controller</span></span><br><span class="line">       <span class="comment">//isBlank()，方法，只有有值的时候，返回true，空，null，换行符/n/t，都返回false;</span></span><br><span class="line">       <span class="keyword">if</span>(!StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">           <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">           <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的是否为空值</span></span><br><span class="line">       <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不为空，则根据ID查询数据库</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">       <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">           stringRedisTemplate.opsForValue()</span><br><span class="line">                   .set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//查到后，写入Redis,将shop转为JSON格式</span></span><br><span class="line">       stringRedisTemplate.opsForValue()</span><br><span class="line">               .set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">       <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>小总结：</strong></p><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li><strong>缓存null值</strong></li><li><strong>布隆过滤</strong></li><li><strong>增强id的复杂度，避免被猜测id规律</strong></li><li><strong>做好数据的基础格式校验</strong></li><li><strong>加强用户权限校验</strong></li><li><strong>做好热点参数的限流</strong></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>问题以及解决思路</strong></p><p><strong>缓存雪崩</strong>：同地段大量的缓存<strong>key同时失效</strong>或者<strong>Redis宕机</strong>，导致大量请求直接到达数据库，带来巨大压力</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410230812500.png" alt="image-20240410230812500"></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿问题，也叫<strong>热点击穿</strong>问题，就是被一个<strong>高并发并且缓存重建业务复杂的key突然失效了</strong>，无数的访问请求会瞬间给数据库带来巨大冲击</p><p><strong>解决方法</strong>：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240410235244817.png" alt="image-20240410235244817"></p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653328288627.png" alt="1653328288627"></p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：<strong>这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理</strong>。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653328663897.png" alt="1653328663897"></p><p>进行对比</p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><h2 id="用互斥锁解决缓存击穿问题"><a href="#用互斥锁解决缓存击穿问题" class="headerlink" title="用互斥锁解决缓存击穿问题"></a>用互斥锁解决缓存击穿问题</h2><p>核心思路：相较于原先从缓存中查不到数据后直接查询数据库而言，现在的方案是查询之后，如果缓存中没有查到数据，就进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有活的到，则说明有线程已经去访问了，则先休眠，过一会儿再去访问，知道获取到了锁为止，才能进行查询</p><p>如果有线程获取到了锁，再去进行查询，查询后将数据写入Redis，再释放锁，返回数据，利用互斥锁就保证只能有一个线程去执行数据库操作的逻辑，防止缓存击穿</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240411102547011.png" alt="image-20240411102547011"></p><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//缓存穿透</span></span><br><span class="line">       <span class="comment">//Shop shop = queryWihPassThrough(id);</span></span><br><span class="line">       <span class="comment">//互斥锁</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithMutex(id);</span><br><span class="line">       <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1.从Redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="comment">//存在，直接返回给controller</span></span><br><span class="line">       <span class="comment">//isBlank()，方法，只有有值的时候，返回true，空，null，换行符/n/t，都返回false;</span></span><br><span class="line">       <span class="keyword">if</span>(!StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的是否为空值</span></span><br><span class="line">       <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不为空，先加互斥锁，注意互斥锁的key与缓存的key不一样</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               log.info(<span class="string">&quot;未获取到互斥锁，休眠，再重试&quot;</span>);</span><br><span class="line">               <span class="comment">//未获取到互斥锁，休眠，再重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//获取锁成功，再检测Redis，做doubleCheck</span></span><br><span class="line">           shopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">           <span class="keyword">if</span>(!StrUtil.isBlank(shopJson))&#123;</span><br><span class="line">               <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//根据ID查询数据库</span></span><br><span class="line">           shop = getById(id);</span><br><span class="line">           <span class="comment">//模拟高并发下的场景</span></span><br><span class="line">           Thread.sleep(<span class="number">500</span>);</span><br><span class="line">           <span class="comment">//数据库没有则写入缓存空值</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">               stringRedisTemplate.opsForValue()</span><br><span class="line">                       .set(key,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//数据库有的话，写入Redis,将shop转为JSON格式</span></span><br><span class="line">           stringRedisTemplate.opsForValue()</span><br><span class="line">                   .set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//释放互斥锁</span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取锁的方法,如果值存在，则不设置，不存在则设置</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//释放锁的方法</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">       stringRedisTemplate.delete(key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong>：删了缓存，加了500毫秒的延时，在每秒100次的请求冲击下，有大量的线程未获取到互斥锁，休眠再重试</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240411151627555.png" alt="image-20240411151627555"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240411151422648.png" alt="image-20240411151422648"></p><p>当500毫秒过去后，就可以正常从缓存中读取程序了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240411151904963.png" alt="image-20240411151904963"></p><p>查询数据库的操作，夹在大量线程的中间，数据库仅仅被查询了一次，达到了用互斥解决缓存击穿的目的</p><h2 id="用逻辑过期解决缓存击穿问题"><a href="#用逻辑过期解决缓存击穿问题" class="headerlink" title="用逻辑过期解决缓存击穿问题"></a>用逻辑过期解决缓存击穿问题</h2><p>思路：当用户开始查询Redis的时候，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回Redis中的数据，如果过期了，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240411155621660.png" alt="image-20240411155621660"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建了10个线程池</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span></span><br><span class="line">           <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">   <span class="comment">//逻辑过期解决缓存击穿</span></span><br><span class="line">   <span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">//1.从Redis查缓存，判断是否命中</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="keyword">if</span>(StrUtil.isBlank(json))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.缓存中查到，需要把JSON反序列化成对象RedisData</span></span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">       <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject)redisData.getData();</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(data, Shop.class);</span><br><span class="line">       <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">       <span class="comment">//3.判断是否过期</span></span><br><span class="line">       <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">           <span class="comment">//未过期。返回店铺信息</span></span><br><span class="line">           <span class="keyword">return</span> shop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//已过期，需要缓存重建</span></span><br><span class="line">       <span class="comment">//获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">       <span class="comment">//判断锁是否成功</span></span><br><span class="line">       <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">           <span class="comment">//获取锁成功，则开启独立线程，用线程池</span></span><br><span class="line">           CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   saveShopToRedis(id,<span class="number">20L</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   unlock(lockKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       log.info(<span class="string">&quot;逻辑过期时间：&#123;&#125;&quot;</span>,redisData.getExpireTime());</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取锁的方法,如果值存在，则不设置，不存在则设置</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//释放锁的方法</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">       stringRedisTemplate.delete(key);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShopToRedis</span><span class="params">(Long id, Long expireSeconds)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">//1.查询店铺数据</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">       <span class="comment">//模拟延时</span></span><br><span class="line">       Thread.sleep(<span class="number">500</span>);</span><br><span class="line">       <span class="comment">//2.封装过期时间</span></span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">       redisData.setData(shop);</span><br><span class="line">       redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">       <span class="comment">//3.写入Redis</span></span><br><span class="line">       stringRedisTemplate.opsForValue().</span><br><span class="line">               set(RedisConstants.CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>测试：我们先在用test测试在缓存中预处理了一个RedisData对象，并且设置了逻辑过期时间为当前时间+10秒</strong></p><p><strong>再10秒后，我们去测试100个线程同时访问，看看已经过期的情况下，会有多少个数据库查询？</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412014628062.png" alt="image-20240412014628062"></p><p>可以看到，在查询后的一段时间内，我设置的是10秒，逻辑过期时间由845毫秒改为069毫秒，实现了缓存重建</p><h2 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h2><p><strong>泛型。函数式编程，lambda表达式，这块上强度了，先copy，有时间再看</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h1><h2 id="全局唯一ID："><a href="#全局唯一ID：" class="headerlink" title="全局唯一ID："></a>全局唯一ID：</h2><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p><ul><li><strong>id的规律性太明显</strong></li><li><strong>受单表数据量的限制</strong></li></ul><p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p><p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p><p><strong>全局ID生成器</strong>：是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><ul><li>唯一性</li><li>递增性</li><li>安全性</li><li>高可用</li><li>高性能</li></ul><p>为了增加ID的安全性，我们不可以直接使用Redis自增的数值，拼接其他一些信息</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412035633407.png" alt="image-20240412035633407"></p><p>ID的组成部分：符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><h2 id="Redis实现全局唯一ID"><a href="#Redis实现全局唯一ID" class="headerlink" title="Redis实现全局唯一ID"></a>Redis实现全局唯一ID</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程测试"><a href="#多线程测试" class="headerlink" title="多线程测试"></a><strong>多线程测试</strong></h2><p><strong>：给300个线程，每个线程生成100个ID，一共三万个ID，在多线程的情况下，如何等全部线程执行完了再去查询方法的执行时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程下测试时间的解释：</p><blockquote><p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p><p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p><p>CountDownLatch 中有两个最重要的方法</p><p>1、countDown</p><p>2、await</p><p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p></blockquote><p><strong>添加优惠券</strong></p><p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p><p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p><p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p><p>**新增普通卷代码：  **VoucherController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新增秒杀卷代码：</strong></p><p><strong>VoucherController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>VoucherServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在postman或者apiair接口传入以下body</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;shopId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;100元代金券&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subTitle&quot;</span><span class="punctuation">:</span><span class="string">&quot;周一至周五可用&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span><span class="string">&quot;全场通用\\n无需预约\\n可无限叠加&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;payValue&quot;</span><span class="punctuation">:</span><span class="number">8000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;actualValue&quot;</span><span class="punctuation">:</span><span class="number">10000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;beginTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2022-01-01T00:00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;endTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2022-10-31T23:59:59&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="实现下单秒杀"><a href="#实现下单秒杀" class="headerlink" title="实现下单秒杀"></a>实现下单秒杀</h2><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回<strong>订单id</strong>，如果有一个条件不满足则直接结束。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412061530933.png" alt="image-20240412061530933"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckikkVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">//2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.判断秒杀是否结束</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span>(voucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.扣减库存,使用mybatisplus的链式查找工具</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService</span><br><span class="line">                .update().setSql(<span class="string">&quot;stock = stock -1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//订单ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//用户ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">//代金券ID</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="comment">//7.返回订单ID</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h2><p>模拟100个线程同时抢券1分钟</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412144726095.png" alt="image-20240412144726095" style="zoom:50%;"><p>数据库中卖出了109条记录</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412144826175.png" alt="image-20240412144826175"></p><p>秒杀券库存为-9</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412144914188.png" alt="image-20240412144914188"></p><p><strong>分析原因：</strong></p><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p>典型的多线程安全问题：</p><p> 针对这一问题，我们就是要加锁，</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412145805456.png" alt="image-20240412145805456"></p><p><strong>悲观锁</strong>：对数据串行化执行，synchroniedz，lock都是悲观锁，直接在我们的方法上加注解@Synchronized就行</p><p><strong>乐观锁：</strong>会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412150751030.png" alt="image-20240412150751030"></p><p>可以用stock来代替version，只需要在后面的查询条件里加上，and stock &#x3D; stock就行</p><p>修改之后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.扣减库存,使用mybatisplus的链式查找工具</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService</span><br><span class="line">        .update().setSql(<span class="string">&quot;stock = stock -1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update();</span><br><span class="line"><span class="keyword">if</span>(!success)&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mybatisPlus中的语句，等效于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update seckill_tab set stock = stock - 1 where voucher_id = #&#123;vocherID&#125; and stock = #&#123;stock&#125;</span><br></pre></td></tr></table></figure><p><strong>来来来，上1秒200个线程的压力测试</strong>，<strong>我32G内存要吃满了</strong></p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412153402542.png" alt="image-20240412153402542" style="zoom:50%;"><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412153536712.png" alt="image-20240412153536712" style="zoom: 50%;"><p>嗯？怎么结果只有23条？</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412153715841.png" alt="image-20240412153715841"></p><p>一看库存，200人1秒抢，是不会库存超卖了，但是没卖完呐，这也太安全了吧</p><p>问题：不一定要相等，只要有票，就接着卖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.扣减库存,使用mybatisplus的链式查找工具</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService</span><br><span class="line">        .update().setSql(<span class="string">&quot;stock = stock -1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>).update();</span><br><span class="line"><span class="keyword">if</span>(!success)&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412155014160.png" alt="image-20240412155014160"></p><p>可以了，卖的很干净</p><p><strong>知识小扩展：</strong></p><p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p><p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p><p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p><p>所以利用这么一个类，LongAdder来进行优化</p><p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412155113542.png" alt="image-20240412155113542"></p><h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><p>要求：修改秒杀业务，要求同一个优惠券，一个用户，只能下一单</p><p>具体的操作逻辑：在扣减库存前，判断订单人的ID和优惠券ID相等的个数，如果个数&gt;1，则失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一人一单</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="comment">//select count(*) from xxx where user_id = #&#123;userId&#125; and voucher_id = #&#123;voucherId&#125;;</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line"><span class="keyword">if</span>(count &gt; <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412161837535.png" alt="image-20240412161837535" style="zoom: 80%;"><p><strong>测试：200个线程，同一用户压力测试走起</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412162226034.png" alt="image-20240412162226034"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412162241869.png" alt="image-20240412162241869"></p><p><strong>结果失败：还是有三个线程同一ID的用户，抢购了三张用户券</strong></p><p>分析：还是线程安全问题，对于我们的代码，多个线程执行的时候，查出的数据都是为0 ，可以插入，插入需要时间，在这个时间内进入的线程，还是会执行插入</p><p> <strong>解决问题：加锁！！！</strong></p><p>初步代码：把一人一单的逻辑代码都提交到一个方法中去，然后给这个方法加锁</p><p>不管哪一个线程（例如线程A），运行到这个方法时，都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A，没有的话，锁定调用者，然后直接运行。</p><p><strong>但是！</strong>（我这里看不懂了）就用老师的吧</p><p><code>事物+多线程+锁，处理的方法</code></p><ul><li><p>但是这样加锁，锁的细粒度太粗了，在使用锁的过程中，控制锁粒度是一个非常重要的事情，因为<code>如果锁的粒度太大，会导致每个线程进来都会被锁住</code>，现在的情况就是所有用户都公用这一把锁，串行执行，效率很低，我们现在要完成的业务是<code>一人一单</code>，所以这个锁，应该只加在单个用户上，用户标识可以用<code>userId</code></p></li><li><p>由于toString的源码是new String，所以如果我们只用<code>userId.toString()</code>拿到的也不是同一个用户，需要使用<code>intern()</code>，如果字符串常量池中已经包含了一个等于这个string对象的字符串（由equals（object）方法确定），那么将返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。</p></li><li><p>（<code>其实以上就可以用了，但是存在事物问题</code>）</p></li><li><p>但是以上代码还是存在问题，问题的原因在于当前方法被Spring的事务控制，如果你在内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放了，这样也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题</p></li><li><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务，这里可以使用<code>AopContext.currentProxy()</code>来获取当前对象的代理对象，然后再用代理对象调用方法，记得要去<code>IVoucherOrderService</code>中创建<code>createVoucherOrder</code>方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>同时在启动类上加上<code>@EnableAspectJAutoProxy(exposeProxy = true)</code>注解</p></li><li><p>引入aspectjweaver依赖</p></li><li><p>重启服务器，再次使用Jmeter测试，200个线程并发，但是只能抢到一张优惠券，目的达成</p></li></ul><h2 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h2><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在<code>集群模式</code>下就不行了</p><p><strong>1.复制服务，将服务启动两份，搭建集群</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412212621591.png" alt="image-20240412212621591"></p><p>2.然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p><blockquote><p>修改配置文件的时候，一定把所有的nginx关闭，因为我手贱多点了几下，启动了太多nginx服务器了，所以一直配置不成功，因为一直有以前的nginx启动</p></blockquote><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412213115309.png" alt="image-20240412213115309" style="zoom:67%;"><p><strong>有关锁失效原因分析</strong></p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412213230593.png" alt="image-20240412213230593" style="zoom:67%;"><p>集群模式下，有多个jvm的存在，每个jvm内都有自己的锁，导致每一个锁都可以有一个线程获取，于是就出现了并行运行</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p><code>分布式锁</code>：满足分布式系统或者集群系统模式下多进程可见并且互斥的锁</p><p><code>核心思想</code>：让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240412214026155.png" alt="image-20240412214026155" style="zoom:50%;"><ul><li><p>那么分布式锁他应该满足一些什么样的条件呢？</p></li><li><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p></li><li><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p></li><li><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p></li><li><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p></li><li><p>安全性：安全也是程序中必不可少的一环</p></li></ul><p>常见的分布式锁有三种</p><ul><li><code>Mysql</code>：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</li><li><code>Redis</code>：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</li><li>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</li></ul><p><img src="/2024/04/07/Java/Redis/BaiduNetdiskDownload/Redis入门到实战教程/02-实战篇/讲义/Redis实战篇.assets/1653382219377.png" alt="1653382219377"></p><h2 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h2><p> 我们虽然有多台服务器集群，但是我们都是在同一个Redis中获取锁，所以可以加锁</p><p>自定义锁的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutSec 持有锁的超时时间。过期自动释放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true代表成功，false代表失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在工具类中实现接口，定义锁的一般方法</p><p>底层是Redis中的set NX互斥和set EX设置超时时间方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分布式锁被误删的情况"><a href="#分布式锁被误删的情况" class="headerlink" title="分布式锁被误删的情况"></a>分布式锁被误删的情况</h2><p>逻辑说明：</p><p>持有锁的线程在锁的<code>内部出现了阻塞，导致他的锁自动释放</code>，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>解决方案：<strong>解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除</strong>，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653385920025.png" alt=" "></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取线程标示</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span>ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">       <span class="comment">// 获取锁</span></span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">               .setIfAbsent(KEY_PREFIX + name, threadId , timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//获取线程标识</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span>ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">       <span class="comment">//获取锁中标识</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">       <span class="comment">//判断是否一致</span></span><br><span class="line">       <span class="keyword">if</span>(threadId.equals(id))&#123;</span><br><span class="line">           <span class="comment">//通过del删除锁</span></span><br><span class="line">           stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="分布式锁的原子性的问题"><a href="#分布式锁的原子性的问题" class="headerlink" title="分布式锁的原子性的问题"></a>分布式锁的原子性的问题</h2><p><strong>更为极端的误删逻辑说明</strong>：</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653387764938.png" alt="1653387764938" style="zoom:67%;"><p>也就是代码中的，判断和删除，两行代码，执行就是会有时间，哪怕几微妙，几纳秒</p><p>就在这时，线程阻塞了，JVM中full gc了，又误删了</p><h2 id="Lua脚本解决多条命令的原子性问题"><a href="#Lua脚本解决多条命令的原子性问题" class="headerlink" title="Lua脚本解决多条命令的原子性问题"></a>Lua脚本解决多条命令的原子性问题</h2><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了。</a></p><blockquote><p><strong>Lua脚本在Redis中是原子性执行的，即使是由多个命令组成的脚本，Redis会将其作为一个整体进行执行，不会被其他客户端的操作打断，从而确保了操作的原子性。</strong></p></blockquote><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure><p>例如，我们要执行set name jack，则脚本是这样：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：<code>EVAL</code></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240413024602579.png" alt="image-20240413024602579"></p><p>释放锁的业务流程是这样的</p><p>​1、获取锁中的线程标示</p><p>​2、判断是否与指定的标示（当前线程标示）一致</p><p>​3、如果一致则释放锁（删除）</p><p>​4、如果不一致则什么都不做</p><p>如果用Lua脚本来表示则是这样的：</p><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="利用Java调用lua脚本"><a href="#利用Java调用lua脚本" class="headerlink" title="利用Java调用lua脚本"></a>利用Java调用lua脚本</h2><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240413040136593.png" alt="image-20240413040136593" style="zoom: 80%;"><p>初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化释放锁的脚本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;  <span class="comment">//静态代码块，在类加载的时候执行，用于初始化</span></span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));<span class="comment">//加载resource下的资源</span></span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);<span class="comment">//配置返回值</span></span><br></pre></td></tr></table></figure><p>调用execute方法去删除锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lua脚本 实现锁的删除</span></span><br><span class="line"><span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span>ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">stringRedisTemplate.execute(UNLOCK_SCRIPT,  <span class="comment">//lua脚本</span></span><br><span class="line">        Collections.singletonList(KEY_PREFIX + name),<span class="comment">//key转为集合</span></span><br><span class="line">        threadId <span class="comment">//线程标识</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>基于Redis实现分布式锁的实现思路</p><ol><li><strong>选择合适的锁键（Lock Key）</strong>：<ul><li>锁键是用于标识和获取锁的唯一标识符。它应该是具有唯一性的，以防止不同的应用程序或线程之间发生冲突。通常，锁键可以是一个字符串，可以包含命名空间、资源名称、唯一标识符等信息。</li></ul></li><li><strong>获取锁</strong>：<ul><li>通过在 Redis 中设置一个键值对来获取锁。键表示锁键，值表示锁的持有者标识符或者一个随机生成的唯一标识符。</li><li>可以使用 Redis 的 SETNX 命令（SET if Not eXists）来尝试设置锁，如果键不存在则设置成功，表示获取锁成功。</li></ul></li><li><strong>设置锁的超时时间</strong>（可选）：<ul><li>可以为锁设置一个超时时间，防止锁被永久持有。可以使用 Redis 的 SETEX 或者 EXPIRE 命令来设置键的过期时间。</li></ul></li><li><strong>释放锁</strong>：<ul><li>当持有锁的线程完成了工作，或者锁超时时，需要将锁释放。可以使用 DEL 命令来删除键，释放锁。</li></ul></li></ol><p>在实现分布式锁时，还需要考虑以下几点：</p><ul><li><strong>锁的互斥性</strong>：确保同一时刻只有一个线程或者进程能够持有锁。</li><li><strong>锁的可重入性</strong>：允许同一线程或者进程多次获取同一个锁。</li><li><strong>锁的可靠性</strong>：确保在各种异常情况下，锁都能够正确地释放，避免死锁或者锁失效。</li><li><strong>锁的性能</strong>：尽量减小锁操作对性能的影响，避免锁竞争和频繁的锁释放操作。</li></ul><h1 id="分布式锁redission"><a href="#分布式锁redission" class="headerlink" title="分布式锁redission"></a>分布式锁redission</h1><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240413045006147.png" alt="image-20240413045006147"></p><p>那么什么是Redission呢</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653546736063.png" alt="1653546736063"></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.28.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义配置类，配置Redis地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.239.129:6379&quot;</span>)</span><br><span class="line">                .setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接注入对象，调用他的getClock和unlock方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分布式锁-redisson可重入锁的原理"><a href="#分布式锁-redisson可重入锁的原理" class="headerlink" title="分布式锁-redisson可重入锁的原理"></a>分布式锁-redisson可重入锁的原理</h2><p> 可重入锁：以前的锁是不可冲重入的，所以当一个线程，里去调用多把锁的时候，就会出现第一把锁获取成功，其他锁获取失败的情况</p><p>为了解决锁的可重入性质。将以前的key值为lock，value属性只有线程自己的ID，改为用hashmap存储，存储当先线程的ID和线程获取锁的次数</p><p>调用锁的时候，判断是不是自己，统计数+1，释放的时候，判断是不是自己，统计数-1，知道统计数为0，再释放锁</p><p>具体的流程如下</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240413182704225.png" alt="image-20240413182704225"></p><p>为了保证原子性，就是执行获取锁和删除锁的过程是一起的，不会被其他线程阻挡</p><p>使用lua脚本实现</p><p><strong>获取锁的逻辑</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"><span class="comment">-- 锁不存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 获取锁并添加线程标识，state设为1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="comment">-- 设置锁有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁存在，判断threadId是否为自己</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 锁存在，重入次数 +1，这里用的是hash结构的incrby增长</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, thread, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">-- 设置锁的有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里，说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure><p><strong>释放锁的逻辑</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="comment">-- 如果锁不是自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁是自己的，锁计数-1，还是用hincrby，不过自增长的值为-1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">-- 判断重入次数为多少</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 大于0，重置有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 否则直接释放锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="分布式锁redisson重试和看门狗机制"><a href="#分布式锁redisson重试和看门狗机制" class="headerlink" title="分布式锁redisson重试和看门狗机制"></a>分布式锁redisson重试和看门狗机制</h2><ol><li><strong>重试机制</strong>：<ul><li>在使用 Redisson 实现分布式锁时，为了应对网络异常、Redis 服务器故障等情况，通常会配置重试机制。重试机制可以在获取锁失败后自动进行多次重试，直到获取锁成功或达到最大重试次数为止。</li><li>Redisson 的重试机制是通过循环调用 Redis 的 SETNX（SET if Not eXists）命令来实现的。当某个节点在获取锁时失败后，会在指定的时间间隔内进行重试，直到获取锁成功或者超过最大重试次数。</li></ul></li><li><strong>看门狗机制</strong>：<ul><li>看门狗机制是用于防止锁持有者在执行业务逻辑时出现异常<code>导致锁没有被释放而造成死锁</code>的情况。看门狗机制会在获取锁成功后启动一个定时任务，定时更新锁的过期时间。如果锁持有者因为异常或其他原因未能及时释放锁，锁的过期时间会被更新，确保锁在一定时间内仍然有效，避免死锁情况的发生。</li><li>在 Redisson 中，看门狗机制是通过 Redis 的 PEXPIRE（设置过期时间，带毫秒单位）命令实现的。当获取锁成功后，会启动一个定时任务定时更新锁的过期时间，保持锁的有效性。</li></ul></li></ol><p>综上所述，重试机制和看门狗机制是 Redisson 保证分布式锁可靠性和稳定性的重要机制。重试机制用于处理获取锁失败的情况，而看门狗机制用于防止锁的持有者出现异常导致锁未被释放而造成死锁的情况。这两种机制结合起来，可以有效地确保分布式锁的正确使用。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240413224056964.png" alt="image-20240413224056964"></p><p><strong>Redisson分布式锁的原理</strong></p><p><strong>可重入：利用hash结构记录线程ID和重入次数</strong></p><p><strong>可重试：利用信号量和PubSUb实现等待，唤醒，获取锁失败的重试机制</strong></p><p><strong>超时续约：利用看门狗，每隔一段时间（释放时间的1&#x2F;3），重置超时时间</strong></p><h2 id="Redisson主从一致性问题–multiLock"><a href="#Redisson主从一致性问题–multiLock" class="headerlink" title="Redisson主从一致性问题–multiLock"></a>Redisson主从一致性问题–multiLock</h2><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653554055048.png" alt="1653554055048"></p><p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240414004700400.png" alt="image-20240414004700400"></p><h2 id="本章小结："><a href="#本章小结：" class="headerlink" title="本章小结："></a>本章小结：</h2><ol><li>不可重入Redis分布式锁<ul><li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入Redis分布式锁<ul><li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：Redis宕机引起锁失效问题</li></ul></li><li>Redisson的multiLock<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li></ul></li></ol><h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><p><strong>测试：在测试类中，将数据库中的所有用户，分发令牌的token写入Redis中，并且把token写入文件里</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> IUserService userService;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tokenWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">       <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;tokens.txt&quot;</span>));</span><br><span class="line">       List&lt;User&gt; list = userService.list();</span><br><span class="line">       <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">           <span class="comment">//6.随机生成token，作为登陆令牌</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">           <span class="comment">//7.将user转为Hash存储。调用工具类</span></span><br><span class="line">           <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">           Map&lt;String, Object&gt; usermap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                   CopyOptions.create()</span><br><span class="line">                           .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                           .setFieldValueEditor((Name, Value) -&gt; Value.toString())</span><br><span class="line">           );</span><br><span class="line">           <span class="comment">//8.存储到Redis中，并且设置token有效期</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">           stringRedisTemplate.opsForHash().putAll(tokenKey, usermap);</span><br><span class="line">           <span class="comment">//stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">           writer.write(token);</span><br><span class="line">           writer.newLine();</span><br><span class="line">       &#125;</span><br><span class="line">       writer.close();</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;测试方法用时&quot;</span> + (end-start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在jmeter中并发测试</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415014955568.png" alt="image-20240415014955568"></p><p>断言就是我们判断返回值Jason中的success，如果等于true，判断成功，其他判断失败</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415015105647.png" alt="image-20240415015105647"></p><p>并发1000次，我发现，我们的自己定义的锁，平均相应3222ms，太慢了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415015229828.png" alt="image-20240415015229828"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415015823187.png" alt="image-20240415015823187"></p><p><strong>先尝试用redisson的锁</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415022237053.png" alt="image-20240415022237053"></p><p>平均值由3222ms提升到了2107ms</p><p>但还是太慢，还得优化</p><h2 id="异步秒杀思路"><a href="#异步秒杀思路" class="headerlink" title="异步秒杀思路"></a>异步秒杀思路</h2><p>我们来回顾一下下单流程</p><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p><p>1、查询优惠卷</p><p>2、判断秒杀库存是否足够</p><p>3、查询订单</p><p>4、校验是否是一人一单</p><p>5、扣减库存</p><p>6、创建订单</p><p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415090059038.png" alt="image-20240415090059038"></p><p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p><p><code>第一个难点</code><strong>是我们怎么在redis中去快速校验一人一单，还有库存判断</strong></p><p><strong><code>第二个难点</code>是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415091025381.png" alt="image-20240415091025381"></p><p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415091234973.png" alt="image-20240415091234973"></p><p>需求：</p><ul><li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p></li><li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p></li><li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p></li><li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p></li></ul><p>VoucherServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整lua表达式</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p><h2 id="基于阻塞队列实现秒杀优化"><a href="#基于阻塞队列实现秒杀优化" class="headerlink" title="基于阻塞队列实现秒杀优化"></a>基于阻塞队列实现秒杀优化</h2><p>没能实现数据库的事物，一加事物就报错，不知道为什么</p><p>一行行敲的代码，不懂的全写在注释里面了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化释放锁的脚本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;  <span class="comment">//静态代码块，在类加载的时候执行，用于初始化</span></span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));<span class="comment">//加载resource下的资源</span></span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);<span class="comment">//配置返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span>  <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//异步处理线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于线程池处理的任务</span></span><br><span class="line">    <span class="comment">// 当初始化完毕后，就会去从阻塞对列中去拿信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 2.创建锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">        <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">            log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">            createVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            redisLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private IVoucherOrderService proxy;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckikkVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1.执行lua脚本</span></span><br><span class="line">        <span class="comment">//使用lua脚本 实现redis中判断用户是否下单</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,  <span class="comment">//lua脚本</span></span><br><span class="line">                Collections.emptyList(),<span class="comment">//keys的集合，没有传空</span></span><br><span class="line">                voucherId.toString(), userId.toString()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span>(result != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//不为0，代表没有资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(result == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> :<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 为0，代表有购买资格，把下单信息保存到阻塞队列中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回订单ID的ID，全局ID生成器，生成的是订单号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//订单ID</span></span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//用户ID</span></span><br><span class="line">        <span class="comment">//Long userId = UserHolder.getUser().getId();</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">//代金券ID</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">//放进阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="comment">//proxy = (IVoucherOrderService) AopContext.currentProxy();</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span>&#123;</span><br><span class="line">        <span class="comment">//一人一单</span></span><br><span class="line">        <span class="comment">//Long userId = UserHolder.getUser().getId();</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">//select count(*) from xxx where user_id = #&#123;userId&#125; and voucher_id = #&#123;voucherId&#125;;</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// Result.fail(&quot;用户已经购买过一次了&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.扣减库存,使用mybatisplus的链式查找工具</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService</span><br><span class="line">                .update().setSql(<span class="string">&quot;stock = stock -1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId())</span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// Result.fail(&quot;库存不足！&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质就是：创建优惠券的时候，将优惠券的信息存入redis中，<code>我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功</code>，将要操作数据库的操作提取出来，放入<code>阻塞队列</code>，后慢慢执行，将其他操作，在redis中执行，秒杀库存的判断，使用lua脚本，lua脚本执行是单线程的，确保操作是原子性的，不会有并发问题。从而达到优化的目的。</p><p><strong>来，上压力测试</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415164508157.png" alt="image-20240415164508157"></p><p>1000个用户并发抢200个，优化到了平均13ms每秒</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417004723644.png" alt="image-20240417004723644"></p><p>第二次压力测试。74ms</p><p>秒杀业务的优化思路是什么？</p><ul><li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li><li>基于阻塞队列的异步秒杀存在哪些问题？<ul><li>阻塞队列基于虚拟机JVM，内存限制问题</li><li>数据安全问题</li></ul></li></ul><p>快把消息队列端上来吧</p><h1 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h1><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为<code>消息代理</code>（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415170000036.png" alt="image-20240415170000036"></p><p>消息队列就类比于<code>快递柜</code>，生产者把快递放在快递柜子，快递柜子作为消息队列，通知我们去拿快递，相当于异步处理，解除了耦合，大大提高了效率</p><p>这里我们可以使用一些现成的mq，<strong>比如kafka，rabbitmq等等</strong>，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><p>Redis提供了三种不同的方式来实现消息队列：</p><p>list结构：</p><p>PubSub:</p><p>Stream:比较完善的消息队列模型 </p><h2 id="List实现消息队列"><a href="#List实现消息队列" class="headerlink" title="List实现消息队列"></a>List实现消息队列</h2><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用<code>BRPOP或者BLPOP来实现阻塞效果。</code></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653575176451.png" alt="1653575176451"></p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h2 id="基于PubSub消息队列"><a href="#基于PubSub消息队列" class="headerlink" title="基于PubSub消息队列"></a>基于PubSub消息队列</h2><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653575506373.png" alt="1653575506373"></p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h2 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h2><p>（没听懂，就跟着敲了）</p><p>需求：</p><ul><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li></ul><p>步骤一：在Linux中Redis创建一个Stream类型的消息队列，名为stream.orders</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE stream.orders g1 0 MKSTREAM</span><br></pre></td></tr></table></figure><p>步骤二：修改Lua脚本，新增orderId参数，并将订单信息加入到消息队列中</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>步骤三：修改秒杀逻辑（这stream真心看不懂啊）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Redis消息队列--基于Stream的消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                            StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 解析数据</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                    Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 3.创建订单</span></span><br><span class="line">                    createVoucherOrder(voucherOrder);</span><br><span class="line">                    <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                    <span class="comment">//处理异常消息</span></span><br><span class="line">                    handlePendingList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                        Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                        StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception s)&#123;</span><br><span class="line">                    s.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240415225523723.png" alt="image-20240415225523723"></p><p>压力一测试，从阻塞队列的13ms，到stream消息队列的203毫秒，真服了 ，反向优化是吧，而且我代码还看不懂，去学其他的消息队列吧MQ吧</p><h2 id="RabbitMQ消息队列实现"><a href="#RabbitMQ消息队列实现" class="headerlink" title="RabbitMQ消息队列实现"></a>RabbitMQ消息队列实现</h2><p><code>花了一天去学习了RabbitMQ，只是浅浅了解了安装和基础的使用方法</code></p><p><code>接下来，用RabbitMQ实现消息队列</code></p><p><code>我只谈代码修改的部分吧</code></p><p><code>详细的RabbitMQ我还记了一篇RabbitMQ笔记</code></p><p>把以前放入阻塞队列的消息，放入消息队列RabbitMQ中</p><p>引入依赖，注入RabbitTemplate对象</p><p>其中，convertAndSend的传入的参数为，交换机，关键字，和对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="comment">/*.......*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//放入消息队列RabbitMQ</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;voucherOrder.topic&quot;</span>,<span class="string">&quot;secKill.success&quot;</span>,voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AmqpException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，用户ID：&#123;&#125;&quot;</span>,voucherOrder.getUserId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放进阻塞队列</span></span><br><span class="line">        <span class="comment">//orderTasks.add(voucherOrder);</span></span><br></pre></td></tr></table></figure><p>新建一个Listener包，定义MQListener类，用于监听消息</p><p>注入之前的service层对象，直接调用其方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> VoucherOrderServiceImpl voucherOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;hello.queue1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listensSimpleQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者收到了hello.queue1的消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;voucherOrder.queue&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;voucherOrder.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = &quot;secKill.success&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">voucherOrderListener</span><span class="params">(VoucherOrder voucherOrder)</span>&#123;</span><br><span class="line">        <span class="comment">//TODO 消费者拿到消息队列的消息，的处理方法</span></span><br><span class="line">        <span class="comment">//voucherOrderService.handleVoucherOrder(voucherOrder);</span></span><br><span class="line">        voucherOrderService.createVoucherOrder(voucherOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;voucherOrder.queue&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;voucherOrder.topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">        key = &quot;secKill.success&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br></pre></td></tr></table></figure><p>使用注解嵌套注解的方式，来实现</p><p>具体解释如下：</p><ol><li><code>@RabbitListener</code>: 这是一个监听器注解，用于声明一个方法作为 RabbitMQ 的消息消费者。当 RabbitMQ 中有消息到达时，被注解的方法将被调用。</li><li><code>bindings</code>: 这是 <code>@RabbitListener</code> 注解的一个属性，用于指定<strong>队列和交换机之间的绑定关系</strong>。在这里，通过 <code>@QueueBinding</code> 注解指定了队列与交换机之间的绑定关系。</li><li><code>@Queue</code>: 在 <code>@QueueBinding</code> 注解中，<code>@Queue</code> 用于声明一个队列，并设置队列的属性。在这里，使用了 <code>name</code> 属性指定了队列的名称为 “voucherOrder.queue”。</li><li><code>@Exchange</code>: 在 <code>@QueueBinding</code> 注解中，<code>@Exchange</code> 用于声明一个交换机，并设置交换机的属性。在这里，使用了 <code>name</code> 属性指定了交换机的名称为 “voucherOrder.topic”，<code>type</code> 属性指定了交换机的类型为 “topic”。</li><li><code>key</code>: 在 <code>@QueueBinding</code> 注解中，<code>key</code> 属性<strong>用于指定路由键</strong>，表示消息从交换机发送到队列时所需匹配的路由规则。在这里，设置了 “secKill.success” 作为路由键。</li></ol><p>综上所述，这段代码的作用是声明了一个 RabbitMQ 的消息监听器，监听名为 “voucherOrder.topic” 的交换机上的 “secKill.success” 路由键对应的队列 “voucherOrder.queue”，当有消息通过该路由键到达时，会触发被注解的方法进行消费。</p><p>来，上压力测试，好快啊，平均26ms</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417155424199.png" alt="image-20240417155424199"></p><p>来三轮求取平均值 82ms</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417160106573.png" alt="image-20240417160106573"></p><p>第三轮68ms</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417160716270.png" alt="image-20240417160716270"></p><p>好像用了lua脚本后，就确保了一人一单不会被抢了，加Redisson分布式锁还有没有用了？</p><p>加锁，也是给后续写入数据库的操作加锁，感觉会没用，试试</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240417161256215.png" alt="image-20240417161256215"></p><p>果然，平均只有1s了</p><h1 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h1><h2 id="发布探店笔记"><a href="#发布探店笔记" class="headerlink" title="发布探店笔记"></a>发布探店笔记</h2><p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p><p>一共两个接口 ，上传 和发布</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418093502146.png" alt="image-20240418093502146"></p><p>上传接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 生成新文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p><p>BlogController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        blog.setUpdateTime(user.getId());</span><br><span class="line">        <span class="comment">//保存探店博文</span></span><br><span class="line">        blogService.saveBlog(blog);</span><br><span class="line">        <span class="comment">//返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="达人探店点赞功能"><a href="#达人探店点赞功能" class="headerlink" title="达人探店点赞功能"></a>达人探店点赞功能</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418110635495.png" alt="image-20240418110635495"></p><p>完善点赞功能</p><p>需求：</p><ul><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现步骤：</p><ul><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><p>思路就是：用一个set集合去存储已经点赞的用户的列表集合</p><p>我们先去Redis中查询，</p><p>查询不到，数据库点赞++，保存用户到Redis说明已经点过赞</p><p>查询到，数据库点赞–，删除Redis中set保存的用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户，从线程池中</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">        <span class="comment">//isMember判断是否是当前set的成员</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">        <span class="keyword">if</span> (BooleanUtil.isFalse(isMember)) &#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">            <span class="comment">//3.1 数据库点赞数+1</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//3.2 保存用户到Redis的set集合</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForSet().add(key, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">            <span class="comment">//4.1 数据库点赞数-1</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//4.2 把用户从Redis的set集合移除</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForSet().remove(key, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryHotBlog</span><span class="params">(Integer current)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据用户查询</span></span><br><span class="line">        Page&lt;Blog&gt; page = query()</span><br><span class="line">                .orderByDesc(<span class="string">&quot;liked&quot;</span>)</span><br><span class="line">                .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">        <span class="comment">// 获取当前页数据</span></span><br><span class="line">        List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">        <span class="comment">// 查询用户</span></span><br><span class="line">        records.forEach(blog -&gt;&#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> blog.getUserId();</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">            blog.setName(user.getNickName());</span><br><span class="line">            blog.setIcon(user.getIcon());</span><br><span class="line">            <span class="built_in">this</span>.isBlogLiked(blog);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="点赞排行傍"><a href="#点赞排行傍" class="headerlink" title="点赞排行傍"></a>点赞排行傍</h2><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p><p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的<code>sortedSet</code></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418151814526.png" alt="image-20240418151814526"></p><p><img src="/2024/04/07/Java/Redis/Users\A\AppData\Roaming\Typora\typora-user-images\image-20240418151858340.png" alt="image-20240418151858340"></p><p><strong>思路：使用zset代替set集合，按照保存时间的毫秒值，获取排名前五的用户</strong></p><p><strong>做一些转换，封装到DTO中即可返回</strong></p><p>controller层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likesBlog</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.likesBlog(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户，从线程池中</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">        <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">            <span class="comment">//3.1 数据库点赞数+1</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//3.2 保存用户到Redis的set集合、Zset集合。zadd key value score</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().add(key, userId.toString(),System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">            <span class="comment">//4.1 数据库点赞数-1</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//4.2 把用户从Redis的set集合移除</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">likesBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">        <span class="comment">//查询top5的点赞用户  zrange key 0 4</span></span><br><span class="line">        Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//        List&lt;Long&gt; ids = new ArrayList&lt;&gt;(); // 创建一个新的列表，用于存储转换后的 Long 类型值</span></span><br><span class="line"><span class="comment">//        for (String str : top5) &#123;</span></span><br><span class="line"><span class="comment">//            Long i = Long.valueOf(str); // 将字符串转换为 Long 类型</span></span><br><span class="line"><span class="comment">//            ids.add(i); // 将转换后的 Long 类型值添加到新的列表中</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(top5 == <span class="literal">null</span> || top5.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stream流实现列表字符串类型转为long类型</span></span><br><span class="line">        List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).toList();</span><br><span class="line">        List&lt;User&gt; users = userService.listByIds(ids);</span><br><span class="line">        List&lt;UserDTO&gt; userDTOS = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(User u : users)&#123;</span><br><span class="line">            <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(u, UserDTO.class);</span><br><span class="line">            userDTOS.add(userDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stream流，将List&lt;User&gt; users 复制转为 List&lt;UserDTO&gt; userDTOS</span></span><br><span class="line"><span class="comment">//        List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids)</span></span><br><span class="line"><span class="comment">//                .stream()</span></span><br><span class="line"><span class="comment">//                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span></span><br><span class="line"><span class="comment">//                .collect(Collectors.toList());</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有好多用流的处理方法，我流使用不习惯，用传统for集合遍历也行</p><h1 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h1><h2 id="好有关注和取关"><a href="#好有关注和取关" class="headerlink" title="好有关注和取关"></a>好有关注和取关</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418153619094.png" alt="image-20240418153619094"></p><p>基于该表数据结构，实现两个接口</p><ul><li>关注和取关接口</li><li>判断关注的接口</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418184922624.png" alt="image-20240418184922624"></p><p>关注是User之间的关系，是博主和粉丝的关系，<strong>是多对多的关系</strong>，数据库中有一张表，tb_follow表示</p><p>思路：</p><p>尝试关注思路：判断是关注还是取关，关注的话就定义对象，存到表中，取关就删除表中字段</p><p>是否关注用户：查询，符合就行</p><p><strong>controller层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">IFollowService followService;</span><br><span class="line"><span class="comment">//关注</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(followUserId, isFollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消关注</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.isFollow(followUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>service层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> BlogMapper blogMapper;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">//判断关注还是取关</span></span><br><span class="line">       <span class="keyword">if</span>(isFollow)&#123;</span><br><span class="line">           <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">           follow.setUserId(userId);</span><br><span class="line">           follow.setFollowUserId(followUserId);</span><br><span class="line">           save(follow);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">               new QueryWrapper&lt;Follow&gt;()：创建一个 Follow 实体类的查询条件包装器对象。</span></span><br><span class="line"><span class="comment">               eq(&quot;user_id&quot;, userId)：指定查询条件，表示要查询 Follow 表中 user_id 列等于 userId 的记录。</span></span><br><span class="line"><span class="comment">               eq(&quot;follow_user_id&quot;, followUserId)：进一步指定查询条件，表示要查询 Follow 表中 follow_user_id 列等于 followUserId 的记录。</span></span><br><span class="line"><span class="comment">               remove()：执行删除操作，删除符合上述查询条件的数据。</span></span><br><span class="line"><span class="comment">               总之，这行代码的作用是删除表中 user_id 等于 userId 且 follow_user_id 等于 followUserId 的记录。*/</span></span><br><span class="line">           <span class="comment">//remove(new QueryWrapper&lt;Follow&gt;().eq(&quot;user_id&quot;,userId).eq(&quot;follow_user_id&quot;,followUserId));</span></span><br><span class="line">           <span class="comment">//不熟悉还是写SQL吧</span></span><br><span class="line">           <span class="comment">//delete from tb_follow where user_id = #&#123;userId&#125; and follow_user_id = #&#123;followUserId&#125;</span></span><br><span class="line">           blogMapper.deleteFollow(userId,followUserId);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">       <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h2><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p><p>1、去查询用户的详情</p><p>2、去查询用户的笔记</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418190839157.png" alt="image-20240418190839157"></p><p><strong>1.查询用户详情</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.查询用户笔记</strong></p><ol><li><code>blogService.page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE))</code>：<ul><li><code>blogService</code> 是一个博客服务对象，通过该对象调用 <code>page</code> 方法来查询博客信息。</li><li><code>page</code> 方法接受一个 <code>Page</code> 对象作为参数，用于指定查询的分页信息。</li><li><code>new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE)</code> 创建了一个分页对象，其中 <code>current</code> 表示当前页数，<code>SystemConstants.MAX_PAGE_SIZE</code> 表示每页的记录数。</li><li>通过传入当前页数和每页记录数，实现了分页查询。</li></ul></li><li><code>List&lt;Blog&gt; records = page.getRecords();</code>：<ul><li><code>page.getRecords()</code> 方法用于获取当前页的记录列表。</li><li>将获取到的记录列表赋值给 <code>List&lt;Blog&gt; records</code>，以便后续返回给前端。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogByUserId</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;id&quot;)</span> Long id,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;,defaultValue = &quot;1&quot;)</span> Integer current)</span>&#123;</span><br><span class="line">    <span class="comment">//根据用户分页查询，current当前页数，M每页最大页数</span></span><br><span class="line">    Page&lt;Blog&gt; objectPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE);</span><br><span class="line">    Page&lt;Blog&gt; page = blogService.page(objectPage);</span><br><span class="line">    <span class="comment">//获取当前页的数据</span></span><br><span class="line">    List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共同关注的实现"><a href="#共同关注的实现" class="headerlink" title="共同关注的实现"></a><strong>共同关注的实现</strong></h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418220145437.png" alt="image-20240418220145437"></p><p>思路：在关注的时候，放入数据库的同时，指定key把<code>当前ID的关注列表</code>以set的形式放入缓存中，</p><p>取消关注的时候，删除数据库的时候，删除缓存</p><p>最后在用set的求交集的api，就可以查找到共同关注</p><p>注意查到的的数据为String，转化为Long类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">        <span class="comment">//判断关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span>(isFollow)&#123;</span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserId);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ifSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">            <span class="keyword">if</span>(ifSuccess)&#123;</span><br><span class="line">                stringRedisTemplate.opsForSet().add(key,followUserId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">/* new QueryWrapper&lt;Follow&gt;()：创建一个 Follow 实体类的查询条件包装器对象。</span></span><br><span class="line"><span class="comment">                eq(&quot;user_id&quot;, userId)：指定查询条件，表示要查询 Follow 表中 user_id 列等于 userId 的记录。</span></span><br><span class="line"><span class="comment">                eq(&quot;follow_user_id&quot;, followUserId)：进一步指定查询条件，表示要查询 Follow 表中 follow_user_id 列等于 followUserId 的记录。</span></span><br><span class="line"><span class="comment">                remove()：执行删除操作，删除符合上述查询条件的数据。</span></span><br><span class="line"><span class="comment">                总之，这行代码的作用是删除表中 user_id 等于 userId 且 follow_user_id 等于 followUserId 的记录。*/</span></span><br><span class="line">            <span class="comment">//remove(new QueryWrapper&lt;Follow&gt;().eq(&quot;user_id&quot;,userId).eq(&quot;follow_user_id&quot;,followUserId));</span></span><br><span class="line">            <span class="comment">//不熟悉还是写SQL吧</span></span><br><span class="line">            <span class="comment">//delete from tb_follow where user_id = #&#123;userId&#125; and follow_user_id = #&#123;followUserId&#125;</span></span><br><span class="line">            blogMapper.deleteFollow(userId,followUserId);</span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key,followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">        Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key1, key2);</span><br><span class="line">        <span class="keyword">if</span>(intersect == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析ID,Stream流处理</span></span><br><span class="line">        List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).toList();</span><br><span class="line">        List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids).stream()</span><br><span class="line">                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">                .toList();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="关注推送Feed流"><a href="#关注推送Feed流" class="headerlink" title="关注推送Feed流"></a>关注推送Feed流</h2><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流</p><p>关注推送也叫做<code>Feed流</code>，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于<code>新型的Feed流</code>的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p><p>Feed流产品有两种常见模式：<br><code>Timeline</code>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如<strong>朋友圈</strong></p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul><p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li><p>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</p></li><li><p>缺点：如果算法不精准，可能起到反作用</p></li><li><p>该模式的实现方案有三种：</p></li></ul><p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p><p>，因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><p><strong>拉模式</strong>：也叫是，<code>读扩散</code></p><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653809450816.png" alt="1653809450816"></p><p><strong>推模式</strong>：也叫做<code>写扩散。</code></p><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653809875208.png" alt="1653809875208"></p><p><strong>推拉结合模式</strong>：也叫做<code>读写混合</code>，兼具推和拉两种模式的优点。</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个<code>普通的人，那么我们采用写扩散的方式</code>，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，<code>如果是大V，那么他是直接将数据先写入到一份到发件箱里边去</code>，然后再直接写一份到<code>活跃粉丝</code>收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653812346852.png" alt="1653812346852"></p><p><strong>大V：发件箱+活跃粉丝收件箱</strong></p><p><strong>普通人：收件箱</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240418221503956.png" alt="image-20240418221503956"></p><h2 id="推送到粉丝邮件箱"><a href="#推送到粉丝邮件箱" class="headerlink" title="推送到粉丝邮件箱"></a>推送到粉丝邮件箱</h2><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653813047671.png" alt="1653813047671"></p><p>Feed流的滚动分页</p><p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653813462834.png" alt="1653813462834"></p><p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p><h2 id="好友关注：实现分页查询收邮箱"><a href="#好友关注：实现分页查询收邮箱" class="headerlink" title="好友关注：实现分页查询收邮箱"></a><strong>好友关注：实现分页查询收邮箱</strong></h2><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p><p>具体操作如下：</p><p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p><p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p><p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p><p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240419010208450.png" alt="image-20240419010208450"></p><p>controller层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层</p><p>思路：使用zset中的方法，</p><ul><li><code>tringRedisTemplate.opsForZSet()</code>：通过 RedisTemplate 获取操作有序集合的接口。</li><li><code>reverseRangeByScoreWithScores()</code>：这是有序集合操作的一个方法，用于按照分数范围反向获取指定数量的成员和分数。</li><li><code>key</code>：指定要查询的有序集合的键。</li><li><code>0</code>：指定分数的最小值，这里为 0。</li><li><code>max</code>：指定分数的最大值，具体数值由变量 <code>max</code> 决定。</li><li><code>offset</code>：指定结果集的偏移量，即从符合条件的结果中的第几个开始取值。</li><li><code>2</code>：指定要返回的成员数量。</li></ul><p>该方法返回一个包含成员及其分数的 <code>TypedTuple</code> 集合，其中每个 <code>TypedTuple</code> 对象包含了一个成员和对应的分数。从有序集合中按照分数范围查询指定数量的成员，并按照分数从高到低进行排序，然后返回成员及其分数的集合。</p><p><code>难点：在于偏移量的处理</code></p><p>让我回想起刷leecode的那些夜晚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">       <span class="comment">//1.获取当前用户的收件箱</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + userId;</span><br><span class="line">       Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">               .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">       <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.ok();</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">       <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">       <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">           <span class="comment">// 4.1.获取id</span></span><br><span class="line">           ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">           <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">           <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">           <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">               os++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               minTime = time;</span><br><span class="line">               os = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       os = minTime == max ? os : os + offset;</span><br><span class="line">       <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">       List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">           <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">           queryBlogUser(blog);</span><br><span class="line">           <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">           isBlogLiked(blog);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 6.封装并返回</span></span><br><span class="line">       <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">       r.setList(blogs);</span><br><span class="line">       r.setOffset(os);</span><br><span class="line">       r.setMinTime(minTime);</span><br><span class="line">       <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="附近商户"><a href="#附近商户" class="headerlink" title="附近商户"></a>附近商户</h1><h2 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240419153837484.png" alt="image-20240419153837484"></p><p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">        <span class="comment">//Stream流实现分组</span></span><br><span class="line">        Map&lt;Long, List&lt;Shop&gt;&gt; shopList = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">        <span class="comment">//一般的分组</span></span><br><span class="line"><span class="comment">//        Map&lt;Long, List&lt;Shop&gt;&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        for (Shop shop : list) &#123;</span></span><br><span class="line"><span class="comment">//            Long id = shop.getId();</span></span><br><span class="line"><span class="comment">//            if (!map.containsKey(id)) &#123;</span></span><br><span class="line"><span class="comment">//                map.put(id, new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            map.get(id).add(shop);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : shopList.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">            <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">            List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">            List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">            <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">            <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">                <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">                locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                        shop.getId().toString(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">                ));</span><br><span class="line">            &#125;</span><br><span class="line">            stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>存入后的数据</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240419154000164.png" alt="image-20240419154000164"></p><p><strong>难点：</strong>不是每次都与Redis链接，去插入数据，而是把数据封装成List&lt;RedisGeoCommands.GeoLocation<String>&gt;集合，一次插入，减小与Redis链接的次数，提升效率</String></p><p>分页查询：</p><h2 id="附近商户的实现功能"><a href="#附近商户的实现功能" class="headerlink" title="附近商户的实现功能"></a>附近商户的实现功能</h2><p><strong>controller层</strong></p><p>ShopController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShopServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">       <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">       <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">           Page&lt;Shop&gt; page = query()</span><br><span class="line">                   .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                   .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">           <span class="comment">// 返回数据</span></span><br><span class="line">           <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.计算分页参数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">       <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">       GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo()</span><br><span class="line">               <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">               .search(</span><br><span class="line">                       key,</span><br><span class="line">                       GeoReference.fromCoordinate(x, y),</span><br><span class="line">                       <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">                       RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">               );</span><br><span class="line">       <span class="comment">// 4.解析出id</span></span><br><span class="line">       <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">       <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">           <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">           <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">       List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">       Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">       list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">           <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">           ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">           <span class="comment">// 4.3.获取距离</span></span><br><span class="line">           <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">           distanceMap.put(shopIdStr, distance);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">       List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">       <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">           shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 6.返回</span></span><br><span class="line">       <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通过 opsForGeo() 方法获取了 Redis 的 Geo 操作对象。</span><br><span class="line">调用 search() 方法执行地理位置的搜索操作。</span><br><span class="line">search() 方法接收了一系列参数：</span><br><span class="line">key：指定了要搜索的 GeoKey（地理位置的键）。</span><br><span class="line">GeoReference.fromCoordinate(x, y)：指定了搜索的中心坐标，其中 x 和 y 分别表示了经度和纬度。</span><br><span class="line">new Distance(5000)：指定了搜索的半径范围，这里设置为 5000 米。</span><br><span class="line">RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)：这是可选的参数，用于配置搜索的行为。includeDistance() 表示在搜索结果中包含距离信息，limit(end) 表示限制搜索结果的数量为 end。</span><br></pre></td></tr></table></figure><h2 id="用户签到BitMap"><a href="#用户签到BitMap" class="headerlink" title="用户签到BitMap"></a>用户签到BitMap</h2><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653823145495.png" alt="1653823145495"></p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现<code>BitMap</code>，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653824498278.png" alt="1653824498278"></p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><strong>代码</strong></p><p>UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户签到-签到统计"><a href="#用户签到-签到统计" class="headerlink" title="用户签到-签到统计"></a>用户签到-签到统计</h2><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p><img src="/2024/04/07/Java/Redis/BaiduNetdiskDownload/Redis入门到实战教程/02-实战篇/讲义/Redis实战篇.assets/1653834455899.png" alt="1653834455899"></p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>  BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：如何从后向前遍历每个bit位？</strong></p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p><p><img src="/2024/04/07/Java/Redis/BaiduNetdiskDownload/Redis入门到实战教程/02-实战篇/讲义/Redis实战篇.assets/1653835784444.png" alt="1653835784444"></p><p>代码</p><p><strong>UserController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="额外加餐"><a href="#额外加餐" class="headerlink" title="额外加餐"></a>额外加餐</h2><p>-关于使用bitmap来解决缓存穿透的方案</p><p>回顾<strong>缓存穿透</strong>：</p><p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p><p>解决方案：</p><ul><li><p>判断id&lt;0</p></li><li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p></li></ul><p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p><p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p><p>所以我们如何解决呢？</p><p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653836416586.png" alt="1653836416586"></p><p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p><p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p><p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p><p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p><p>id % bitmap.size  &#x3D; 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1653836578970.png" alt="1653836578970"></p><h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><p><strong>UV统计-HyperLogLog</strong></p><p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PFADD key element [element...]</span><br><span class="line">summary: Adds the specified elements to the specified HyperLogLog</span><br><span class="line"></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line">Return the approximated cardinality of the <span class="built_in">set</span>(s) observed by the HyperLogLog at key(s).</span><br><span class="line"></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br><span class="line">lnternal commands <span class="keyword">for</span> debugging HyperLogLog values</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHyperLogLog</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] users = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        j = i % <span class="number">1000</span>;</span><br><span class="line">        users[j] = <span class="string">&quot;user_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">999</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForHyperLogLog().add(<span class="string">&quot;HLL&quot;</span>, users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class="string">&quot;HLL&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240420010114009.png" alt="image-20240420010114009"></p><p>1000000存入997593，误差率约为0.2%</p><h1 id="实战篇结束，完结撒花"><a href="#实战篇结束，完结撒花" class="headerlink" title="实战篇结束，完结撒花"></a>实战篇结束，完结撒花</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础篇</title>
      <link href="/2024/04/05/Java/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/04/05/Java/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java快速入门"><a href="#Java快速入门" class="headerlink" title="Java快速入门"></a>Java快速入门</h1><h2 id="java程序基础"><a href="#java程序基础" class="headerlink" title="java程序基础"></a>java程序基础</h2><h3 id="JVM、JDK和JRE"><a href="#JVM、JDK和JRE" class="headerlink" title="JVM、JDK和JRE"></a>JVM、JDK和JRE</h3><ul><li>JVM：Java Virtual Machine</li><li>JDK：Java Development Kit</li><li>JRE：Java Runtime Environment</li></ul><p>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p><p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。</p><p><img src="/2024/04/05/Java/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/imgs/FkFHBGhlwkvD7j7wPFUnRCjrOHSX" alt="image-20200302140334046"></p><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>整数类型：byte，short，int，long</li><li>浮点数类型：float，double</li><li>字符类型：char</li><li>布尔类型：boolean</li></ul><p>计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从<code>00000000</code><del><code>11111111</code>，换算成十进制是0</del>255，换算成十六进制是<code>00</code>~&#96;ff&#96;。</p><p>Java基本数据类型占用的字节数：</p><p>Boolean 占1个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">  byte │   │</span><br><span class="line">       └───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line"> short │   │   │</span><br><span class="line">       └───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line">   int │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">  long │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line"> float │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">double │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line">  char │   │   │</span><br><span class="line">       └───┴───┘</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>定义变量的时候，如果加上<code>final</code>修饰符，这个变量就变成了常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">// PI是一个常量</span></span><br></pre></td></tr></table></figure><p>常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。根据习惯，常量名通常全部大写。</p><h3 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h3><p>如果想省略变量类型，可以使用<code>var</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>编译器会根据赋值语句自动推断出变量<code>sb</code>的类型是<code>StringBuilder</code>。对编译器来说，语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>实际上会自动变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>因此，使用<code>var</code>定义变量，仅仅是少写了变量类型而已。</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算是按位进行与、或、非和异或的运算。</p><p>与运算的规则是，必须两个数同时为<code>1</code>，结果才为<code>1</code>。</p><p>或运算的规则是，只要任意一个为<code>1</code>，结果就为<code>1</code>。</p><p>非运算的规则是，<code>0</code>和<code>1</code>互换。</p><p>异或运算的规则是，如果两个数不同，结果为<code>1</code>，否则为<code>0</code>。</p><h3 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h3><p>在Java的计算表达式中，运算优先级从高到低依次是：</p><ul><li><code>()</code></li><li><code>!</code> <code>~</code> <code>++</code> <code>--</code></li><li><code>*</code> <code>/</code> <code>%</code></li><li><code>+</code> <code>-</code></li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code></li></ul><h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p>浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。</p><p>由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较x和y是否相等，先计算其差的绝对值:</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.abs(x - y);</span><br><span class="line"><span class="comment">// 再判断绝对值是否足够小:</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p><ul><li><code>NaN</code>表示Not a Number</li><li><code>Infinity</code>表示无穷大</li><li><code>-Infinity</code>表示负无穷大</li></ul><p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。</p><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</p><p>数组一旦创建后，大小就不可改变。</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNames</span><span class="params">(String... names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Group</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Group</span>();</span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>, <span class="string">&quot;Xiao Jun&quot;</span>); <span class="comment">// 传入3个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>); <span class="comment">// 传入2个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 传入1个String</span></span><br><span class="line">g.setNames(); <span class="comment">// 传入0个String</span></span><br></pre></td></tr></table></figure><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法名相同，但各自的参数不同，称为方法重载（<code>Overload</code>）。</p><p>注意：方法重载的返回值类型通常都是相同的。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">super</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p>如果一个引用变量的类型是<code>Student</code>，那么它可以指向一个<code>Student</code>类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p>如果一个引用类型的变量是<code>Person</code>，那么它可以指向一个<code>Person</code>类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>现在问题来了：如果<code>Student</code>是从<code>Person</code>继承下来的，那么，一个引用类型为<code>Person</code>的变量，能否指向<code>Student</code>类型的实例？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><p>测试一下就可以发现，这种指向是允许的！</p><p>这是因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。<code>Person</code>类型的变量，如果指向<code>Student</code>类型的实例，对它进行操作，是没有问题的！</p><p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</p><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> p; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure><p>注意到继承树是<code>Student &gt; Person &gt; Object</code>，所以，可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p><h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><p>和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) p1; <span class="comment">// ok</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) p2; <span class="comment">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure><p>如果测试上面的代码，可以发现：</p><p><code>Person</code>类型<code>p1</code>实际指向<code>Student</code>实例，<code>Person</code>类型变量<code>p2</code>实际指向<code>Person</code>实例。在向下转型的时候，把<code>p1</code>转型为<code>Student</code>会成功，因为<code>p1</code>确实指向<code>Student</code>实例，把<code>p2</code>转型为<code>Student</code>会失败，因为<code>p2</code>的实际类型是<code>Person</code>，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p><p>向下转型时最好先用<code>instanceof</code>判断一下，避免转型失败。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p><p>Override和Overload不同的是，如果方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</p><p><strong>多态</strong>是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p.run(); <span class="comment">// 无法确定运行时究竟调用哪个run()方法</span></span><br></pre></td></tr></table></figure><p>有童鞋会问，从上面的代码一看就明白，肯定调用的是<code>Student</code>的<code>run()</code>方法啊。</p><p>但是，假设我们编写这样一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTwice</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">    p.run();</span><br><span class="line">    p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>它传入的参数类型是<code>Person</code>，我们是无法知道传入的参数实际类型究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。</strong></p><p><em>多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</em></p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>。</p><p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承。</p><p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。</p><h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p>我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。</p><p>然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><ul><li><p>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p></li><li><p>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p></li><li><p>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</p></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p><p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类。</p><p>无法实例化的抽象类有什么用？</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p><h3 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h3><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br></pre></td></tr></table></figure><p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不关心Person变量的具体子类型:</span></span><br><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样不关心新的子类是如何实现run()方法的：</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">e.run();</span><br></pre></td></tr></table></figure><p><em>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</em></p><p>面向抽象编程的本质就是：</p><ul><li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p><p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以把该抽象类改写为接口：<code>interface</code>。</p><p>在Java中，使用<code>interface</code>可以声明一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p><p><em>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。</em></p><p><em>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>。</em></p><p>抽象类和接口的对比如下：</p><table><thead><tr><th align="left"></th><th align="left">abstract class</th><th align="left">interface</th></tr></thead><tbody><tr><td align="left">继承</td><td align="left">只能extends一个class</td><td align="left">可以implements多个interface</td></tr><tr><td align="left">字段</td><td align="left">可以定义实例字段</td><td align="left">不能定义实例字段</td></tr><tr><td align="left">抽象方法</td><td align="left">可以定义抽象方法</td><td align="left">可以定义抽象方法</td></tr><tr><td align="left">非抽象方法</td><td align="left">可以定义非抽象方法</td><td align="left">可以定义default方法</td></tr></tbody></table><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>Person</code>接口继承自<code>Hello</code>接口，因此，<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐</span><br><span class="line">│   Iterable    │</span><br><span class="line">└───────────────┘</span><br><span class="line">        ▲                ┌───────────────────┐</span><br><span class="line">        │                │      Object       │</span><br><span class="line">┌───────────────┐        └───────────────────┘</span><br><span class="line">│  Collection   │                  ▲</span><br><span class="line">└───────────────┘                  │</span><br><span class="line">        ▲     ▲          ┌───────────────────┐</span><br><span class="line">        │     └──────────│AbstractCollection │</span><br><span class="line">┌───────────────┐        └───────────────────┘</span><br><span class="line">│     List      │                  ▲</span><br><span class="line">└───────────────┘                  │</span><br><span class="line">              ▲          ┌───────────────────┐</span><br><span class="line">              └──────────│   AbstractList    │</span><br><span class="line">                         └───────────────────┘</span><br><span class="line">                                ▲     ▲</span><br><span class="line">                                │     │</span><br><span class="line">                                │     │</span><br><span class="line">                     ┌────────────┐ ┌────────────┐</span><br><span class="line">                     │ ArrayList  │ │ LinkedList │</span><br><span class="line">                     └────────────┘ └────────────┘</span><br></pre></td></tr></table></figure><p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 用List接口引用具体子类的实例</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> list; <span class="comment">// 向上转型为Collection接口</span></span><br><span class="line"><span class="type">Iterable</span> <span class="variable">it</span> <span class="operator">=</span> coll; <span class="comment">// 向上转型为Iterable接口</span></span><br></pre></td></tr></table></figure><h4 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h4><p>接口可以定义<code>default</code>方法（JDK&gt;&#x3D;1.8）。</p><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</strong></p><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><h4 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h4><p>在一个<code>class</code>中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</p><p>还有一种字段，是用<code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p><p>静态字段只有一个共享“空间”，所有实例都会共享该字段。</p><p>虽然实例可以访问静态字段，但是它们指向的其实都是<code>Person class</code>的静态字段。所以，所有实例共享一个静态字段。</p><p>因此，不推荐用<code>实例变量.静态字段</code>去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象。</p><p>推荐用类名来访问静态字段。可以把静态字段理解为描述<code>class</code>本身的字段（非实例字段）。</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>用<code>static</code>修饰的方法称为静态方法。</p><p>因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段。</p><p>静态方法经常用于工具类。例如：</p><ul><li>Arrays.sort()</li><li>Math.random()</li></ul><h4 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h4><p><em>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会自动把该字段变为<code>public static final</code>类型。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h4><p>在现实中，如果小明写了一个<code>Person</code>类，小红也写了一个<code>Person</code>类，现在，小白既想用小明的<code>Person</code>，也想用小红的<code>Person</code>，怎么办？</p><p>在Java中，我们使用<code>package</code>来解决名字冲突。</p><p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p><p><em>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</em></p><h4 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h4><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 包作用域:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Main</code>类也定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.hello(); <span class="comment">// 可以调用，因为Main和Person在同一个包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>还有一种<code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入System类的所有静态字段和静态方法:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 相当于调用System.out.println(…)</span></span><br><span class="line">        out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li></ul><p>编写class的时候，编译器会自动帮我们做两个import动作：</p><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li><li>默认自动<code>import java.lang.*</code>。</li></ul><p>*在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><code>public</code>、<code>protected</code>、<code>private</code>这些修饰符可以用来限定访问作用域。</p><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问。</p><p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限。</p><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问。</p><p>实际上，确切地说，<code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>。</p><p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类。</p><p>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问该类<code>private</code>的权限。</p><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类。</p><h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><p>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p><p>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code>。</p><p><em>注意，包名必须完全一致，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</em></p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p><p>使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。</p><h4 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h4><p>Java还提供了一个<code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p><ul><li>用<code>final</code>修饰<code>class</code>可以阻止被继承；</li><li>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写；</li><li>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值；</li><li>用<code>final</code>修饰局部变量可以阻止被重新赋值。</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p><p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p><h3 id="classpath和jar"><a href="#classpath和jar" class="headerlink" title="classpath和jar"></a>classpath和jar</h3><h4 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h4><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p><p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</p><h4 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h4><p>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p><p>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p><p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>从Java 9开始，JDK又引入了模块（Module）。</p><p>Jar只是用于存放class的容器，它并不关心class之间的依赖。</p><p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是<strong>模块</strong>。</p><h4 id="打包jre"><a href="#打包jre" class="headerlink" title="打包jre"></a>打包jre</h4><p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p><p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。</p><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p><p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p><p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> java.xml &#123;</span><br><span class="line">    <span class="keyword">exports</span> java.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.catalog;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.datatype;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有它声明的导出的包，外部代码才被允许访问。因此，模块进一步隔离了代码的访问权限。</p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938">廖雪峰关于模块的讲解</a></p><h2 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h2><h3 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。</p><p>实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p><em>Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</em></p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用<code>equals()</code>方法而不能用<code>==</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的。</p><p><em>两个字符串比较，必须总是使用<code>equals()</code>方法。</em></p><p><em>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</em></p><p><code>String</code>类常用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否包含子串:</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.contains(<span class="string">&quot;ll&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  \tHello\r\n &quot;</span>.trim(); <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p><p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripLeading(); <span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripTrailing(); <span class="comment">// &quot; Hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br><span class="line"></span><br><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，11</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs); <span class="comment">// char[] -&gt; String</span></span><br><span class="line"><span class="comment">//通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份</span></span><br></pre></td></tr></table></figure><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从<code>0</code>到<code>127</code>，最高位始终为<code>0</code>，称为<code>ASCII</code>编码。</p><p>为了统一全球所有语言的编码，全球统一码联盟发布了<code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p><p>那我们经常使用的<code>UTF-8</code>又是什么编码呢？因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，包含大量英文的文本会浪费空间，所以，出现了<code>UTF-8</code>编码，它是一种变长编码，用来把固定长度的<code>Unicode</code>编码变成1～4字节的变长编码。</p><p><code>UTF-8</code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p><p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。</p><p><em><strong>Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</strong></em></p><h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p>对于不同版本的JDK，<code>String</code>类在内存中有不同的优化方式。具体来说，早期JDK版本的<code>String</code>总是以<code>char[]</code>存储，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而较新的JDK版本的<code>String</code>则以<code>byte[]</code>存储：如果<code>String</code>仅包含ASCII字符，则每个<code>byte</code>存储一个字符，否则，每两个<code>byte</code>存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的<code>String</code>通常仅包含ASCII字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder; <span class="comment">// 0 = LATIN1, 1 = UTF16</span></span><br></pre></td></tr></table></figure><p>对于使用者来说，<code>String</code>内部的优化不影响任何已有代码，因为它的<code>public</code>方法签名是不变的。</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>Java编译器对<code>String</code>做了特殊处理，使得我们可以直接用<code>+</code>拼接字符串。</p><p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象。</p><p>你可能还听说过<code>StringBuffer</code>，这是Java早期的一个<code>StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作<code>StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。</p><p><code>StringBuilder</code>和<code>StringBuffer</code>接口完全相同，现在完全没有必要使用<code>StringBuffer</code>。</p><h4 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h4><p>要高效拼接字符串，应该使用<code>StringBuilder</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">      <span class="comment">//结果用,分割，第二个参数是开头，第三个参数是结尾</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么<code>StringJoiner</code>内部是如何拼接字符串的呢？如果查看源码，可以发现，<code>StringJoiner</code>内部实际上就是使用了<code>StringBuilder</code>，所以拼接效率和<code>StringBuilder</code>几乎是一模一样的。</p><h4 id="String-join"><a href="#String-join" class="headerlink" title="String.join()"></a>String.join()</h4><p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>我们已经知道，Java的数据类型分两种：</p><ul><li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></li><li>引用类型：所有<code>class</code>和<code>interface</code>类型</li></ul><p>注：<code>String</code>就是一个<code>class</code>。</p><p>那么，如何把一个基本类型视为对象（引用类型）？</p><p>比如，想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<code>Integer</code>类就可以视为<code>int</code>的包装类（Wrapper Class）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><table><thead><tr><th align="left">基本类型</th><th align="left">对应的引用类型</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">java.lang.Boolean</td></tr><tr><td align="left">byte</td><td align="left">java.lang.Byte</td></tr><tr><td align="left">short</td><td align="left">java.lang.Short</td></tr><tr><td align="left">int</td><td align="left">java.lang.Integer</td></tr><tr><td align="left">long</td><td align="left">java.lang.Long</td></tr><tr><td align="left">float</td><td align="left">java.lang.Float</td></tr><tr><td align="left">double</td><td align="left">java.lang.Double</td></tr><tr><td align="left">char</td><td align="left">java.lang.Character</td></tr></tbody></table><p>我们可以直接使用这些基本类型的包装类。</p><h4 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure><p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p><em>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</em></p><p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code>。</p><h4 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h4><p>所有的包装类型都是不变类。我们查看<code>Integer</code>的源码可知，它的核心代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class Integer &#123;</span><br><span class="line">    private final int value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，一旦创建了<code>Integer</code>对象，该对象就是不变的。</p><p>对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较。</p><p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例，因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p><ul><li>方法1：<code>Integer n = new Integer(100);</code></li><li>方法2：<code>Integer n = Integer.valueOf(100);</code></li></ul><p>方法2更好，因为方法1总是创建新的<code>Integer</code>实例，方法2把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为静态工厂方法。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br><span class="line"></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// &quot;64&quot;,表示为16进制</span></span><br><span class="line">System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// &quot;144&quot;,表示为8进制</span></span><br><span class="line">System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// &quot;1100100&quot;,表示为2进制</span></span><br></pre></td></tr></table></figure><p>Java的包装类型还定义了一些有用的静态变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">t</span> <span class="operator">=</span> Boolean.TRUE;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">f</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line"><span class="comment">// int可表示的最大/最小值:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// long类型占用的bit和byte数量:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sizeOfLong</span> <span class="operator">=</span> Long.SIZE; <span class="comment">// 64 (bits)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bytesOfLong</span> <span class="operator">=</span> Long.BYTES; <span class="comment">// 8 (bytes)</span></span><br></pre></td></tr></table></figure><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>如果读写方法符合以下这种命名规范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> Type <span class="title function_">getXyz</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXyz</span><span class="params">(Type value)</span></span><br></pre></td></tr></table></figure><p>那么这种<code>class</code>被称为<code>JavaBean</code>。</p><h4 id="JavaBean的作用"><a href="#JavaBean的作用" class="headerlink" title="JavaBean的作用"></a>JavaBean的作用</h4><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p><h4 id="枚举JavaBean属性"><a href="#枚举JavaBean属性" class="headerlink" title="枚举JavaBean属性"></a>枚举JavaBean属性</h4><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BeanInfo</span> <span class="variable">info</span> <span class="operator">=</span> Introspector.getBeanInfo(Person.class);</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Weekday &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意到定义枚举类是通过关键字<code>enum</code>实现的，我们只需依次列出枚举的常量名。</p><p>首先，<code>enum</code>常量本身带有类型信息，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误。</p><p>其次，不可能引用到非枚举的值，因为无法通过编译。</p><p>引用类型比较，要始终使用<code>equals()</code>方法，但<code>enum</code>类型可以例外。</p><p>这是因为<code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较。</p><hr><p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>有什么区别？</p><p>答案是没有任何区别。<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li></ul><p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p><p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p><p>可以为<code>enum</code>编写构造方法、字段和方法</p><p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p><p><code>enum</code>适合用在<code>switch</code>语句中。</p><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了<code>long</code>型怎么办？<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数。</p><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure><p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.4567&quot;</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>。</p><p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.456789&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断。</p><p>还可以对<code>BigDecimal</code>做除法的同时求余数。</p><h4 id="比较BigDecimal"><a href="#比较BigDecimal" class="headerlink" title="比较BigDecimal"></a>比较BigDecimal</h4><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等。</p><p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数。</p><p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>object类中包含的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h3><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p><p>延伸：<br>关于Integer和int的比较<br>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = new Integer(100);</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">int j = 100；</span><br><span class="line">System.out.print(i == j); //true</span><br></pre></td></tr></table></figure><p>3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为 ①当变量值在-128<del>127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同；②当变量值不在-128</del>127之间时，非new生成Integer变量时，java API中最终会按照new Integer(i)进行处理（参考下面第4条），最终两个Interger的地址同样是不相同的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //true</span><br><span class="line">Integer i = 128;</span><br><span class="line">Integer j = 128;</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>对于第4条的原因：<br>java在编译Integer i &#x3D; 100 ;时，会翻译成为Integer i &#x3D; Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;= 127;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java对于-128到127之间的数，会进行缓存，Integer i &#x3D; 127时，会将127进行缓存，下次再写Integer j &#x3D; 127时，就会直接从缓存中取，就不会new了</p><p>如果有错误的地方，还请指正。</p><p>参考：<br><a href="http://blog.csdn.net/you23hai45/article/details/50734274">http://blog.csdn.net/you23hai45/article/details/50734274</a><br><a href="http://www.cnblogs.com/liuling/archive/2013/05/05/intAndInteger.html">http://www.cnblogs.com/liuling/archive/2013/05/05/intAndInteger.html</a></p><h3 id="Java-String、StringBuffer-和-StringBuilder-的区别"><a href="#Java-String、StringBuffer-和-StringBuilder-的区别" class="headerlink" title="Java String、StringBuffer 和 StringBuilder 的区别"></a>Java String、StringBuffer 和 StringBuilder 的区别</h3><h4 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h4><p><strong>String</strong>：字符串常量，字符串长度不可变。Java 中 String 是 immutable（不可变）的。</p><p>String 类的包含如下定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** The value is used for character storage. */</span><br><span class="line">private final char value[];</span><br><span class="line"></span><br><span class="line">/** The offset is the first index of the storage that is used. */</span><br><span class="line">private final int offset;</span><br><span class="line"></span><br><span class="line">/** The count is the number of characters in the String. */</span><br><span class="line">private final int count;</span><br></pre></td></tr></table></figure><p>用于存放字符的数组被声明为 final 的，因此只能赋值一次，不可再更改。</p><h4 id="StringBuffer（JDK1-0）"><a href="#StringBuffer（JDK1-0）" class="headerlink" title="StringBuffer（JDK1.0）"></a>StringBuffer（JDK1.0）</h4><p><strong>StringBuffer</strong>：字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用 StringBuffer，如果想转成 String 类型，可以调用 StringBuffer 的 toString() 方法。</p><p><strong>Java.lang.StringBuffer</strong> 线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。</p><p><strong>StringBuffer</strong> 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。</p><ul><li>append 方法始终将这些字符添加到缓冲区的末端；</li><li>insert 方法则在指定的点添加字符。</li></ul><p>例如，如果 <strong>z</strong> 引用一个当前内容是 <strong>start</strong> 的字符串缓冲区对象，则此方法调用 <strong>z.append(“le”)</strong> 会使字符串缓冲区包含 <strong>startle</strong> ，而 <strong>z.insert(4, “le”)</strong> 将更改字符串缓冲区，使之包含 <strong>starlet</strong> 。</p><h4 id="StringBuilder（JDK5-0）"><a href="#StringBuilder（JDK5-0）" class="headerlink" title="StringBuilder（JDK5.0）"></a>StringBuilder（JDK5.0）</h4><p><strong>StringBuilder</strong>：字符串变量（非线程安全）。在内部，StringBuilder 对象被当作是一个包含字符序列的变长数组。</p><p>java.lang.StringBuilder 是一个可变的字符序列，是 JDK5.0 新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。</p><p>其构造方法如下：</p><table><thead><tr><th>构造方法</th><th>描述</th></tr></thead><tbody><tr><td>StringBuilder()</td><td>创建一个容量为16的StringBuilder对象（16个空元素）</td></tr><tr><td>StringBuilder(CharSequence cs)</td><td>创建一个包含cs的StringBuilder对象，末尾附加16个空元素</td></tr><tr><td>StringBuilder(int initCapacity)</td><td>创建一个容量为initCapacity的StringBuilder对象</td></tr><tr><td>StringBuilder(String s)</td><td>创建一个包含s的StringBuilder对象，末尾附加16个空元素</td></tr></tbody></table><p>在大部分情况下，<strong>StringBuilder &gt; StringBuffer</strong>。这主要是由于前者不需要考虑线程安全。</p><h4 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h4><p>String 类型和 StringBuffer 的主要性能区别：String 是不可变的对象, 因此在每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，性能就会降低。</p><p>使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。</p><p>在某些特别情况下， String 对象的字符串拼接其实是被 Java Compiler 编译成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = “This is only a” + “ simple” + “ test”;</span><br><span class="line">StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);</span><br></pre></td></tr></table></figure><p>生成 String s1 对象的速度并不比 StringBuffer 慢。其实在 Java Compiler 里，自动做了如下转换：</p><p>Java Compiler直接把上述第一条语句编译为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = “This is only a simple test”;  </span><br></pre></td></tr></table></figure><p>所以速度很快。但要注意的是，如果拼接的字符串来自另外的 String 对象的话，Java Compiler 就不会自动转换了，速度也就没那么快了，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s2 = “This is only a”;  </span><br><span class="line">String s3 = “ simple”;  </span><br><span class="line">String s4 = “ test”;  </span><br><span class="line">String s1 = s2 + s3 + s4;  </span><br></pre></td></tr></table></figure><p>这时候，Java Compiler 会规规矩矩的按照原来的方式去做，String 的 concatenation（即+）操作利用了 StringBuilder（或StringBuffer）的append 方法实现，此时，对于上述情况，若 s2，s3，s4 采用 String 定义，拼接时需要额外创建一个 StringBuffer（或StringBuilder），之后将StringBuffer 转换为 String，若采用 StringBuffer（或StringBuilder），则不需额外创建 StringBuffer。</p><h4 id="使用策略"><a href="#使用策略" class="headerlink" title="使用策略"></a>使用策略</h4><ul><li><p>（1）基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。</p></li><li><p>（2）不要使用String类的”+”来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类，这在Java的优化上是一条比较重要的原则。例如：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String result = &quot;&quot;;</span><br><span class="line">for (String s : hugeArray) &#123;</span><br><span class="line">    result = result + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用StringBuilder</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">for (String s : hugeArray) &#123;</span><br><span class="line">    sb.append(s);</span><br><span class="line">&#125;</span><br><span class="line">String result = sb.toString();</span><br></pre></td></tr></table></figure><p>  当出现上面的情况时，显然我们要采用第二种方法，因为第一种方法，每次循环都会<strong>创建一个String result用于保存结果，除此之外二者基本相同（对于jdk1.5及之后版本）</strong>。</p></li><li><p>（3）为了获得更好的性能，在构造 StringBuffer 或 StringBuilder 时应尽可能指定它们的容量。当然，如果你操作的字符串长度（length）不超过 16 个字符就不用了，当不指定容量（capacity）时默认构造一个容量为16的对象。不指定容量会显著降低性能。</p></li><li><p>（4）StringBuilder 一般使用在方法内部来完成类似 <strong>+</strong> 功能，因为是线程不安全的，所以用完以后可以丢弃。StringBuffer 主要用在全局变量中。</p></li><li><p>（5）相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用 StringBuilder；否则还是用 StringBuffer。</p></li></ul><h3 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><p>求绝对值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.abs(-<span class="number">7.8</span>); <span class="comment">// 7.8</span></span><br></pre></td></tr></table></figure><p>取最大或最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure><p>计算xy次方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br></pre></td></tr></table></figure><p>计算√x：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br></pre></td></tr></table></figure><p>计算ex次方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.389...</span></span><br></pre></td></tr></table></figure><p>计算以e为底的对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br></pre></td></tr></table></figure><p>计算以10为底的对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.log10(<span class="number">100</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>三角函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br></pre></td></tr></table></figure><p>Math还提供了几个数学常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br></pre></td></tr></table></figure><p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure><h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure><p>有童鞋问，每次运行程序，生成的随机数都是不同的，没看出<em>伪随机数</em>的特性来。</p><p>这是因为我们创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p><p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列。</p><h4 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h4><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用<code>SecureRandom</code>来产生安全的随机数。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h2><p>因为Java的异常是<code>class</code>，它的继承关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br><span class="line">         └─────────────────────┘ └─────────────────────────┘</span><br></pre></td></tr></table></figure><p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><code>OutOfMemoryError</code>：内存耗尽</li><li><code>NoClassDefFoundError</code>：无法加载某个Class</li><li><code>StackOverflowError</code>：栈溢出</li></ul><p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p><ul><li><code>NumberFormatException</code>：数值类型的格式错误</li><li><code>FileNotFoundException</code>：未找到文件</li><li><code>SocketException</code>：读取网络失败</li></ul><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li><li><code>IndexOutOfBoundsException</code>：数组索引越界</li></ul><p><code>Exception</code>又分为两大类：</p><ol><li><code>RuntimeException</code>以及它的子类；</li><li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li></ol><p>Java规定：</p><ul><li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li><li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li></ul><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>在Java中，凡是可能抛出异常的语句，都可以用<code>try ... catch</code>捕获。把可能发生异常的语句放在<code>try &#123; ... &#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类。</p><p>可以使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后<em>不再</em>继续匹配。</p><p>存在多个<code>catch</code>的时候，<code>catch</code>的顺序非常重要：子类必须写在前面。</p><p>注意<code>finally</code>有几个特点：</p><ol><li><code>finally</code>语句不是必须的，可写可不写；</li><li><code>finally</code>总是最后执行。</li></ol><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>通常不要在<code>finally</code>中抛出异常。如果在<code>finally</code>中抛出异常，应该原始异常加入到原有异常中。调用方可通过<code>Throwable.getSuppressed()</code>获取所有添加的<code>Suppressed Exception</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Integer.parseInt(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            origin = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">            <span class="keyword">if</span> (origin != <span class="literal">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(origin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言（Assertion）是一种调试程序的方式。在Java中，使用<code>assert</code>关键字来实现断言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p><p><em>JVM默认关闭断言指令</em>，即遇到<code>assert</code>语句就自动忽略了，不执行。</p><p>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><p><code>class</code>（包括<code>interface</code>）的本质是数据类型（<code>Type</code>）。无继承关系的数据类型无法赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">123.456</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">123.456</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>而<code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p><p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。它长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure><p>这个<code>Class</code>实例是JVM内部创建的，如果我们查看JDK源码，可以发现<code>Class</code>类的构造方法是<code>private</code>，只有JVM能创建<code>Class</code>实例，我们自己的Java程序是无法创建<code>Class</code>实例的。</p><hr><p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p><p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p><p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p><p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure><p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。</p><p>注意一下<code>Class</code>实例比较和<code>instanceof</code>的差别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure><p>用<code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。</p><p>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p><p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) cls.newInstance();</span><br></pre></td></tr></table></figure><p>上述代码相当于<code>new String()</code>。通过<code>Class.newInstance()</code>可以创建类实例，它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用</p><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>Main.java</code>时，由于用到了<code>Main</code>，因此，JVM首先会把<code>Main.class</code>加载到内存。然而，并不会加载<code>Person.class</code>，除非程序执行到<code>create()</code>方法，JVM发现需要加载<code>Person</code>类时，才会首次加载<code>Person.class</code>。如果没有执行<code>create()</code>方法，那么<code>Person.class</code>根本就不会被加载。</p><h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><p>对任意的一个<code>Object</code>实例，只要我们获取了它的<code>Class</code>，就可以获取它的一切信息。</p><p>我们先看看如何通过<code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul><p>一个<code>Field</code>对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p>通过反射可以获取字段值和设置字段值。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>我们已经能通过<code>Class</code>实例获取所有<code>Field</code>对象，同样的，可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>一个<code>Method</code>对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><h3 id="调用方法-1"><a href="#调用方法-1" class="headerlink" title="调用方法"></a>调用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> (Integer) m.invoke(<span class="literal">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。</p><p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；(可能会设置失败)</p><h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = Person.class.newInstance();</span><br></pre></td></tr></table></figure><p>调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</p><p>为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Class实例获取Constructor的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>注意<code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><p>通过<code>Class</code>对象可以获取继承关系：</p><ul><li><code>Class getSuperclass()</code>：获取父类类型；</li><li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li></ul><p><strong>要特别注意：<code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型。</strong></p><p>此外，对所有<code>interface</code>的<code>Class</code>调用<code>getSuperclass()</code>返回的是<code>null</code>，获取接口的父接口要用<code>getInterfaces()</code>。</p><p>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</p><p>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>我们来比较Java的<code>class</code>和<code>interface</code>的区别：</p><ul><li>可以实例化<code>class</code>（非<code>abstract</code>）；</li><li>不能实例化<code>interface</code>。</li></ul><p>所有<code>interface</code>类型的变量总是通过向上转型并指向某个实例的。</p><p>Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p><p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例，转型为接口并调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式就是我们通常编写代码的方式。</p><p>还有一种方式是动态代码，我们仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建了一个<code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p><ol><li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li><li>通过<code>Proxy.newProxyInstance()</code>创建<code>interface</code>实例，它需要3个参数：<ol><li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li></ol></li><li>将返回的<code>Object</code>强制转型为接口。</li></ol><p>动态代理实际上是JDK在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="built_in">this</span>,</span><br><span class="line">           Hello.class.getMethod(<span class="string">&quot;morning&quot;</span>),</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是JDK帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p><p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p><p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p><p>Java的注解可以分为三类：</p><p>第一类是由编译器使用的注解，例如：</p><ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul><p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p><p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p><p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p><p>注解可以配置参数，没有指定配置的参数使用默认值；</p><h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul><p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p><ul><li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li><li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li></ul><p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解。</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>使用<code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。</p><p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Reports.class)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重复使用这个注解</span></span><br><span class="line"><span class="meta">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class="line"><span class="meta">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效。</p><p><em>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</em></p><h2 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h2><p>Java的注解本身对代码逻辑没有任何影响。根据<code>@Retention</code>的配置：</p><ul><li><code>SOURCE</code>类型的注解在编译期就被丢掉了；</li><li><code>CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li><li><code>RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li></ul><p>如何使用注解完全由工具决定。<code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p><p>因此，我们只讨论如何读取<code>RUNTIME</code>类型的注解。</p><p>因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p><h3 id="使用注解-1"><a href="#使用注解-1" class="headerlink" title="使用注解"></a>使用注解</h3><p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p><p>我们来看一个<code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在某个JavaBean中，我们可以使用该注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Range(min=1, max=20)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(max=10)</span></span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<em>定义了注解，本身对程序逻辑没有任何影响</em>。我们必须自己编写代码来使用注解。这里，我们编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException &#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们通过<code>@Range</code>注解，配合<code>check()</code>方法，就可以完成<code>Person</code>实例的检查。<em>注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</em></p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型就是定义一种模板，例如<code>ArrayList</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p><em>要特别注意：不能把<code>ArrayList</code>向上转型为<code>ArrayList</code>或<code>List</code>。</em></p><h2 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h2><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p><p>Java使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li><li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br></pre></td></tr></table></figure><p>而虚拟机执行的代码并没有泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> (String) p.getLast();</span><br></pre></td></tr></table></figure><p>所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p><p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code>int</code>；</li><li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair</code>；</li><li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li></ul><p>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</p><p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。</p><h2 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> add(p);</span><br><span class="line">    System.out.println(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> &#123; <span class="comment">// 设置extends通配符，Pari&lt;Integer&gt;类型可传入Pair&lt;Number&gt;</span></span><br><span class="line">    <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">    <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，给方法传入<code>Pair&lt;Integer&gt;</code>类型时，它符合参数<code>Pair&lt;? extends Number&gt;</code>类型。这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code>T</code>的上界限定在<code>Number</code>了。</p><p>除了可以传入<code>Pair&lt;Integer&gt;</code>类型，我们还可以传入<code>Pair&lt;Double&gt;</code>类型，<code>Pair&lt;BigDecimal&gt;</code>类型等等，因为<code>Double</code>和<code>BigDecimal</code>都是<code>Number</code>的子类。</p><p>使用类似<code>Pair&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li></ul><p>即一句话总结：使用<code>extends</code>通配符表示可以读，不能写。</p><p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p><ul><li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li></ul><h2 id="super通配符"><a href="#super通配符" class="headerlink" title="super通配符"></a>super通配符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Pair&lt;? <span class="built_in">super</span> Integer&gt; p, Integer first, Integer last)</span> &#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型。</p><p>使用<code>Pair&lt;? super Integer&gt;</code>通配符表示：</p><ul><li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li><li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li></ul><p>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</p><p>换句话说，使用<code> super</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p><h3 id="PESC原则"><a href="#PESC原则" class="headerlink" title="PESC原则"></a>PESC原则</h3><p>何时使用<code>extends</code>，何时使用<code>super</code>？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。</p><p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p><h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><p>我们已经讨论了<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code>?</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sample</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p><ul><li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li><li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li></ul><p>换句话说，既不能读，也不能写，那只能做一些<code>null</code>判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数情况下，可以引入泛型参数<code>&lt;T&gt;</code>消除<code>&lt;?&gt;</code>通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;T&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类。</p><h2 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h2><p>部分反射API是泛型，例如：<code>Class</code>，<code>Constructor</code>；</p><p>可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；</p><p>可以通过<code>Array.newInstance(Class, int)</code>创建<code>T[]</code>数组，需要强制转型；</p><p>同时使用泛型和可变参数时需要特别小心。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="Java集合简介"><a href="#Java集合简介" class="headerlink" title="Java集合简介"></a>Java集合简介</h2><p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。</p><p>Java标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是除<code>Map</code>外所有其他集合类的根接口。Java的<code>java.util</code>包主要提供了以下三种类型的集合：</p><ul><li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li><li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li><li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li></ul><div align="center"> <img src="https://raw.githubusercontent.com/wardseptember/notes/master/imgs/FgPceiQ8m6EUWxVQtN6Riy5-FSYo" width="600"> </div><br><p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p><ul><li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li><li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li><li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li></ul><p>还有一小部分接口是遗留接口，也不应该继续使用：</p><ul><li><code>Enumeration</code>：已被<code>Iterator</code>取代。</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="List和Array互转"><a href="#List和Array互转" class="headerlink" title="List和Array互转"></a>List和Array互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">      <span class="comment">//list转array</span></span><br><span class="line">        Number[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">Number</span>[list.size()]);</span><br><span class="line">      <span class="comment">//array转list</span></span><br><span class="line">      List&lt;Number&gt; list = List.of(array);</span><br><span class="line">        <span class="keyword">for</span> (Number n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap（基于jdk-1-8和jdk-1-7）"><a href="#HashMap（基于jdk-1-8和jdk-1-7）" class="headerlink" title="HashMap（基于jdk 1.8和jdk 1.7）"></a>HashMap（基于jdk 1.8和jdk 1.7）</h2><p>HashMap这个笔记有点多，我专门整理成一个专题，可以去看<a href="https://wardseptember.github.io/notes/#/docs/HashMap%E8%AF%A6%E8%A7%A3(1.7%E5%92%8C1.8)">hashmap详解专题</a></p><h1 id="Java多线程与高并发"><a href="#Java多线程与高并发" class="headerlink" title="Java多线程与高并发"></a>Java多线程与高并发</h1><p>详细内容见<a href="https://wardseptember.gitee.io/mynotes/#/docs/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91">多线程和高并发</a>。</p><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="IO简介"><a href="#IO简介" class="headerlink" title="IO简介"></a>IO简介</h2><p>IO是指Input&#x2F;Output，即输入和输出。以内存为中心：</p><ul><li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><h3 id="InputStream-OutputStream"><a href="#InputStream-OutputStream" class="headerlink" title="InputStream &#x2F; OutputStream"></a>InputStream &#x2F; OutputStream</h3><p>IO流以<code>byte</code>（字节）为最小单位，因此也称为<em>字节流</em>。</p><p>在Java中，<code>InputStream</code>代表输入字节流，<code>OuputStream</code>代表输出字节流，这是最基本的两种IO流。</p><h3 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader &#x2F; Writer"></a>Reader &#x2F; Writer</h3><p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照<code>char</code>来读写显然更方便，这种流称为<em>字符流</em>。</p><p>Java提供了<code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。</p><p>例如，我们把<code>char[]</code>数组<code>Hi你好</code>这4个字符用<code>Writer</code>字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符<code>H</code>和<code>i</code>各占一个字节，中文字符<code>你好</code>各占3个字节。</p><p>使用<code>Reader</code>，数据源虽然是字节，但我们读入的数据都是<code>char</code>类型的字符，原因是<code>Reader</code>内部把读入的<code>byte</code>做了解码，转换成了<code>char</code>。使用<code>InputStream</code>，我们读入的数据和原始二进制数据一模一样，是<code>byte[]</code>数组，但是我们可以自己把二进制<code>byte[]</code>数组按照某种编码转换为字符串。究竟使用<code>Reader</code>还是<code>InputStream</code>，要取决于具体的使用场景。如果数据源不是文本，就只能使用<code>InputStream</code>，如果数据源是文本，使用Reader更方便一些。<code>Writer</code>和<code>OutputStream</code>是类似的。</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p><p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p><p>Java标准库的包<code>java.io</code>提供了同步IO，而<code>java.nio</code>则是异步IO。上面我们讨论的<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>和<code>Writer</code>都是同步IO的抽象类，对应的具体实现类，以文件为例，有<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>和<code>FileWriter</code>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>IO流是一种流式的数据输入&#x2F;输出模型：</p><ul><li>二进制数据以<code>byte</code>为最小单位在<code>InputStream</code>&#x2F;<code>OutputStream</code>中单向流动；</li><li>字符数据以<code>char</code>为最小单位在<code>Reader</code>&#x2F;<code>Writer</code>中单向流动。</li></ul><p>Java标准库的<code>java.io</code>包提供了同步IO功能：</p><ul><li>字节流接口：<code>InputStream</code>&#x2F;<code>OutputStream</code>；</li><li>字符流接口：<code>Reader</code>&#x2F;<code>Writer</code>。</li></ul><h2 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h2><p>在计算机系统中，文件是非常重要的存储方式。Java的标准库<code>java.io</code>提供了<code>File</code>对象来操作文件和目录。</p><p><code>File</code>对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个<code>File</code>对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个<code>File</code>对象，并不会导致任何磁盘操作。只有当我们调用<code>File</code>对象的某些方法的时候，才真正进行磁盘操作。</p><p>Java标准库的<code>java.io.File</code>对象表示一个文件或者目录：</p><ul><li>创建<code>File</code>对象本身不涉及IO操作；</li><li>可以获取路径／绝对路径／规范路径：<code>getPath()</code>&#x2F;<code>getAbsolutePath()</code>&#x2F;<code>getCanonicalPath()</code>；</li><li>可以获取目录的文件和子目录：<code>list()</code>&#x2F;<code>listFiles()</code>；</li><li>可以创建或删除文件和目录。</li></ul><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p><code>InputStream</code>就是Java标准库提供的最基本的输入流。它位于<code>java.io</code>这个包里。<code>java.io</code>包提供了所有同步IO的功能。</p><p>要特别注意的一点是，<code>InputStream</code>并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是<code>int read()</code>，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>这个方法会读取输入流的下一个字节，并返回字节表示的<code>int</code>值（0~255）。如果已读到末尾，返回<code>-1</code>表示不能继续读取了。</p><p><code>FileInputStream</code>是<code>InputStream</code>的一个子类。顾名思义，<code>FileInputStream</code>就是从文件流中读取数据。下面的代码演示了如何完整地读取一个<code>FileInputStream</code>的所有字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputStream对象:</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// 打印byte的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    input.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。</p><p><code>InputStream</code>和<code>OutputStream</code>都是通过<code>close()</code>方法来关闭流。关闭流就会释放对应的底层资源。</p><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。<code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p><ul><li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li><li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li></ul><p>利用上述方法一次读取多个字节时，需要先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。如果返回<code>-1</code>，表示没有更多的数据了。</p><p>利用缓冲区一次读取多个字节的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void readFile() throws IOException &#123;</span><br><span class="line">    try (InputStream input = new FileInputStream(&quot;src/readme.txt&quot;)) &#123;</span><br><span class="line">        // 定义1000个字节大小的缓冲区:</span><br><span class="line">        byte[] buffer = new byte[1000];</span><br><span class="line">        int n;</span><br><span class="line">        while ((n = input.read(buffer)) != -1) &#123; // 读取到缓冲区</span><br><span class="line">            System.out.println(&quot;read &quot; + n + &quot; bytes.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n;</span><br><span class="line">n = input.read(); // 必须等待read()方法返回才能执行下一行代码</span><br><span class="line">int m = n;</span><br></pre></td></tr></table></figure><p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java标准库的<code>java.io.InputStream</code>定义了所有输入流的超类：</p><ul><li><code>FileInputStream</code>实现了文件流输入；</li><li><code>ByteArrayInputStream</code>在内存中模拟一个字节流输入。</li></ul><p>总是使用<code>try(resource)</code>来保证<code>InputStream</code>正确关闭。</p><h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>和<code>InputStream</code>相反，<code>OutputStream</code>是Java标准库提供的最基本的输出流。</p><p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>，签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是<code>int</code>参数，但只会写入一个字节，即只写入<code>int</code>最低8位表示字节的部分（相当于<code>b &amp; 0xff</code>）。</p><p>和<code>InputStream</code>类似，<code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p><p>为什么要有<code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以<code>OutputStream</code>有个<code>flush()</code>方法，能强制把缓冲区内容输出。</p><p>通常情况下，我们不需要调用这个<code>flush()</code>方法，因为缓冲区写满了<code>OutputStream</code>会自动调用它，并且，在调用<code>close()</code>方法关闭<code>OutputStream</code>之前，也会自动调用<code>flush()</code>方法。</p><p>但是，在某些情况下，我们必须手动调用<code>flush()</code>方法。举个栗子：</p><p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过<code>OutputStream</code>的<code>write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？</p><p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p><p>解决办法就是每输入一句话后，立刻调用<code>flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p><p>实际上，<code>InputStream</code>也有缓冲区。例如，从<code>FileInputStream</code>读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用<code>int read()</code>读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用<code>read()</code>，则会触发操作系统的下一次读取并再次填满缓冲区。</p><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>我们以<code>FileOutputStream</code>为例，演示如何将若干个字节写入文件流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="number">72</span>); <span class="comment">// H</span></span><br><span class="line">    output.write(<span class="number">101</span>); <span class="comment">// e</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">108</span>); <span class="comment">// l</span></span><br><span class="line">    output.write(<span class="number">111</span>); <span class="comment">// o</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用<code>OutputStream</code>提供的重载方法<code>void write(byte[])</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>);</span><br><span class="line">    output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>InputStream</code>一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用<code>try(resource)</code>来保证<code>OutputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞-1"><a href="#阻塞-1" class="headerlink" title="阻塞"></a>阻塞</h3><p>和<code>InputStream</code>一样，<code>OutputStream</code>的<code>write()</code>方法也是阻塞的。</p><h3 id="OutputStream实现类"><a href="#OutputStream实现类" class="headerlink" title="OutputStream实现类"></a>OutputStream实现类</h3><p>用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            output.write(<span class="string">&quot;Hello &quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            output.write(<span class="string">&quot;world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            data = output.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteArrayOutputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>OutputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>OutputStream</code>。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Java标准库的<code>java.io.OutputStream</code>定义了所有输出流的超类：</p><ul><li><code>FileOutputStream</code>实现了文件流输出；</li><li><code>ByteArrayOutputStream</code>在内存中模拟一个字节流输出。</li></ul><p>某些情况下需要手动调用<code>OutputStream</code>的<code>flush()</code>方法来强制输出缓冲区。</p><p>总是使用<code>try(resource)</code>来保证<code>OutputStream</code>正确关闭。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p><p>为什么要把Java对象序列化呢？因为序列化后可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p><p>有序列化，就有反序列化，即把一个二进制内容（也就是<code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code>byte[]</code>并把它“变回”Java对象。</p><p>我们来看看如何把一个Java对象序列化。</p><p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serializable</code>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p><h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p><p>因为写入<code>Object</code>时需要大量的类型信息，所以写入的内容很大。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(...)) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.readInt();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readUTF();</span><br><span class="line">    <span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了能读取基本类型和<code>String</code>类型外，调用<code>readObject()</code>可以直接返回一个<code>Object</code>对象。要把它变成一个特定类型，必须强制转型。</p><p><code>readObject()</code>可能抛出的异常有：</p><ul><li><code>ClassNotFoundException</code>：没有找到对应的Class；</li><li><code>InvalidClassException</code>：Class不匹配。</li></ul><p>对于<code>ClassNotFoundException</code>，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，<code>Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义<code>Person</code>类，所以无法反序列化。</p><p>对于<code>InvalidClassException</code>，这种情况常见于序列化的<code>Person</code>对象定义了一个<code>int</code>类型的<code>age</code>字段，但是反序列化时，<code>Person</code>类定义的<code>age</code>字段被改成了<code>long</code>类型，所以导致class不兼容。</p><p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2709425275741743919L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要特别注意反序列化的几个重要特点：</p><p>反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>因为Java的序列化机制可以导致一个实例能直接从<code>byte[]</code>数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的<code>byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p><p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>可序列化的Java对象必须实现<code>java.io.Serializable</code>接口，类似<code>Serializable</code>这样的空接口被称为“标记接口”（Marker Interface）；</p><p>反序列化时不调用构造方法，可设置<code>serialVersionUID</code>作为版本号（非必需）；</p><p>Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p><table><thead><tr><th align="left">InputStream</th><th align="left">Reader</th></tr></thead><tbody><tr><td align="left">字节流，以<code>byte</code>为单位</td><td align="left">字符流，以<code>char</code>为单位</td></tr><tr><td align="left">读取字节（-1，0~255）：<code>int read()</code></td><td align="left">读取字符（-1，0~65535）：<code>int read()</code></td></tr><tr><td align="left">读到字节数组：<code>int read(byte[] b)</code></td><td align="left">读到字符数组：<code>int read(char[] c)</code></td></tr></tbody></table><p><code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>这个方法读取字符流的下一个字符，并返回字符表示的<code>int</code>，范围是<code>0</code>~&#96;65535<code>。如果已读到末尾，返回</code>-1&#96;。</p><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p><code>FileReader</code>是<code>Reader</code>的一个子类，它可以打开文件并获取<code>Reader</code>。下面的代码演示了如何完整地读取一个<code>FileReader</code>的所有字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileReader对象:</span></span><br><span class="line">    <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>); <span class="comment">// 字符编码是???</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> reader.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((<span class="type">char</span>)n); <span class="comment">// 打印char</span></span><br><span class="line">    &#125;</span><br><span class="line">    reader.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为<code>FileReader</code>默认的编码与系统相关，例如，Windows系统的默认编码可能是<code>GBK</code>，打开一个<code>UTF-8</code>编码的文本文件就会出现乱码。</p><p>要避免乱码问题，我们需要在创建<code>FileReader</code>时指定编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p>和<code>InputStream</code>类似，<code>Reader</code>也是一种资源，需要保证出错的时候也能正确关闭，所以我们需要用<code>try (resource)</code>来保证<code>Reader</code>在无论有没有IO错误的时候都能够正确地关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Reader</code>还提供了一次性读取若干字符并填充到<code>char[]</code>数组的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] c)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure><p>它返回实际读入的字符个数，最大不超过<code>char[]</code>数组的长度。返回<code>-1</code>表示流结束。</p><p>利用这个方法，我们可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; chars.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h3><p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayReader</span>(<span class="string">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h3><p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p><code>Reader</code>和<code>InputStream</code>有什么关系？</p><p>除了特殊的<code>CharArrayReader</code>和<code>StringReader</code>，普通的<code>Reader</code>实际上是基于<code>InputStream</code>构造的，因为<code>Reader</code>需要从<code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为<code>char</code>就可以实现字符流。如果我们查看<code>FileReader</code>的源码，它在内部实际上持有一个<code>FileInputStream</code>。</p><p>既然<code>Reader</code>本质上是一个基于<code>InputStream</code>的<code>byte</code>到<code>char</code>的转换器，那么，如果我们已经有一个<code>InputStream</code>，想把它转换为<code>Reader</code>，是完全可行的。<code>InputStreamReader</code>就是这样一个转换器，它可以把任何<code>InputStream</code>转换为<code>Reader</code>。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>构造<code>InputStreamReader</code>时，我们需要传入<code>InputStream</code>，还需要指定编码，就可以得到一个<code>Reader</code>对象。上述代码可以通过<code>try (resource)</code>更简洁地改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实际上就是<code>FileReader</code>的一种实现方式。</p><p>使用<code>try (resource)</code>结构时，当我们关闭<code>Reader</code>时，它会在内部自动调用<code>InputStream</code>的<code>close()</code>方法，所以，只需要关闭最外层的<code>Reader</code>对象即可。</p><blockquote><p>使用InputStreamReader，可以把一个InputStream转换成一个Reader。</p></blockquote><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p><code>Reader</code>定义了所有字符输入流的超类：</p><ul><li><code>FileReader</code>实现了文件字符流输入，使用时需要指定编码；</li><li><code>CharArrayReader</code>和<code>StringReader</code>可以在内存中模拟一个字符流输入。</li></ul><p><code>Reader</code>是基于<code>InputStream</code>构造的：可以通过<code>InputStreamReader</code>在指定编码的同时将任何<code>InputStream</code>转换为<code>Reader</code>。</p><p>总是使用<code>try (resource)</code>保证<code>Reader</code>正确关闭。</p><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p><code>Reader</code>是带编码转换器的<code>InputStream</code>，它把<code>byte</code>转换为<code>char</code>，而<code>Writer</code>就是带编码转换器的<code>OutputStream</code>，它把<code>char</code>转换为<code>byte</code>并输出。</p><p><code>Writer</code>和<code>OutputStream</code>的区别如下：</p><table><thead><tr><th align="left">OutputStream</th><th align="left">Writer</th></tr></thead><tbody><tr><td align="left">字节流，以<code>byte</code>为单位</td><td align="left">字符流，以<code>char</code>为单位</td></tr><tr><td align="left">写入字节（0~255）：<code>void write(int b)</code></td><td align="left">写入字符（0~65535）：<code>void write(int c)</code></td></tr><tr><td align="left">写入字节数组：<code>void write(byte[] b)</code></td><td align="left">写入字符数组：<code>void write(char[] c)</code></td></tr><tr><td align="left">无对应方法</td><td align="left">写入String：<code>void write(String s)</code></td></tr></tbody></table><p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p><ul><li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li><li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li><li>写入String表示的所有字符：<code>void write(String s)</code>。</li></ul><h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">&#x27;H&#x27;</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">&quot;Hello&quot;</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CharArrayWriter"><a href="#CharArrayWriter" class="headerlink" title="CharArrayWriter"></a>CharArrayWriter</h3><p><code>CharArrayWriter</code>可以在内存中创建一个<code>Writer</code>，它的作用实际上是构造一个缓冲区，可以写入<code>char</code>，最后得到写入的<code>char[]</code>数组，这和<code>ByteArrayOutputStream</code>非常类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">CharArrayWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayWriter</span>()) &#123;</span><br><span class="line">    writer.write(<span class="number">65</span>);</span><br><span class="line">    writer.write(<span class="number">66</span>);</span><br><span class="line">    writer.write(<span class="number">67</span>);</span><br><span class="line">    <span class="type">char</span>[] data = writer.toCharArray(); <span class="comment">// &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringWriter"><a href="#StringWriter" class="headerlink" title="StringWriter"></a>StringWriter</h3><p><code>StringWriter</code>也是一个基于内存的<code>Writer</code>，它和<code>CharArrayWriter</code>类似。实际上，<code>StringWriter</code>在内部维护了一个<code>StringBuffer</code>，并对外提供了<code>Writer</code>接口。</p><h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p>除了<code>CharArrayWriter</code>和<code>StringWriter</code>外，普通的Writer实际上是基于<code>OutputStream</code>构造的，它接收<code>char</code>，然后在内部自动转换成一个或多个<code>byte</code>，并写入<code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的<code>OutputStream</code>转换为<code>Writer</code>的转换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实际上就是<code>FileWriter</code>的一种实现方式。这和上一节的<code>InputStreamReader</code>是一样的。</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p><code>Writer</code>定义了所有字符输出流的超类：</p><ul><li><code>FileWriter</code>实现了文件字符流输出；</li><li><code>CharArrayWriter</code>和<code>StringWriter</code>在内存中模拟一个字符流输出。</li></ul><p>使用<code>try (resource)</code>保证<code>Writer</code>正确关闭。</p><p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码。</p><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>从Java 7开始，提供了<code>Files</code>和<code>Paths</code>这两个工具类，能极大地方便我们读写文件。</p><p>虽然<code>Files</code>和<code>Paths</code>是<code>java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个<code>byte[]</code>，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = Files.readAllBytes(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>如果是文本文件，可以把一个文件的全部内容读取为<code>String</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用UTF-8编码读取:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content1</span> <span class="operator">=</span> Files.readString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 可指定编码:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content2</span> <span class="operator">=</span> Files.readString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行读取并返回每行内容:</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p>写入文件也非常方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入二进制文件:</span></span><br><span class="line"><span class="type">byte</span>[] data = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), data);</span><br><span class="line"><span class="comment">// 写入文本并指定编码:</span></span><br><span class="line">Files.writeString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), <span class="string">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行写入文本:</span></span><br><span class="line">List&lt;String&gt; lines = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), lines);</span><br></pre></td></tr></table></figure><p>此外，<code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p><p>最后需要特别注意的是，<code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>对于简单的小文件读写操作，可以使用<code>Files</code>工具类简化代码。</p><h1 id="加密与安全"><a href="#加密与安全" class="headerlink" title="加密与安全"></a>加密与安全</h1><p>在计算机系统中，什么是加密与安全呢？</p><p>我们举个栗子：假设Bob要给Alice发一封邮件，在邮件传送的过程中，黑客可能会窃取到邮件的内容，所以需要防窃听。黑客还可能会篡改邮件的内容，Alice必须有能力识别出邮件有没有被篡改。最后，黑客可能假冒Bob给Alice发邮件，Alice必须有能力识别出伪造的邮件。</p><p>所以，应对潜在的安全威胁，需要做到三防：</p><ul><li>防窃听</li><li>防篡改</li><li>防伪造</li></ul><h1 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h1><p>详细设计模式见<a href="https://wardseptember.gitee.io/mynotes/#/docs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">Notes</a></p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><blockquote><p><em>定义一个用于创建对象的接口，让子类决定实例化哪一个类。</em></p></blockquote><p>工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。</p><p>实际更常用的是更简单的静态工厂方法，它允许工厂内部对创建产品进行优化。</p><p>调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><blockquote><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></blockquote><p>原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。</p><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote><p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态方法返回实例:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><blockquote><p>动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。</p></blockquote><p>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。</p><p>我们还是举个栗子：假设我们需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。</p><p>顶层接口TextNode，写一个它的实现类SpanNode，实现TextNode的一个抽象类NodeDecorator，并在抽象类中定义一个TextNode字段，再去实现这个NodeDecorator类，就是装饰者模式。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。</p><p>使用Proxy模式要求调用方持有接口，作为Proxy的类也必须实现相同的接口类型。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式是为了允许调用方选择一个算法，从而通过不同策略实现不同的计算结果。</p><p>通过扩展策略，不必修改主逻辑，即可获得新策略的结果。</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote><p>模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Java基础篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Java基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合常用方法</title>
      <link href="/2024/04/04/Java/java%E9%9B%86%E5%90%88/"/>
      <url>/2024/04/04/Java/java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="java-数组，集合，字符串中常用的方法"><a href="#java-数组，集合，字符串中常用的方法" class="headerlink" title="java 数组，集合，字符串中常用的方法"></a>java 数组，集合，字符串中常用的方法</h1><h4 id="数组Arrays-类"><a href="#数组Arrays-类" class="headerlink" title="数组Arrays 类"></a>数组Arrays 类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">Arrays.toString() <span class="comment">//输出数组的内容</span></span><br><span class="line"></span><br><span class="line">Arrays.sort()<span class="comment">//快速排序</span></span><br><span class="line"></span><br><span class="line">Arrays.equals()<span class="comment">//逐个比较数组元素是否相等</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch( c数组,key定值)   <span class="comment">//在数组中寻找定值，返回此值的下标</span></span><br><span class="line"></span><br><span class="line">Arrays.copyOf() <span class="comment">//拷贝数组</span></span><br><span class="line"></span><br><span class="line">Arrays.copyOfRange(arr,from A，to B)  <span class="comment">//拷贝AB 之间的数组的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符串String类"><a href="#字符串String类" class="headerlink" title="字符串String类"></a>字符串String类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">()</span>;<span class="comment">//提取字符串中指定位置的值</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">toCharArray</span><span class="params">()</span>;<span class="comment">//将字符串转变为字符数组</span></span><br><span class="line">String <span class="title function_">trim</span><span class="params">()</span>; <span class="comment">//返回字符串，忽略前导空白和尾部空白</span></span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span>;</span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmptyt</span><span class="params">()</span>;<span class="comment">//判断是否为空字符串</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String s)</span>; <span class="comment">//忽略大小比较字符串的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String s)</span>; <span class="comment">//比较两个字符串的大小，相等0，不相等-1</span></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>; <span class="comment">//返回新字符串，从指定位置开始截取到最有一个位置</span></span><br><span class="line">String <span class="title function_">subString</span><span class="params">(<span class="type">int</span> begin ,<span class="type">int</span> end)</span>;<span class="comment">//截取左闭右开的字符串</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String str)</span>;<span class="comment">// str.contains(str1);str中是否包含str1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span> <span class="comment">//返回字符串在此字符串中第一次出现的索引，没有返回-1</span></span><br><span class="line">    indexOf(String str,<span class="type">int</span> index);<span class="comment">//index之后开始索引查找</span></span><br><span class="line">String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar,newChar)</span>;<span class="comment">//替换字符串</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String str)</span>;<span class="comment">//匹配是否符合正则表达式</span></span><br><span class="line">String [] split(<span class="string">&quot;字符&quot;</span>);<span class="comment">//根据给定的正则表达式拆分字符串，形成一个新的String数组</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer</span><br><span class="line">线程安全： StringBuffer 是线程安全的，因此适用于多线程环境，可以确保在并发操作时不会出现数据不一致的问题。</span><br><span class="line">同步方法： StringBuffer 的方法都是同步的，这会带来一些性能上的损失。因此，当需要在线程安全的环境中进行字符串操作时，使用 StringBuffer 是合适的选择。</span><br><span class="line"></span><br><span class="line">StringBuilder JDK1<span class="number">.5</span>版本之后引入的</span><br><span class="line">非线程安全： StringBuilder 不是线程安全的，因此在单线程环境中使用更为高效。</span><br><span class="line"></span><br><span class="line">性能优势： 由于不需要考虑线程安全性，StringBuilder 在性能上通常比 StringBuffer 更优秀。在单线程环境中进行大量字符串操作时，使用 StringBuilder 可以提高效率。</span><br><span class="line"></span><br><span class="line">选择场景：</span><br><span class="line">多线程环境： 如果在多线程环境中需要进行字符串操作，选择 StringBuffer。</span><br><span class="line">单线程环境： 如果在单线程环境中进行字符串操作，选择 StringBuilder 可以获得更好的性能。</span><br></pre></td></tr></table></figure><h4 id="StringBuilder的常用方法"><a href="#StringBuilder的常用方法" class="headerlink" title="StringBuilder的常用方法"></a>StringBuilder的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">                                      (<span class="type">int</span> capacity);</span><br><span class="line">  (空参构造器)<span class="comment">//默认初始为16个字符</span></span><br><span class="line">str.append(String str);<span class="comment">//添加各种数据</span></span><br><span class="line">str.delete(<span class="type">int</span> start,<span class="type">int</span> end);<span class="comment">//删除指定位置的内容</span></span><br><span class="line">deletecharAt(<span class="type">int</span> index);<span class="comment">//删除指定索引位置上的元素</span></span><br><span class="line">str.replace(<span class="type">int</span> start,<span class="type">int</span> end,String str);<span class="comment">//指定位置替换</span></span><br><span class="line">str.insert(<span class="type">int</span> start,String s);<span class="comment">//指定位置插入</span></span><br><span class="line">str.reverse();<span class="comment">//当前字符翻转</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span> <span class="comment">//str在字符串中首次出现的位置</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> ch)</span> <span class="comment">//将指定位置的字符换为新的</span></span><br></pre></td></tr></table></figure><h4 id="集合框架：collection接口继承树"><a href="#集合框架：collection接口继承树" class="headerlink" title="集合框架：collection接口继承树"></a>集合框架：collection接口继承树</h4><p>集合框架：</p><p>Collection接口：单列集合，用来存储一个一个的对象</p><p>list接口：存储有序的，可以重复的数据 –&gt;”动态数组”</p><p>​ArrayList: list的主要实现类，线程不安全。底层使用object[]数组存储</p><p>​LinkedList:底层使用双向链表存储。对于频繁的插入和删除操作，效率高</p><p>​Vector：古老实现类，线程安全，效率低</p><p>set接口：无序的，不可重复的数据  –&gt;高中数学中的集合</p><p>​       </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      无序性，不等于随机性，存储数据根据数据计算哈希值，根据哈希值存储</span><br><span class="line"></span><br><span class="line">​不可重复性：靠存储的元素类型是否重写hashcode()和equals()方法实现的，比较过程：存储元素会使用hash()算法生成一个int类型的hashcode散列值，然后与以存储的元素的hashcode比较，如果不一致则是新的对象，如果一致的话，再调用equals()方法，比较两个对象的内容是否相等，这样就确保了存储的唯一性。</span><br></pre></td></tr></table></figure><p>​HashSet：set接口的主要实现类，线程不安全，可以存储null值，底层使用哈希表</p><p>​LinkedHashSet：HashSet的子类，可以按照添加的顺序遍历，底层使用哈希表和链表，频繁遍历效率高</p><p>​TreeSet：底层二叉树红黑树，可以按照添加的对象的指定属性，排序，所以只能添加同类的对象 </p><pre><code>        TreeSet底层数据结构采用二叉树来实现，元素唯一且已经排好序；唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性。根据构造方法不同，分为自然排序（无参构造）和比较器排序（有参构造），自然排序要求元素必须实现Compareable接口，并重写里面的compareTo()方法，元素通过比较返回的int值来判断排序序列，返回0说明两个对象相同，不需要存储；比较器排需要在TreeSet初始化是时候传入一个实现Comparator接口的比较器对象，或者采用匿名内部类的方式new一个Comparator对象，重写里面的compare()方法；</code></pre><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240109193220620.png" alt="image-20240109193220620"></p><p>Map接口：双列集合，用来存储一对（key,value）的数据  ，底层数组+链表+红黑树</p><p>​HashMap：主要实现类。线程不安全，效率高，可以存储null，</p><p>​LinkedHashMap：底层链表，保证在遍历元素时候，可以按照添加的顺序遍历，频繁的遍历效率高</p><p>​WeakHashMap： </p><p>​Hashtable：古老实现类。线程安全，效率低，不能存储null</p><pre><code>               properties:常用来处理配置文件，key-value都是String类型的</code></pre><p>​TreeMap：底层红黑树，保证添加的key进行排序（key必须是同一类对象）实现排序遍历</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240109152948047.png" alt="image-20240109152948047" style="zoom: 50%;"><p>map中的key：无序的，不可重复的，使用set存储所有的key</p><p>​               value：无序的，可重复的</p><p><strong>map的底层实现原理：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JDK8之后map底层是  数组+链表+红黑树</span><br><span class="line">当首次执行执行插入操作map.put(key,value)后，底层创建一个长度为16的数组</span><br><span class="line">key相当于set不可重复，调用key1类所在的hashcode()计算哈希值，不一样，根据hash值计算出存储在数组中的位置，</span><br><span class="line">若存放位置为空的话，则添加成功</span><br><span class="line">若存放位置的数据不为空，(说明此位置已经有一个或者多个数据了，以链表的形式存在)，比较key1和已有元素的hash值，如果都不相同，则添加成功，</span><br><span class="line">如果相同，则继续比较key1类所在的equals()方法，判断是否为相同的元素，</span><br><span class="line">如果不相同，则直接添加</span><br><span class="line">如果相同，则使用新的的value值，替换之前的value值</span><br><span class="line"></span><br><span class="line">当使用hashcode()计算出的数组的一个索引位置上的元素以链表的形式存在的结构个数&gt;8，并且当前数组的长度大于16的时候，此时将此索引位置上所有的数据改为使用红黑树存储，为了提高查找的效率</span><br><span class="line"></span><br><span class="line">再不断的添加数据的过程中，会涉及到底层数组扩容的问题</span><br><span class="line"></span><br><span class="line">HashMap 的底层数组在什么时候扩容，是由负载因子（Load Factor）和阈值（Threshold）决定的。负载因子是一个表示哈希表满程度的值，而阈值则是根据负载因子和数组长度计算得出的阈值。当哈希表中的元素个数超过阈值时，数组会进行扩容操作。默认扩容为原来的2倍</span><br><span class="line"></span><br><span class="line">具体来说，扩容的触发条件是：元素个数超过阈值。而阈值的计算方式为：threshold=capacity×loadFactor</span><br><span class="line">其中：</span><br><span class="line">capacity 是哈希表数组的容量（数组的长度）。</span><br><span class="line">loadFactor 是负载因子，默认为 0.75。</span><br><span class="line">当哈希表中的元素个数达到阈值时，就会触发数组的扩容。扩容的具体过程包括：</span><br><span class="line"></span><br><span class="line">创建新数组： 创建一个新的数组，其容量是原数组的两倍。</span><br><span class="line">重新哈希： 将原数组中的所有元素重新计算哈希码，并放入新数组中。由于数组容量变化，哈希码的计算可能会得到不同的索引位置。</span><br><span class="line">替换原数组： 将新数组替换为原数组。</span><br></pre></td></tr></table></figure><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240109213415336.png" alt="image-20240109213415336" style="zoom:50%;"><p><strong>map的主要方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>:</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> <span class="comment">//查询map中是否包含指定的key，如果包含则返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span><span class="comment">//查询map中是否包含指定的value，如果包含返回true</span></span><br><span class="line"></span><br><span class="line">Object <span class="title function_">get</span><span class="params">(Object key)</span><span class="comment">//返回指定可以对应的value。如果map中不包含key则返回null</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">//顾名思义，空返回true</span></span><br><span class="line">Object <span class="title function_">put</span><span class="params">(key,value)</span>;<span class="comment">//添加一个键值对，如果已经有则覆盖原有的键值对</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">()</span>;<span class="comment">//将指定map的键值复制到对应的map中去</span></span><br><span class="line">Object <span class="title function_">remove</span><span class="params">(key)</span>;<span class="comment">//删除指定key对应的键值对，返回相关联的value，若key不存在，则返回null</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;<span class="comment">//返回map中键值对的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getOrDefault</span><span class="params">(key, defaultValue)</span><span class="comment">//获取指定key对应对value,如果找不到key，则返回设置的默认值</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//原视图操作法</span></span><br><span class="line">Set <span class="title function_">entrySet</span><span class="params">()</span><span class="comment">//返回map中包含的所有key-value对应的set集合</span></span><br><span class="line">Set <span class="title function_">keySet</span><span class="params">()</span><span class="comment">//返回map中所有的key组成的set集合</span></span><br><span class="line">Collection <span class="title function_">values</span><span class="params">()</span>;<span class="comment">//返回map里所有的value组成的Collection</span></span><br></pre></td></tr></table></figure><h4 id="HashMap中按照key和value排序的两种方法"><a href="#HashMap中按照key和value排序的两种方法" class="headerlink" title="HashMap中按照key和value排序的两种方法"></a>HashMap中按照key和value排序的两种方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.对key值进行排序</span></span><br><span class="line"><span class="comment">HashMap的存储是没有顺序的，而是按照key值的hashcode()实现的，</span></span><br><span class="line"><span class="comment">所以对key值排序，首先要得到HashMap中的所有key组成的集合，使用keyset()方法，并且转换为数组，这样才能用Arrays.sort()进行排序，*/</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keyset();</span><br><span class="line">Object[] arr = set.toArray();</span><br><span class="line"><span class="keyword">for</span>(Object key :arr)&#123;</span><br><span class="line">map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*2.对value值进行排序</span></span><br><span class="line"><span class="comment">对value进行排序，首先要得到HashMap中的包含映射关系的视图entrySet</span></span><br><span class="line"><span class="comment">将entrySet转为List，然后重写比较器即可，</span></span><br><span class="line"><span class="comment">可以使用List.sort(comparator);</span></span><br><span class="line"><span class="comment">Collections.sort(comparator);*/</span></span><br><span class="line"></span><br><span class="line">List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(map.entrySet()); <span class="comment">//转换为list</span></span><br><span class="line"><span class="comment">//Map.Entry表示java中操作键值对的接口，Map 接口的实现类（如 HashMap）的 entrySet() 方法返回一个包含 Map.Entry 对象的集合，这样可以遍历并操作键值对。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//List&lt;Map.Entry&lt;String, Integer&gt;&gt; entryList 表示一个包含键值对的列表，其中键是 String 类型，值是 Integer 类型。这个列表被用来对键值对进行排序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用list排序;</span></span><br><span class="line">       list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Collections.sort()进行排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240105161818539.png" alt="image-20240105161818539" style="zoom:50%;"><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240420230623402.png" alt="image-20240420230623402"></p><h4 id="集合和数组"><a href="#集合和数组" class="headerlink" title="集合和数组"></a>集合和数组</h4><p>长度区别：数组固定，集合长度可变</p><p>内容区别：数组可以是基本的数据类型，也可以是引用的数据类型</p><p>​集合只能是引用类型</p><p>元素内容：数组只能存储同一种类型</p><p>​集合可以存储不同类型的（一般也是同一种类型的）</p><h4 id="collection集合的方法："><a href="#collection集合的方法：" class="headerlink" title="collection集合的方法："></a>collection集合的方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;<span class="comment">//在集合末尾添加元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;<span class="comment">//删除与o值相等的元素，并且返回</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;<span class="comment">//清除完集合中的所有元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(O o)</span>;<span class="comment">//判断集合中是否包含元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;<span class="comment">//判断集合是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;<span class="comment">//返回集合中的元素个数</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection c)</span>;<span class="comment">//将c中的所有元素添加到另一个集</span></span><br><span class="line">Object[] toArray();<span class="comment">//返回包含本集合中所有元素的数组，集合--&gt;数组</span></span><br><span class="line">Iterator <span class="title function_">iterator</span><span class="params">()</span>;<span class="comment">//迭代器，集合的专用遍历方式</span></span><br><span class="line">iterator.next(),iterator.hasnext()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">collection和collections的区别</span><br><span class="line">collection是所有集合的接口，list，set，map</span><br><span class="line">collections是操作集合的工具类;</span><br><span class="line"></span><br><span class="line">collections的常用方法,都是静态方法，<span class="keyword">static</span>，直接调用它</span><br><span class="line">Collections.reverse(list); <span class="comment">//反转集合中的元素</span></span><br><span class="line">shuffle(list);<span class="comment">//对集合的元素进行随机排序</span></span><br><span class="line">sort();<span class="comment">//升序排序</span></span><br><span class="line">sort(list,comparator);<span class="comment">//指定comparator的产生顺序对集合list排序</span></span><br><span class="line">swap(list,<span class="type">int</span> i,<span class="type">int</span> j);<span class="comment">//指定集合中的i,j 处的元素进行交换</span></span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">frequency(Collection，Object o);<span class="comment">//集合中指定元素出现的个数</span></span><br><span class="line">copy(list dest,list,src);<span class="comment">//将 src的内容复制到desc中</span></span><br><span class="line">replaceAll(list，old，<span class="keyword">new</span>);<span class="comment">//将list中的所有旧值改为新的值</span></span><br><span class="line">Collections提供了多个synchronizedXxx()方法，解决ArrayList，Hashmap等线程安全的问题 </span><br></pre></td></tr></table></figure><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240106164926820.png" alt="image-20240106164926820"></p><p>总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">增：add(Object)</span><br><span class="line"></span><br><span class="line">删：remove(<span class="type">int</span> index)/remove(Object obj)</span><br><span class="line"></span><br><span class="line">改：set(<span class="type">int</span> index,Object o)</span><br><span class="line"></span><br><span class="line">查：get(<span class="type">int</span> index)</span><br><span class="line"></span><br><span class="line">长度：size()</span><br><span class="line"></span><br><span class="line">遍历：foreach 迭代器Iterator()</span><br><span class="line"></span><br><span class="line">集合--&gt;数组：toArray()</span><br><span class="line">数组--&gt;集合：Arrays.asList();</span><br></pre></td></tr></table></figure><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>java与C、C++的异同</p><p>1.相同，java和C++都是面向对象的语言，封装，继承，多态</p><p>封装：就是将对象的属性和状态封装在一个类中，并且提供公共的public来get，set此属性的值。好处是，高内聚，低耦合，隐藏对象内部的复杂性，只对外公开简单的接口，供外界调用</p><p>继承：extends，子类可以继承父类的属性和方法，不修改父类的情况下添加自己的新成员方法，子类成员通过super关键字调用父类的构造方法和成员。</p><p>多态性质：同一操作对不同的对象，有不同的解释，就是多态性（父类的引用指向子类的对象）</p><p>通过方法重写override或者方法重载</p><p>2.不同之处：</p><p>java是解释性的语言，运行过程为：java编译后生成字节码文件，然后在java虚拟机JVM中解释运行，</p><p>C++编译型语言，编译后直接生成二进制的字节码文件，所以C++运行速度快，但是java可以移植</p><p>java中没有指针，提供了数组和集合这样的类和方法去操作，使得程序更加安全</p><p>java中没法实现多重继承，只能实现多个接口来达到与C++中多重继承的作用</p><p>C++中，经常需要去malloc去分配和释放内存，java中有垃圾回收机制，会自动释放内存</p><p>C++支持运算符的重载，java不支持</p><p>C++更接近底层，允许更多的底层控制，java隐藏了更多的底层细节，提供了丰富的库和内置功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">集合collection中存储的如果是自定义的对象，需要重写哪儿些方法</span><br><span class="line">list：equals()方法判断对象的属性是否相等</span><br><span class="line">hashset：重写equals()和hashcode()方法，为什么要重写hashcode，这与hashset的比较过程是有关系的，存储对象会采用hash算法生成一个int类型的哈希值，如果hash值不一样判断不是相同的元素，再存储，如果hash值一样，就调用equals 方法判断，所以不去重写的话，会调用父类的hash算法，这样相同的元素就会被判断为不同的hash值，就违背了set表不能有重复元素的定义</span><br><span class="line">treeset：底层二叉树，元素唯一且已经排好序，因为需要排序，所以就需要在compare方法里定义比较对象的属性，进行排序。重写compareTo()，compare()</span><br></pre></td></tr></table></figure><p><strong>线程安全和线程不安全</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程安全就是：多线程访问时候，提供一种加锁的机制，当其中一个线程访问的时候，其他的线程不能进行访问，从而达到保护数据的目的，对java中的synchronized关键字</span><br><span class="line">线程不安全：不加锁，有可能出现多个线程先后更爱数据得到的是错误数据</span><br><span class="line">例如：1000张票，A和B同时买票，如果线程不安全，会出现同时执行1000-1 的操作，导致最后剩下999张票，而不是998张</span><br></pre></td></tr></table></figure><p>例题：理解hashset的底层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        hashSet.add(p1);</span><br><span class="line">        hashSet.add(p2);</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        p1.age = <span class="number">3</span>;</span><br><span class="line">        hashSet.remove(p1);</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>,<span class="number">1</span>));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person类重写了hashcode和equals方法</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">1</span>&#125;, Person&#123;name=<span class="string">&#x27;B&#x27;</span>, age=<span class="number">2</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">3</span>&#125;, Person&#123;name=<span class="string">&#x27;B&#x27;</span>, age=<span class="number">2</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">3</span>&#125;, Person&#123;name=<span class="string">&#x27;B&#x27;</span>, age=<span class="number">2</span>&#125;, Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">3</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">3</span>&#125;, Person&#123;name=<span class="string">&#x27;B&#x27;</span>, age=<span class="number">2</span>&#125;, Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">1</span>&#125;, Person&#123;name=<span class="string">&#x27;A&#x27;</span>, age=<span class="number">3</span>&#125;]</span><br><span class="line">    </span><br><span class="line">解析：先往set添加了两个元素，所以输出两个</span><br><span class="line">   <span class="comment">// 修改了p1的age，移除了p1，在set中remove，还是要先计算hash值，因为修改了p1=Person(&quot;A&quot;, 3)，所以哈希值变了，但是原来在底层的还是Person(&quot;A&quot;, 1)，所以remove找不到，没有删除，输出仍为两个，再添加Person(&quot;A&quot;,3)，重新计算hash值，可以添加成功，最后添加new Person(&quot;A&quot;,1)，与之前的hash值相等，所以再调用equals判断是否为同一个对象，很明显不是同一个对象，所以也可以添加成功</span></span><br><span class="line">    <span class="comment">//总结：尽量不要再set中修改属性，很麻烦，直接删了重新添加</span></span><br></pre></td></tr></table></figure><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">push(value)<span class="comment">//将给定的值，压入栈的顶端，入站</span></span><br><span class="line">pop()<span class="comment">//删除并且返回栈顶的值，出栈</span></span><br><span class="line">peek()<span class="comment">//返回栈顶的值，但并不删除</span></span><br><span class="line">isEmpty()<span class="comment">//</span></span><br><span class="line">size()<span class="comment">//长度</span></span><br><span class="line">search(Object o)<span class="comment">//返回对象在栈中的位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，</span></span><br><span class="line"><span class="comment">//LinkedList实现了Queue接口，因此我们可以把LinkedList当成Queue队列来用</span></span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//add()和remove()，方法在失败的时候会抛出异常（不推荐使用）</span></span><br><span class="line"></span><br><span class="line">add(E e)：将元素 e 插入到队列末尾，如果插入成功，则返回 <span class="literal">true</span>；如果插入失败（即队列已满），则会抛出异常；</span><br><span class="line"></span><br><span class="line">remove()：移除队首元素，若移除成功，则返回 <span class="literal">true</span>；如果移除失败（队列为空），则会抛出异常；</span><br><span class="line"></span><br><span class="line">remove(Object o)：移除指定的元素，若移除成功，则返回 <span class="literal">true</span>；如果移除失败（队列为空），则会抛出异常</span><br><span class="line"></span><br><span class="line">offer(E e)：将元素 e 插入到队列末尾，如果插入成功，则返回 <span class="literal">true</span>；如果插入失败（即队列已满），则返回 <span class="literal">false</span>；</span><br><span class="line"></span><br><span class="line">poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回 <span class="literal">null</span>；</span><br><span class="line"></span><br><span class="line">peek()：获取队首元素，若成功，则返回队首元素；否则返回 <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">isEmpty</span><span class="params">()</span>：队列是否为空</span><br><span class="line"></span><br><span class="line">size()：队列长度</span><br><span class="line"></span><br><span class="line">对于非阻塞队列，一般情况下建议使用 offer、poll 和 peek 三个方法，不建议使用 add 和 remove 方法。因为使用 offer、poll 和 peek 三个方法可以通过返回值判断操作成功与否，而使用 add 和 remove 方法却不能达到这样的效果。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Collections </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Takeaways</title>
      <link href="/2024/04/03/Project/takeaways/"/>
      <url>/2024/04/03/Project/takeaways/</url>
      
        <content type="html"><![CDATA[<h1 id="苍穹外卖"><a href="#苍穹外卖" class="headerlink" title="苍穹外卖"></a>苍穹外卖</h1><h2 id="1-软件开发流程"><a href="#1-软件开发流程" class="headerlink" title="1.软件开发流程"></a>1.软件开发流程</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/leecode/image-20240403233526824.png" alt="image-20240403233526824"></p><h3 id="1-1完成需求规格说明书、产品原型编写。"><a href="#1-1完成需求规格说明书、产品原型编写。" class="headerlink" title="1.1完成需求规格说明书、产品原型编写。"></a>1.1完成需求规格说明书、产品原型编写。</h3><p>需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目的各个组成部分，如：系统定义、应用环境、功能规格、性能需求等，都会在文档中描述。</p><h3 id="1-2设计"><a href="#1-2设计" class="headerlink" title="1.2设计"></a>1.2设计</h3><p>设计的内容包含 UI设计、数据库设计、接口设计。</p><p><strong>UI设计</strong>：用户界面的设计，主要设计项目的页面效果，小到一个按钮，大到一个页面布局，还有人机交互逻辑的体现。</p><p><strong>数据库设计</strong>：需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段。</p><p>即是画出ER图，实体关系图</p><p>ER图（实体-关系图）是数据库设计中常用的一种图形化工具，用于描述数据库中实体（Entity）之间的关系（Relationship）和属性（Attribute）。它是一种概念模型，用于可视化数据库结构，帮助设计者理清数据模型的结构和关系，从而更好地设计数据库。</p><p>以下是 ER 图中常见的几个要素：</p><ol><li><p><strong>实体（Entity）</strong>：表示数据库中存储的现实世界中的一个事物，可以是一个对象、一个概念或者一个事件。每个实体通常有属性，用来描述实体的特征。</p></li><li><p><strong>属性（Attribute）</strong>：实体的特征或者属性，用于描述实体的性质或特征，例如一个人实体可以有姓名、年龄等属性。</p></li><li><p><strong>关系（Relationship）</strong>：表示实体之间的关联或联系，描述实体之间的联系方式和约束条件。关系可以是一对一、一对多或者多对多的。</p></li><li><p><strong>主键（Primary Key）</strong>：实体中的一个属性或属性组合，能够唯一标识实体的属性。在 ER 图中通常用下划线或者加粗表示。</p></li><li><p><strong>外键（Foreign Key）</strong>：表示一个实体中的属性，引用了另一个实体的主键，用来建立实体之间的关联关系。</p></li></ol><p>ER 图通过图形化的方式展现了数据库中实体之间的关系，有助于开发人员、数据库管理员和用户理解数据库的结构和设计。在数据库设计阶段，ER 图是一个重要的工具，可以用来进行概念建模、需求分析、设计评审和沟通交流。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/leecode/image-20240403234404661.png" alt="image-20240403234404661"></p><p><strong>接口设计</strong>：通过分析原型图，首先，粗分析每个页面有多少个接口，然后，再细分析，每个接口的传入参数，返回值参数，同时明确接口的路径以及请求方式</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/leecode/image-20240403234624591.png" alt="image-20240403234624591" style="zoom: 67%;"><h3 id="1-3编码"><a href="#1-3编码" class="headerlink" title="1.3编码"></a>1.3编码</h3><p>编写项目代码、并完成单元测试。</p><p>项目代码编写：作为软件开发工程师，我们需要对项目的模块功能分析后，进行编码实现。</p><p>单元测试：编码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。</p><h3 id="1-4测试"><a href="#1-4测试" class="headerlink" title="1.4测试"></a>1.4测试</h3><p>在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。</p><h3 id="1-5上线运维"><a href="#1-5上线运维" class="headerlink" title="1.5上线运维"></a>1.5上线运维</h3><p>在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发好的项目，部署在服务器上运行。</p><h2 id="2-角色分工"><a href="#2-角色分工" class="headerlink" title="2.角色分工"></a>2.角色分工</h2><table><thead><tr><th align="left">岗位&#x2F;角色</th><th>对应阶段</th><th align="left">职责&#x2F;分工</th></tr></thead><tbody><tr><td align="left">项目经理</td><td>全阶段</td><td align="left">对整个项目负责，任务分配、把控进度</td></tr><tr><td align="left">产品经理</td><td>需求分析</td><td align="left">进行需求调研，输出需求调研文档、产品原型等</td></tr><tr><td align="left">UI设计师</td><td>设计</td><td align="left">根据产品原型输出界面效果图</td></tr><tr><td align="left">架构师</td><td>设计</td><td align="left">项目整体架构设计、技术选型等</td></tr><tr><td align="left"><font color="red">开发工程师</font></td><td><font color="red">编码</font></td><td align="left"><font color="red">功能代码实现</font></td></tr><tr><td align="left">测试工程师</td><td>测试</td><td align="left">编写测试用例，输出测试报告</td></tr><tr><td align="left">运维工程师</td><td>上线运维</td><td align="left">软件环境搭建、项目上线</td></tr></tbody></table><h3 id="2-1项目介绍"><a href="#2-1项目介绍" class="headerlink" title="2.1项目介绍"></a>2.1项目介绍</h3><p><strong>1). 管理端功能</strong></p><p>员工登录&#x2F;退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管理 ，数据统计，来单提醒。</p><p><strong>2). 用户端功能</strong></p><p> 微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能 , 下单 , 支付、分类及菜品浏览。</p><p><strong>1). 管理端</strong></p><p>餐饮企业内部员工使用。 主要功能有: </p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>登录&#x2F;退出</td><td>内部员工必须登录后,才可以访问系统管理后台</td></tr><tr><td>员工管理</td><td>管理员可以在系统后台对员工信息进行管理，包含查询、新增、编辑、禁用等功能</td></tr><tr><td>分类管理</td><td>主要对当前餐厅经营的 菜品分类 或 套餐分类 进行管理维护， 包含查询、新增、修改、删除等功能</td></tr><tr><td>菜品管理</td><td>主要维护各个分类下的菜品信息，包含查询、新增、修改、删除、启售、停售等功能</td></tr><tr><td>套餐管理</td><td>主要维护当前餐厅中的套餐信息，包含查询、新增、修改、删除、启售、停售等功能</td></tr><tr><td>订单管理</td><td>主要维护用户在移动端下的订单信息，包含查询、取消、派送、完成，以及订单报表下载等功能</td></tr><tr><td>数据统计</td><td>主要完成对餐厅的各类数据统计，如营业额、用户数量、订单等</td></tr></tbody></table><p><strong>2). 用户端</strong></p><p>移动端应用主要提供给消费者使用。主要功能有:</p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>登录&#x2F;退出</td><td>用户需要通过微信授权后登录使用小程序进行点餐</td></tr><tr><td>点餐-菜单</td><td>在点餐界面需要展示出菜品分类&#x2F;套餐分类, 并根据当前选择的分类加载其中的菜品信息, 供用户查询选择</td></tr><tr><td>点餐-购物车</td><td>用户选中的菜品就会加入用户的购物车, 主要包含 查询购物车、加入购物车、删除购物车、清空购物车等功能</td></tr><tr><td>订单支付</td><td>用户选完菜品&#x2F;套餐后, 可以对购物车菜品进行结算支付, 这时就需要进行订单的支付</td></tr><tr><td>个人信息</td><td>在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址, 也可以查询历史订单数据</td></tr></tbody></table><h3 id="2-3-技术选型"><a href="#2-3-技术选型" class="headerlink" title="2.3 技术选型"></a>2.3 技术选型</h3><p>关于本项目的技术选型, 我们将会从 用户层、网关层、应用层、数据层 这几个方面进行介绍，主要用于展示项目中使用到的技术框架和中间件等。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/leecode/image-20240403235057323.png" alt="image-20240403235057323"></p><p><strong>1). 用户层</strong></p><p>本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI、apache echarts(展示图表)等技术。而在构建移动端应用时，我们会使用到微信小程序。</p><p><strong>2). 网关层</strong></p><p>Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通过Nginx来实现。</p><p><strong>3). 应用层</strong></p><p>SpringBoot： 快速构建Spring项目, 采用 “约定优于配置” 的思想, 简化Spring项目的配置开发。</p><p>SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合，可以无缝集成。</p><p>Spring Task:  由Spring提供的定时任务框架。</p><p>httpclient:  主要实现了对http请求的发送。</p><p>Spring Cache:  由Spring提供的数据缓存框架</p><p>JWT:  用于对应用程序上的用户进行身份验证的标记。</p><p>阿里云OSS:  对象存储服务，在项目中主要存储文件，如图片等。</p><p>Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。</p><p>POI:  封装了对Excel表格的常用操作。</p><p>WebSocket: 一种通信网络协议，使客户端和服务器之间的数据交换更加简单，用于项目的来单、催单功能实现。</p><p><strong>4). 数据层</strong></p><p>MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。</p><p>Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存。</p><p>Mybatis： 本项目持久层将会使用Mybatis开发。</p><p>pagehelper:  分页插件。</p><p>spring data redis:  简化java代码操作Redis的API。</p><p><strong>5). 工具</strong></p><p>git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。</p><p>maven: 项目构建工具。</p><p>junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。</p><p>postman:  接口测工具，模拟用户发起的各类HTTP请求，获取对应的响应结果。</p><h3 id="2-4-nginx"><a href="#2-4-nginx" class="headerlink" title="2.4 nginx"></a>2.4 nginx</h3><p>对登录功能测试完毕后，接下来，我们思考一个问题：<strong>前端发送的请求，是如何请求到后端服务的？</strong></p><p>前端请求地址：<a href="http://localhost/api/employee/login">http://localhost/api/employee/login</a></p><p>后端接口地址：<a href="http://localhost:8080/admin/employee/login">http://localhost:8080/admin/employee/login</a></p><p><strong>nginx反向代理</strong>：就是将前端发送的动态请求由nginx转发到后端服务器</p><p><strong>nginx 反向代理的好处：</strong></p><ul><li><p>提高访问速度</p><p>因为nginx本身可以进行缓存，如果访问的同一接口，并且做了数据缓存，nginx就直接可把数据返回，不需要真正地访问服务端，从而提高访问速度。</p></li><li><p>进行负载均衡</p><p>所谓负载均衡,就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器。</p></li><li><p>保证后端服务安全</p><p>因为一般后台服务地址不会暴露，所以使用浏览器不能直接访问，可以把nginx作为请求访问的入口，请求到达nginx后转发到具体的服务中，从而保证后端服务的安全。</p></li></ul><p><strong>nginx 反向代理的配置方式：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> /api/&#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080/admin/; <span class="comment">#反向代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>proxy_pass：</strong>该指令是用来设置代理服务器的地址，可以是主机名称，IP地址加端口号等形式。</p><p>如上代码的含义是：监听80端口号， 然后当我们访问 <a href="http://localhost/..%E8%BF%99%E6%A0%B7%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%AE%83%E4%BC%9A%E9%80%9A%E8%BF%87">http://localhost:80/api/../..这样的接口的时候，它会通过</a> location &#x2F;api&#x2F; {} 这样的反向代理到 <a href="http://localhost:8080/admin/%E4%B8%8A%E6%9D%A5%E3%80%82">http://localhost:8080/admin/上来。</a></p><p>接下来，进到nginx-1.20.2\conf，打开nginx配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 反向代理,处理管理端发送的请求</span></span><br><span class="line"><span class="section">location</span> /api/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span>   http://localhost:8080/admin/;</span><br><span class="line">    <span class="comment">#proxy_pass   http://webservers/admin/;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在访问<a href="http://localhost/api/employee/login%EF%BC%8Cnginx%E6%8E%A5%E6%94%B6%E5%88%B0%E8%AF%B7%E6%B1%82%E5%90%8E%E8%BD%AC%E5%88%B0http://localhost:8080/admin/%EF%BC%8C%E6%95%85%E6%9C%80%E7%BB%88%E7%9A%84%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80%E4%B8%BAhttp://localhost:8080/admin/employee/login%EF%BC%8C%E5%92%8C%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%9C%B0%E5%9D%80%E4%B8%80%E8%87%B4%E3%80%82">http://localhost/api/employee/login，nginx接收到请求后转到http://localhost:8080/admin/，故最终的请求地址为http://localhost:8080/admin/employee/login，和后台服务的访问地址一致。</a></p><p><strong>2). nginx 负载均衡</strong></p><p>当如果服务以集群的方式进行部署时，那nginx在转发请求到服务器时就需要做相应的负载均衡。其实，负载均衡从本质上来说也是基于反向代理来实现的，最终都是转发请求。</p><p><strong>nginx 负载均衡的配置方式：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> webservers&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.100.128:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.100.129:8080</span>;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> /api/&#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://webservers/admin;<span class="comment">#负载均衡</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>upstream：</strong>如果代理服务器是一组服务器的话，我们可以使用upstream指令配置后端服务器组。</p><p>如上代码的含义是：监听80端口号， 然后当我们访问 <a href="http://localhost/..%E8%BF%99%E6%A0%B7%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%AE%83%E4%BC%9A%E9%80%9A%E8%BF%87">http://localhost:80/api/../..这样的接口的时候，它会通过</a> location &#x2F;api&#x2F; {} 这样的反向代理到 <a href="http://webservers/admin%EF%BC%8C%E6%A0%B9%E6%8D%AEwebservers%E5%90%8D%E7%A7%B0%E6%89%BE%E5%88%B0%E4%B8%80%E7%BB%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%AE%BE%E7%BD%AE%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5(%E9%BB%98%E8%AE%A4%E6%98%AF%E8%BD%AE%E8%AF%A2)%E8%BD%AC%E5%8F%91%E5%88%B0%E5%85%B7%E4%BD%93%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82">http://webservers/admin，根据webservers名称找到一组服务器，根据设置的负载均衡策略(默认是轮询)转发到具体的服务器。</a></p><p><strong>注：</strong>upstream后面的名称可自定义，但要上下保持一致。</p><p><strong>nginx 负载均衡策略：</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>轮询</td><td>默认方式</td></tr><tr><td>weight</td><td>权重方式，默认为1，权重越高，被分配的客户端请求就越多</td></tr><tr><td>ip_hash</td><td>依据ip分配方式，这样每个访客可以固定访问一个后端服务</td></tr><tr><td>least_conn</td><td>依据最少连接方式，把请求优先分配给连接数少的后端服务</td></tr><tr><td>url_hash</td><td>依据url分配方式，这样相同的url会被分配到同一个后端服务</td></tr><tr><td>fair</td><td>依据响应时间方式，响应时间短的服务将会被优先分配</td></tr></tbody></table><p>具体配置方式：</p><h3 id="2-5登陆加密MD5"><a href="#2-5登陆加密MD5" class="headerlink" title="2.5登陆加密MD5"></a>2.5登陆加密MD5</h3><p>调用spring框架的DigestUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password = DigestUtils.md5DigestAsHex(password.getBytes());</span><br></pre></td></tr></table></figure><h2 id="3-导入接口文档"><a href="#3-导入接口文档" class="headerlink" title="3.导入接口文档"></a>3.导入接口文档</h2><p>在真实的企业开发中，接口设计过程其实是一个非常漫长的过程，可能需要多次开会讨论调整，甚至在开发的过程中才会发现某些接口定义还需要再调整，这种情况其实是非常常见的</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405030836477.png" alt="image-20240405030836477"></p><p>第一步：定义接口，确定接口的路径、请求方式、传入参数、返回参数。</p><p>第二步：前端开发人员和后端开发人员并行开发，同时，也可自测。</p><p>第三步：前后端人员进行连调测试。</p><p>第四步：提交给测试人员进行最终测试。</p><h2 id="4-Swagger"><a href="#4-Swagger" class="headerlink" title="4.  Swagger"></a>4.  Swagger</h2><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<a href="https://swagger.io/">https://swagger.io/</a>)。 它的主要作用是：</p><ol><li><p>使得前后端分离开发更加方便，有利于团队协作</p></li><li><p>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p></li><li><p>功能测试 </p><p>Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。</p></li></ol><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名knife4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!</p><p>目前，一般都使用knife4j框架。</p><p>项目启动后的访问地址：<a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p><p>访问界面如下：</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405045847411.png" alt="image-20240405045847411"><h3 id="4-1使用步骤"><a href="#4-1使用步骤" class="headerlink" title="4.1使用步骤"></a>4.1使用步骤</h3><p>新版型详情参见：</p><p><a href="https://zhuanlan.zhihu.com/p/657916069">SpringBoot从入门到精通（二十一）SpringBoot3 集成Swagger3 - 知乎 (zhihu.com)</a></p><ol><li><p>导入 knife4j 的maven坐标</p><p>在pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我自己是springboot3.1.4，老版本不适配了，搞了我好久</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi3-jakarta-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在配置类中加入 knife4j 相关配置</p><p>新版本是</p><p>WebMvcConfiguration.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过knife4j生成接口文档</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApiInfo</span> <span class="variable">apiInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Docket</span> <span class="variable">docket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.sky.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>新版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.ExternalDocumentation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.OpenAPI;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAPIConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">openAPI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">                .info(<span class="keyword">new</span> <span class="title class_">Info</span>()</span><br><span class="line">                        .title(<span class="string">&quot;测试 title&quot;</span>)</span><br><span class="line">                        .description(<span class="string">&quot;SpringBoot3 集成 Swagger3&quot;</span>)</span><br><span class="line">                        .version(<span class="string">&quot;v1&quot;</span>))</span><br><span class="line">                .externalDocs(<span class="keyword">new</span> <span class="title class_">ExternalDocumentation</span>()</span><br><span class="line">                        .description(<span class="string">&quot;项目API文档&quot;</span>)</span><br><span class="line">                        .url(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置静态资源映射，否则接口文档页面无法访问</p><p>WebMvcConfiguration.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置静态资源映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/doc.html&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问测试</p><p>接口文档访问路径为 <a href="http://ip:port/doc.html">http://ip:port/doc.html</a> —&gt; <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p></li></ol><h3 id="4-2常用注解"><a href="#4-2常用注解" class="headerlink" title="4.2常用注解"></a>4.2常用注解</h3><p>通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下：</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@Api</td><td>用在类上，例如Controller，表示对类的说明</td></tr><tr><td>@ApiModel</td><td>用在类上，例如entity、DTO、VO</td></tr><tr><td>@ApiModelProperty</td><td>用在属性上，描述属性信息</td></tr><tr><td>@ApiOperation</td><td>用在方法上，例如Controller的方法，说明方法的用途、作用</td></tr></tbody></table><p>接下来，使用上述注解，生成可读性更好的接口文档</p><p>默认是可以不配置任何注解的，不过增加一些注解可以使swagger可读性更加好。</p><table><thead><tr><th>注解SpringBoot3 版本</th><th>替换旧注解 SpringBoot2 版本</th><th>描述</th></tr></thead><tbody><tr><td>@Tag</td><td>@Api</td><td>用于标注一个Controller（Class）。 在默认情况下，Swagger-Core只会扫描解析具有@Api注解的类，而会自动忽略其他类别资源（JAX-RS endpoints，Servlets等等）的注解。</td></tr><tr><td>@Operation</td><td>@ApiOperation</td><td>用于对一个操作或HTTP方法进行描述。 具有相同路径的不同操作会被归组为同一个操作对象。 不同的HTTP请求方法及路径组合构成一个唯一操作。</td></tr><tr><td>@Parameter</td><td>@ApiParam</td><td>@Parameter作用于请求方法上，定义api参数的注解。</td></tr><tr><td>@Parameters、 @Parameter</td><td>@ApiImplicitParams、@ApiImplicitParam</td><td>都可以定义参数 （1）@Parameters：用在请求的方法上，包含一组参数说明 （2）@Parameter：对单个参数的说明</td></tr><tr><td>io.swagger.v3.oas.annotations新包中的@ApiResponses、@ApiResponse</td><td>旧包io.swagger.annotations中的@ApiResponses、@ApiResponse</td><td>进行方法返回对象的说明。</td></tr><tr><td>@Schema</td><td>@ApiModel、@ApiModelProperty</td><td>@Schema用于描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景）。</td></tr></tbody></table><p>新增SwaggerController.java，配置具体Swagger常用注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.annotations.media.Schema;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema(description= &quot;学生信息&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerApiModel</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;主键ID&quot;, required = true, example = &quot;1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;手机号&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String phonenum;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;密码&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;年龄&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><p>这里就不大段复制代码了，写一下大概得流程和自己的理解吧，主要之前在Web里面也实现过，看一看实现的区别吧</p><h2 id="1-项目框架描述"><a href="#1-项目框架描述" class="headerlink" title="1.项目框架描述"></a>1.项目框架描述</h2><p>主体sky-take-out由三个模块实现</p><p><strong>common</strong> 、<strong>pojo</strong>、 <strong>server</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405050734981.png" alt="image-20240405050734981"></p><h3 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h3><ul><li><p>constant：一些常量类</p></li><li><p>context：存储的通常是与上下文（Context）相关的类和接口，可能包括与线程上下文、应用程序上下文等相关的功能和工具类。</p></li><li><p>enumeration:一般用于存储枚举（Enumeration）相关的类。枚举是一种特殊的数据类型，用于表示一组有限的可能取值。在 Java 中，枚举通常用于表示一组相关的常量或选项，它们在逻辑上是有序的，并且具有固定数量的取值。</p></li><li><p>exception：处理各种异常的类</p></li><li><p>json:将Java对象转换为JSON格式的数据的类</p></li><li><p>properties：阿里云OSS，JWT，WeChat等的配置类</p></li><li><p>result：最后封装相应的结果类</p></li><li><p>utils：阿里云OSS，JWT，WeChat，Http等的工具类</p></li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405051146796.png" alt="image-20240405051146796"></p><h3 id="Pojo"><a href="#Pojo" class="headerlink" title="Pojo"></a>Pojo</h3><ul><li>dto：前端接口响应数据的封装类，只有实体类的部分数据（前端给后端响应的）</li><li>entity：顾名思义，存放实体类，（与数据库对应的）</li><li>vo：前端需要哪儿些内容，实体类对应不上，新建一个vo类去封装（后端给前端响应的）</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405052718857.png" alt="image-20240405052718857"></p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>在一个典型的Java Web应用中，这些包的作用和存放的类通常如下：</p><ol><li><p><strong>config 包</strong>：存放配置类，用于配置应用程序的各种组件，例如数据库连接、缓存配置、安全配置等。这些配置类通常使用注解 <code>@Configuration</code> 标记，并且可能包含 <code>@Bean</code> 方法用于定义和初始化各种Bean。</p></li><li><p><strong>controller 包</strong>：存放控制器类，用于处理HTTP请求和响应。控制器类通常使用注解 <code>@Controller</code> 或 <code>@RestController</code> 标记，其中 <code>@RestController</code> 通常用于RESTful风格的控制器。控制器类中的方法通常使用 <code>@RequestMapping</code> 或其他注解映射到特定的HTTP请求路径，并返回响应给客户端。</p></li><li><p><strong>handler 包</strong>：存放异常处理类，用于处理应用程序中的异常情况。异常处理类通常使用 <code>@ControllerAdvice</code> 或 <code>@ExceptionHandler</code> 注解标记，用于捕获和处理全局异常或特定类型的异常。</p></li><li><p><strong>interceptor 包</strong>：存放拦截器类，用于拦截和处理HTTP请求和响应。拦截器类通常实现 <code>HandlerInterceptor</code> 接口，并且可以在请求处理之前、之后或完成之后执行特定的逻辑，例如身份验证、日志记录等。</p></li><li><p><strong>mapper 包</strong>：存放数据访问层（DAO）的接口或类，用于定义数据访问的接口和方法。通常与MyBatis或其他持久化框架结合使用，用于执行数据库操作和管理持久化对象。</p></li><li><p><strong>service 包</strong>：存放服务层（Service）的类，用于实现应用程序的业务逻辑。服务类通常包含业务逻辑的实现方法，并且可能依赖于DAO（数据访问对象）进行数据访问和持久化操作。服务类通常使用注解 <code>@Service</code> 标记，以便Spring框架能够自动扫描和管理。</p></li></ol><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405053253815.png" alt="image-20240405053253815"></p><h2 id="2-新增员工"><a href="#2-新增员工" class="headerlink" title="2.新增员工"></a>2.新增员工</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405045516830.png" alt="image-20240405045516830"></p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405141719655.png" alt="image-20240405141719655" style="zoom:67%;"><p>新增员工对应的实体类</p><p>因为我们员工类定义的属性比较多</p><p>但是在添加员工的过程中，又不需要那么多的属性</p><p>所以根据新增员工接口设计对应的DTO类</p><p>当然也可以用我们的<strong>实体类</strong>去封装前端提交的数据</p><p><strong>注意：当前端提交的数据和实体类中对应的属性差别比较大时，建议使用DTO来封装数据</strong>**</p><p>然后就是常规三段式：</p><p>controller层接受前端请求，调用service层的save方法，在service层接口定义save方法，并且在serviceiml实现类中实现save方法</p><p><strong>注意</strong>：因为接受的是dto，要在save中补全，再调用mapper层insert插入</p><p>在mapper层，用@Insert或者MybatisPlus直接插入数据库中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(EmployeeDTO employeeDTO)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象属性拷贝</span></span><br><span class="line">        BeanUtils.copyProperties(employeeDTO, employee);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置账号的状态，默认正常状态 1表示正常 0表示锁定</span></span><br><span class="line">        employee.setStatus(StatusConstant.ENABLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置密码，默认密码123456</span></span><br><span class="line">        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置当前记录的创建时间和修改时间</span></span><br><span class="line">        employee.setCreateTime(LocalDateTime.now());</span><br><span class="line">        employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置当前记录创建人id和修改人id</span></span><br><span class="line">        employee.setCreateUser(<span class="number">10L</span>);<span class="comment">//目前写个假数据，后期修改</span></span><br><span class="line">        employee.setUpdateUser(<span class="number">10L</span>);</span><br><span class="line"></span><br><span class="line">        employeeMapper.insert(employee);<span class="comment">//后续步骤定义</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>问题1：若录入用户名已经存在，该如何处理异常？</strong></p><p><strong>解决</strong>：通过全局异常处理器来处理</p><p>进入到sky-server模块，com.sky.hander包下，GlobalExceptionHandler.java添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理SQL异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">exceptionHandler</span><span class="params">(SQLIntegrityConstraintViolationException ex)</span>&#123;</span><br><span class="line">    <span class="comment">//Duplicate entry &#x27;zhangsan&#x27; for key &#x27;employee.idx_username&#x27;</span></span><br><span class="line">    <span class="comment">//这是SQL字段重复报出来的异常</span></span><br><span class="line">    <span class="comment">//先将捕获异常的字符串封装</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">    <span class="comment">//如果字符串包含Duplicate entry，则说明是这个重复问题</span></span><br><span class="line">    <span class="keyword">if</span>(message.contains(<span class="string">&quot;Duplicate entry&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//按照空格对字符串分割</span></span><br><span class="line">        String[] split = message.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> split[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//将姓名取出拼接给前端响应</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> username + MessageConstant.ALREADY_EXISTS;</span><br><span class="line">        <span class="keyword">return</span> Result.error(msg);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//返回不知道异常</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(MessageConstant.UNKNOWN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题2：</strong>新增员工时，如何获取创建人和修改人的ID？</p><p><strong>解决1</strong>：直接注入HTTP对象，拿到Token去解析（web方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//为什么可以自动注入，可以理解为spring自动交给IOC容器管理了</span></span><br><span class="line">    <span class="meta">@Autowired()</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取操作人id，从JWT令牌中获取（如何获取操作令牌呢？注入HTTP request对象）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.parseJWT(jwt);</span><br><span class="line"> <span class="comment">//Integer operateUser = Integer.parseInt(claims.getId());</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">operateUser</span> <span class="operator">=</span> (Integer) claims.get(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>解决2：</strong>在拦截器中，根据请求头Token携带的JWT令牌，用JWT工具类反向解析出用户ID，解析出ID后，如何传递给service层的save方法呢？</p><p><strong>通过ThreadLocal进行传递。</strong></p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>介绍：</p><p>ThreadLocal不是一个Thread，而是Thread的局部变量</p><p>ThreadLocal为每一个线程单独提供一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的数值，线程外则不能访问</p><p><strong>常用方法：</strong></p><ul><li>public void set(T value) 设置当前线程的线程局部变量的值</li><li>public T get() 返回当前线程所对应的线程局部变量的值</li><li>public void remove()        移除当前线程的线程局部变量</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405061903284.png" alt="image-20240405061903284"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/////将用户id存储到ThreadLocal////////</span></span><br><span class="line">        BaseContext.setCurrentId(empId);</span><br><span class="line"><span class="comment">//在service层中取出线程局部变量中的值</span></span><br><span class="line">employee.setCreateUser(BaseContext.getCurrentId());</span><br></pre></td></tr></table></figure><p>在拦截器中，将解析出来的ID放入线程中</p><p>在service层中取出线程局部变量中的值</p><h2 id="3-员工分页查询"><a href="#3-员工分页查询" class="headerlink" title="3.员工分页查询"></a>3.员工分页查询</h2><p><strong>业务规则</strong>：</p><ul><li>根据页码展示员工信息</li><li>每页展示10条数据</li><li>分页查询时可以根据需要，输入员工姓名进行查询</li></ul><p>分页查询页面中，前端传递三个参数，name，page，pageSize</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405140926346.png" alt="image-20240405140926346"></p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405142152293.png" alt="image-20240405142152293" style="zoom:67%;"><p>使用泛型参数<T>可以在编译的时候，进行类型检查，从而在编译阶段发现类型错误，而使用object类型不提供编译时的检查，所以在运行的时候会可能会发生类型转换异常的错误</T></p><p>实现思路：dto类封装请求参数</p><p>对所有的分页查询对象，都统一定义封装为PageResult对象</p><p>再封装到Result<PageResult>返回前端</PageResult></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> total; <span class="comment">//总记录数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List records; <span class="comment">//当前页数据集合</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>controller层</strong>： 调用service层的方法返回pageResult对象，再封装到Result中返回</p><p><strong>service层：</strong>调用分页查询的插件方法，PageHelper.startPage(页码，分页数)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">pageQuery</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// select * from employee limit 0,10</span></span><br><span class="line">    <span class="comment">//开始分页查询</span></span><br><span class="line">    PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());</span><br><span class="line"></span><br><span class="line">    Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);<span class="comment">//后续定义</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();</span><br><span class="line">    List&lt;Employee&gt; records = page.getResult();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(total, records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再调用mapper层的方法返回page<Employee> page类型的变量（分页查询依赖提供）</Employee></p><p><strong>mapper</strong>：因为name参数不一定传进来，所以要在xml文件中写动态SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;pageQuery&quot; resultType<span class="operator">=</span>&quot;com.sky.entity.Employee&quot;<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee</span><br><span class="line">        <span class="operator">&lt;</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;name != null and name != &#x27;&#x27;&quot;<span class="operator">&gt;</span></span><br><span class="line">                <span class="keyword">and</span> name <span class="keyword">like</span> concat(<span class="string">&#x27;%&#x27;</span>,#&#123;name&#125;,<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">            <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">desc</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PageHelper"><a href="#PageHelper" class="headerlink" title="PageHelper"></a>PageHelper</h3><p> 是一个用于 MyBatis 的分页插件，它的执行逻辑如下：</p><ol><li><p><strong>拦截 SQL 语句</strong>：当调用 <code>PageHelper.startPage()</code> 方法设置分页参数后，PageHelper 会拦截后续执行的 SQL 语句。</p></li><li><p><strong>解析 SQL 语句</strong>：PageHelper 会解析被拦截的 SQL 语句，提取其中的查询语句和条件。</p></li><li><p><strong>生成分页 SQL</strong>：根据设置的分页参数，PageHelper 会根据原始的查询语句生成对应的分页 SQL，包括对应的 LIMIT 或者 ROW_NUMBER() 等语句，以实现数据库分页查询。</p></li><li><p><strong>执行分页查询</strong>：PageHelper 将修改后的分页 SQL 交给 MyBatis 执行，MyBatis 查询得到的结果已经被分页处理，只包含指定页码范围内的数据。</p></li><li><p><strong>封装查询结果</strong>：PageHelper 将查询结果封装成 Page 对象返回，该对象包含了分页信息和查询结果。</p></li></ol><p>总的来说，PageHelper 主要通过拦截 SQL 语句、解析并修改 SQL、执行分页查询，最终封装查询结果来实现分页功能。这样的设计可以使得分页查询逻辑与业务逻辑分离，提高了代码的可维护性和可扩展性。</p><h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>Spring MVC 的消息转换器（Message Converters）负责在 HTTP 请求和响应的过程中，将请求体和响应体的数据与 Java 对象之间进行相互转换。它们将来自客户端的请求数据转换为 Java 对象，以便在控制器中进行处理，并将处理结果转换为客户端可接受的格式返回。</p><p>消息转换器在 Spring MVC 中扮演着重要的角色，因为它们使得开发人员可以轻松地处理各种类型的数据，例如 JSON、XML、HTML、文本等。Spring MVC 框架提供了一组默认的消息转换器来处理常见的数据格式转换，例如：</p><ul><li><code>MappingJackson2HttpMessageConverter</code>：用于将 JSON 数据转换为 Java 对象，以及将 Java 对象转换为 JSON 数据。</li><li><code>StringHttpMessageConverter</code>：用于处理字符串数据的转换。</li><li><code>MarshallingHttpMessageConverter</code>：用于处理 XML 数据的转换。</li></ul><p>开发人员还可以根据需要自定义消息转换器，以支持其他数据格式的转换。通过扩展 <code>WebMvcConfigurer</code> 接口或重写 <code>WebMvcConfigurationSupport</code> 类中的 <code>extendMessageConverters</code> 方法，可以将自定义的消息转换器添加到 Spring MVC 中。</p><p><strong>问题</strong>：操作时间段显示有问题</p><p><strong>解决方式：</strong></p><p><strong>1).  方式一</strong></p><p>在属性上加上注解，对日期进行格式化</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20221112103501581.png" alt="image-20221112103501581" style="zoom:67%;"> <p>但这种方式，需要在每个时间属性上都要加上该注解，使用较麻烦，不能全局处理。</p><p><strong>2).  方式二（推荐 )</strong></p><p>在WebMvcConfiguration中扩展SpringMVC的消息转换器，统一对日期类型进行格式处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 扩展Spring MVC框架的消息转化器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">       log.info(<span class="string">&quot;扩展消息转换器...&quot;</span>);</span><br><span class="line">       <span class="comment">//创建一个消息转换器对象</span></span><br><span class="line">       <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">       <span class="comment">//需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据</span></span><br><span class="line">       converter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">       <span class="comment">//将自己的消息转化器加入容器中</span></span><br><span class="line">       converters.add(<span class="number">0</span>,converter);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>说实话，我看不懂这里的消息转换器的代码</p><h2 id="4-启用禁用员工的账号"><a href="#4-启用禁用员工的账号" class="headerlink" title="4.启用禁用员工的账号"></a>4.启用禁用员工的账号</h2><p><strong>业务规则：</strong></p><ul><li>可以对状态为“启用” 的员工账号进行“禁用”操作</li><li>可以对状态为“禁用”的员工账号进行“启用”操作</li><li>状态为“禁用”的员工账号不能登录系统</li></ul><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240405190442375.png" alt="image-20240405190442375" style="zoom:67%;"><p>controller层：路径参数用@PathVariable接收，查询参数query，用名字相同的参数封装</p><p>service层：创建对象，设置对象的ID，query</p><p>mapper层：本来是可以直接用注解写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Update</span></span><br><span class="line"><span class="keyword">update</span> employee <span class="keyword">set</span> statues <span class="operator">=</span> ?  <span class="keyword">where</span> id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>但是为了其他跟新的可以也直接调用这个方法，所以写动态SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> id<span class="operator">=</span>&quot;update&quot; parameterType<span class="operator">=</span>&quot;Employee&quot;<span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">update</span> employee</span><br><span class="line">        <span class="operator">&lt;</span><span class="keyword">set</span><span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;name != null&quot;<span class="operator">&gt;</span>name <span class="operator">=</span> #&#123;name&#125;,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;username != null&quot;<span class="operator">&gt;</span>username <span class="operator">=</span> #&#123;username&#125;,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;password != null&quot;<span class="operator">&gt;</span>password <span class="operator">=</span> #&#123;password&#125;,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;phone != null&quot;<span class="operator">&gt;</span>phone <span class="operator">=</span> #&#123;phone&#125;,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;sex != null&quot;<span class="operator">&gt;</span>sex <span class="operator">=</span> #&#123;sex&#125;,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;idNumber != null&quot;<span class="operator">&gt;</span>id_Number <span class="operator">=</span> #&#123;idNumber&#125;,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;updateTime != null&quot;<span class="operator">&gt;</span>update_Time <span class="operator">=</span> #&#123;updateTime&#125;,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;updateUser != null&quot;<span class="operator">&gt;</span>update_User <span class="operator">=</span> #&#123;updateUser&#125;,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;status != null&quot;<span class="operator">&gt;</span>status <span class="operator">=</span> #&#123;status&#125;,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">set</span><span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-编辑员工"><a href="#5-编辑员工" class="headerlink" title="5.编辑员工"></a>5.编辑员工</h2><p>先查询用于页面的回显，再更新员工的信息</p><p><strong>页面回显：</strong></p><p>controller：@PathVariable接收路径参数{id}</p><p>servide:定义getById方法</p><p>mapper:注解@select * from emp where id &#x3D; ?</p><p><strong>跟新员工：</strong></p><p>controller：@RequestBody接收body参数封装到类中</p><p>service：new实体 对象，拷贝dto到实体类，在设置跟新时间等其它参数</p><p>mapper：update的动态SQL，刚才已经写过</p><h2 id="6-导入分类模块功能代码"><a href="#6-导入分类模块功能代码" class="headerlink" title="6.导入分类模块功能代码"></a>6.导入分类模块功能代码</h2><p>基础的基于分类模块的，增删改查，直接导入</p><h2 id="7-公共字段填充"><a href="#7-公共字段填充" class="headerlink" title="7.公共字段填充"></a>7.公共字段填充</h2><p>在<strong>新增员工</strong>或者<strong>新增菜品分类</strong>时需要设置创建时间、创建人、修改时间、修改人等字段，在<strong>编辑员工</strong>或者<strong>编辑菜品分类</strong>时需要设置修改时间、修改人等字段。这些字段属于公共字段，也就是也就是在我们的系统中很多表中都会有这些字段，如下：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>字段名</strong></th><th><strong>含义</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>1</td><td>create_time</td><td>创建时间</td><td>datetime</td></tr><tr><td>2</td><td>create_user</td><td>创建人id</td><td>bigint</td></tr><tr><td>3</td><td>update_time</td><td>修改时间</td><td>datetime</td></tr><tr><td>4</td><td>update_user</td><td>修改人id</td><td>bigint</td></tr></tbody></table><p>而针对于这些字段，我们的赋值要在很多请求中进行</p><p>新增，编辑，员工，菜品等等</p><p>果都按照上述的操作方式来处理这些公共字段, 需要在每一个业务方法中进行操作, 编码相对冗余、繁琐，那能不能对于这些公共字段在某个地方统一处理，来简化开发呢？</p><p><strong>答案是可以的，我们使用AOP切面编程，实现功能增强，来完成公共字段自动填充功能。</strong></p><table><thead><tr><th><strong>序号</strong></th><th><strong>字段名</strong></th><th><strong>含义</strong></th><th><strong>数据类型</strong></th><th><strong>操作类型</strong></th></tr></thead><tbody><tr><td>1</td><td>create_time</td><td>创建时间</td><td>datetime</td><td>insert</td></tr><tr><td>2</td><td>create_user</td><td>创建人id</td><td>bigint</td><td>insert</td></tr><tr><td>3</td><td>update_time</td><td>修改时间</td><td>datetime</td><td>insert、update</td></tr><tr><td>4</td><td>update_user</td><td>修改人id</td><td>bigint</td><td>insert、update</td></tr></tbody></table><p>1). 在新增数据时, 将createTime、updateTime 设置为当前时间, createUser、updateUser设置为当前登录用户ID。</p><p>2). 在更新数据时, 将updateTime 设置为当前时间, updateUser设置为当前登录用户ID。</p><p>实现步骤：</p><p>1.自定义注解@a，用于表示需要进行公共字段填充的方法</p><p>2.自定义切面类AOP ，统一拦截加入注解@a的方法，通过反射为公共字段赋值</p><p>3.在mapper中的方法上，加入@a注解</p><p>技术点：枚举，注解，AOP，反射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">反射的概念</span><br><span class="line">反射（Reflection）是 Java 的一种特性，它可以让程序在运行时获取自身的信息，并且动态地操作类或对象的属性、方法和构造器等。通过反射功能，可以让我们在不知道具体类名的情况下，依然能够实例化对象，调用方法以及设置属性。</span><br><span class="line"></span><br><span class="line">反射的作用</span><br><span class="line">反射的作用有以下几点：</span><br><span class="line"></span><br><span class="line">运行时探查类的信息：反射允许我们在运行时加载、检查和使用类，甚至可以在运行时获取一个未加载的类。</span><br><span class="line"></span><br><span class="line">动态创建对象：使用反射可以实现动态地创建对象，而且可以选择该类的任意一个构造函数来创建对象实例。</span><br><span class="line"></span><br><span class="line">访问或修改私有成员：反射可以访问和修改一个类中私有的字段和方法，即使这些字段和方法是私有的。</span><br><span class="line"></span><br><span class="line">扩展应用程序的可控性：反射可以提高应用程序的可扩展性，例如，它可以读取配置文件来决定需要加载哪个类。</span><br><span class="line"></span><br><span class="line">反射的特点</span><br><span class="line">反射具有以下几个特点：</span><br><span class="line"></span><br><span class="line">动态性：反射允许程序在运行期间动态地创建对象、调用方法和修改属性。</span><br><span class="line"></span><br><span class="line">类型检查问题：虽然反射可以使用某个类的任何方法或属性，但是编译器在编译时并不会检查这些方法或属性是否可用。</span><br><span class="line"></span><br><span class="line">性能问题：反射的性能比直接调用方法要差。因为在使用反射时，需要先获取方法或变量的引用，然后再进行调用或访问。</span><br><span class="line"></span><br><span class="line">安全性问题：反射破坏了封装￥，可以对私有成员进行访问和修改</span><br></pre></td></tr></table></figure><p><strong>自定义切面，实现公共逻辑的处理问题</strong></p><p>反射的逻辑太复杂了，尤其这里还是枚举，注解，AOP，反射集合在了一起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//将备注接的类实例化，交给IOC容器管理</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFillAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义切面类，实现公共字段的处理逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//切入点表达式，用于匹配所有位于com.sky.mapper包下的任意类的任意方法，并且这些方法上标注了@AutoFill注解。</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFillPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;autoFillPointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取当前被拦截方法的数据库操作类型</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();<span class="comment">//方法签名对象</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">autoFill</span> <span class="operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);<span class="comment">//获得方法上的注解对象</span></span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> autoFill.value();<span class="comment">//获得数据库操作类型</span></span><br><span class="line">        <span class="comment">//总之，上述三行代码通过反射获取到的是，@AutoFill(value = OperationType.INSERT、UPDATE)</span></span><br><span class="line">        <span class="comment">//获得Insert还是update方法，Insert更新四个字段，update更新三个字段</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取当前被拦截方法的参数--实体对象</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();<span class="comment">//获得当前方法的所有实体参数</span></span><br><span class="line">        <span class="keyword">if</span>(args == <span class="literal">null</span> || args.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> args[<span class="number">0</span>];<span class="comment">//约定：将第一个参数作为实体对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.准备赋值数据，创建时间、创建人</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();<span class="comment">//从LocalThread线程中获取</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.根据当前不同的操作类型，为对应的属性通过反射来获取数据</span></span><br><span class="line">        <span class="keyword">if</span>(operationType == OperationType.INSERT)&#123;<span class="comment">//如果是插入操作，为四个公共字段都赋值</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取到实体对象的Class对象，再根据方法名称获得Class对象中声明为这些的方法</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//invoke利用反射调用了entity的setCreateTime方法，设置了now值</span></span><br><span class="line">                setCreateTime.invoke(entity,now);</span><br><span class="line">                setCreateUser.invoke(entity,currentId);</span><br><span class="line">                setUpdateTime.invoke(entity,now);</span><br><span class="line">                setUpdateUser.invoke(entity,currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operationType == OperationType.UPDATE) &#123;<span class="comment">//如果是更新操作，为两个公共字段赋值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取到实体对象的Class对象，再根据方法名称获得Class对象中声明为这些的方法</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//invoke利用反射调用了entity的setCreateTime方法，设置了now值</span></span><br><span class="line">                setUpdateTime.invoke(entity,now);</span><br><span class="line">                setUpdateUser.invoke(entity,currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一行代码一行代码的注释，反射逻辑太复杂了，看了三遍这段</strong></p><h2 id="8-新增菜品"><a href="#8-新增菜品" class="headerlink" title="8.新增菜品"></a>8.新增菜品</h2><p><strong>业务规则：</strong></p><ul><li>菜品名称必须是唯一的</li><li>菜品必须属于某个分类下，不能单独存在</li><li>新增菜品时可以根据情况选择菜品的口味</li><li>每个菜品必须对应一张图片</li></ul><p><strong>接口设计：</strong></p><ul><li>根据类型查询分类（已完成）</li><li>文件上传。web中已完成</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">阿里OSS上传流程</span><br><span class="line">1.定义阿里云工具类（从阿里云的官方demo中获取）</span><br><span class="line">2.定义阿里云配置类，@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span><br><span class="line">用于在配置项中获取响应的配置属性</span><br><span class="line">3.在其他类中直接调用阿里云OSSUtils的方法上传，得到返回的url 即可</span><br></pre></td></tr></table></figure><ul><li>新增菜品：</li></ul><p>新增菜品，其实就是将新增页面录入的菜品信息插入到dish表，如果添加了口味做法，还需要向dish_flavor表插入数据。所以在新增菜品时，涉及到两个表：</p><table><thead><tr><th>表名</th><th>说明</th></tr></thead><tbody><tr><td>dish</td><td>菜品表</td></tr><tr><td>dish_flavor</td><td>菜品口味表</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.设计DTO类，@RequestBody将前端的参数全部封装</span><br><span class="line">2.service层用事物，定义两个新对象，@transaction开启事务，同时将前端的数据插入到两张表中去</span><br><span class="line">3.mapper层动态SQL执行插入</span><br></pre></td></tr></table></figure><h2 id="9-菜品分页查询"><a href="#9-菜品分页查询" class="headerlink" title="9.菜品分页查询"></a>9.菜品分页查询</h2><p><strong>业务规则：</strong></p><ul><li>根据页码展示菜品信息</li><li>每页展示10条数据</li><li>分页查询时可以根据需要输入菜品名称、菜品分类、菜品状态进行查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>因为要查询菜品的信息，以及菜品所在的分类，所以要查两张表</span><br><span class="line"><span class="number">2.</span>响应的数据无法与现有的DTO类和实体类匹配，所以创建VO表，响应前端的数据</span><br><span class="line"><span class="number">3.</span>现在数据库里面，查询测试</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">d.<span class="operator">*</span>,</span><br><span class="line">c.NAME </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">dish d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> category c <span class="keyword">ON</span> d.category_id <span class="operator">=</span> c.id</span><br><span class="line">再动态写入<span class="keyword">SQL</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>spring3版本的分页查询插件的版本一定不能太低，否则分页不了，我真的</strong>！！！</p><p><strong>debug排查了一晚上的代码，都逼得我去看PageHelper的源码了</strong></p><p><strong>原来不是代码写错了，只是版本太低不兼容的问题</strong></p><h2 id="10删除菜品"><a href="#10删除菜品" class="headerlink" title="10删除菜品"></a>10删除菜品</h2><p><strong>业务规则：</strong></p><ul><li>可以一次删除一个菜品，也可以批量删除菜品</li><li>起售中的菜品不能删除</li><li>被套餐关联的菜品不能删除</li><li>删除菜品后，关联的口味数据也需要删除掉</li></ul><p><strong>接口设计</strong></p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240406211632736.png" alt="image-20240406211632736" style="zoom:50%;"><p><strong>表设计</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240406211551682.png" alt="image-20240406211551682"></p><p><strong>注意事项：</strong></p><ul><li>在dish表中删除菜品基本数据时，同时，也要把关联在dish_flavor表中的数据一块删除。</li><li>setmeal_dish表为菜品和套餐关联的中间表。</li><li>若删除的菜品数据关联着某个套餐，此时，删除失败。</li><li>若要删除套餐关联的菜品数据，先解除两者关联，再对菜品进行删除。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.@requestParame接收，封装为List&lt;Long&gt;</span><br><span class="line">2.主要是service层的逻辑，操作两张表，去查询，没有再删除，添加事物</span><br><span class="line">3.mapper接口写删除和查询逻辑</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBatch</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">     <span class="comment">//1.判断当前的菜品能否删除，查询，是否存在起售中的菜品</span></span><br><span class="line">     <span class="keyword">for</span>(Long id : ids)&#123;</span><br><span class="line">         <span class="comment">//根据id查询菜品</span></span><br><span class="line">         <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> dishMapper.getById(id);</span><br><span class="line">         <span class="keyword">if</span>(dish.getStatus().equals(StatusConstant.ENABLE))&#123;<span class="comment">//status状态为1</span></span><br><span class="line">             <span class="comment">//当前菜品处于起售中，不能删除，抛出异常</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DeletionNotAllowedException</span>(MessageConstant.DISH_ON_SALE);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//2.判断当前菜品能否删除，是否被套餐关联了？</span></span><br><span class="line">     <span class="comment">//在另一张表中，去查询当前菜品的id在套餐表中是dish_id与之对应</span></span><br><span class="line">     <span class="comment">//查询返回列表数据，因为可能不止一个关联</span></span><br><span class="line">     List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);</span><br><span class="line">     <span class="keyword">if</span>(setmealIds != <span class="literal">null</span> &amp;&amp; setmealIds.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DeletionNotAllowedException</span>(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3.根据id集合，批量删除菜品数据，批量删除关联口味数据</span></span><br><span class="line">     dishMapper.deleteByIds(ids);</span><br><span class="line">     dishFlavorMapper.deleteByIds(ids);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="11-修改菜品"><a href="#11-修改菜品" class="headerlink" title="11.修改菜品"></a>11.修改菜品</h2><p>5.1.2 接口设计</p><p>通过对上述原型图进行分析，该页面共涉及4个接口。</p><p><strong>接口：</strong></p><ul><li>根据id查询菜品</li><li>根据类型查询分类(已实现)</li><li>文件上传(已实现)</li><li>修改菜品</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询菜谱：接收DTO，根据id查菜品，根据id查口味，封装到VO响应给前端</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DishVO <span class="title function_">getByIdWithFlavor</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//查询菜品数据</span></span><br><span class="line">        <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> dishMapper.getById(id);</span><br><span class="line">        <span class="comment">//查询口味数据</span></span><br><span class="line">        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将查询结果封装到VO</span></span><br><span class="line">        <span class="type">DishVO</span> <span class="variable">dishVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishVO</span>();</span><br><span class="line"></span><br><span class="line">        BeanUtils.copyProperties(dish,dishVO);</span><br><span class="line">        <span class="comment">//BeanUtils.copyProperties(dishFlavors,dishVO);</span></span><br><span class="line">        dishVO.setFlavors(dishFlavors);</span><br><span class="line">        <span class="keyword">return</span> dishVO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改菜谱：修改基本信息，删除口味，重新插入口味</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithFlavor</span><span class="params">(DishDTO dishDTO)</span> &#123;</span><br><span class="line">        <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dish</span>();</span><br><span class="line">        BeanUtils.copyProperties(dishDTO, dish);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改菜品表基本信息</span></span><br><span class="line">        dishMapper.update(dish);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除原有的口味数据</span></span><br><span class="line">        dishFlavorMapper.deleteByDishId(dishDTO.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新插入口味数据</span></span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();</span><br><span class="line">        <span class="keyword">if</span> (flavors != <span class="literal">null</span> &amp;&amp; flavors.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flavors.forEach(dishFlavor -&gt; &#123;</span><br><span class="line">                dishFlavor.setDishId(dishDTO.getId());</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="comment">//            for(DishFlavor dishFlavor : flavors)&#123;</span></span><br><span class="line"><span class="comment">//                dishFlavor.setDishId(dish.getId());</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//向口味表插入n条数据</span></span><br><span class="line">            dishFlavorMapper.insertBatch(flavors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> Takeaways </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> Takeaways </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus（持续更新）</title>
      <link href="/2024/04/02/Java/mybatisplus/"/>
      <url>/2024/04/02/Java/mybatisplus/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h1><p><a href="https://www.baomidou.com/">MyBatis-Plus (baomidou.com)</a></p><p>MyBatis-Plus 是基于 MyBatis 的增强工具，提供了便捷的 CRUD 操作、条件构造器、分页查询、自动填充、乐观锁、逻辑删除等功能，极大地简化了 MyBatis 的开发流程，提高了开发效率。</p><h2 id="快速入门mybatisplus"><a href="#快速入门mybatisplus" class="headerlink" title="快速入门mybatisplus"></a>快速入门mybatisplus</h2><p>1.引入mybatis-plus的起步依赖代替mybatis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis-plus官方提供了starter，集成了mybatis和plus的所有功能，并且实现了自动装配的效果</p><p>2.自定义的mapper接口，继承mybatisplus提供的BaseMapper接口，并且指定泛型</p><p>3.直接注入mapper对象，用对象.调用父类BaseMapper中的方法，免去我们以前在mybatis中写SQL的步骤了</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt;</span><br></pre></td></tr></table></figure><p><strong>mp通过扫描实体类，并基于反射作为实体类的信息作为数据库的信息表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类名驼峰转下划线作为表名称</li><li>名为id的字段作为表的主键</li><li>变量名驼峰转下换线作为表的字段名称</li></ul><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><p>mybatis中的常见注解如下：</p><ul><li><strong>@TableName：用来指定表名称</strong></li><li><strong>@TableId:用来指定表中主键字段的信息</strong></li><li><strong>@TableField:用来指定表中普通字段的信息</strong></li></ul><p>解释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">users</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@TableField(&quot;is_married&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isMarried;</span><br><span class="line">    <span class="meta">@TableField(&quot;`order`&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer order;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些注解用于映射 Java 对象与数据库表之间的关系，具体解释如下：</p><ol><li><code>@TableName(&quot;tb_user&quot;)</code>: 用于指定该实体类对应的数据库表名为 “tb_user”。</li><li><code>@TableId(value = &quot;id&quot;, type = IdType.AUTO)</code>: 标注在实体类的主键字段上，用于指定主键属性，<code>value</code> 指定数据库表中对应的列名为 “id”，<code>type</code> 指定主键生成策略为自动增长。</li><li><code>@TableField(&quot;username&quot;)</code>: 用于指定实体类属性与数据库表字段之间的映射关系，<code>value</code> 指定数据库表中对应的列名为 “username”。</li><li><code>@TableField(&quot;is_married&quot;)</code>: 用于指定实体类属性与数据库表字段之间的映射关系，<code>value</code> 指定数据库表中对应的列名为 “is_married”，通常用于 boolean 类型的属性。</li><li><code>@TableField(&quot;</code>order<code>&quot;)</code>: 用于指定实体类属性与数据库表字段之间的映射关系，由于 “order” 是 SQL 关键字，所以使用了 “&#96;” 来包裹列名。</li><li><code>@TableField(exist = false)</code>: 标注在实体类的非数据库字段上，表示该属性在数据库表中不存在，即不与数据库表字段进行映射。</li></ol><p>这些注解可以帮助 MyBatis-Plus 框架自动生成 SQL 语句，并实现对象与数据库表之间的映射关系，简化了持久层操作的开发。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/leecode/image-20240402231304865.png" alt="image-20240402231304865"></p><h2 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h2><p><strong>mybatis-plus</strong>:<br>  <strong>type-aliases-package</strong>: com.itheima.mp.domain.po <em>#</em> <em>别名扫描包<br>*  <strong>mapper-locations</strong>: **”classpath*:&#x2F;mapper&#x2F;*<em>&#x2F;*.xml”</em></em> <em># Mapper.xml<strong>文件地址</strong>，默认值*</em><br>*  <strong>configuration</strong>:<br>   <strong>map-underscore-to-camel-case</strong>: <strong>true</strong> <em>#</em> *是否开启下划线和驼峰的映射<br>*   <strong>cache-enabled</strong>: <strong>false</strong> <em>#</em> <em>是否开启二级缓存</em></p><p> <strong>global-config</strong>:<br>   <strong>db-config</strong>:<br>    <strong>id-type</strong>: <em>assign_id</em> <em># id<strong>为</strong>雪花算法生成*</em><br>*    <strong>update-strategy</strong>: <em>not_null</em> <em>#</em> <em>更新策略：只更新非空字段</em></p><p>去官网查看</p><p><a href="https://www.baomidou.com/pages/56bac0/">使用配置 | MyBatis-Plus (baomidou.com)</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MybatisPlus使用的基本流程</p><ul><li>引入起步依赖</li><li>自定义mapper基础BaseMapper</li><li>（约定大于配置，遵从约定上述）</li><li>在实体类上，添加注解声明，表示信息</li><li>在.yaml中根据需要添加配置</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> MybatisPlus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（八）动态规划篇(持续更新)</title>
      <link href="/2024/03/31/leetcode/dongtaiguihua/"/>
      <url>/2024/03/31/leetcode/dongtaiguihua/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="动态规划的理论基础"><a href="#动态规划的理论基础" class="headerlink" title="动态规划的理论基础"></a>动态规划的理论基础</h2><p><strong>动态规划 Dynamic Programming（DP）</strong>：若果一个问题有很多重叠的子问题，使用动态规划是最有效的。</p><p>动态规划中的每一个状态是由上一个状态推导出来的，这一点就有别于贪心，贪心是没有推导状态，直接从局部选最优的</p><h2 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h2><ul><li>确定dp数组以及其下标的含义</li><li>确定递推公式（转移状态公式）</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul><h2 id="动态规划如何debug"><a href="#动态规划如何debug" class="headerlink" title="动态规划如何debug"></a>动态规划如何debug</h2><p><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p>一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p><p>这是一个很不好的习惯！</p><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p><p>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p><p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了</strong>。</p><p>这也是我为什么在动规五步曲里强调推导dp数组的重要性。</p><h2 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509.斐波那契数列"></a>509.斐波那契数列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><p>假设你正在爬楼梯。需要 <code>n</code>阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分析：因为每次只能上一节台阶或者是两节台阶，</span></span><br><span class="line"><span class="comment">//所以楼梯的个数可以由前两节楼梯的个数所决定的，所以转移状态公式就位</span></span><br><span class="line"><span class="comment">//dp[i] = dp[i-1]+dp[i-2]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 表示上第一节台阶只有一种方法</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">// 表示上两节台阶有两种方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从dp[0]&#x3D;1设置也可以的，下面的i就要从2开始了，本质上是你怎么理解dp[0]，dp[1]的含义了</p><h2 id="746-使用最小的花费爬楼梯"><a href="#746-使用最小的花费爬楼梯" class="headerlink" title="746.使用最小的花费爬楼梯"></a>746.使用最小的花费爬楼梯</h2><p>dp[i]为使用最小的花费爬楼梯，因为还是一次只能爬一层楼梯或者两层，但是有选择了，cost最小的楼梯</p><p>dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。</p><p>dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。</p><p>那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？</p><p>一定是选最小的，所以dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p><p>因为你可以选择从下标为 0或下标为 1 的台阶开始爬楼梯。</p><p>初始化dp[0] 表示上到第0层需要的最小花费，为0</p><p>dp[1]为上到第1层的最小花费，为 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（七）贪心算法（持续更新）</title>
      <link href="/2024/03/31/leetcode/tanxin/"/>
      <url>/2024/03/31/leetcode/tanxin/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>本质是：每一个阶段选择局部最优，从而打到所谓的全局最优，即为<strong>贪心</strong></p><p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p><p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p><p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p><p>再举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划</p><p><strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p><p><strong>例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！</strong></p><h2 id="贪心解题的一般步骤"><a href="#贪心解题的一般步骤" class="headerlink" title="贪心解题的一般步骤"></a>贪心解题的一般步骤</h2><ul><li>将问题分解为若干个子问题</li><li>找出合适的贪心策略</li><li>求解每一个问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h2><p>大饼干先满足大胃口的，局部最优解到全局最优解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> g.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是，if (index &gt;&#x3D; 0 &amp;&amp; s[index] &gt;&#x3D; g[i]) 这里，一定要是index在&amp;&amp; 的前面，因为要保证s[index]数组补不为null</p><h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376.摆动序列"></a>376.摆动序列</h2><p>贪心：局部最优：找到局部波动的峰值，结果++</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 当前差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">post</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 上一个差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; l; i++) &#123;</span><br><span class="line">            pre = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((pre &lt; <span class="number">0</span> &amp;&amp; post &gt;= <span class="number">0</span>) || (pre &gt; <span class="number">0</span> &amp;&amp; post &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                post = pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if中的判断条件，为什么一定要是上一个差值包含等于0的情况？</p><p>我调试了好久</p><ol><li><code>(last &gt;= 0 &amp;&amp; pre &lt; 0)</code>：这部分判断条件表示上一个差值为非负（大于等于0），而当前差值为负（小于0）。这说明了当前差值由正数变为了负数，即发生了一次从上升到下降的转折点。</li><li><code>(last &lt;= 0 &amp;&amp; pre &gt; 0)</code>：这部分判断条件表示上一个差值为非正（小于等于0），而当前差值为正（大于0）。这说明了当前差值由负数变为了正数，即发生了一次从下降到上升的转折点。</li></ol><p>在摆动序列中，我们希望找到一系列交替出现的峰值和谷值，因此需要判断当前差值和上一个差值的符号是否发生了变化。取等号的目的是为了确保在连续相同差值时不计数，因为连续相同的差值并不会对序列的摆动性产生影响。</p><p>为什么不能是if ((last &gt; 0 &amp;&amp; pre &lt;&#x3D; 0) || (last &lt; 0 &amp;&amp; pre &gt;&#x3D; 0)) ？<br>我们初始last是＝0的，如果这样写，判断条件一直为false了</p>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（六）回溯算法篇（持续更新）</title>
      <link href="/2024/03/31/leetcode/huisu/"/>
      <url>/2024/03/31/leetcode/huisu/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>回溯算法也叫做，回溯搜索法，它是一种搜索的方式</p><p><strong>回溯的本质是穷举，穷举出所有的可能，再选出我们想要的答案</strong></p><p>可以加一些剪枝的操作优化，但改变不了穷举的本质</p><p><strong>回溯和递归是相辅相成的，递归函数的下面就是递归的过程</strong></p><h2 id="回溯算法解决的问题"><a href="#回溯算法解决的问题" class="headerlink" title="回溯算法解决的问题"></a>回溯算法解决的问题</h2><ul><li>组合问题：N个数里面按照一定规则找出k个数的集合</li><li>切割问题：一个字符串按照一定的规则，有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按照一定规则全排列，有几种排列组合</li><li>棋盘问题：N皇后，解数独等</li></ul><p><strong>组合问题</strong>：{1,2}{2,1}就是一个组合，不强调顺序</p><p><strong>排列问题</strong>：{1,2}{2,1}就是两个组合，有顺序</p><h2 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h2><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><p>这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/leecode/20210130173631174.png" alt="回溯算法理论基础"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/leecode/20201123195242899.png" alt="77.组合1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            <span class="comment">//调用回溯函数，找下一个数字</span></span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯的精华，将最后一个数字移除当前组合</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//path.removeLast();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77-组合优化"><a href="#77-组合优化" class="headerlink" title="77.组合优化"></a>77.组合优化</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/leecode/20210130194335207.png" alt="77.组合4"></p><p>简单来说就是，数的每一层是dfs()，每一层的个数是for循环控制的</p><p>当n&#x3D;4,k&#x3D;4的时候，[1-4]中所有可能只有一种，所以要在for循环中，排除不需要的分支</p><p>1.已经选择的元素是path.size();</p><p>2.所需要的元素是k-path.size();</p><p>3.剩余元素为n-(k-size)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="216-组合优化III"><a href="#216-组合优化III" class="headerlink" title="216.组合优化III"></a>216.组合优化III</h2><p>在集合[1-9]中选取k个数,和n&#x3D;4的组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        dfs(k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> index, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k &amp;&amp; sum == n) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在1-9中选择数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            dfs(k, n, i + <span class="number">1</span>, sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
            <tag> leecode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>太子湾+法喜寺游记</title>
      <link href="/2024/03/26/life/taiziwan/"/>
      <url>/2024/03/26/life/taiziwan/</url>
      
        <content type="html"><![CDATA[<p>游记怎么写？就当写流水账吧</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_0060.jpg" alt="DSC_0060"><h1 id="太子湾郁金香-法喜寺五百年玉兰花"><a href="#太子湾郁金香-法喜寺五百年玉兰花" class="headerlink" title="太子湾郁金香&amp;&amp;法喜寺五百年玉兰花"></a>太子湾郁金香&amp;&amp;法喜寺五百年玉兰花</h1><p><strong>“三月春花渐次醒”</strong></p><p>睡到自然醒骑车出发</p><p>我骑车，室友坐地铁去</p><p>太子湾在西湖旁边，离学校30公里吧，正常我一个一个半小时骑到</p><p>在杭州求学第六年了，之江东路，不知道骑了多少次了，西湖也去过太多次了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_120917.jpg" alt="IMG_20240316_120917"></p><p>路上遇到一个骑行的小姐姐，太狠了，一路35+，我跟了七八公里，一个上坡跟不住了，女骑恐怖如斯</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_130552.jpg" alt="IMG_20240316_130552"></p><h2 id="太子湾门口"><a href="#太子湾门口" class="headerlink" title="太子湾门口"></a>太子湾门口</h2><p>以前的太子湾是不要预约的，现在要预约了，但是免费，门口也不差，人工看二维码我真的是绷不住了</p><p>南山路，路两边不知道什么时候围了栏杆，以往周末堵得水泄不通的南山路，现在好像不让私家车进来了，也就只有公交车了，不堵了，很好</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_130952.jpg" alt="IMG_20240316_130952"></p><p>樱花还没开，人很多，两边很突兀，就地上一点郁金香展示着春天的色彩</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_1032.jpg" alt="DSC_1032"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_1036.jpg" alt="DSC_1036"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_1049.jpg" alt="DSC_1049"></p><p>不多说了，上图</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_1057.jpg" alt="DSC_1057"></p><p>这张红白分明的，真的拍的很好</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_1069.jpg" alt="DSC_1069"></p><p>人是真的多，多到走不动道</p><p>但花也是真好看</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_1083.jpg" alt="DSC_1083"></p><p>小河边拍花，一个小姐姐闯进我的镜头</p><p>突然发现，小桥，流水，小姐姐，还蛮和谐的</p><p>拍了好几张，留下一张侧脸，我觉得这张，嗯，刚刚好</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_1097.jpg" alt="DSC_1097"></p><p>郁金香下的城堡</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_2836.jpg" alt="DSC_2836"></p><p>粉色郁金香</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_2953.jpg" alt="DSC_2953"></p><p>拉近拍近景，郁金香下还有蜜蜂在吸取花蜜</p><p>此时室友已经快到法喜寺了</p><p>我该去与之汇合</p><p>太子湾我来过很多次了，印象最深的是，19年那会儿，我也是，在这儿见到了杭州最美的春天，樱花和郁金香一起开放，樱花树下就是郁金香，各种颜色的，今年来的太早啦，如果等一两周后，樱花盛开，那将别是一番风采</p><h2 id="法喜寺"><a href="#法喜寺" class="headerlink" title="法喜寺"></a>法喜寺</h2><p>骑车从太子湾去法喜寺，从杨公堤上去，一路上还是堵堵堵堵</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_1107.jpg" alt="DSC_1107"></p><p>来杭州这么多年了，灵隐寺去过不少次，法喜寺还是第一次去</p><p>门票10元</p><p><strong>上天竺法喜讲寺</strong></p><p>都说是求姻缘的好地方</p><p>我可要好好上个香，看看到底能不能在今年实现了哈哈哈（开玩笑</p><p>（我可是来看五百年的玉兰花的）</p><p>求还得求</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240317_014700.jpg" alt="IMG_20240317_014700"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/wx_camera_1710571294492.jpg" alt="wx_camera_1710571294492"></p><p>你别说这寺庙看起来还蛮宏伟的</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/wx_camera_1710571653012.jpg" alt="wx_camera_1710571653012"></p><p>法喜寺的网红拍照打卡点，得用长焦拍，我随便一拍一点意境都没有了</p><p>可惜相机没有长焦，不过我用手机的10倍长焦拍到了好看的小姐姐</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_144848.jpg" alt="IMG_20240316_144848"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_144851.jpg" alt="IMG_20240316_144851"></p><p>此刻，景已经不重要了，人好看就成功了</p><p>哦忘了，我们的正事是来看五百年的玉兰花的</p><p>转了一圈都没找到，终于下楼拐进一个小巷子看到了</p><p>传说中的五百岁的玉兰花</p><p><strong>“花开花落五百次，只为遇见你”</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_150955.jpg" alt="IMG_20240316_150955"></p><p>人太多辣，全部都是人，慕名而来的人</p><p>看到了就是值得的</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_0025.jpg" alt="DSC_0025"></p><p>从这个角度拍，避开人群，背景刚好是寺庙的黄墙上，很不错</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_0013.jpg" alt="DSC_0013"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_0021.jpg" alt="DSC_0021"></p><p>是谁的手，刚好出现在我的镜头</p><p>佛堂下，一只手抚摸着玉兰不错，意境不错，但总觉得哪儿怪怪的</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_0015.jpg" alt="DSC_0015"></p><p>嗯，55毫米的焦段刚好拍到 <strong>五观堂</strong> 和 灯笼上的字<strong>一心念佛世界和平</strong></p><p>可惜，还是来迟了些，这边的玉兰花，可能是因为阳光照射的过多了，都快凋谢了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_0014.jpg" alt="DSC_0014"></p><p>此刻我真想唱</p><p>“我真的还想再活五百年~”</p><p>看完玉兰花四处闲逛之际</p><p>来到了寺庙深处，食堂的后面</p><p>遇到了我觉得今天最好的拍照点，可能也是运气好，阳光洒落刚刚好落在食堂黄墙的后面</p><p>还没人，真的是绝佳的拍照地点</p><p>我赶紧让家豪先上，机不可失时不再来，一会儿太阳就落山了，就没这么好的景色了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/DSC_0046.jpg" alt="DSC_0046"></p><p>快门按下，随手一拍就是大片，拍出了男明星的感觉</p><p>有一说一</p><p>这张真的不错</p><p>把我室友拍的很帅</p><p>当然，怎么能少的了我</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240317_014446.jpg" alt="IMG_20240317_014446"></p><p>嘿还行吧，我挺喜欢这张的</p><p>发给朋友看</p><p>朋友说我拿掉眼睛更好看，真的么？我觉得都还行</p><p>为了等着吃法喜寺的斋饭，要到四点半</p><p>我们就去逛纪念品店</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_161748.jpg" alt="IMG_20240316_161748"></p><p>在一把串手串中，我一看就相中了，那款猫爪的手串</p><p>太可爱了</p><p>虽然店员说，图中[2.4]经典款卖的最火</p><p>但我还是觉得猫爪好看哦</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_162941.jpg" alt="IMG_20240316_162941"></p><p>-68，不过值了</p><p>（后面才知道朋友说这是拿火烤的，抖音一看只要30块）</p><p>（瓦不管，瓦我开过光！）</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240317_192214.jpg" alt="IMG_20240317_192214"></p><p>对比一下我们仨的，还是我的好看</p><p>四点半了，去吃法喜寺斋饭了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_163636%20(1).jpg" alt="IMG_20240316_163636 (1)"></p><p>开始好奇只要五块钱的斋饭是什么</p><p>后来知道了，就这啊</p><p>白水煮菜豆皮加大米饭</p><p>我好奇了，偶尔吃就算了</p><p>和尚天天吃这个怎么受得了的，营养肯定跟不上啊</p><p>室友说：穿上袈裟是上班，脱下袈裟是生活</p><p>我懂了</p><h2 id="闻涛路樱花"><a href="#闻涛路樱花" class="headerlink" title="闻涛路樱花"></a>闻涛路樱花</h2><p>和室友告别，继续前行，通过梅灵南路的隧道，下到之江路，过钱塘江大桥</p><p>我想要去闻涛路看看樱花</p><p>我记得有一年来过</p><p>江畔两岸一路的樱花，特别美，但去之前我就可能有预感了，太子湾的樱花都还没有开，那么闻涛路的应该也没开吧</p><p>果然不出我所料</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_180616.jpg" alt="IMG_20240316_180616"></p><p>可能要等两周吧才能开咯 ，那就下周再来</p><p>不过江边骑行还是不错的</p><p>闻涛路，有专门的骑行道，比一般的江堤的路要宽不少</p><p>骑着骑着天就黑了</p><p>夜晚的复兴大桥</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_183723.jpg" alt="IMG_20240316_183723"></p><p>手机渣渣画质只能拍成这样了</p><p>还有半小时，准备去看林俊杰的演唱会</p><p>什么？你问我怎么抢到票的？</p><p>那当然是，根本抢不到好吧</p><p>只能去外场听</p><p>喜欢听林俊杰，周杰伦，许嵩的歌</p><h2 id="林俊杰演唱会"><a href="#林俊杰演唱会" class="headerlink" title="林俊杰演唱会"></a>林俊杰演唱会</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_190703.jpg" alt="IMG_20240316_190703"></p><p>呼呼呼，人是真的多</p><p>大莲花也是真的好看啊</p><p>变色，五颜六色的</p><p>外场的人也好多啊</p><p>看来抢不到票的人，还是真的多啊</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/IMG_20240316_190927%20(1).jpg" alt="IMG_20240316_190927 (1)"></p><p>稳啦，找到位置了，席地而坐大家，都是JJ的粉丝</p><p>我看还有人拿着票，我去一问，才是旁边买的仿制的票奥</p><p>真粉丝啊，留个仿制的当个纪念</p><p>等了好久</p><p>林俊杰的第一首是，记得</p><p><strong>谁还记得是谁先说，永远的爱我~</strong></p><p>但是大莲花太大啦，声音很嘈杂，听得不是很清楚，我也是第一次听外场</p><p>体验极差，不如回去看饭拍的视频（写这篇文档的时候，其实边学习，边听了两遍饭拍了都）</p><p>外场大家在唱，虽然听不清，但是氛围还是有的</p><p>林俊杰的《关键词》真的太好听啦</p><p><strong>好好爱自己，就有人会爱你，这乐观的说辞~</strong></p><p>还有《将故事写成我们》</p><p><strong>这最美的秘密，是我们都在制造巧遇</strong></p><p>后面听到快结束《她说》的时候，保安开始清场了，因为要保证散场</p><p>我就回去了</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/tzwan/Screenshot_2024-03-16-22-56-15-866_com.mi.health.jpg" alt="Screenshot_2024-03-16-22-56-15-866_com.mi.health"></p><p>86.57公里</p><p>充实的一天</p><p>充实的一篇流水账</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 太子湾 </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 原理篇</title>
      <link href="/2024/03/26/Java/springboot/"/>
      <url>/2024/03/26/Java/springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpingBoot原理"><a href="#SpingBoot原理" class="headerlink" title="SpingBoot原理"></a>SpingBoot原理</h1><p>在前面十多天的课程当中，我们学习的都是web开发的技术使用，都是面向应用层面的，我们学会了怎么样去用。而我们今天所要学习的是web后端开发的最后一个篇章springboot原理篇，主要偏向于底层原理。</p><p>我们今天的课程安排包括这么三个部分：</p><ol><li>配置优先级：Springboot项目当中属性配置的常见方式以及配置的优先级</li><li>Bean的管理</li><li>剖析Springboot的底层原理</li></ol><h2 id="1-配置优先级"><a href="#1-配置优先级" class="headerlink" title="1. 配置优先级"></a>1. 配置优先级</h2><p>在我们前面的课程当中，我们已经讲解了SpringBoot项目当中支持的三类配置文件：</p><ul><li>application.properties</li><li>application.yml</li><li>application.yaml</li></ul><p>在SpringBoot项目当中，我们要想配置一个属性，可以通过这三种方式当中的任意一种来配置都可以，那么如果项目中同时存在这三种配置文件，且都配置了同一个属性，如：Tomcat端口号，到底哪一份配置文件生效呢？</p><ul><li>application.properties</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure><ul><li>application.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">8082</span></span><br></pre></td></tr></table></figure><ul><li>application.yaml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">8082</span></span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/picture/yourname.png" alt="image-7832738"></p><p>我们启动SpringBoot程序，测试下三个配置文件中哪个Tomcat端口号生效：</p><ul><li>properties、yaml、yml三种配置文件同时存在</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113144757856.png" alt="image-20230113144757856"></p><blockquote><p>properties、yaml、yml三种配置文件，优先级最高的是properties</p></blockquote><ul><li>yaml、yml两种配置文件同时存在</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113145158771.png" alt="image-20230113145158771"></p><blockquote><p>配置文件优先级排名（从高到低）：</p><ol><li>properties配置文件</li><li>yml配置文件</li><li>yaml配置文件</li></ol></blockquote><p>注意事项：虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置。（yml是主流）</p><p>在SpringBoot项目当中除了以上3种配置文件外，SpringBoot为了增强程序的扩展性，除了支持配置文件的配置方式以外，还支持另外两种常见的配置方式：</p><ol><li><p>Java系统属性配置 （格式： -Dkey&#x3D;value）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dserver.port=9000</span><br></pre></td></tr></table></figure></li><li><p>命令行参数 （格式：–key&#x3D;value）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--server.port=10010</span><br></pre></td></tr></table></figure></li></ol><p>那在idea当中运行程序时，如何来指定Java系统属性和命令行参数呢？</p><ul><li>编辑启动程序的配置信息</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113162746634.png" alt="image-20230113162746634"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113162639630.png" alt="image-20230113162639630"></p><p>重启服务，同时配置Tomcat端口(三种配置文件、系统属性、命令行参数)，测试哪个Tomcat端口号生效：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113165006550.png" alt="image-20230113165006550"></p><p>删除命令行参数配置，重启SpringBoot服务：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113170841253.png" alt="image-20230113170841253"></p><blockquote><p>优先级： 命令行参数 &gt;  系统属性参数 &gt; properties参数 &gt; yml参数 &gt; yaml参数</p></blockquote><p>思考：如果项目已经打包上线了，这个时候我们又如何来设置Java系统属性和命令行参数呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=9000 -jar XXXXX.jar --server.port=10010</span><br></pre></td></tr></table></figure><p>下面我们来演示下打包程序运行时指定Java系统属性和命令行参数：</p><ol><li>执行maven打包指令package，把项目打成jar文件</li><li>使用命令：java -jar 方式运行jar文件程序</li></ol><p>项目打包：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113172313655.png" alt="image-20230113172313655"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113172854016.png" alt="image-20230113172854016"></p><p>运行jar程序：</p><ul><li>同时设置Java系统属性和命令行参数</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113172659269.png" alt="image-20230113172659269"></p><ul><li>仅设置Java系统属性</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113173228232.png" alt="image-20230113173228232"></p><blockquote><p>注意事项：</p><ul><li>Springboot项目进行打包时，需要引入插件 spring-boot-maven-plugin (基于官网骨架创建项目，会自动添加该插件)</li></ul></blockquote><p>在SpringBoot项目当中，常见的属性配置方式有5种， 3种配置文件，加上2种外部属性的配置(Java系统属性、命令行参数)。通过以上的测试，我们也得出了优先级(从低到高)：</p><ul><li>application.yaml（忽略）</li><li>application.yml</li><li>application.properties</li><li>java系统属性（-Dxxx&#x3D;xxx）</li><li>命令行参数（–xxx&#x3D;xxx）</li></ul><h2 id="2-Bean管理"><a href="#2-Bean管理" class="headerlink" title="2. Bean管理"></a>2. Bean管理</h2><p>在前面的课程当中，我们已经讲过了我们可以通过Spring当中提供的注解@Component以及它的三个衍生注解（@Controller、@Service、@Repository）来声明IOC容器中的bean对象，同时我们也学习了如何为应用程序注入运行时所需要依赖的bean对象，也就是依赖注入DI。</p><p>我们今天主要学习IOC容器中Bean的其他使用细节，主要学习以下三方面：</p><ol><li>如何从IOC容器中手动的获取到bean对象</li><li>bean的作用域配置</li><li>管理第三方的bean对象</li></ol><p>接下来我们先来学习第一方面，从IOC容器中获取bean对象。</p><h3 id="2-1-获取Bean"><a href="#2-1-获取Bean" class="headerlink" title="2.1 获取Bean"></a>2.1 获取Bean</h3><p>默认情况下，SpringBoot项目在启动的时候会自动的创建IOC容器(也称为Spring容器)，并且在启动的过程当中会自动的将bean对象都创建好，存放在IOC容器当中。应用程序在运行时需要依赖什么bean对象，就直接进行依赖注入就可以了。</p><p>而在Spring容器中提供了一些方法，可以主动从IOC容器中获取到bean对象，下面介绍3种常用方式：</p><ol><li><p>根据name获取bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">getBean</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure></li><li><p>根据类型获取bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span></span><br></pre></td></tr></table></figure></li><li><p>根据name获取bean（带类型转换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span></span><br></pre></td></tr></table></figure></li></ol><p>思考：要从IOC容器当中来获取到bean对象，需要先拿到IOC容器对象，怎么样才能拿到IOC容器呢？</p><ul><li>想获取到IOC容器，直接将IOC容器对象注入进来就可以了</li></ul><p>控制器：DeptController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/depts&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptService deptService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeptController</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DeptController constructor ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Dept&gt; deptList = deptService.list();</span><br><span class="line">        <span class="keyword">return</span> Result.success(deptList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>  &#123;</span><br><span class="line">        deptService.delete(id);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Dept dept)</span>&#123;</span><br><span class="line">        deptService.save(dept);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务实现类：DeptServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Dept&gt; deptList = deptMapper.list();</span><br><span class="line">        <span class="keyword">return</span> deptList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        deptMapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Dept dept)</span> &#123;</span><br><span class="line">        dept.setCreateTime(LocalDateTime.now());</span><br><span class="line">        dept.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        deptMapper.save(dept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部部门数据</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from dept&quot;)</span></span><br><span class="line">    List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除部门</span></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from dept where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增部门</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into dept(name, create_time, update_time) values (#&#123;name&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Dept dept)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext; <span class="comment">//IOC容器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取bean对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//根据bean的名称获取</span></span><br><span class="line">        <span class="type">DeptController</span> <span class="variable">bean1</span> <span class="operator">=</span> (DeptController) applicationContext.getBean(<span class="string">&quot;deptController&quot;</span>);</span><br><span class="line">        System.out.println(bean1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据bean的类型获取</span></span><br><span class="line">        <span class="type">DeptController</span> <span class="variable">bean2</span> <span class="operator">=</span> applicationContext.getBean(DeptController.class);</span><br><span class="line">        System.out.println(bean2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据bean的名称 及 类型获取</span></span><br><span class="line">        <span class="type">DeptController</span> <span class="variable">bean3</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;deptController&quot;</span>, DeptController.class);</span><br><span class="line">        System.out.println(bean3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后控制台日志：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113211619818.png" alt="image-20230113211619818"></p><blockquote><p>问题：输出的bean对象地址值是一样的，说明IOC容器当中的bean对象有几个？</p><p>答案：只有一个。        （默认情况下，IOC中的bean对象是单例）</p><p>那么能不能将bean对象设置为非单例的(每次获取的bean都是一个新对象)？</p><p>可以，在下一个知识点(bean作用域)中讲解。</p></blockquote><p>注意事项：</p><ul><li>上述所说的 【Spring项目启动时，会把其中的bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。</li></ul><h3 id="2-2-Bean作用域"><a href="#2-2-Bean作用域" class="headerlink" title="2.2 Bean作用域"></a>2.2 Bean作用域</h3><p>在前面我们提到的IOC容器当中，默认bean对象是单例模式(只有一个实例对象)。那么如何设置bean对象为非单例呢？需要设置bean的作用域。</p><p>在Spring中支持五种作用域，后三种在web环境才生效：</p><table><thead><tr><th><strong>作用域</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>singleton</td><td>容器内同名称的bean只有一个实例（单例）（默认）</td></tr><tr><td>prototype</td><td>每次使用该bean时会创建新的实例（非单例）</td></tr><tr><td>request</td><td>每个请求范围内会创建新的实例（web环境中，了解）</td></tr><tr><td>session</td><td>每个会话范围内会创建新的实例（web环境中，了解）</td></tr><tr><td>application</td><td>每个应用范围内会创建新的实例（web环境中，了解）</td></tr></tbody></table><p>知道了bean的5种作用域了，我们要怎么去设置一个bean的作用域呢？</p><ul><li>可以借助Spring中的@Scope注解来进行配置作用域</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230113214244144.png" alt="image-20230113214244144"></p><p><strong>1). 测试一</strong></p><ul><li>控制器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认bean的作用域为：singleton (单例)</span></span><br><span class="line"><span class="meta">@Lazy</span> <span class="comment">//延迟加载（第一次使用bean对象时，才会创建bean对象并交给ioc容器管理）</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/depts&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptService deptService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeptController</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DeptController constructor ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext; <span class="comment">//IOC容器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean的作用域</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScope</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">DeptController</span> <span class="variable">deptController</span> <span class="operator">=</span> applicationContext.getBean(DeptController.class);</span><br><span class="line">            System.out.println(deptController);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启SpringBoot服务，运行测试方法，查看控制台打印的日志：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114001348839.png" alt="image-20230114001348839"></p><blockquote><p>注意事项：</p><ul><li><p>IOC容器中的bean默认使用的作用域：singleton (单例)</p></li><li><p>默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化(延迟到第一次使用时)</p></li></ul></blockquote><p><strong>2). 测试二</strong></p><p>修改控制器DeptController代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">//bean作用域为非单例</span></span><br><span class="line"><span class="meta">@Lazy</span> <span class="comment">//延迟加载</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/depts&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptService deptService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeptController</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DeptController constructor ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启SpringBoot服务，再次执行测试方法，查看控制吧打印的日志：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114001736151.png" alt="image-20230114001736151"></p><blockquote><p>注意事项：</p><ul><li>prototype的bean，每一次使用该bean的时候都会创建一个新的实例</li><li>实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性</li></ul></blockquote><h3 id="2-3-第三方Bean"><a href="#2-3-第三方Bean" class="headerlink" title="2.3 第三方Bean"></a>2.3 第三方Bean</h3><p>学习完bean的获取、bean的作用域之后，接下来我们再来学习第三方bean的配置。</p><p>之前我们所配置的bean，像controller、service，dao三层体系下编写的类，这些类都是我们在项目当中自己定义的类(自定义类)。当我们要声明这些bean，也非常简单，我们只需要在类上加上@Component以及它的这三个衍生注解（@Controller、@Service、@Repository），就可以来声明这个bean对象了。<br>但是在我们项目开发当中，还有一种情况就是这个类它不是我们自己编写的，而是我们引入的第三方依赖当中提供的。</p><p>在pom.xml文件中，引入dom4j：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Dom4j--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>dom4j就是第三方组织提供的。 dom4j中的SAXReader类就是第三方编写的。</p></blockquote><p>当我们需要使用到SAXReader对象时，直接进行依赖注入是不是就可以了呢？</p><ul><li>按照我们之前的做法，需要在SAXReader类上添加一个注解@Component（将当前类交给IOC容器管理）</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114003903285.png" alt="image-20230114003903285"></p><blockquote><p>结论：第三方提供的类是只读的。无法在第三方类上添加@Component注解或衍生注解。</p></blockquote><p>那么我们应该怎样使用并定义第三方的bean呢？</p><ul><li>如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component 及衍生注解声明bean的，就需要用到**@Bean**注解。</li></ul><p><strong>解决方案1：在启动类上添加@Bean标识的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明第三方bean</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span></span><br><span class="line">    <span class="keyword">public</span> SAXReader <span class="title function_">saxReader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">emp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">emp</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SAXReader saxReader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三方bean的管理</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testThirdBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;1.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rootElement.element(<span class="string">&quot;name&quot;</span>).getText();</span><br><span class="line">        <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> rootElement.element(<span class="string">&quot;age&quot;</span>).getText();</span><br><span class="line"></span><br><span class="line">        System.out.println(name + <span class="string">&quot; : &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重启SpringBoot服务，执行测试方法后，控制台输出日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tom : 18</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：以上在启动类中声明第三方Bean的作法，不建议使用（项目中要保证启动类的纯粹性）</strong></p></blockquote><p><strong>解决方案2：在配置类中定义@Bean标识的方法</strong></p><ul><li>如果需要定义第三方Bean时， 通常会单独定义一个配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类  (在配置类当中对第三方bean进行集中的配置管理)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明第三方bean</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span></span><br><span class="line">          <span class="comment">//通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名</span></span><br><span class="line">    <span class="keyword">public</span> SAXReader <span class="title function_">reader</span><span class="params">(DeptService deptService)</span>&#123;</span><br><span class="line">        System.out.println(deptService);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注释掉SpringBoot启动类中创建第三方bean对象的代码，重启服务，执行测试方法，查看控制台日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tom : 18</span><br></pre></td></tr></table></figure><p>在方法上加上一个@Bean注解，Spring 容器在启动的时候，它会自动的调用这个方法，并将方法的返回值声明为Spring容器当中的Bean对象。</p><blockquote><p>注意事项 ：</p><ul><li><p>通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。</p></li><li><p>如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。</p></li></ul></blockquote><p>关于Bean大家只需要保持一个原则：</p><ul><li>如果是在项目当中我们自己定义的类，想将这些类交给IOC容器管理，我们直接使用@Component以及它的衍生注解来声明就可以。</li><li>如果这个类它不是我们自己定义的，而是引入的第三方依赖当中提供的类，而且我们还想将这个类交给IOC容器管理。此时我们就需要在配置类中定义一个方法，在方法上加上一个@Bean注解，通过这种方式来声明第三方的bean对象。</li></ul><h2 id="3-SpringBoot原理"><a href="#3-SpringBoot原理" class="headerlink" title="3. SpringBoot原理"></a>3. SpringBoot原理</h2><p>经过前面10多天课程的学习，大家也会发现基于SpringBoot进行web程序的开发是非常简单、非常高效的。</p><p>SpringBoot使我们能够集中精力地去关注业务功能的开发，而不用过多地关注框架本身的配置使用。而我们前面所讲解的都是面向应用层面的技术，接下来我们开始学习SpringBoot的原理，这部分内容偏向于底层的原理分析。</p><p>在剖析SpringBoot的原理之前，我们先来快速回顾一下我们前面所讲解的Spring家族的框架。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114171304644.png" alt="image-20230114171304644"></p><p>Spring是目前世界上最流行的Java框架，它可以帮助我们更加快速、更加容易的来构建Java项目。而在Spring家族当中提供了很多优秀的框架，而所有的框架都是基于一个基础框架的SpringFramework(也就是Spring框架)。而前面我们也提到，如果我们直接基于Spring框架进行项目的开发，会比较繁琐。</p><p>这个繁琐主要体现在两个地方：</p><ol><li>在pom.xml中依赖配置比较繁琐，在项目开发时，需要自己去找到对应的依赖，还需要找到依赖它所配套的依赖以及对应版本，否则就会出现版本冲突问题。</li><li>在使用Spring框架进行项目开发时，需要在Spring的配置文件中做大量的配置，这就造成Spring框架入门难度较大，学习成本较高。</li></ol><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114170610438.png" alt="image-20230114170610438"></p><blockquote><p>基于Spring存在的问题，官方在Spring框架4.0版本之后，又推出了一个全新的框架：SpringBoot。</p><p>通过 SpringBoot来简化Spring框架的开发(是简化不是替代)。我们直接基于SpringBoot来构建Java项目，会让我们的项目开发更加简单，更加快捷。</p></blockquote><p>SpringBoot框架之所以使用起来更简单更快捷，是因为SpringBoot框架底层提供了两个非常重要的功能：一个是起步依赖，一个是自动配置。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114172442018.png" alt="image-20230114172442018"></p><blockquote><p>通过SpringBoot所提供的起步依赖，就可以大大的简化pom文件当中依赖的配置，从而解决了Spring框架当中依赖配置繁琐的问题。</p><p>通过自动配置的功能就可以大大的简化框架在使用时bean的声明以及bean的配置。我们只需要引入程序开发时所需要的起步依赖，项目开发时所用到常见的配置都已经有了，我们直接使用就可以了。</p></blockquote><p>简单回顾之后，接下来我们来学习下SpringBoot的原理。其实学习SpringBoot的原理就是来解析SpringBoot当中的起步依赖与自动配置的原理。我们首先来学习SpringBoot当中起步依赖的原理。</p><h3 id="3-1-起步依赖"><a href="#3-1-起步依赖" class="headerlink" title="3.1 起步依赖"></a>3.1 起步依赖</h3><p>假如我们没有使用SpringBoot，用的是Spring框架进行web程序的开发，此时我们就需要引入web程序开发所需要的一些依赖。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114173645101.png" alt="image-20230114173645101"></p><blockquote><p>spring-webmvc依赖：这是Spring框架进行web程序开发所需要的依赖</p><p>servlet-api依赖：Servlet基础依赖</p><p>jackson-databind依赖：JSON处理工具包</p><p>如果要使用AOP，还需要引入aop依赖、aspect依赖</p><p>项目中所引入的这些依赖，还需要保证版本匹配，否则就可能会出现版本冲突问题。</p></blockquote><p>如果我们使用了SpringBoot，就不需要像上面这么繁琐的引入依赖了。我们只需要引入一个依赖就可以了，那就是web开发的起步依赖：springboot-starter-web。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114174805852.png" alt="image-20230114174805852"></p><p>为什么我们只需要引入一个web开发的起步依赖，web开发所需要的所有的依赖都有了呢？</p><ul><li>因为Maven的依赖传递。</li></ul><blockquote><ul><li><p>在SpringBoot给我们提供的这些起步依赖当中，已提供了当前程序开发所需要的所有的常见依赖(官网地址：<a href="https://docs.spring.io/spring-boot/docs/2.7.7/reference/htmlsingle/#using.build-systems.starters)%E3%80%82">https://docs.spring.io/spring-boot/docs/2.7.7/reference/htmlsingle/#using.build-systems.starters)。</a></p></li><li><p>比如：springboot-starter-web，这是web开发的起步依赖，在web开发的起步依赖当中，就集成了web开发中常见的依赖：json、web、webmvc、tomcat等。我们只需要引入这一个起步依赖，其他的依赖都会自动的通过Maven的依赖传递进来。</p></li></ul></blockquote><p><strong>结论：起步依赖的原理就是Maven的依赖传递。</strong></p><h3 id="3-2-自动配置"><a href="#3-2-自动配置" class="headerlink" title="3.2 自动配置"></a>3.2 自动配置</h3><p>我们讲解了SpringBoot当中起步依赖的原理，就是Maven的依赖传递。接下来我们解析下自动配置的原理，我们要分析自动配置的原理，首先要知道什么是自动配置。</p><h4 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h4><p>SpringBoot的自动配置就是当Spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。</p><blockquote><p>比如：我们要进行事务管理、要进行AOP程序的开发，此时就不需要我们再去手动的声明这些bean对象了，我们直接使用就可以从而大大的简化程序的开发，省去了繁琐的配置操作。</p></blockquote><p>下面我们打开idea，一起来看下自动配置的效果：</p><ul><li>运行SpringBoot启动类</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114205745221.png" alt="image-20230114205745221"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114213945851.png" alt="image-20230114213945851"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114212750007.png" alt="image-20230114212750007"></p><p>大家会看到有两个CommonConfig，在第一个CommonConfig类中定义了一个bean对象，bean对象的名字叫reader。</p><p>在第二个CommonConfig中它的bean名字叫commonConfig，为什么还会有这样一个bean对象呢？原因是在CommonConfig配置类上添加了一个注解@Configuration，而@Configuration底层就是@Component</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114220159619.png" alt="image-20230114220159619"></p><blockquote><p>所以配置类最终也是SpringIOC容器当中的一个bean对象</p></blockquote><p>在IOC容器中除了我们自己定义的bean以外，还有很多配置类，这些配置类都是SpringBoot在启动的时候加载进来的配置类。这些配置类加载进来之后，它也会生成很多的bean对象。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114221341811.png" alt="image-20230114221341811"></p><blockquote><p>比如：配置类GsonAutoConfiguration里面有一个bean，bean的名字叫gson，它的类型是Gson。 </p><p>com.google.gson.Gson是谷歌包中提供的用来处理JSON格式数据的。</p></blockquote><p>当我们想要使用这些配置类中生成的bean对象时，可以使用@Autowired就自动注入了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.itheima.pojo.Result;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJson</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> gson.toJson(Result.success());</span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加断点，使用debug模式运行测试类程序：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114222245520.png" alt="image-20230114222245520"></p><p>问题：在当前项目中我们并没有声明谷歌提供的Gson这么一个bean对象，然后我们却可以通过@Autowired从Spring容器中注入bean对象，那么这个bean对象怎么来的？</p><p>答案：SpringBoot项目在启动时通过自动配置完成了bean对象的创建。</p><p>体验了SpringBoot的自动配置了，下面我们就来分析自动配置的原理。其实分析自动配置原理就是来解析在SpringBoot项目中，在引入依赖之后是如何将依赖jar包当中所定义的配置类以及bean加载到SpringIOC容器中的。</p><h4 id="3-2-2-常见方案"><a href="#3-2-2-常见方案" class="headerlink" title="3.2.2 常见方案"></a>3.2.2 常见方案</h4><h5 id="3-2-2-1-概述"><a href="#3-2-2-1-概述" class="headerlink" title="3.2.2.1 概述"></a>3.2.2.1 概述</h5><p>我们知道了什么是自动配置之后，接下来我们就要来剖析自动配置的原理。解析自动配置的原理就是分析在 SpringBoot项目当中，我们引入对应的依赖之后，是如何将依赖jar包当中所提供的bean以及配置类直接加载到当前项目的SpringIOC容器当中的。</p><p>接下来，我们就直接通过代码来分析自动配置原理。</p><blockquote><p>准备工作：在Idea中导入”资料\03. 自动配置原理”下的itheima-utils工程</p></blockquote><p>1、在SpringBoot项目 spring-boot-web-config2 工程中，通过坐标引入itheima-utils依赖</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114224107653.png" alt="image-20230114224107653"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenParser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TokenParser ... parse ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在测试类中，添加测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTokenParse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(TokenParser.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、执行测试方法</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114225018255.png" alt="image-20230114225018255"></p><blockquote><p>异常信息描述： 没有com.example.TokenParse类型的bean</p><p>说明：在Spring容器中没有找到com.example.TokenParse类型的bean对象</p></blockquote><p>思考：引入进来的第三方依赖当中的bean以及配置类为什么没有生效？</p><ul><li>原因在我们之前讲解IOC的时候有提到过，在类上添加@Component注解来声明bean对象时，还需要保证@Component注解能被Spring的组件扫描到。</li><li>SpringBoot项目中的@SpringBootApplication注解，具有包扫描的作用，但是它只会扫描启动类所在的当前包以及子包。 </li><li>当前包：com.itheima， 第三方依赖中提供的包：com.example（扫描不到）</li></ul><p>那么如何解决以上问题的呢？</p><ul><li>方案1：@ComponentScan 组件扫描</li><li>方案2：@Import 导入（使用@Import导入的类会被Spring加载到IOC容器中）</li></ul><h5 id="3-2-2-2-方案一"><a href="#3-2-2-2-方案一" class="headerlink" title="3.2.2.2 方案一"></a>3.2.2.2 方案一</h5><p>@ComponentScan组件扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima&quot;,&quot;com.example&quot;&#125;)</span> <span class="comment">//指定要扫描的包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新执行测试方法，控制台日志输出：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114231121016.png" alt="image-20230114231121016"></p><blockquote><p>大家可以想象一下，如果采用以上这种方式来完成自动配置，那我们进行项目开发时，当需要引入大量的第三方的依赖，就需要在启动类上配置N多要扫描的包，这种方式会很繁琐。而且这种大面积的扫描性能也比较低。</p><p>缺点：</p><ol><li>使用繁琐</li><li>性能低</li></ol><p><strong>结论：SpringBoot中并没有采用以上这种方案。</strong></p></blockquote><h5 id="3-2-2-3-方案二"><a href="#3-2-2-3-方案二" class="headerlink" title="3.2.2.3 方案二"></a>3.2.2.3 方案二</h5><p>@Import导入</p><ul><li>导入形式主要有以下几种：<ol><li>导入普通类</li><li>导入配置类</li><li>导入ImportSelector接口实现类</li></ol></li></ul><p>1). 使用@Import导入普通类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(TokenParser.class)</span> <span class="comment">//导入的类会被Spring加载到IOC容器中</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重新执行测试方法，控制台日志输出：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114231709392.png" alt="image-20230114231709392"></p></blockquote><p>2). 使用@Import导入配置类：</p><ul><li>配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HeaderGenerator <span class="title function_">headerGenerator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(HeaderConfig.class)</span> <span class="comment">//导入配置类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHeaderParser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(HeaderParser.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHeaderGenerator</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(HeaderGenerator.class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行测试方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114233252259.png" alt="image-20230114233252259"></p></blockquote><p>3). 使用@Import导入ImportSelector接口实现类：</p><ul><li>ImportSelector接口实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="comment">//返回值字符串数组（数组中封装了全限定名称的类）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.example.HeaderConfig&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(MyImportSelector.class)</span> <span class="comment">//导入ImportSelector接口实现类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行测试方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114234222946.png" alt="image-20230114234222946"></p></blockquote><p>我们使用@Import注解通过这三种方式都可以导入第三方依赖中所提供的bean或者是配置类。</p><p>思考：如果基于以上方式完成自动配置，当要引入一个第三方依赖时，是不是还要知道第三方依赖中有哪些配置类和哪些Bean对象？</p><ul><li>答案：是的。 （对程序员来讲，很不友好，而且比较繁琐）</li></ul><p>思考：当我们要使用第三方依赖，依赖中到底有哪些bean和配置类，谁最清楚？</p><ul><li>答案：第三方依赖自身最清楚。</li></ul><blockquote><p><strong>结论：我们不用自己指定要导入哪些bean对象和配置类了，让第三方依赖它自己来指定。</strong></p></blockquote><p>怎么让第三方依赖自己指定bean对象和配置类？</p><ul><li>比较常见的方案就是第三方依赖给我们提供一个注解，这个注解一般都以@EnableXxxx开头的注解，注解中封装的就是@Import注解</li></ul><p>4). 使用第三方依赖提供的 @EnableXxxxx注解</p><ul><li>第三方依赖中提供的注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span><span class="comment">//指定要导入哪些bean对象或配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHeaderConfig &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在使用时只需在启动类上加上@EnableXxxxx注解即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHeaderConfig</span>  <span class="comment">//使用第三方依赖提供的Enable开头的注解</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行测试方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114233252259.png" alt="image-20230114233252259"></p></blockquote><p>以上四种方式都可以完成导入操作，但是第4种方式会更方便更优雅，而这种方式也是SpringBoot当中所采用的方式。</p><h4 id="3-2-3-原理分析"><a href="#3-2-3-原理分析" class="headerlink" title="3.2.3 原理分析"></a>3.2.3 原理分析</h4><h5 id="3-2-3-1-源码跟踪"><a href="#3-2-3-1-源码跟踪" class="headerlink" title="3.2.3.1 源码跟踪"></a>3.2.3.1 源码跟踪</h5><p>前面我们讲解了在项目当中引入第三方依赖之后，如何加载第三方依赖中定义好的bean对象以及配置类，从而完成自动配置操作。那下面我们通过源码跟踪的形式来剖析下SpringBoot底层到底是如何完成自动配置的。</p><blockquote><p>源码跟踪技巧：</p><p>在跟踪框架源码的时候，一定要抓住关键点，找到核心流程。一定不要从头到尾一行代码去看，一个方法的去研究，一定要找到关键流程，抓住关键点，先在宏观上对整个流程或者整个原理有一个认识，有精力再去研究其中的细节。</p></blockquote><p>要搞清楚SpringBoot的自动配置原理，要从SpringBoot启动类上使用的核心注解@SpringBootApplication开始分析：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115001439110.png" alt="image-20230115001439110"></p><p>在@SpringBootApplication注解中包含了：</p><ul><li>元注解（不再解释）</li><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><p>我们先来看第一个注解：@SpringBootConfiguration</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115001950076.png" alt="image-20230115001950076"></p><blockquote><p>@SpringBootConfiguration注解上使用了@Configuration，表明SpringBoot启动类就是一个配置类。</p><p>@Indexed注解，是用来加速应用启动的（不用关心）。</p></blockquote><p>接下来再先看@ComponentScan注解：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115002450993.png" alt="image-20230115002450993"></p><blockquote><p>@ComponentScan注解是用来进行组件扫描的，扫描启动类所在的包及其子包下所有被@Component及其衍生注解声明的类。</p><p>SpringBoot启动类，之所以具备扫描包功能，就是因为包含了@ComponentScan注解。</p></blockquote><p>最后我们来看看@EnableAutoConfiguration注解（自动配置核心注解）：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115002743115.png" alt="image-20230115002743115"></p><blockquote><p>使用@Import注解，导入了实现ImportSelector接口的实现类。</p><p>AutoConfigurationImportSelector类是ImportSelector接口的实现类。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115003242549.png" alt="image-20230115003242549"></p></blockquote><p>AutoConfigurationImportSelector类中重写了ImportSelector接口的selectImports()方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115003348288.png" alt="image-20230115003348288"></p><blockquote><p>selectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合</p></blockquote><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115003704385.png" alt="image-20230115003704385"></p><blockquote><p>getAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合</p></blockquote><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115003903302.png" alt="image-20230115003903302"></p><blockquote><p>getCandidateConfigurations方法的功能：</p><p>获取所有基于META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports文件、META-INF&#x2F;spring.factories文件中配置类的集合</p></blockquote><p>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports文件和META-INF&#x2F;spring.factories文件这两个文件在哪里呢？</p><ul><li>通常在引入的起步依赖中，都有包含以上两个文件</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230129090835964.png" alt="image-20230129090835964"> </p><p><img src="/2024/03/26/Java/springboot/image-20230115064329460.png" alt="image-20230115064329460"></p><p>在前面在给大家演示自动配置的时候，我们直接在测试类当中注入了一个叫gson的bean对象，进行JSON格式转换。虽然我们没有配置bean对象，但是我们是可以直接注入使用的。原因就是因为在自动配置类当中做了自动配置。到底是在哪个自动配置类当中做的自动配置呢？我们通过搜索来查询一下。</p><p>在META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports配置文件中指定了第三方依赖Gson的配置类：GsonAutoConfiguration</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115005159530.png" alt="image-20230115005159530"></p><p>第三方依赖中提供的GsonAutoConfiguration类：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115005418900.png" alt="image-20230115005418900"></p><blockquote><p>在GsonAutoConfiguration类上，添加了注解@AutoConfiguration，通过查看源码，可以明确：GsonAutoConfiguration类是一个配置。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115065247287.png" alt="image-20230115065247287"></p></blockquote><p>看到这里，大家就应该明白为什么可以完成自动配置了，原理就是在配置类中定义一个@Bean标识的方法，而Spring会自动调用配置类中使用@Bean标识的方法，并把方法的返回值注册到IOC容器中。</p><p><strong>自动配置源码小结</strong></p><p>自动配置原理源码入口就是@SpringBootApplication注解，在这个注解中封装了3个注解，分别是：</p><ul><li>@SpringBootConfiguration<ul><li>声明当前类是一个配置类</li></ul></li><li>@ComponentScan<ul><li>进行组件扫描（SpringBoot中默认扫描的是启动类所在的当前包及其子包）</li></ul></li><li>@EnableAutoConfiguration<ul><li>封装了@Import注解（Import注解中指定了一个ImportSelector接口的实现类）<ul><li>在实现类重写的selectImports()方法，读取当前项目下所有依赖jar包中META-INF&#x2F;spring.factories、META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports两个文件里面定义的配置类（配置类中定义了@Bean注解标识的方法）。</li></ul></li></ul></li></ul><p>当SpringBoot程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息(类的全限定名)封装到String类型的数组中，最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中，交给IOC容器管理。</p><blockquote><p>最后呢给大家抛出一个问题：在META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，那这些bean都会注册到Spring的IOC容器中吗？</p><p>答案：并不是。 在声明bean对象时，上面有加一个以@Conditional开头的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）</p></blockquote><h5 id="3-2-3-2-Conditional"><a href="#3-2-3-2-Conditional" class="headerlink" title="3.2.3.2 @Conditional"></a>3.2.3.2 @Conditional</h5><p>我们在跟踪SpringBoot自动配置的源码的时候，在自动配置类声明bean的时候，除了在方法上加了一个@Bean注解以外，还会经常用到一个注解，就是以Conditional开头的这一类的注解。以Conditional开头的这些注解都是条件装配的注解。下面我们就来介绍下条件装配注解。</p><p>@Conditional注解：</p><ul><li>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring的IOC容器中。</li><li>位置：方法、类</li><li>@Conditional本身是一个父注解，派生出大量的子注解：<ul><li>@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。</li><li>@ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。</li><li>@ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。</li></ul></li></ul><p>下面我们通过代码来演示下Conditional注解的使用：</p><ul><li>@ConditionalOnClass注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name=&quot;io.jsonwebtoken.Jwts&quot;)</span><span class="comment">//环境中存在指定的这个类，才会将该bean加入IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pom.xml</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--JWT令牌--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">0.9</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHeaderParser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(HeaderParser.class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行testHeaderParser()测试方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115203748022.png" alt="image-20230115203748022"></p><p>因为io.jsonwebtoken.Jwts字节码文件在启动SpringBoot程序时已存在，所以创建HeaderParser对象并注册到IOC容器中。</p></blockquote><ul><li>@ConditionalOnMissingBean注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">//不存在该类型的bean，才会将该bean加入IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行testHeaderParser()测试方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115211029855.png" alt="image-20230115211029855"></p><p>SpringBoot在调用@Bean标识的headerParser()前，IOC容器中是没有HeaderParser类型的bean，所以HeaderParser对象正常创建，并注册到IOC容器中。</p></blockquote><p>再次修改@ConditionalOnMissingBean注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name=&quot;deptController2&quot;)</span><span class="comment">//不存在指定名称的bean，才会将该bean加入IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行testHeaderParser()测试方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115211351681.png" alt="image-20230115211351681"></p><p>因为在SpringBoot环境中不存在名字叫deptController2的bean对象，所以创建HeaderParser对象并注册到IOC容器中。</p></blockquote><p>再次修改@ConditionalOnMissingBean注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(HeaderConfig.class)</span><span class="comment">//不存在指定类型的bean，才会将bean加入IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHeaderParser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(applicationContext.getBean(HeaderParser.class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行testHeaderParser()测试方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115211957191.png" alt="image-20230115211957191"></p><p>因为HeaderConfig类中添加@Configuration注解，而@Configuration注解中包含了@Component，所以SpringBoot启动时会创建HeaderConfig类对象，并注册到IOC容器中。</p><p>当IOC容器中有HeaderConfig类型的bean存在时，不会把创建HeaderParser对象注册到IOC容器中。而IOC容器中没有HeaderParser类型的对象时，通过getBean(HeaderParser.class)方法获取bean对象时，引发异常：NoSuchBeanDefinitionException</p></blockquote><ul><li>@ConditionalOnProperty注解（这个注解和配置文件当中配置的属性有关系）</li></ul><p>先在application.yml配置文件中添加如下的键值对：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">itheima</span></span><br></pre></td></tr></table></figure><p>在声明bean的时候就可以指定一个条件@ConditionalOnProperty</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(name =&quot;name&quot;,havingValue = &quot;itheima&quot;)</span><span class="comment">//配置文件中存在指定属性名与值，才会将bean加入IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HeaderGenerator <span class="title function_">headerGenerator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行testHeaderParser()测试方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115220235511.png" alt="image-20230115220235511"></p></blockquote><p>修改@ConditionalOnProperty注解：  havingValue的值修改为”itheima2”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name =&quot;name&quot;,havingValue = &quot;itheima2&quot;)</span><span class="comment">//配置文件中存在指定属性名与值，才会将bean加入IOC容器</span></span><br><span class="line"><span class="keyword">public</span> HeaderParser <span class="title function_">headerParser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderParser</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再次执行testHeaderParser()测试方法：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115211957191.png" alt="image-20230115211957191"></p><p>因为application.yml配置文件中，不存在： name:  itheima2，所以HeaderParser对象在IOC容器中不存在</p></blockquote><p>我们再回头看看之前讲解SpringBoot源码时提到的一个配置类：GsonAutoConfiguration</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115222128740.png" alt="image-20230115222128740"></p><p>最后再给大家梳理一下自动配置原理：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115222302753.png" alt="image-20230115222302753"></p><blockquote><p>自动配置的核心就在@SpringBootApplication注解上，SpringBootApplication这个注解底层包含了3个注解，分别是：</p><ul><li><p>@SpringBootConfiguration</p></li><li><p>@ComponentScan</p></li><li><p>@EnableAutoConfiguration</p></li></ul><p>@EnableAutoConfiguration这个注解才是自动配置的核心。</p><ul><li>它封装了一个@Import注解，Import注解里面指定了一个ImportSelector接口的实现类。</li><li>在这个实现类中，重写了ImportSelector接口中的selectImports()方法。</li><li>而selectImports()方法中会去读取两份配置文件，并将配置文件中定义的配置类做为selectImports()方法的返回值返回，返回值代表的就是需要将哪些类交给Spring的IOC容器进行管理。</li><li>那么所有自动配置类的中声明的bean都会加载到Spring的IOC容器中吗? 其实并不会，因为这些配置类中在声明bean时，通常都会添加@Conditional开头的注解，这个注解就是进行条件装配。而Spring会根据Conditional注解有选择性的进行bean的创建。</li><li>@Enable 开头的注解底层，它就封装了一个注解 import 注解，它里面指定了一个类，是 ImportSelector 接口的实现类。在实现类当中，我们需要去实现 ImportSelector  接口当中的一个方法 selectImports 这个方法。这个方法的返回值代表的就是我需要将哪些类交给 spring 的 IOC容器进行管理。</li><li>此时它会去读取两份配置文件，一份儿是 spring.factories，另外一份儿是 autoConfiguration.imports。而在  autoConfiguration.imports 这份儿文件当中，它就会去配置大量的自动配置的类。</li><li>而前面我们也提到过这些所有的自动配置类当中，所有的 bean都会加载到 spring 的 IOC 容器当中吗？其实并不会，因为这些配置类当中，在声明 bean 的时候，通常会加上这么一类@Conditional 开头的注解。这个注解就是进行条件装配。所以SpringBoot非常的智能，它会根据 @Conditional 注解来进行条件装配。只有条件成立，它才会声明这个bean，才会将这个 bean 交给 IOC 容器管理。</li></ul></blockquote><h4 id="3-2-4-案例"><a href="#3-2-4-案例" class="headerlink" title="3.2.4 案例"></a>3.2.4 案例</h4><h5 id="3-2-4-1-自定义starter分析"><a href="#3-2-4-1-自定义starter分析" class="headerlink" title="3.2.4.1 自定义starter分析"></a>3.2.4.1 自定义starter分析</h5><p>前面我们解析了SpringBoot中自动配置的原理，下面我们就通过一个自定义starter案例来加深大家对于自动配置原理的理解。首先介绍一下自定义starter的业务场景，再来分析一下具体的操作步骤。</p><p>所谓starter指的就是SpringBoot当中的起步依赖。在SpringBoot当中已经给我们提供了很多的起步依赖了，我们为什么还需要自定义 starter 起步依赖？这是因为在实际的项目开发当中，我们可能会用到很多第三方的技术，并不是所有的第三方的技术官方都给我们提供了与SpringBoot整合的starter起步依赖，但是这些技术又非常的通用，在很多项目组当中都在使用。</p><p>业务场景：</p><ul><li>我们前面案例当中所使用的阿里云OSS对象存储服务，现在阿里云的官方是没有给我们提供对应的起步依赖的，这个时候使用起来就会比较繁琐，我们需要引入对应的依赖。我们还需要在配置文件当中进行配置，还需要基于官方SDK示例来改造对应的工具类，我们在项目当中才可以进行使用。</li><li>大家想在我们当前项目当中使用了阿里云OSS，我们需要进行这么多步的操作。在别的项目组当中要想使用阿里云OSS，是不是也需要进行这么多步的操作，所以这个时候我们就可以自定义一些公共组件，在这些公共组件当中，我就可以提前把需要配置的bean都提前配置好。将来在项目当中，我要想使用这个技术，我直接将组件对应的坐标直接引入进来，就已经自动配置好了，就可以直接使用了。我们也可以把公共组件提供给别的项目组进行使用，这样就可以大大的简化我们的开发。</li></ul><p>在SpringBoot项目中，一般都会将这些公共组件封装为SpringBoot当中的starter，也就是我们所说的起步依赖。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115224939131.png" alt="image-20230115224939131"></p><blockquote><p>SpringBoot官方starter命名： spring-boot-starter-xxxx</p><p>第三组织提供的starter命名：  xxxx-spring-boot-starter</p></blockquote><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115225703863.png" alt="image-20230115225703863"></p><blockquote><p>Mybatis提供了配置类，并且也提供了springboot会自动读取的配置文件。当SpringBoot项目启动时，会读取到spring.factories配置文件中的配置类并加载配置类，生成相关bean对象注册到IOC容器中。</p><p>结果：我们可以直接在SpringBoot程序中使用Mybatis自动配置的bean对象。</p></blockquote><p>在自定义一个起步依赖starter的时候，按照规范需要定义两个模块：</p><ol><li>starter模块（进行依赖管理[把程序开发所需要的依赖都定义在starter起步依赖中]）</li><li>autoconfigure模块（自动配置）</li></ol><blockquote><p>将来在项目当中进行相关功能开发时，只需要引入一个起步依赖就可以了，因为它会将autoconfigure自动配置的依赖给传递下来。</p></blockquote><p>上面我们简单介绍了自定义starter的场景，以及自定义starter时涉及到的模块之后，接下来我们就来完成一个自定义starter的案例。</p><p>需求：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类AliyunOSSUtils的自动配置。</p><p>目标：引入起步依赖引入之后，要想使用阿里云OSS，注入AliyunOSSUtils直接使用即可。</p><p>之前阿里云OSS的使用：</p><ul><li>配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置阿里云OSS参数</span></span><br><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">oss:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">https://oss-cn-shanghai.aliyuncs.com</span></span><br><span class="line">    <span class="attr">accessKeyId:</span> <span class="string">LTAI5t9MZK8iq5T2Av5GLDxX</span></span><br><span class="line">    <span class="attr">accessKeySecret:</span> <span class="string">C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc</span></span><br><span class="line">    <span class="attr">bucketName:</span> <span class="string">web-framework01</span></span><br></pre></td></tr></table></figure><ul><li>AliOSSProperties类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSProperties</span> &#123;</span><br><span class="line">    <span class="comment">//区域</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="comment">//身份ID</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId ;</span><br><span class="line">    <span class="comment">//身份密钥</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret ;</span><br><span class="line">    <span class="comment">//存储空间</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>AliOSSUtils工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//当前类对象由Spring创建和管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSUtils</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliOSSProperties aliOSSProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现上传图片到OSS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取上传的文件的输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> multipartFile.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免文件覆盖</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> multipartFile.getOriginalFilename();</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上传文件到 OSS</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(aliOSSProperties.getEndpoint(),</span><br><span class="line">                aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret());</span><br><span class="line">        ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span>aliOSSProperties.getEndpoint().split(<span class="string">&quot;//&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;//&quot;</span> + aliOSSProperties.getBucketName() + <span class="string">&quot;.&quot;</span> + aliOSSProperties.getEndpoint().split(<span class="string">&quot;//&quot;</span>)[<span class="number">1</span>] + <span class="string">&quot;/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭ossClient</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        <span class="keyword">return</span> url;<span class="comment">// 把上传到oss的路径返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在项目当中要使用阿里云OSS，就可以注入AliOSSUtils工具类来进行文件上传。但这种方式其实是比较繁琐的。</p><p>大家再思考，现在我们使用阿里云OSS，需要做这么几步，将来大家在开发其他的项目的时候，你使用阿里云OSS，这几步你要不要做？当团队中其他小伙伴也在使用阿里云OSS的时候，步骤 不也是一样的。</p><p>所以这个时候我们就可以制作一个公共组件(自定义starter)。starter定义好之后，将来要使用阿里云OSS进行文件上传，只需要将起步依赖引入进来之后，就可以直接注入AliOSSUtils使用了。</p><p>需求明确了，接下来我们再来分析一下具体的实现步骤：</p><ul><li>第1步：创建自定义starter模块（进行依赖管理）<ul><li>把阿里云OSS所有的依赖统一管理起来</li></ul></li><li>第2步：创建autoconfigure模块<ul><li>在starter中引入autoconfigure （我们使用时只需要引入starter起步依赖即可）</li></ul></li><li>第3步：在autoconfigure中完成自动配置<ol><li>定义一个自动配置类，在自动配置类中将所要配置的bean都提前配置好</li><li>定义配置文件，把自动配置类的全类名定义在配置文件中</li></ol></li></ul><p>我们分析完自定义阿里云OSS自动配置的操作步骤了，下面我们就按照分析的步骤来实现自定义starter。</p><h5 id="3-2-4-2-自定义starter实现"><a href="#3-2-4-2-自定义starter实现" class="headerlink" title="3.2.4.2 自定义starter实现"></a>3.2.4.2 自定义starter实现</h5><p>自定义starter的步骤我们刚才已经分析了，接下来我们就按照分析的步骤来完成自定义starter的开发。</p><p>首先我们先来创建两个Maven模块：</p><p>1). aliyun-oss-spring-boot-starter模块</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115234739988.png" alt="image-20230115234739988"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115234823134.png" alt="image-20230115234823134"></p><p>创建完starter模块后，删除多余的文件，最终保留内容如下：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115235429353.png" alt="image-20230115235429353"></p><p>删除pom.xml文件中多余的内容后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2). aliyun-oss-spring-boot-autoconfigure模块</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116000302319.png" alt="image-20230116000302319"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230115235921014.png" alt="image-20230115235921014"></p><p>创建完starter模块后，删除多余的文件，最终保留内容如下：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116000542905.png" alt="image-20230116000542905"></p><p>删除pom.xml文件中多余的内容后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照我们之前的分析，是需要在starter模块中来引入autoconfigure这个模块的。打开starter模块中的pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入autoconfigure模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前两步已经完成了，接下来是最关键的就是第三步：</p><p>在autoconfigure模块当中来完成自动配置操作。</p><blockquote><p> 我们将之前案例中所使用的阿里云OSS部分的代码直接拷贝到autoconfigure模块下，然后进行改造就行了。</p></blockquote><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116001622679.png" alt="image-20230116001622679"></p><p>拷贝过来后，还缺失一些相关的依赖，需要把相关依赖也拷贝过来：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入web起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Lombok--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--阿里云OSS--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.15.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- no more than 2.3.3--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在大家思考下，在类上添加的@Component注解还有用吗？</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116002417105.png" alt="image-20230116002417105"></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116002442736.png" alt="image-20230116002442736"></p><p>答案：没用了。  在SpringBoot项目中，并不会去扫描com.aliyun.oss这个包，不扫描这个包那类上的注解也就失去了作用。</p><blockquote><p>@Component注解不需要使用了，可以从类上删除了。</p><p>删除后报红色错误，暂时不理会，后面再来处理。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116002747681.png" alt="image-20230116002747681"></p><p>删除AliOSSUtils类中的@Component注解、@Autowired注解</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116003046768.png" alt="image-20230116003046768"></p></blockquote><p>下面我们就要定义一个自动配置类了，在自动配置类当中来声明AliOSSUtils的bean对象。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116003513900.png" alt="image-20230116003513900"></p><p> AliOSSAutoConfiguration类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//当前类为Spring配置类</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AliOSSProperties.class)</span><span class="comment">//导入AliOSSProperties类，并交给SpringIOC管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建AliOSSUtils对象，并交给SpringIOC容器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AliOSSUtils <span class="title function_">aliOSSUtils</span><span class="params">(AliOSSProperties aliOSSProperties)</span>&#123;</span><br><span class="line">        <span class="type">AliOSSUtils</span> <span class="variable">aliOSSUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliOSSUtils</span>();</span><br><span class="line">        aliOSSUtils.setAliOSSProperties(aliOSSProperties);</span><br><span class="line">        <span class="keyword">return</span> aliOSSUtils;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AliOSSProperties类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*阿里云OSS相关配置*/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSProperties</span> &#123;</span><br><span class="line">    <span class="comment">//区域</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="comment">//身份ID</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId ;</span><br><span class="line">    <span class="comment">//身份密钥</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret ;</span><br><span class="line">    <span class="comment">//存储空间</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AliOSSUtils类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AliOSSProperties aliOSSProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现上传图片到OSS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取上传的文件的输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> multipartFile.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免文件覆盖</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> multipartFile.getOriginalFilename();</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上传文件到 OSS</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(aliOSSProperties.getEndpoint(),</span><br><span class="line">                aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret());</span><br><span class="line">        ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span>aliOSSProperties.getEndpoint().split(<span class="string">&quot;//&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;//&quot;</span> + aliOSSProperties.getBucketName() + <span class="string">&quot;.&quot;</span> + aliOSSProperties.getEndpoint().split(<span class="string">&quot;//&quot;</span>)[<span class="number">1</span>] + <span class="string">&quot;/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭ossClient</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        <span class="keyword">return</span> url;<span class="comment">// 把上传到oss的路径返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在aliyun-oss-spring-boot-autoconfigure模块中的resources下，新建自动配置文件：</p><ul><li><p>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.aliyun.oss.AliOSSAutoConfiguration</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116004957697.png" alt="image-20230116004957697"></p><h5 id="3-2-4-3-自定义starter测试"><a href="#3-2-4-3-自定义starter测试" class="headerlink" title="3.2.4.3 自定义starter测试"></a>3.2.4.3 自定义starter测试</h5><p>阿里云OSS的starter我们刚才已经定义好了，接下来我们就来做一个测试。</p><blockquote><p>今天的课程资料当中，提供了一个自定义starter的测试工程。我们直接打开文件夹，里面有一个测试工程。测试工程就是springboot-autoconfiguration-test，我们只需要将测试工程直接导入到Idea当中即可。</p></blockquote><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116005530815.png" alt="image-20230116005530815"></p><p>测试前准备：</p><ol><li><p>在test工程中引入阿里云starter依赖</p><ul><li>通过依赖传递，会把autoconfigure依赖也引入了</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入阿里云OSS起步依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在test工程中的application.yml文件中，配置阿里云OSS配置参数信息（从以前的工程中拷贝即可）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置阿里云OSS参数</span></span><br><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">oss:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">https://oss-cn-shanghai.aliyuncs.com</span></span><br><span class="line">    <span class="attr">accessKeyId:</span> <span class="string">LTAI5t9MZK8iq5T2Av5GLDxX</span></span><br><span class="line">    <span class="attr">accessKeySecret:</span> <span class="string">C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc</span></span><br><span class="line">    <span class="attr">bucketName:</span> <span class="string">web-framework01</span></span><br></pre></td></tr></table></figure></li><li><p>在test工程中的UploadController类编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliOSSUtils aliOSSUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile image)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//上传文件到阿里云 OSS</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> aliOSSUtils.upload(image);</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>编写完代码后，我们启动当前的SpringBoot测试工程：</p><ul><li>随着SpringBoot项目启动，自动配置会把AliOSSUtils的bean对象装配到IOC容器中</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116011039611.png" alt="image-20230116011039611"></p><p>用postman工具进行文件上传：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116010731914.png" alt="image-20230116010731914"></p><p>通过断点可以看到自动注入AliOSSUtils的bean对象：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230116011501201.png" alt="image-20230116011501201"></p><h2 id="4-Web后端开发总结"><a href="#4-Web后端开发总结" class="headerlink" title="4. Web后端开发总结"></a>4. Web后端开发总结</h2><p>到此基于SpringBoot进行web后端开发的相关知识我们已经学习完毕了。下面我们一起针对这段web课程做一个总结。</p><p>我们来回顾一下关于web后端开发，我们都学习了哪些内容，以及每一块知识，具体是属于哪个框架的。</p><p>web后端开发现在基本上都是基于标准的三层架构进行开发的，在三层架构当中，Controller控制器层负责接收请求响应数据，Service业务层负责具体的业务逻辑处理，而Dao数据访问层也叫持久层，就是用来处理数据访问操作的，来完成数据库当中数据的增删改查操作。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114180044897.png" alt="image-20230114180044897"></p><blockquote><p>在三层架构当中，前端发起请求首先会到达Controller(不进行逻辑处理)，然后Controller会直接调用Service 进行逻辑处理， Service再调用Dao完成数据访问操作。</p></blockquote><p>如果我们在执行具体的业务处理之前，需要去做一些通用的业务处理，比如：我们要进行统一的登录校验，我们要进行统一的字符编码等这些操作时，我们就可以借助于Javaweb当中三大组件之一的过滤器Filter或者是Spring当中提供的拦截器Interceptor来实现。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114191737227.png" alt="image-20230114191737227"></p><p>而为了实现三层架构层与层之间的解耦，我们学习了Spring框架当中的第一大核心：IOC控制反转与DI依赖注入。</p><blockquote><p>所谓控制反转，指的是将对象创建的控制权由应用程序自身交给外部容器，这个容器就是我们常说的IOC容器或Spring容器。</p><p>而DI依赖注入指的是容器为程序提供运行时所需要的资源。</p></blockquote><p>除了IOC与DI我们还讲到了AOP面向切面编程，还有Spring中的事务管理、全局异常处理器，以及传递会话技术Cookie、Session以及新的会话跟踪解决方案JWT令牌，阿里云OSS对象存储服务，以及通过Mybatis持久层架构操作数据库等技术。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114192921673.png" alt="image-20230114192921673"></p><p>我们在学习这些web后端开发技术的时候，我们都是基于主流的SpringBoot进行整合使用的。而SpringBoot又是用来简化开发，提高开发效率的。像过滤器、拦截器、IOC、DI、AOP、事务管理等这些技术到底是哪个框架提供的核心功能？</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114193609782.png" alt="image-20230114193609782"></p><blockquote><p>Filter过滤器、Cookie、 Session这些都是传统的JavaWeb提供的技术。</p><p>JWT令牌、阿里云OSS对象存储服务，是现在企业项目中常见的一些解决方案。</p><p>IOC控制反转、DI依赖注入、AOP面向切面编程、事务管理、全局异常处理、拦截器等，这些技术都是 Spring Framework框架当中提供的核心功能。</p><p>Mybatis就是一个持久层的框架，是用来操作数据库的。</p></blockquote><p>在Spring框架的生态中，对web程序开发提供了很好的支持，如：全局异常处理器、拦截器这些都是Spring框架中web开发模块所提供的功能，而Spring框架的web开发模块，我们也称为：SpringMVC</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230114195143418.png" alt="image-20230114195143418"></p><blockquote><p>SpringMVC不是一个单独的框架，它是Spring框架的一部分，是Spring框架中的web开发模块，是用来简化原始的Servlet程序开发的。</p></blockquote><p>外界俗称的SSM，就是由：SpringMVC、Spring Framework、Mybatis三块组成。</p><p>基于传统的SSM框架进行整合开发项目会比较繁琐，而且效率也比较低，所以在现在的企业项目开发当中，基本上都是直接基于SpringBoot整合SSM进行项目开发的。</p><p>到此我们web后端开发的内容就已经全部讲解结束了。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/26/hello-world/"/>
      <url>/2024/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line"><span class="built_in">date</span>:</span><br><span class="line">updated:</span><br><span class="line"><span class="built_in">type</span>:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><button id="code1Btn">Show Code 1</button><br><button id="code2Btn">Show Code 2</button><br><button id="code3Btn">Show Code 3</button><br><button id="code4Btn">Show Code 4</button></p>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello </tag>
            
            <tag> World </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb笔记</title>
      <link href="/2024/03/25/Java/JavaWeb/"/>
      <url>/2024/03/25/Java/JavaWeb/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb开发"><a href="#JavaWeb开发" class="headerlink" title="JavaWeb开发"></a>JavaWeb开发</h1><p>自己在学习web知识时候记得一些笔记，有三万字</p><ol><li>它打通了从前端 &#x3D;&gt; MySQL &#x3D;&gt; Java Web &#x3D;&gt; SSM &#x3D;&gt; Spring Boot &#x3D;&gt; Maven 这一套技术栈</li><li>它包含了像 Postman、MySQL 图形界面等开发工具的使用</li><li>它包含了像登录校验（JWT）、文件上传等常见业务的实践</li><li>它包含了 AOP 应用、SpringBoot 原理、Maven 高级等进阶知识</li></ol><h3 id="初识web前端"><a href="#初识web前端" class="headerlink" title="初识web前端"></a>初识web前端</h3><p>用户在浏览器页面输入网址，是如何得到响应的页面数据的？<br>1.浏览器根据请求的URL网址，查看缓存，如果资源未缓存，则<br>2.交给DNS域名解析，转换为服务器的ip地址，向服务器发起请求<br>3.建立tcp连接：三次握手：<br>    第一次握手：客户端向服务端发送数据包，选择一个起始序列号ISN，表示想建立连接<br>    第二次握手：服务端收到客户端的请求后，确认客户端请求发送带确认标记的数据包，也包括服务端的ISN<br>    第三次握手：客户端收到数据包后，明确了从客户端到服务器之间的数据传输的正常的，都确认了对方的ISN<br>    三次握手的目的是：确保双方能够接受和发送数据，同步双方的初始序列号ISN，这样就建立了可靠的链接，可以惊进行后续的通信<br>    在握手的过程中，如果某个阶段数据包丢失或者延迟，tcp协议会等待一段时间后，重新发送和接收数据，直到建立连接或者放弃链接，<br>4.HTTP请求响应：握手建立连接成功后，客户端发起HTTP请求：包含要访问的信息<br>5.服务器处理请求：服务器收到HTTP请求后，根据请求的资源和参数执行相应的处理，会涉及到数据库的查询和业务逻辑的处理<br>6.服务器返回HTTP响应：根据HTTP响应协议，返回包括状态码，响应头，响应体等等<br>7.浏览器接受响应：接收到后，开始处理，解析HTML文件，解析CSS，构建DOM树，布局和绘制，js代码的执行，最终呈现页面等等（涉及到前端的知识）<br>    HTML：负责网页的结构（页面和元素）<br>    CSS：负责网页的表现（页面元素的外观，位置，颜色大小等）<br>    JS：负责网页的行为（交互，动态，逻辑效果等等）</p><p>HTML：HyperText Markup Language超文本标记语言，除了文本，还能定义图片，音频，视频等内容</p><p>CSS：Cascading Style Sheet 层叠样式表，用于控制页面的样式</p><p>JavaScript：跨平台的面向对象的语言，用于网页的交互，不需要编译运行，直接用于浏览器的解释就可以</p><p>JSON对象：JavaScript Object Notation，JS对象标记法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">“key” <span class="punctuation">:</span>value<span class="punctuation">,</span></span><br><span class="line">“key”<span class="punctuation">:</span>value<span class="punctuation">,</span></span><br><span class="line">“key”<span class="punctuation">:</span>value</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>BOM对象：Browser Object model 浏览器对象模型，将js的各个组成部分分装成对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对象名称描述</span><br><span class="line">Window浏览器窗口对象</span><br><span class="line">Navigator浏览器对象</span><br><span class="line">Screen屏幕对象</span><br><span class="line">History历史记录对象</span><br><span class="line">Locationd地址栏对象</span><br></pre></td></tr></table></figure><h3 id="Vue概述"><a href="#Vue概述" class="headerlink" title="Vue概述"></a>Vue概述</h3><p>Vue是一套前端框架，免除原生js中的DOM操作，简化书写</p><p>基于MVVM的思想：Model-View-ViewModel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model：数据模型，特指前端中通过请求从后端获取数据</span><br><span class="line">view：视图，用于展示数据的页面，可以理解成用html+css搭建的页面，但是没有数据</span><br><span class="line">viewmodel：将数据绑定到视图上，负责将数据model通过js的DOM技术，将数据展示到视图上view上</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue的快速入门</span><br><span class="line">1.新建HTML页面，引入Vue.js文件</span><br><span class="line">2.在JS代码区域，创建Vue对象，定义数据模型</span><br><span class="line">在创建vue对象时，有几个常用的属性：</span><br><span class="line">- el:  用来指定哪儿些标签受 Vue 管理。 该属性取值 `#app` 中的 `app` 需要是受管理的标签的id属性值</span><br><span class="line">- data: 用来定义数据模型</span><br><span class="line">- methods: 用来定义函数。这个我们在后面就会用到</span><br><span class="line">3.编写视图</span><br><span class="line">差值表达式：&#123;&#123;表达式&#125;&#125;。</span><br><span class="line">Vue常用指令：</span><br><span class="line">Html中带有V-前缀 的特殊属性</span><br></pre></td></tr></table></figure><h4 id="Vue生命周期："><a href="#Vue生命周期：" class="headerlink" title="Vue生命周期："></a>Vue生命周期：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">指的是：Vue对象从创建到销毁的全过程，Vue的生命周期包括8个阶段，每触发一个生命周期，就会自动执行一个生命周期的方法</span><br><span class="line">状态阶段周期</span><br><span class="line">beforeCreate创建前</span><br><span class="line">created创建后</span><br><span class="line">beforeMount挂载前</span><br><span class="line">mounted挂载完成</span><br><span class="line">beforeUpdate更新前</span><br><span class="line">updated更新后</span><br><span class="line">beforeDestroy销毁前</span><br><span class="line">destroyed销毁后</span><br></pre></td></tr></table></figure><h4 id="Ajax："><a href="#Ajax：" class="headerlink" title="Ajax："></a>Ajax：</h4><p>（Asynchronous JavaScript and XML）</p><p>是一种用于在不重新加载整个页面的情况下，通过后台与服务器进行异步通信的技术</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">概念：异步的js和xml</span><br><span class="line">作用：通过Ajax可以给服务端发送请求，并获取服务器相应的数据</span><br><span class="line">异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并且更新部分网页的数据</span><br><span class="line"></span><br><span class="line">同步：在服务器请求的过程中，浏览器页面不能做其他的操作，只能等待响应结束</span><br><span class="line"></span><br><span class="line">Ajax 的核心是通过 XMLHttpRequest 对象进行数据的异步传输。该对象提供了在后台与服务器交互的方法和属性。通过 open() 方法指定请求的类型、URL 和是否异步，然后使用 send() 方法发送请求。</span><br></pre></td></tr></table></figure><h4 id="Axios："><a href="#Axios：" class="headerlink" title="Axios："></a>Axios：</h4><p>对原生Ajax的封装，简化书写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Axios 是一个基于 Promise 的 HTTP 客户端，用于在浏览器和 Node.js 环境中发送 HTTP 请求。它是一个流行的 JavaScript 库，简化了对后端 API 的数据请求和响应处理。Axios 支持浏览器环境和Node.js环境，因此可以在前端和后端同时使用。</span><br></pre></td></tr></table></figure><h4 id="YApi"><a href="#YApi" class="headerlink" title="YApi:"></a>YApi:</h4><p>接口文档管理平台</p><h4 id="Vue组件库"><a href="#Vue组件库" class="headerlink" title="Vue组件库"></a>Vue组件库</h4><p>Vue组件库Element</p><p>Element：饿了么开发，基于Vue2.0的桌面组件库</p><p>组件：超链接，按钮，图片，表格表单等</p><h4 id="Nginx服务器"><a href="#Nginx服务器" class="headerlink" title="Nginx服务器"></a>Nginx服务器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Nginx是一个高性能、可靠性强的开源Web服务器软件，也可以用作反向代理服务器、负载均衡器和 HTTP缓存。</span><br><span class="line">特点:轻量级的web服务器，占用内存少，并发能力强</span><br><span class="line"></span><br><span class="line">正向代理：例如：我们直接用国内的服务器访问国外的服务器很慢，或者无法访问，需要在本地搭建一个服务器来帮助我们去访问，这种就是正向代理，浏览器中配置代理服务器</span><br><span class="line"></span><br><span class="line">反向代理：比如我们访问淘宝时候，淘宝内部肯定不止一个服务器，那我们访问的时候，是不是要在服务器中频繁登陆？</span><br><span class="line">搭建过渡服务器，只登录一次，但是访问所有，这就是反向代理，我们只需要把请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器，隐藏了正式服务器的地址。</span><br><span class="line"></span><br><span class="line">作用：隐藏真实服务器： 反向代理服务器隐藏了真实的目标服务器，客户端无法直接访问目标服务器。这提高了服务器的安全性，因为客户端无法得知实际处理请求的服务器的信息。</span><br><span class="line"></span><br><span class="line">负载均衡： 反向代理服务器可以分发客户端的请求到多个目标服务器，以实现负载均衡。这有助于分担服务器的负载，提高整体系统的性能和可用性。</span><br><span class="line"></span><br><span class="line">安全性： 反向代理可以作为一个额外的安全层，过滤恶意请求、拦截攻击，提供安全性功能如SSL终止和Web应用防火墙（WAF）。</span><br><span class="line"></span><br><span class="line">SSL终止： 反向代理可以终止（解密）客户端发来的SSL/TLS加密连接，将请求以明文形式发送到目标服务器，然后将目标服务器的响应重新加密后返回给客户端。这有助于减轻目标服务器的负担。</span><br><span class="line"></span><br><span class="line">缓存： 反向代理服务器可以缓存静态内容，提高访问速度，减轻目标服务器的负载。它可以缓存响应并将相同的响应直接返回给多个客户端，而无需重新请求目标服务器。</span><br><span class="line"></span><br><span class="line">压缩： 反向代理服务器可以对传输到客户端的响应进行压缩，减小传输数据的大小，提高页面加载速度。</span><br><span class="line"></span><br><span class="line">静态资源服务： 反向代理可以专门处理静态资源的请求，如图片、CSS和JavaScript文件，提供更高效的静态资源服务。</span><br><span class="line"></span><br><span class="line">故障转移： 如果目标服务器出现故障，反向代理可以将请求转发到备用服务器，提高系统的可用性。</span><br></pre></td></tr></table></figure><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240129212602769.png" alt="image-20240129212602769" style="zoom: 80%;"><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><p>一款基于JAVA平台的项目管理和整合工具，将项目开发和管理过程，抽象成一个项目对象模型POM，只需要做一些简单的配置，</p><p>Maven就可以自动完成项目的编译，测试，打包，部署</p><p>pom.xml（配置文件）  –&gt;   <strong>POM （项目对象）–&gt;  依赖管理</strong>  –&gt;本地仓库–&gt;私服–&gt;中央仓库</p><p>​                                                 构建生命周期阶段</p><p>​                                                通过一些插件–&gt;生成jar包，源代码，帮助文档，XML等</p><p><strong>Maven作用：</strong></p><p>项目构建：提供方便的，跨平台的自动化构建方式</p><p>依赖管理：管理项目依赖的资源（jar包），避免资源间的版本冲突</p><p>统一开发结构：提供标准的，统一的项目结构</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自己组织的话：基于java的项目构建和管理的工具，主要作用有仨：1.依赖管理：传统手动导入的话很麻烦，还会有jar包之间的冲突（比如要升级一个版本，其他相关的jar包版本都要升级）使用Maven管理的话，直接在pom.xml文件中用修改dependence中的即可，2.统一开发的结构：比如就是我们开发工具是常用的是IDAE，当然也有其他的工具，eclipse等，提供这种统一的开发结构就能让项目在不同的平台哦也能运行 3、项目构建：提供项目周期中的各种插件：包括项目的清理(clean)，编译(compiler),打包(jar)等等</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建Maven工程：配置Maven环境：使用本地安装的Maven，修改配置文件以及本地仓库</span><br></pre></td></tr></table></figure><p>Maven基本概念：仓库，坐标</p><p>仓库：用于存储资源，包含各种jar包</p><p>本地（个人开发者）—局域网—&gt;私服（企业服务器）–&gt;中央仓库（Maven团队）</p><p>本地仓库：</p><p>远程仓库： 私服，中央仓库</p><p>坐标：Maven中坐标用于描述仓库资源的位置</p><p>坐标组成：</p><p>groupID：项目组织</p><p>artifactID：项目名称</p><p>version：版本号</p><p>packageing：打包方式</p><p>坐标作用：找到资源的位置，通过标识将资源的识别与下载交给机器</p><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>...<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>...<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依赖传递：</p><p>直接依赖：在当前项目中通过依赖配置建立依赖关系</p><p>间接依赖：通过依赖的依赖，间接依赖其他资源</p><p>依赖传递的冲突问题：路径优先，层级越深，优先度越低</p><p>可选依赖：对外隐藏 optional</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;<span class="name">optional</span>&gt;</span></span><br></pre></td></tr></table></figure><p>排除依赖 exclusion</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span> junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&lt;artifactidjunit&lt;/artifactId</span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core&lt;/artifactId</span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依赖范围：主程序，测试程序，参与打包</p><p>依赖的jar默认情况下是可以在任何地方使用的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span> compile <span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">compile <span class="comment">&lt;!--默认全局--&gt;</span></span><br><span class="line">test</span><br><span class="line">provided<span class="comment">&lt;!--主代码和测试--&gt;</span></span><br><span class="line">runtime <span class="comment">&lt;!--打包--&gt;</span></span><br></pre></td></tr></table></figure><p>依赖范围的传递性：</p><p>项目构建生命周期：</p><ul><li><p>clean</p></li><li><p>default：主要生命周期，用于构建应用程序</p></li><li><p>site：</p></li></ul><p>插件：插件与生命周期的阶段绑定，执行到对应生命周期时，执行对应插件的功能</p><h2 id="web分析"><a href="#web分析" class="headerlink" title="web分析"></a>web分析</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230906144736342.png" alt="image-20230906144736342"></p><p>浏览器：</p><ul><li><p>输入网址：<code>http://192.168.100.11:8080/hello</code></p><ul><li><p>通过IP地址192.168.100.11定位到网络上的一台计算机</p><blockquote><p>我们之前在浏览器中输入的localhost，就是127.0.0.1（本机）</p></blockquote></li><li><p>通过端口号8080找到计算机上运行的程序</p><blockquote><p><code>localhost:8080</code>  , 意思是在本地计算机中找到正在运行的8080端口的程序</p></blockquote></li><li><p>&#x2F;hello是请求资源位置</p><ul><li>资源：对计算机而言资源就是数据<ul><li>web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据）</li></ul></li></ul><blockquote><p><code>localhost:8080/hello</code> ，意思是向本地计算机中的8080端口程序，获取资源位置是&#x2F;hello的数据</p><ul><li>8080端口程序，在服务器找&#x2F;hello位置的资源数据，发给浏览器</li></ul></blockquote></li></ul></li></ul><p>服务器：（可以理解为ServerSocket）</p><ul><li>接收到浏览器发送的信息（如：&#x2F;hello）</li><li>在服务器上找到&#x2F;hello的资源</li><li>把资源发送给浏览器</li></ul><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP：Hyper Text Transfer Protocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。</p><p>http协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照固定的格式进行数据传输</p><p>特点：</p><ul><li><blockquote><p>是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全</p></blockquote></li><li><p><strong>基于请求-响应模型:</strong>   一次请求对应一次响应（先请求后响应）</p><blockquote><p>请求和响应是一一对应关系，没有请求，就没有响应</p></blockquote></li><li><p><strong>HTTP协议是无状态协议:</strong>  对于数据没有记忆能力。每次请求-响应都是独立的</p></li></ul><p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。</p><ul><li>缺点:  多次请求间不能共享数据</li><li>优点:  速度快</li></ul><h2 id="HTTP-请求协议："><a href="#HTTP-请求协议：" class="headerlink" title="HTTP-请求协议："></a>HTTP-请求协议：</h2><p>浏览器和服务器是按照HTTP协议进行数据通信的。</p><p>HTTP协议又分为：请求协议和响应协议</p><ul><li>请求协议：浏览器将数据以请求格式发送到服务器<ul><li>包括：<strong>请求行</strong>、<strong>请求头</strong> 、<strong>请求体</strong></li></ul></li><li>响应协议：服务器将数据以响应格式返回给浏览器<ul><li>包括：<strong>响应行</strong> 、<strong>响应头</strong> 、<strong>响应体</strong></li></ul></li></ul><table><thead><tr><th align="center">请求方式</th><th align="left">请求说明</th></tr></thead><tbody><tr><td align="center"><strong>GET</strong></td><td align="left">获取资源。<br>向特定的资源发出请求。例：<a href="http://www.baidu.com/s?wd=itheima">http://www.baidu.com/s?wd=itheima</a></td></tr><tr><td align="center"><strong>POST</strong></td><td align="left">传输实体主体。<br>向指定资源提交数据进行处理请求（例：上传文件），数据被包含在请求体中。</td></tr></tbody></table><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230906151225973.png" alt="image-20230906151225973"></p><p>GET请求和POST请求的区别：</p><table><thead><tr><th align="left">区别方式</th><th>GET请求</th><th>POST请求</th></tr></thead><tbody><tr><td align="left">请求参数</td><td>请求参数在请求行中。<br>例：&#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1</td><td>请求参数在请求体中</td></tr><tr><td align="left">请求参数长度</td><td>请求参数长度有限制(浏览器不同限制也不同)</td><td>请求参数长度没有限制</td></tr><tr><td align="left">安全性</td><td>安全性低。原因：请求参数暴露在浏览器地址栏中。</td><td>安全性相对高</td></tr></tbody></table><h2 id="HTTP-响应协议"><a href="#HTTP-响应协议" class="headerlink" title="HTTP-响应协议"></a>HTTP-响应协议</h2><p>格式：与HTTP的请求一样，HTTP响应的数据也分为3部分：<strong>响应行</strong>、<strong>响应头</strong> 、<strong>响应体</strong> </p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230906152641833.png" alt="image-20230906152641833"></p><ul><li><p>响应行(以上图中红色部分)：响应数据的第一行。响应行由<code>协议及版本</code>、<code>响应状态码</code>、<code>状态码描述</code>组成</p><ul><li>协议&#x2F;版本：HTTP&#x2F;1.1</li><li>响应状态码：200</li><li>状态码描述：OK</li></ul></li><li><p>响应头(以上图中黄色部分)：响应数据的第二行开始。格式为key：value形式</p></li></ul><p>响应体(以上图中绿色部分)： 响应数据的最后一部分。存储响应的数据</p><ul><li>响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束）</li></ul><p>响应状态码</p><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong> — 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略</td></tr><tr><td>2xx</td><td><strong>成功</strong> — 表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong> — 重定向到其它地方，让客户端再发起一个请求以完成整个处理</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong> — 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong> — 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><h2 id="HTTP-协议解析-Tomcat"><a href="#HTTP-协议解析-Tomcat" class="headerlink" title="HTTP-协议解析-Tomcat"></a>HTTP-协议解析-Tomcat</h2><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。</p><p>服务器只是一台设备，必须安装服务器软件才能提供相应的服务。</p><p><strong>服务器软件</strong></p><p>服务器软件：基于ServerSocket编写的程序</p><ul><li>服务器软件本质是一个运行在服务器设备上的应用程序</li><li>能够接收客户端请求，并根据请求给客户端响应数据</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/1530625192392.png" alt="1530625192392"></p><h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷。主要功能是”提供网上信息浏览服务”。</p><p>Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><p><strong>Web服务器软件使用步骤</strong></p><ul><li>准备静态资源</li><li>下载安装Web服务器软件</li><li>将静态资源部署到Web服务器上</li><li>启动Web服务器使用浏览器访问对应的资源</li></ul><h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring 是一款轻量级的java开发框架，一般指的是spring framework,他是很多模块的集合，包括springboot快速启动，springcloud微服务，spring Data数据库等spring全家桶</span><br><span class="line"></span><br><span class="line">springboot就是帮助我们快速的构建应用程序，简化开发，提高效率</span><br></pre></td></tr></table></figure><h2 id="springboot入门程序解析"><a href="#springboot入门程序解析" class="headerlink" title="springboot入门程序解析"></a>springboot入门程序解析</h2><p>起步依赖：创建好springboot工程就会导入的依赖，含有starter的</p><h2 id="SpringBootWeb的请求响应"><a href="#SpringBootWeb的请求响应" class="headerlink" title="SpringBootWeb的请求响应"></a>SpringBootWeb的请求响应</h2><p>快速入门程序：</p><p>基于springboot开发一个web应用，浏览器发起&#x2F;hello请求时候，给浏览器返回字符串helloworld，</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230907090532641.png" alt="image-20230907090532641"></p><p>我们在浏览器发起请求，请求了后端web服务器（内置的Tomcat），请求会被部署在Tomcat的Controller接收，然后Controller再给浏览器一个响应helloworld</p><p>其实呢，在Tomcat这类web服务器中，是不识别我们自己定义的Controller类的， </p><p>Tomcat是一个servlet容器，支持servlet规范的，所以在Tomcat中是可以识别servlet程序的</p><p>那我们所编写的XxxController 是如何处理请求的，又与Servlet之间有什么联系呢？</p><p>其实呢，在SpringBoot进行web程序开发时，它内置了一个核心的Servlet程序 DispatcherServlet，称之为 核心控制器。 DispatcherServlet 负责接收页面发送的请求，然后根据执行的规则，将请求再转发给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由DispatcherServlet给浏览器响应数据</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>是一种Java编程模型，用于在Web服务器上处理HTTP请求和响应。Servlet充当了Web应用程序的控制器，允许开发者以Java编写服务器端逻辑，以响应客户端的HTTP请求。</p><h2 id="请求：Postman"><a href="#请求：Postman" class="headerlink" title="请求：Postman"></a>请求：Postman</h2><p>Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。</p><p>可以模拟浏览器向后端服务器发起任何形式(如:get、post)的HTTP请求</p><p>使用Postman还可以在发起请求时，携带一些请求参数、请求头等信息</p><h3 id="简单参数"><a href="#简单参数" class="headerlink" title="简单参数"></a>简单参数</h3><p>在向服务器发起请求时，向服务器传递一些普通的请求数据</p><p>后端程序中，两种方式接受传递过来的普通数据</p><p>1.原始方式：通过servlet中提供的API：</p><p>2.springboot方式：对原始的API进行了封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="comment">//是spring框架中的注解，告诉spring该类是一个控制器，用于处理HPPT的请求和响应</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="comment">//用于将HTTP请求映射到控制器的方法，在这里指定了路径</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name,Integer age)</span>&#123;</span><br><span class="line">        System.out.println(name +<span class="string">&quot;:&quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的作用：用来为代码提供元数据信息的特殊标注，以便在编译，运行，框架扫描，执行特定的操作</p><p>在Java中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编译时注解：作用于编译器，在代码编译时执行特定的操作，例如重写override，就会确保子类正确的覆盖父类的方法</span><br><span class="line"></span><br><span class="line">运行时注解：在运行中执行特定的操作，例如：使用反射机制，获取类的信息，或者配置应用程序</span><br></pre></td></tr></table></figure><p>在springboot中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.依赖注入：@Autowired自动装配bean，当一个类上使用 `@Autowired` 注解时，Spring容器会自动查找并注入满足依赖关系的Bean。减少了手动配置的需求</span><br><span class="line"></span><br><span class="line">2.请求映射：用注解来定义web请求的映射规则，@RequestMapping，@GetMapping用于定义HTTP请求的处理方法</span><br><span class="line"></span><br><span class="line">3.配置管理：例如 @Configuration 用于定义配置类，@Value 用于获取配置属性的值。</span><br><span class="line"></span><br><span class="line">4.AOP（面向切面编程）：Spring Boot支持AOP，可以使用注解如 @Aspect 和 @Around 来实现切面编程。</span><br></pre></td></tr></table></figure><h3 id="RequestParam注解："><a href="#RequestParam注解：" class="headerlink" title="@RequestParam注解："></a>@RequestParam注解：</h3><p>对于简单参数来讲</p><p>请求参数名和controller方法中的形参名不一致时，无法接收到请求数据</p><p>那么如果我们开发中，遇到了这种请求参数名和controller方法中的形参名不相同，怎么办？</p><p>解决方案：可以使用Spring提供的@RequestParam注解完成映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span></span><br><span class="line">    <span class="comment">// 请求参数名：name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//springboot方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username , Integer age )</span>&#123;</span><br><span class="line">        System.out.println(username+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体参数</p><p>简单实体对象：将请求参数封装为一个对象，请求参数名称和实体类的属性名称相同</p><p>复杂实体对象：</p><p>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数。*</p><h3 id="数组和集合参数"><a href="#数组和集合参数" class="headerlink" title="数组和集合参数"></a>数组和集合参数</h3><p>数组：直接使用数组封装</p><p>集合：通过@RequestParam注解绑定参数关系@RequestParam List<String> list</String></p><h3 id="日期参数"><a href="#日期参数" class="headerlink" title="日期参数"></a>日期参数</h3><p>使用注解@DateTimeFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”)注解指明其具体格式完成</p><h3 id="JSON参数：最常见的前后端数据交互方式"><a href="#JSON参数：最常见的前后端数据交互方式" class="headerlink" title="JSON参数：最常见的前后端数据交互方式"></a>JSON参数：最常见的前后端数据交互方式</h3><p>需要使用@Requestbody标识</p><h3 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h3><p>直接在请求的url中传递参数，例如<a href="http://localhost:8080/user/1name">http://localhost:8080/user/1name</a> </p><p>@pathParam</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//路径参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathParam2</span><span class="params">(<span class="meta">@PathVariable</span> Integer id, <span class="meta">@PathVariable</span> String name)</span>&#123;</span><br><span class="line">        System.out.println(id+ <span class="string">&quot; : &quot;</span> +name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@PathVariable注解</p><p>作用：从url中提取并且映射到方法参数中的<strong>占位符</strong>（路径变量）的值</p><p>过程：当一个请求到达spring控制器controller时，spring会解析请求的url，并将其中的路径变量与使用注解的参数方法匹配，匹配成功后，将路径变量的值映射到方法参数中，供方法使用</p><p>@Requestbody注解</p><p>作用：用于将HTTP请求的具体内容（通常为JSON或者xml的数据）映射到JAVA对象上</p><p>过程：当一个HTTP POST请求到达Spring控制器方法时，Spring会从请求体中提取数据，然后使用 <code>@RequestBody</code> 注解的方法参数的类型来进行反序列化，将请求体中的数据映射为Java对象。</p><p>@RequestParam注解</p><p>作用：用于从HTTP请求中获取参数的值，并且将其绑定到方法参数上，供方法使用</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230908140427712.png" alt="image-20230908140427712"></p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>请求响应模式：有请求就有响应</p><p>Controller程序除了接受请求外，还能进行响应，通过@ResponseBody响应，而@ResponseBody又是集成在@ResController中</p><p>@RestController &#x3D; @Controller + @ResponseBody </p><p>@ResponseBody注解</p><ul><li>类型：方法注解、类注解</li><li>位置：书写在Controller方法上或类上</li><li>作用：将方法返回值直接响应给浏览器<ul><li>如果返回值类型是实体对象&#x2F;集合，将会转换为JSON格式后在响应给浏览器</li></ul></li></ul><h3 id="分层解耦合"><a href="#分层解耦合" class="headerlink" title="分层解耦合"></a>分层解耦合</h3><p>三层架构：开发程序时候尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。</p><blockquote><p>单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。</p><p>这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。</p></blockquote><p>基于三层架构的执行流程：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20221204194207812.png" alt="image-20221204194207812"></p><p>前端发起请求，由Controller层接受（Controller 响应数据给前端）</p><p>Controller层，调用Service层来进行逻辑处理，把处理结果返回给Controller层</p><p>Service层：在逻辑处理的过程中调用Dao层（逻辑处理的过程中需要数据从Dao层中获取）</p><p>Dao层操作文件中的数据（Dao层中拿到的数据会返回给Service层）</p><p>由于数据访问的对象，可能是文件，数据库，别人接口获取到的数据，</p><p>所以要先定义一个Dao的接口，再用不同的类去实现这个接口，重写接口中的方法</p><p>（这里本质上就是接口多态的实现，传入一个接口类型的实现类对象，根据不同实现类对象调用不同实现类里重写的方法）</p><h3 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h3><p>内聚：软件中各个模块内部的功能联系</p><p>耦合：衡量软件中各层、模块之间的依赖，关联程度</p><h5 id="软件设计原则：高内聚低耦合"><a href="#软件设计原则：高内聚低耦合" class="headerlink" title="软件设计原则：高内聚低耦合"></a>软件设计原则：高内聚低耦合</h5><p>高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 “高内聚”。</p><p>低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。</p><p>需要用到spring的核心概念</p><h5 id="控制反转：IOC，"><a href="#控制反转：IOC，" class="headerlink" title="控制反转：IOC，"></a>控制反转：IOC，</h5><p>对象的创建控制权由程序自身，转移到外部容器</p><p>@Component &#x2F;&#x2F;将当前对象交给IOC容器管理，成为IOC容器的bean</p><h5 id="依赖注入：DI，"><a href="#依赖注入：DI，" class="headerlink" title="依赖注入：DI，"></a>依赖注入：DI，</h5><p>容器为应用程序提供运行时，所依赖的资源，称依赖注入</p><p>@Autowired&#x2F;&#x2F;运行时从IOC容器中获取该类型的对象，并且赋值给变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将当前对象交给IOC容器管理,成为IOC容器的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceA</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpDao empDao ;</span><br></pre></td></tr></table></figure><h5 id="IOC-详解"><a href="#IOC-详解" class="headerlink" title="IOC 详解"></a>IOC 详解</h5><p>bean对象的声明：Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解：</p><ul><li>@Controller    （标注在控制层类上）</li><li>@Service          （标注在业务层类上）</li><li>@Repository    （标注在数据访问层类上）</li></ul><table><thead><tr><th align="left">注解</th><th>说明</th><th>位置</th></tr></thead><tbody><tr><td align="left">@Controller</td><td>@Component的衍生注解</td><td>标注在控制器类上</td></tr><tr><td align="left">@Service</td><td>@Component的衍生注解</td><td>标注在业务类上</td></tr><tr><td align="left">@Repository</td><td>@Component的衍生注解</td><td>标注在数据访问类上（由于与mybatis整合，用的少）</td></tr><tr><td align="left">@Component</td><td>声明bean的基础注解</td><td>不属于以上三类时，用此注解</td></tr></tbody></table><h5 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h5><p>bean对象要生效，还需要被组件扫描</p><p>需要被组件@ComponentScan扫描，被集成在@SpringbootApplication中，默认扫描范围是SpringBoot启动类所在的包及其子包</p><h5 id="依赖注入详解DI："><a href="#依赖注入详解DI：" class="headerlink" title="依赖注入详解DI："></a>依赖注入详解DI：</h5><p>使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：自动装配。</p><p>@Autowired注解，默认是按照<strong>类型</strong>进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）</p><p>举例：在Controller运行的时候，就要到IOC容器当中去查找service类型的对象，而我们的IOC容器中刚好有service对象，所以，就找到这个类型的对象完成注入操作</p><p>IOC容器里，存在多个相同类型的bean对象，会报错，需要添加注解指明当前生效的bean类</p><ul><li><p>@Primary：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。</p></li><li><p>@Qualifier：指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。</p></li><li><p>@Resource：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。</p></li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230911160941781.png" alt="image-20230911160941781"></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>概述：持久化，把数据保存到可掉电式存储设备中供以后使用</p><p>数据库： database  DB：文件系统，保存了一系列数据</p><p>DBMS：数据库管理系统：操作和管理数据库的大型软件</p><p>关系型数据库：行列形式存储</p><p>非关系型：数据以对象的形式存储在数据库中</p><p>键值型数据库：key-value形式</p><p>搜索引擎数据库：倒排索引</p><p>针对于数据库来说，主要包括三个阶段：</p><ol><li>数据库设计阶段<ul><li>参照页面原型以及需求文档设计数据库表结构</li></ul></li><li>数据库操作阶段<ul><li>根据业务功能的实现，编写SQL语句对数据表中的数据进行增删改查操作</li></ul></li><li>数据库优化阶段<ul><li>通过数据库的优化来提高数据库的访问性能。优化手段：索引、SQL优化、分库分表等</li></ul></li></ol><h2 id="SQL："><a href="#SQL：" class="headerlink" title="SQL："></a>SQL：</h2><p>结构化查询语言 structured Query Language</p><ol><li>SQL的分类</li></ol><p>DDL：数据定义语言 ，CREATE \ ALTER \ DROP \ RENAME \ TRUNCATE</p><p>DML：数据操作语言 INSERT \ DELETE \ UPDATE \ SELECT \ </p><p>DCL：数据控制语言 COMMIT \ ROLLBACK \ SAVEPOINT \ GRANT \ REVOKE</p><p><strong>链接：localhost 端口：3306 用户名：user  密码：123456</strong></p><h4 id="表操作："><a href="#表操作：" class="headerlink" title="表操作："></a>表操作：</h4><p>案例：创建一个表 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table  表名(</span><br><span class="line">字段1  字段1类型 [约束]  [comment  字段1注释 ],</span><br><span class="line">字段2  字段2类型 [约束]  [comment  字段2注释 ],</span><br><span class="line">......</span><br><span class="line">字段n  字段n类型 [约束]  [comment  字段n注释 ] </span><br><span class="line">) [ comment  表注释 ] ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user (</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;ID,唯一标识&#x27;</span>,   # id是一行数据的唯一标识（不能重复）</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20220829143005524.png" alt="image-20220829143005524"></p><h4 id="约束："><a href="#约束：" class="headerlink" title="约束："></a>约束：</h4><table><thead><tr><th><strong>约束</strong></th><th><strong>描述</strong></th><th><strong>关键字</strong></th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段值不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证字段的所有数据都是唯一、不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段值，则采用默认值</td><td>default</td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接，保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;ID,唯一标识&#x27;</span>, #主键自动增长</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;男&#x27;</span> comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>数据类型：数值类型，字符串类型，日期和时间类型</p><p>数值类型</p><p> <img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230912140829164.png" alt="image-20230912140829164"></p><p>字符串类型</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230912142339315.png" alt="image-20230912142339315"></p><p>日期时间类型</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230912144451625.png" alt="image-20230912144451625"></p><h5 id="设计表流程"><a href="#设计表流程" class="headerlink" title="设计表流程"></a>设计表流程</h5><p>通过上面的案例，我们明白了，设计一张表，基本的流程如下：</p><ol><li><p>阅读页面原型及需求文档</p></li><li><p>基于页面原则和需求文档，确定原型字段(类型、长度限制、约束)</p></li><li><p>再增加表设计所需要的业务基础字段(id主键、插入时间、修改时间)</p></li></ol><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20221205232253088.png" alt="image-20221205232253088"></p><blockquote><p>说明：</p><ul><li><p>create_time：记录的是当前这条数据插入的时间。 </p></li><li><p>update_time：记录当前这条数据最后更新的时间。</p></li></ul></blockquote><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230913095855893.png" alt="image-20230913095855893"></p><p>或者直接用图形化界面操作完成</p><h4 id="数据库操作：DML"><a href="#数据库操作：DML" class="headerlink" title="数据库操作：DML"></a>数据库操作：DML</h4><p>增加：insert </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段名<span class="number">1</span>, 字段名<span class="number">2</span>) <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>案例1：向tb_emp表的username、name、gender字段插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 因为设计表时create_time, update_time两个字段不能为NULL，所以也做为要插入的字段</span><br><span class="line">insert into tb_emp(username, name, gender, create_time, update_time)</span><br><span class="line">values (&#x27;wuji&#x27;, &#x27;张无忌&#x27;, 1, now(), now());</span><br></pre></td></tr></table></figure><p>案例2：向tb_emp表的所有字段插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_emp(id, username, password, name, gender, image, job, entrydate, create_time, update_time)</span><br><span class="line">values (null, &#x27;zhirou&#x27;, &#x27;123&#x27;, &#x27;周芷若&#x27;, 2, &#x27;1.jpg&#x27;, 1, &#x27;2010-01-01&#x27;, now(), now());</span><br></pre></td></tr></table></figure><p>案例3：批量向tb_emp表的username、name、gender字段插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_emp(username, name, gender, create_time, update_time)</span><br><span class="line">values (&#x27;weifuwang&#x27;, &#x27;韦一笑&#x27;, 1, now(), now()),</span><br><span class="line">       (&#x27;fengzi&#x27;, &#x27;张三疯&#x27;, 1, now(), now());</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>修改：update</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span> , 字段名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span> , .... [<span class="keyword">where</span> 条件] ;</span><br></pre></td></tr></table></figure><p>删除：delete</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名  [<span class="keyword">where</span>  条件] ;</span><br></pre></td></tr></table></figure><h4 id="数据库操作：DQL"><a href="#数据库操作：DQL" class="headerlink" title="数据库操作：DQL"></a>数据库操作：DQL</h4><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select...from(<span class="keyword">join</span> <span class="keyword">on</span>)...where...group by...having...order by...limit...</span><br></pre></td></tr></table></figure><p>sql语句的底层执行过程</p><p>在SQL语句中，执行顺序通常遵循以下规则：</p><p>FROM子句：首先执行FROM子句，以确定要查询的表和列。</p><p> FROM…(LEFT&#x2F;RIGHT)JOIN…ON 多表的链接条件</p><p>WHERE子句：如果存在WHERE子句，则会先执行WHERE子句，以过滤出符合条件的行。</p><p>GROUP BY子句：如果存在GROUP BY子句，则会先执行GROUP BY子句，以将结果按照指定的列进行分组。</p><p>HAVING子句：如果存在HAVING子句，则会先执行HAVING子句，以过滤出满足聚合函数条件的组。</p><p>ORDER BY 。。。</p><p>LIMIT。。。</p><p>SELECT子句：最后执行SELECT子句，以选择需要返回的列。</p><p>具体见数据库学习笔记</p><p>where having</p><p><strong>where与having区别（面试题）</strong></p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时指定</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段名    数据类型,</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">constraint</span>]   [外键名称]  <span class="keyword">foreign</span>  key (外键字段名)   <span class="keyword">references</span>   主表 (主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建完表后，添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>  表名  <span class="keyword">add</span> <span class="keyword">constraint</span>  外键名称  <span class="keyword">foreign</span> key(外键字段名) <span class="keyword">references</span> 主表(主表列名);</span><br></pre></td></tr></table></figure><p>多表设计</p><p>一对多</p><p>一对一</p><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><p>多对多的关系在开发中属于也比较常见的。比如：学生和老师的关系，一个学生可以有多个授课老师，一个授课老师也可以有多个学生。在比如：学生和课程的关系，一个学生可以选修多门课程，一个课程也可以供多个学生选修。</p><ul><li><p>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</p></li><li><p>实现关系：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p></li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20221207113341028.png" alt="image-20221207113341028"></p><h4 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 表<span class="number">1</span>字段，表<span class="number">2</span>字段 <span class="keyword">from</span> 表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">where</span> 表<span class="number">1.</span>字段<span class="operator">=</span>表<span class="number">2.</span>字段</span><br><span class="line"><span class="keyword">select</span> 表<span class="number">1</span>字段，表<span class="number">2</span>字段 form 表<span class="number">1</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 链接条件 </span><br></pre></td></tr></table></figure><p>多表查询的分类：</p><p>1.等值连接  非等值连接</p><p>2.自连接  非自连接</p><p>3.内连接 外连接</p><p>1.等值连接  非等值连接的例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.salary,j.grade_level</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades j</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="keyword">BETWEEN</span> j.lowest_sal <span class="keyword">AND</span> j.highest_sal</span><br></pre></td></tr></table></figure><p>2.自连接的例子：在同一张表里</p><p>查询员工ID，员工姓名，及其管理者的ID和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.employee_id,e1.last_name,e2.employee_id,e2.last_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> employees e1,employees e2</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> e1.manager_id <span class="operator">=</span> e2.employee_id</span><br></pre></td></tr></table></figure><p>3.内连接，外连接</p><p>内连接：结果集中，不包括一个表与另一个表不匹配的行</p><p>外连接：结果集中，出了匹配的行，还查询左表或者右表中不匹配的行</p><p>外连接的分类：左外连接，右外连接，全满外连接</p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230915100030081.png" alt="image-20230915100030081" style="zoom:150%;"><h4 id="单行函数，聚合函数"><a href="#单行函数，聚合函数" class="headerlink" title="单行函数，聚合函数"></a>单行函数，聚合函数</h4><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>单行子查询：查找出的只有一行数据，使用常规的比较符，&#x3D;，&lt;,&gt;,</p><p>多行子查询，查找出多行数据</p><p>多行比较的操作符：</p><p>​IN：等于列表中任意一个</p><p>​ANY：某一个值比较</p><p>​ALL:所有值比较</p><p>​Some：any的别名</p><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>事物：是一组操作的集合，它是一个不可分割的工作单位，事物会把所有的操作试做一个整体，一起向系统提交或者撤销操作请求操作，要么同事成功，要么同时失败。</p><p>一个业务要发送多条SQL语句给数据库执行。需要将多次访问数据库的操作视为一个整体来执行，要么所有的SQL语句全部执行成功。如果其中有一条SQL语句失败，就进行事务的回滚，所有的SQL语句全部执行失败。</p><p>使用事务控制删除部门和删除该部门下的员工的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除学工部</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_dept <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除学工部的员工</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>上述的这组SQL语句，如果如果执行成功，则提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 提交事务 (成功时执行)</span></span><br><span class="line"><span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure><ul><li>上述的这组SQL语句，如果如果执行失败，则回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 回滚事务 (出错时执行)</span></span><br><span class="line"><span class="keyword">rollback</span> ;</span><br></pre></td></tr></table></figure><h4 id="事物的四大特性"><a href="#事物的四大特性" class="headerlink" title="事物的四大特性"></a>事物的四大特性</h4><p>原子性：事物是不可分割的最小单元，要么全部成功，要么全部失败</p><p>一致性：事物完成时，必须使得所有的数据状态都保持一致</p><p>隔离性：数据库系统提供隔离机制，保证事物在不受外部并发操作影响的独立环境下运行</p><p>持久性：事物一旦回滚，它对数据库中的数据的改变是永久的</p><h4 id="索引：index："><a href="#索引：index：" class="headerlink" title="索引：index："></a>索引：index：</h4><p>帮助数据库高效获取数据的数据结构</p><p>无索引：全表扫描</p><p>有索引： 树形结构，大大减少查询时间</p><p>优点：大大提高查询效率</p><p>缺点：索引占用存储空间，同时降低，插入，删除，更新效率，要维护索引</p><p>MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。</p><p>我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。</p><p>二叉树：左边子节点比父节点小，右边子节点比父节点大</p><p>红黑树：是一种平衡二叉树</p><p>B+Tree：多路平衡搜索树</p><p><strong>创建索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create  [ unique ]  index 索引名 on  表名 (字段名,... ) ;</span><br></pre></td></tr></table></figure><p><strong>查看索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show  index  from  表名;</span><br></pre></td></tr></table></figure><p><strong>删除索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop  index  索引名  on  表名;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>主键字段，在建表时，会自动创建主键索引</li><li>添加唯一约束时，数据库实际上会添加唯一索引</li></ul><h3 id="自己做SQL时候的一些训练"><a href="#自己做SQL时候的一些训练" class="headerlink" title="自己做SQL时候的一些训练"></a>自己做SQL时候的一些训练</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id ,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">BETWEEN</span> <span class="number">6000</span> <span class="keyword">AND</span> <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span> <span class="keyword">and</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%e%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">not</span> <span class="keyword">BETWEEN</span> <span class="number">5000</span> <span class="keyword">and</span> <span class="number">12000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id <span class="keyword">FROM</span> employees</span><br><span class="line">#<span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">20</span> <span class="keyword">OR</span> department_id <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="number">20</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,commission_pct <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">like</span> <span class="string">&#x27;__a%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span> <span class="keyword">AND</span> last_name <span class="keyword">like</span> <span class="string">&#x27;%k%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> first_name <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> first_name <span class="keyword">like</span> <span class="string">&#x27;%e&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,manager_id </span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">in</span> (<span class="number">100</span>,<span class="number">101</span>,<span class="number">110</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">DESC</span>,salary <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id,</span><br><span class="line">salary<span class="operator">*</span><span class="number">12</span> newsalary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> newsalary <span class="keyword">DESC</span>,last_name <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">8008</span> <span class="keyword">AND</span> <span class="number">17000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">20</span>,<span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,job_id,email,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">like</span> <span class="string">&#x27;%e%&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> LENGTH(email) <span class="keyword">DESC</span>,department_id <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DESC</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> employee_id,department_name</span><br><span class="line"><span class="keyword">from</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t1.employee_id,t2.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees t1,departments t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.department_id <span class="operator">=</span> t2.department_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.employee_id,e.last_name,d.department_name,l.city</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">AND</span> d.location_id <span class="operator">=</span> l.location_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> job_grades</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.salary,j.grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades j</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="keyword">BETWEEN</span> j.lowest_sal <span class="keyword">AND</span> j.highest_sal</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e1.employee_id,e1.last_name,e2.employee_id,e2.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e1,employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.manager_id <span class="operator">=</span> e2.employee_id</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id,</span><br><span class="line">salary<span class="operator">*</span><span class="number">12</span> newsalary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> newsalary <span class="keyword">DESC</span>,last_name <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e1.employee_id,e1.last_name,e2.employee_id,e2.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e1,employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.manager_id <span class="operator">=</span> e2.employee_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> CONCAT(e1.last_name,<span class="string">&#x27;  worked for &#x27;</span>,e2.last_name) &quot;details&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees e1 <span class="keyword">JOIN</span> employees e2</span><br><span class="line"><span class="keyword">ON</span> e1.manager_id <span class="operator">=</span> e2.employee_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> CURDATE(),NOW()</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name ,salary,<span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">&#x27;富人&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">&#x27;中产&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">5000</span> <span class="keyword">THEN</span> <span class="string">&#x27;屌丝&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;穷人&#x27;</span> <span class="keyword">END</span> &quot;标签&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> PASSWORD(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"><span class="keyword">SELECT</span> MD5(<span class="string">&#x27;mysql&#x27;</span>),SHA(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> VERSION(),CONNECTION_ID()</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,LENGTH(last_name)</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> last_name <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,ROUND(DATEDIFF(CURDATE(),hire_date)<span class="operator">/</span><span class="number">365</span>,<span class="number">1</span>) &quot;work_years&quot; ,DATEDIFF(CURDATE(),hire_date) </span><br><span class="line">&quot;work_days&quot; <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> work_days <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,hire_date,department_id</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> department_id <span class="keyword">IN</span> (<span class="number">80</span>,<span class="number">90</span>,<span class="number">110</span>)</span><br><span class="line"><span class="keyword">AND</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">AND</span> hire_date <span class="operator">&gt;=</span> <span class="string">&#x27;1997-01-01&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary),<span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary),<span class="built_in">MAX</span>(salary),<span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,job_id,<span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id,job_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">10000</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">10000</span> <span class="keyword">AND</span> department_id <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>) </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line">#选择具有各个job_id的员工人数</span><br><span class="line"><span class="keyword">SELECT</span> job_id,<span class="built_in">COUNT</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"></span><br><span class="line">#查询员工最高工资与最低工资的差距</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary)<span class="operator">-</span><span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line">#查询管理者手下员工的最低工资，其中最低不超过<span class="number">6000</span>，没有管理者的不再内</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> manager_id,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">where</span> manager_id <span class="keyword">is</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> salary <span class="operator">&gt;=</span> <span class="number">6000</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line">#<span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary) <span class="operator">&gt;=</span><span class="number">6000</span></span><br><span class="line"></span><br><span class="line">#查询所有部门的名字，位置，员工数量和平均工资，按平均工资排序</span><br><span class="line"><span class="keyword">SELECT</span> d.department_name,d.location_id,<span class="built_in">count</span>(employee_id),<span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> departments d <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.department_id <span class="operator">=</span> e.department_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name,location_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e2.last_name,e2.salary</span><br><span class="line"><span class="keyword">from</span> employees e1,employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e2.salary <span class="operator">&gt;</span> e1.salary</span><br><span class="line"><span class="keyword">AND</span> e1.last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">where</span> employee_id <span class="operator">=</span> <span class="number">149</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(salary) <span class="operator">&gt;</span> (</span><br><span class="line">                   <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line"> <span class="keyword">FROM</span> employees</span><br><span class="line"> <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(salary) <span class="keyword">ASC</span></span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> department_id </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id </span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&lt;=</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> e.department_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">Asc</span> ,salary <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>mybatis是一款优秀的dao持久层框架，使用Java程序操作数据库</p><p>使用mybatis操作数据库，就是在mybatis中编写查询代码，发送给数据库执行，数据库执行后，会把数据执行的查询结果，使用实体类封装起来（一行记录对应一个实体类对象）</p><p>使用实体类定义对象的属性的时候，要用包装类，因为数据库中的数据存在为空的情况，字段会返回值null，int类型的默认数值为0，包装类Integer 的默认类型为null</p><h3 id="mybatis快速入门"><a href="#mybatis快速入门" class="headerlink" title="mybatis快速入门"></a>mybatis快速入门</h3><p>1.创建springboot工程，数据表user，实体类User</p><p>2.引入mybatis的相关依赖，mybatis Framework框架，MySQL Driver配置信息</p><p>在resource中的application中里配置数据库的驱动，url，用户名，密码等</p><p>3.定义接口，@Mapper ,注解用于运行时自动生成实现类对象，交给spring的IOC容器管理</p><p>​                       @select，编写SQL语句</p><p>4，单元测试：通过依赖注入@Autowired，注入mapper接口，再调用mapper接口的list方法，输出所查询到的数据</p><h4 id="JDBC：Java-DataBase-Connectivity"><a href="#JDBC：Java-DataBase-Connectivity" class="headerlink" title="JDBC：Java DataBase Connectivity"></a>JDBC：Java DataBase Connectivity</h4><p>使用Java操作数据库的一套api，一套操作所有关系型数据库的规范，即接口。各个数据库厂商去实现这套接口</p><p>Mybatis框架，就是对原始的JDBC程序的封装。 </p><p> 原始jdbc程序的步骤：</p><p>1.注册驱动</p><p>2.获取链接对象</p><p>3.执行SQL语句，返回执行结果</p><p>4.处理执行结果</p><p>5.释放资源</p><p>缺点：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20221210153407998.png" alt="image-20221210153407998"></p><p>mybatis中对这些问题的解决</p><p>1.数据库链接的四要素，(驱动，链接，用户名，密码)，都配置在springboot的默认配置文件中，</p><p>2.查俊结果以及解析的封装，都由mybatis自动完成映射封装，我们无需关注</p><p>3.在mybatis中使用了数据库的连接池技术，从而避免了频繁的创建链接，销毁链接而带来的资源浪费</p><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><p>没有使用数据库连接池：</p><p>​客户端执行SQL语句，要先创建一个链接对象，在执行SQL，执行完后要释放，每次都要，频繁的重复销毁会比较耗费计算机的性能</p><p>数据库连接池是个容器，负责分配管理数据库的链接Connection</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20221210161016314.png" alt="image-20221210161016314"></p><ul><li>程序在启动时，会在数据库连接池(容器)中，创建一定数量的Connection对象</li></ul><p>允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</p><ul><li>客户端在执行SQL时，先从连接池中获取一个Connection对象，然后在执行SQL语句，SQL语句执行完之后，释放Connection时就会把Connection对象归还给连接池（Connection对象可以复用）</li></ul><p>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</p><ul><li>客户端获取到Connection对象了，但是Connection对象并没有去访问数据库(处于空闲)，数据库连接池发现Connection对象的空闲时间 &gt; 连接池中预设的最大空闲时间，此时数据库连接池就会自动释放掉这个连接对象</li></ul><p><strong>连接池的好处：</strong></p><p>资源重用</p><p>提升系统的响应速度</p><p>避免数据库的链接泄露</p><h4 id="产品：常用的数据库连接池"><a href="#产品：常用的数据库连接池" class="headerlink" title="产品：常用的数据库连接池"></a>产品：常用的数据库连接池</h4><p>Hikari：追光者，springboot默认的连接池</p><p>Druid：德鲁伊，阿里开源的数据库连接池</p><p>修改连接池的方法：直接引入依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Druid连接池依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h3><p>是一个实用的JAVA类库，通过注解的方式自动生成，构造器，getter,setter,hashcode,toString等方法，并且可以自动化生成日志变量，简化JAVA开发，提高效率</p><table><thead><tr><th align="left"><strong>注解</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td align="left">@Getter&#x2F;@Setter</td><td>为所有的属性提供get&#x2F;set方法</td></tr><tr><td align="left">@ToString</td><td>会给类自动生成易阅读的  toString 方法</td></tr><tr><td align="left">@EqualsAndHashCode</td><td>根据类所拥有的非静态字段自动重写 equals 方法和  hashCode 方法</td></tr><tr><td align="left">@Data</td><td>提供了更综合的生成代码功能（@Getter  + @Setter + @ToString + @EqualsAndHashCode）</td></tr><tr><td align="left">@NoArgsConstructor</td><td>为实体类生成无参的构造器方法</td></tr><tr><td align="left">@AllArgsConstructor</td><td>为实体类生成除了static修饰的字段之外带有各参数的构造器方法。</td></tr></tbody></table><p>使用：</p><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在springboot的父工程中，已经集成了lombok并指定了版本号，故当前引入依赖时不需要指定version --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在实体类上添加注解</p><h2 id="Mybatis的基础操作"><a href="#Mybatis的基础操作" class="headerlink" title="Mybatis的基础操作"></a>Mybatis的基础操作</h2><h4 id="日志输入"><a href="#日志输入" class="headerlink" title="日志输入"></a>日志输入</h4><p>打开application.properties文件,配置文件，配置一下属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#指定mybatis输出日志的位置, 输出控制台</span><br><span class="line">mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><p>1.删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Mapper</span></span><br><span class="line">public interface EmpMapper &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="variable">@Delete</span>(&quot;delete from emp where id = 17&quot;)</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>public void <span class="keyword">delete</span>();</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>以上<span class="keyword">delete</span>操作的<span class="keyword">SQL</span>语句中的id值写成固定的<span class="number">17</span>，就表示只能删除id<span class="operator">=</span><span class="number">17</span>的用户数据</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="keyword">SQL</span>语句中的id值不能写成固定数值，需要变为动态的数值</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>解决方案：在<span class="keyword">delete</span>方法中添加一个参数(用户id)，将方法中的参数，传给<span class="keyword">SQL</span>语句</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="variable">@Delete</span>(&quot;delete from emp where id = #&#123;id&#125;&quot;)<span class="operator">/</span><span class="operator">/</span>使用#&#123;key&#125;方式获取方法中的参数值</span><br><span class="line">    public void <span class="keyword">delete</span>(<span class="type">Integer</span> id);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#{id} 是一个占位符，表示要传递给SQL语句的参数值。这个占位符会在实际执行时被具体的参数值替代</p><h4 id="预编译SQL"><a href="#预编译SQL" class="headerlink" title="预编译SQL"></a>预编译SQL</h4><p>优势：1.性能更高 2.更安全：防止SQL注入</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20221210202222206.png" alt="image-20221210202222206"></p><p>普通的SQL执行过程：解析-优化-编译-执行</p><p>预编译SQL：编译一次后将SQL语句缓存起来，后续再执行时，不会再次编译，只是输入的参数不同</p><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>原因：由于没有对用户输入内容进行充分检查，而SQL又是字符串拼接方式而成，在用户输入参数时，在参数中添加一些SQL关键字，达到改变SQL运行结果的目的，从而完成恶意攻击。</p><p>举例：一个登录管理系统中，有账户名和密码字段，而判断是否为用户登陆就是，查询用户名和密码字段是否与数据库中的匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>SQL注入：任意username ，password为 ‘ or ‘1’&#x3D;’1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>用户在页面提交数据的时候人为的添加一些特殊字符，使得sql语句的结构发生了变化，最终可以在没有用户名或者密码的情况下进行登录。</p><h4 id="参数占位符"><a href="#参数占位符" class="headerlink" title="参数占位符"></a>参数占位符</h4><p>在mybatis中提供的参数占位符有两种：${}，#{}</p><ul><li><p>#{…}</p><ul><li>执行SQL时，会将#{…}替换为?，生成预编译SQL，会自动设置参数值</li><li>使用时机：参数传递，都使用#{…}</li></ul></li><li><p>${…}</p><ul><li>拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题</li><li>使用时机：如果对表名、列表进行动态设置时使用</li></ul></li></ul><p>用like等模糊查询时，需要使用MySQL提供的字符串拼接函数：concat(‘%’ , ‘关键字’ , ‘%’)，以防止SQL注入问题</p><p>在上面我们所编写的条件查询功能中，我们需要保证接口中方法的形参名和SQL语句中的参数占位符名相同。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230925145458269.png" alt="image-20230925145458269"></p><h4 id="MyBatista的XML配置文件"><a href="#MyBatista的XML配置文件" class="headerlink" title="MyBatista的XML配置文件"></a>MyBatista的XML配置文件</h4><p>使用MyBatista注解的方式，主要是完成一些简单的增删改查功能</p><p>如果需要实现复杂的SQL功能，建议使用XML配置映射，将SQL语句写在XML配置文件中</p><p>在MyBatis中使用XML需要符合一定的规范</p><p>1.XML映射文件名称与Mapper接口的名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名） 一个接口对应一个相同的XML文件</p><p>2.XML映射文件的namespace属性与Mapper接口全限定名一样</p><p>3.XML映射文件中SQL语句的id与Mapper接口的方法名称一样，并且保持返回类型一致</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20221212153529732.png" alt="image-20221212153529732"></p><p>配置：XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20221212163528787.png" alt="image-20221212163528787"></p><h4 id="Mybatis动态SQL"><a href="#Mybatis动态SQL" class="headerlink" title="Mybatis动态SQL"></a>Mybatis动态SQL</h4><p> SQL语句会随着用户的输入或者外部的条件变化而变化，称为：动态SQL</p><p>动态SQL-if</p><p><if>：用于判断条件是否成立，使用test进行条件判断，如果条件为TRUE，则拼接</if></p><p><where>:<code>&lt;where&gt;</code>只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR</where></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- if做为where标签的子元素 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                 and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                 and gender = #&#123;gender&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">        order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><set>:动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）</set></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">    update emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username = #&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span> name = #&#123;name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span>gender = #&#123;gender&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;image != null&quot;</span>&gt;</span>image = #&#123;image&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>job = #&#123;job&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;entrydate != null&quot;</span>&gt;</span>entrydate = #&#123;entrydate&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptId != null&quot;</span>&gt;</span>dept_id = #&#123;deptId&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span>update_time = #&#123;updateTime&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p><foreach>:遍历操作</foreach></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--批量删除员工(1,2,3)</span></span><br><span class="line"><span class="comment">    collection:遍历的集合</span></span><br><span class="line"><span class="comment">    item:遍历出来的元素</span></span><br><span class="line"><span class="comment">    separator:分隔符</span></span><br><span class="line"><span class="comment">    open:遍历开始的SQL片段</span></span><br><span class="line"><span class="comment">    close:遍历结束后的SQL片段</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete from emp where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;sql&gt;</code>：定义可重用的SQL片段</p><p><include>&#96;：通过属性refid，指定包含的SQL片段，在原来抽取的地方进行引用</include></p><h4 id="案例的开发规范与开发流程"><a href="#案例的开发规范与开发流程" class="headerlink" title="案例的开发规范与开发流程"></a>案例的开发规范与开发流程</h4><h4 id="开发规范-REST"><a href="#开发规范-REST" class="headerlink" title="开发规范-REST"></a>开发规范-REST</h4><p>在前后端进行交互的时候，要基于当前主流的的REST风格的API进行交互</p><p>REST是一种风格，REST（Representational State Transfer），表述性状态转换，它是一种软件架构风格。</p><p>传统的url风格如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/user/getById?id=1     GET：查询id为1的用户</span><br><span class="line">http://localhost:8080/user/saveUser         POST：新增用户</span><br><span class="line">http://localhost:8080/user/updateUser       POST：修改用户</span><br><span class="line">http://localhost:8080/user/deleteUser?id=1  GET：删除id为1的用户</span><br></pre></td></tr></table></figure><p>基于REST风格的URL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/users/1  GET：查询id为1的用户</span><br><span class="line">http://localhost:8080/users    POST：新增用户</span><br><span class="line">http://localhost:8080/users    PUT：修改用户</span><br><span class="line">http://localhost:8080/users/1  DELETE：删除id为1的用户</span><br></pre></td></tr></table></figure><p>总结：通过url定位要操作的资源，通过HTTP请求方式来描述具体的操作</p><p>GET：查询  </p><p>POST：新增   </p><p>PUT：修改</p><p>DELETE：删除</p><h4 id="开发规范-统一响应流程"><a href="#开发规范-统一响应流程" class="headerlink" title="开发规范-统一响应流程"></a>开发规范-统一响应流程</h4><p>在使用前后端工程交互的时候，统一使用响应结果Result</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;<span class="comment">//响应码，1 代表成功; 0 代表失败</span></span><br><span class="line">    <span class="keyword">private</span> String msg;  <span class="comment">//响应信息 描述字符串</span></span><br><span class="line">    <span class="keyword">private</span> Object data; <span class="comment">//返回的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增删改 成功响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询 成功响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//失败响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>,msg,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发流程</p><p>查看页面原型明确需求–&gt;阅读接口文档–&gt;思路分析–&gt;接口开发–&gt;接口测试–&gt;前后端联调</p><p>基本上就是围绕接口文档做开发，要用到spring中的很多注解</p><table><thead><tr><th>10月7日</th><th></th><th>复习相关注解</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>@Pathvarible</td><td></td><td></td><td>将路径url中提取参数并映射到方法参数中</td><td></td><td></td><td></td></tr><tr><td></td><td>@RequestBody</td><td></td><td></td><td>将HTTP请求的具体内容，JSON或者XML</td><td>映射到Java对象上</td><td></td><td></td></tr><tr><td>10月8日</td><td></td><td>后端按照接口的实现流程</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>Controller控制层</td><td></td><td></td><td>@RequestMapping请求路径 @RequestController控制器 @SLf4j自动定义日志记录对象log</td><td>@Autowired依赖注入 deptService对象 @XXXMapping限定请求方式</td><td>调用deptService.函数()</td><td></td></tr><tr><td></td><td>Service逻辑处理层</td><td></td><td></td><td>Service接口：定义接口方法 Service实现类:重写+逻辑处理</td><td>@Autowired依赖注入 deptMapper对象</td><td>调用deptMapper.函数()</td><td></td></tr><tr><td></td><td>Dao数据访问层</td><td></td><td></td><td>@Mapper注解：</td><td>表示mybatis映射的接口</td><td>定义数据库操作的方法</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>10月9日</td><td></td><td>根据接口文档的实现流程</td><td></td><td></td><td>请求路径：url 请求方式：get set put 请求参数;json</td><td>@RequestMapping&#x2F;@PathVarible @GetMapping @RequestBody</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>10月10日</td><td></td><td>分页查询插件PageHelper</td><td></td><td></td><td>PageHelper.startPage()设置分页参数</td><td>将查询结果强转为Page类型</td><td>调用page方法，getTotalgetResult</td></tr><tr><td></td><td>@RequestParam</td><td></td><td></td><td>defaultvalue，如果没有，设置默认值</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>写了份表格记录一下</p><p>大体的开发流程就是</p><p>1.根据接口文档确定是什么请求，一般是请求路径和请求方式</p><p>请求路径就是&#x2F;emp&#x2F;upload等等，请求方式：POST，GET，DELETE，等等</p><p>判断是否有路径参数或者请求参数等</p><p>2.在控制层，用XXXXMapping接受路径&#x2F;emp这些，定义一个类型为Result的返回函数，去接受参数</p><p>如果请求传递的是路径参数，就用注解@PathVariable接受</p><p>如果请求参数是JSON格式的，就需要自己定一个对象，对象的私有属性包含这些，必须同名称，然后用注解</p><p>@RequestBody接受，将请求参数封装到实体类的私有属性中，再去调用</p><p>3.在控制层用@AutoWired自动注入service层的接口对象，调用service接口层中声明的方法，</p><p>定义业务实现类serviceImpl，具体实现这些方法，做一些逻辑处理，并且在类中，自动注入mybatis层的对象</p><p>4.在数据控制层就是Mybatis层，用注解@Mapper，这里主要是一些调用数据库的操作</p><p>用注解@Select,@delete等等，注解地下声明一个方法，用于接受查询返回的值</p><p>或者在resource层中定义xml配置文件，xml配置文件的位置定义要有讲究，在resource层下，要与mapper层的包名类名相同，在xml配置文件中定义动态查询语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> EmpService empService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">page</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> Integer page,</span></span><br><span class="line"><span class="params">                   <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> Integer pageSize,</span></span><br><span class="line"><span class="params">                    String name,</span></span><br><span class="line"><span class="params">                    Short gender,</span></span><br><span class="line"><span class="params">                   <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate begin,</span></span><br><span class="line"><span class="params">                   <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end</span></span><br><span class="line"><span class="params">                   )</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;分页查询部门数据&quot;</span>);</span><br><span class="line">    <span class="type">PageBean</span> <span class="variable">pageBean</span> <span class="operator">=</span> empService.page(page,pageSize,name,gender,begin,end);</span><br><span class="line">    <span class="keyword">return</span> Result.success(pageBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@RequestParam(defaultValue = &quot;1&quot;) Integer page</code>：这是一个查询参数，用于指定页码，默认值是 1。<code>@RequestParam</code> 用于从请求中获取名为 <code>page</code> 的参数值。如果请求中没有 <code>page</code> 参数，它将使用默认值 1。</p><p>在 Spring MVC 中，默认情况下，如果方法参数的名称与请求中的查询参数名称匹配，Spring 将自动将请求参数值绑定到方法参数，无需显式使用 <code>@RequestParam</code> 注解。这意味着当客户端发送一个请求，其中包含名为 <code>name</code> 和 <code>gender</code> 的查询参数时，Spring 将自动将它们绑定到方法的 <code>name</code> 和 <code>gender</code> 参数上。</p><h4 id="文件上传功能"><a href="#文件上传功能" class="headerlink" title="文件上传功能"></a>文件上传功能</h4><p>1.前端程序，定义form表单</p><p>我们先来看看在前端程序中要完成哪些代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">姓名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    头像: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上传文件的原始form表单，要求表单必须具备以下三点（上传文件页面三要素）：</p><ul><li><p>表单必须有file域，用于选择要上传的文件</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>表单提交方式必须为POST</p><blockquote><p>通常上传的文件会比较大，所以需要使用 POST 提交方式</p></blockquote></li><li><p>表单的编码类型enctype必须要设置为：multipart&#x2F;form-data</p><blockquote><p>普通默认的编码格式是不适合传输大型的二进制数据的，所以在文件上传时，表单的编码格式必须设置为multipart&#x2F;form-data</p></blockquote></li></ul><p>2.后端程序</p><p>​在服务端定义一个Controller用于文件的上传，在controller中定义一个方法，来处理&#x2F;upload请求</p><p>​在定义的方法中接收提交过来的数据（形参名称和请求参数名称保持一致）不一样用@RequestParam</p><p>​spring中提供了一个API：MultipartFile  image 接收文件</p><p>MultipartFile 常见方法： </p><ul><li>String  getOriginalFilename();  &#x2F;&#x2F;获取原始文件名</li><li>void  transferTo(File dest);     &#x2F;&#x2F;将接收的文件转存到磁盘文件中</li><li>long  getSize();     &#x2F;&#x2F;获取文件的大小，单位：字节</li><li>byte[]  getBytes();    &#x2F;&#x2F;获取文件内容的字节数组</li><li>InputStream  getInputStream();    &#x2F;&#x2F;获取接收到的文件内容的输入流</li></ul><p>用image.XXX调用即可</p><p>并且使用UUID获取随机文件名称，保证每次上传时候的文件名称都是唯一的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(String username, Integer age, MultipartFile image)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;文件上传：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,username,age,image);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取原始文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建新的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extname</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));<span class="comment">//文件扩展名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString()+extname;<span class="comment">//随机名+文件扩展名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将文件存储在服务器的磁盘目录</span></span><br><span class="line">        image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/images/&quot;</span>+newFileName));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只是将上传的文件保存到本地</p><p>上传到阿里云OSS（Object Storage Service）</p><p>注册:获得阿里云的AccessKey，bucketname等信息</p><p>参照官方实例文档的SDK</p><p>在Maven项目中使用OSS的SDK，只需要pom文件中添加相应的pom依赖即可</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20231029151527018.png" alt="image-20231029151527018"></p><p>导入依赖后，修改官方参考文档，调用oss中的相关函数，实现文件的上传</p><p>使用唯一的UUID确保上传的文件名称唯一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSS;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSSClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;https://oss-cn-shanghai.aliyuncs.com&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> <span class="string">&quot;LTAI5t9MZK8iq5T2Av5GLDxX&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> <span class="string">&quot;C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> <span class="string">&quot;web-framework01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现上传图片到OSS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取上传的文件的输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> multipartFile.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免文件覆盖</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> multipartFile.getOriginalFilename();</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上传文件到 OSS</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">        ossClient.putObject(bucketName, fileName, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> endpoint.split(<span class="string">&quot;//&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;//&quot;</span> + bucketName + <span class="string">&quot;.&quot;</span> + endpoint.split(<span class="string">&quot;//&quot;</span>)[<span class="number">1</span>] + <span class="string">&quot;/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭ossClient</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        <span class="keyword">return</span> url;<span class="comment">// 把上传到oss的路径返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后返回的url就是图片的地址，例如：</p><p><a href="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/01b43569-4c97-4efe-8e0a-7631044b4ac1.jpg">https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/01b43569-4c97-4efe-8e0a-7631044b4ac1.jpg</a></p><p>用网址打开会直接显示下载，在前端的页面就会直接渲染出来</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>上述阿里云的配置信息写死在了代码中（硬编码）</p><p>缺点：在源码中重新改动，要重新编译，配置参数过于分散，不便于集中维护和管理</p><p>解决方法1：在application.properties中定义配置信息，再使用注解@Value注入</p><p>@Value 注解通常用于外部配置的属性注入，具体用法为： @Value(“${配置文件中的key}”)</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230102173905913.png" alt="image-20230102173905913"></p><h4 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h4><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230102181215809.png" alt="image-20230102181215809"></p><p>简单的了解过springboot所支持的配置文件，以及不同类型配置文件之间的优缺点之后，接下来我们就来了解下yml配置文件的基本语法：</p><ul><li>大小写敏感</li><li>数值前边必须有空格，作为分隔符</li><li>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230103084645450.png" alt="image-20230103084645450"></p><p>了解完yml格式配置文件的基本语法之后，接下来我们再来看下yml文件中常见的数据格式。在这里我们主要介绍最为常见的两类：</p><ol><li>定义对象或Map集合</li><li>定义数组、list或set集合</li></ol><p>对象&#x2F;Map集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>数组&#x2F;List&#x2F;Set集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hobby:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sport</span></span><br></pre></td></tr></table></figure><p>@ConfigurationProperties(prefix &#x3D; “aliyun.oss”)</p><p>Spring提供的简化方式套路：</p><ol><li><p>需要创建一个实现类，且实体类中的属性名和配置文件当中key的名字必须要一致</p><blockquote><p>比如：配置文件当中叫endpoints，实体类当中的属性也得叫endpoints，另外实体类当中的属性还需要提供 getter &#x2F; setter方法</p></blockquote></li><li><p>需要将实体类交给Spring的IOC容器管理，成为IOC容器当中的bean对象@Compoent</p></li><li><p>在实体类上添加<code>@ConfigurationProperties</code>注解，并通过perfect属性来指定配置参数项的前缀</p></li><li><p>直接@Autowired自动注入bean对象，调用get方法获取到属性值即可</p></li></ol><p>分</p><h4 id="登录认证："><a href="#登录认证：" class="headerlink" title="登录认证："></a>登录认证：</h4><p>新建LoginController控制层，service层和mapper，因为是底层校验员工的数据，所以还是用员工emp层的即可</p><p>select * from emp where userame &#x3D; #{} and pasword &#x3D; #{}</p><p>返回查询到的员工信息，判断是否为null，判断成功或者失败</p><p>直接登陆的功能有漏洞，开发的接口功能在服务端没有做任何的判断，就去实现，所以无论用于是否登陆，都能执行数据的操作，所以需要登陆校验</p><h4 id="登陆校验"><a href="#登陆校验" class="headerlink" title="登陆校验"></a>登陆校验</h4><p>HTTP协议是无状态协议，每次请求都是独立的，下次的请求不会携带上一次的数据，所以我们在执行业务操作的时候，服务器也不知道这个员工是否登陆了</p><p>解决方法：</p><p>1.登陆标记</p><p>2.同意拦截，登陆校验</p><h4 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h4><p>会话跟踪技术有两种：</p><ol><li>Cookie（客户端会话跟踪技术）<ul><li>数据存储在客户端浏览器当中</li></ul></li><li>Session（服务端会话跟踪技术）<ul><li>数据存储在储在服务端</li></ul></li><li>令牌技术</li></ol><p>在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><h5 id="方案一：cookie"><a href="#方案一：cookie" class="headerlink" title="方案一：cookie"></a>方案一：cookie</h5><p>cookie是会话跟踪技术，存储在客户端浏览器的，<strong>第一次发起请求的时候，在服务器设置一个cookie</strong>，在cookie中存储用户相关的一些数据信息，例如：登陆的用户名称，id等等</p><p>之后服务端在给客户端响应的时候，同时会将cookie响应给浏览器，浏览器收到cookie后，会自动将其存储在浏览器本地，在后面的每一次请求之后，都会将本地存储的cookie自动携带到服务端，服务端就会判断是否存在cookie的数值，如果有，就说明之前已经登陆完成了，，基于cookie的在同一次会话的不同请求之间共享数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie会话跟踪技术的主要过程</span><br><span class="line">1.客户端发起请求</span><br><span class="line">2.服务器处理请求：服务器会在响应中包含一个Set-Cookie头部，用来设置cookie</span><br><span class="line">3.设置cookie：浏览器接收到服务器的响应后，会解析set-cookie，将其中的cookie信息保存到浏览器本地中</span><br><span class="line">4.发送请求：浏览器再次向服务端发起请求，浏览器会将cookie包含在请求头中，发送给服务器</span><br><span class="line">5.服务器读取cookie，根据cookie的内容，识别用户的身份，会话状态等信息</span><br><span class="line">6.服务器根据收到的 Cookie 信息，对请求进行处理。根据需要，可以向客户端发送新的 Cookie 信息，更新会话状态。</span><br><span class="line">7，重复1-6步</span><br></pre></td></tr></table></figure><p>cookie是浏览器HTTP协议之中所支持的数据，所以</p><p>用了 3 个自动：</p><ul><li><p>服务器会 <strong>自动</strong> 的将 cookie 响应给浏览器。</p></li><li><p>浏览器接收到响应回来的数据之后，会 <strong>自动</strong> 的将 cookie 存储在浏览器本地。</p></li><li><p>在后续的请求当中，浏览器会 <strong>自动</strong> 的将 cookie 携带到服务器端。</p></li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230112101804878.png" alt="image-20230112101804878"></p><p>cookie的优缺点</p><p>优点：HTTP协议之中支持的技术，浏览器自动响应，存储cookie，无需我们手动进行</p><p>缺点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">移动端无法使用cookie，浏览器设置中可以自己禁止使用cookie</span><br><span class="line"></span><br><span class="line">​开发中通常前端Tomcat和服务器端会部署在不同的的服务器中，IP地址和端口号各不相同</span><br><span class="line"></span><br><span class="line">​就存在跨域操作，cookie无法跨域</span><br></pre></td></tr></table></figure><p>补充:区分跨域的维度：</p><ul><li>协议</li><li>IP&#x2F;协议</li><li>端口</li></ul><p>只要上述的三个维度有任何一个维度不同，那就是跨域操作</p><h5 id="方案二：Session会话跟踪"><a href="#方案二：Session会话跟踪" class="headerlink" title="方案二：Session会话跟踪"></a>方案二：Session会话跟踪</h5><p>底层基于cookie实现的，但是存储在服务器端，相较于cookie更安全一些</p><p>前面介绍的时候，我们提到Session，它是服务器端会话跟踪技术，所以它是存储在服务器端的。而 Session 的底层其实就是基于我们刚才所介绍的 Cookie 来实现的。</p><ul><li><p>获取Session</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230112105938545.png" alt="image-20230112105938545"> </p><p>如果我们现在要基于 Session 来进行会话跟踪，浏览器在第一次请求服务器的时候，我们就可以直接在服务器当中来获取到会话对象Session。如果是第一次请求Session ，会话对象是不存在的，这个时候服务器会自动的创建一个会话对象Session 。而每一个会话对象Session ，它都有一个ID（示意图中Session后面括号中的1，就表示ID），我们称之为 Session 的ID。</p></li><li><p>响应Cookie (JSESSIONID)</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230112110441075.png" alt="image-20230112110441075"> </p><p>接下来，服务器端在给浏览器响应数据的时候，它会将 Session 的 ID 通过 Cookie 响应给浏览器。其实在响应头当中增加了一个 Set-Cookie 响应头。这个  Set-Cookie  响应头对应的值是不是cookie？ cookie 的名字是固定的 JSESSIONID 代表的服务器端会话对象 Session 的 ID。浏览器会自动识别这个响应头，然后自动将Cookie存储在浏览器本地。</p></li><li><p>查找Session</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230112101943835.png" alt="image-20230112101943835"> </p><p>接下来，在后续的每一次请求当中，都会将 Cookie 的数据获取出来，并且携带到服务端。接下来服务器拿到JSESSIONID这个 Cookie 的值，也就是 Session 的ID。拿到 ID 之后，就会从众多的 Session 当中来找到当前请求对应的会话对象Session。</p></li></ul><p><strong>优缺点</strong></p><ul><li>优点：Session是存储在服务端的，安全</li><li>缺点：<ul><li>服务器集群环境下无法直接使用Session</li><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.客户端发起请求： 用户在浏览器中输入网址或点击链接，向服务器发起请求。</span><br><span class="line"></span><br><span class="line">2.服务器处理请求： 服务器接收到请求后，根据请求的内容进行处理。如果需要进行会话跟踪，服务器会为每个客户端创建一个唯一的会话标识，并将该会话标识与客户端关联起来。</span><br><span class="line"></span><br><span class="line">3.生成 Session ID： 在服务器端生成一个唯一的 Session ID，用来标识当前会话。Session ID 可以是一个随机生成的字符串，也可以是其他形式的唯一标识符。</span><br><span class="line"></span><br><span class="line">4.存储 Session 数据： 服务器将生成的 Session ID 与会话数据进行关联，并将该关联保存在服务器端的存储介质中，如内存、数据库、文件系统等。会话数据可以包含用户的身份信息、会话状态、购物车内容等。</span><br><span class="line"></span><br><span class="line">5.返回 Session ID： 服务器在响应中包含一个 Set-Cookie 头部，用来设置一个名为 &quot;JSESSIONID&quot; 的 Cookie，并将 Session ID 的值设置为该 Cookie 的内容。这样，客户端在收到响应后就会保存 Session ID。</span><br><span class="line"></span><br><span class="line">6.发送请求： 当用户再次向服务器发起请求时，浏览器会自动将之前保存的 Session ID 包含在请求头中，并发送给服务器。</span><br><span class="line"></span><br><span class="line">7.读取 Session 数据： 服务器接收到请求后，从请求头中读取到 Session ID。根据 Session ID，服务器可以在存储介质中检索到相应的会话数据，并根据需要进行处理。</span><br><span class="line"></span><br><span class="line">8.处理请求： 服务器根据收到的 Session 数据，对请求进行处理。根据需要，可以更新会话状态、添加新的会话数据等。</span><br><span class="line"></span><br><span class="line">重复步骤 6~8： 在会话过程中，客户端和服务器会持续交互，根据需要更新和读取 Session 数据，以实现持续的会话跟踪。</span><br></pre></td></tr></table></figure><p>一般企业项目不会部署在同一个服务器上的，因为一个挂了就没法访问了，所以是服务器集群</p><p>会有一个均衡负载服务器，将前端请求均匀的分发给集群的服务器</p><h5 id="方案三：令牌技术"><a href="#方案三：令牌技术" class="headerlink" title="方案三：令牌技术"></a>方案三：令牌技术</h5><p>​在请求登陆接口的时候，如果登陆成功，就生成一个令牌，令牌就是用户的合法身份凭证，接下来响应数据的时候，将令牌响应给前端</p><p>​接下来我们在前端程序当中接收到令牌之后，就需要将这个令牌存储起来。这个存储可以存储在 cookie 当中，也可以存储在其他的存储空间(比如：localStorage)当中。</p><p>​接下来，在后续的每一次请求当中，都需要将令牌携带到服务端。携带到服务端之后，接下来我们就需要来校验令牌的有效性。如果令牌是有效的，就说明用户已经执行了登录操作，如果令牌是无效的，就说明用户之前并未执行登录操作。</p><p><strong>优缺点</strong></p><ul><li>优点：<ul><li>支持PC端、移动端</li><li>解决集群环境下的认证问题</li><li>减轻服务器的存储压力（无需在服务器端存储）</li></ul></li><li>缺点：需要自己实现（包括令牌的生成、令牌的传递、令牌的校验）</li></ul><h4 id="JWT令牌：JSON-Web-Token"><a href="#JWT令牌：JSON-Web-Token" class="headerlink" title="JWT令牌：JSON Web Token"></a>JWT令牌：JSON Web Token</h4><p>定义了一种简洁的，自包含的，用于通信双方以JSON数据格式安全传递信息，由于数字签名的存在，这些信息是可靠的。</p><p>组成：三部分组成</p><p>第一部分：head头，记录令牌的类型，签名是算法</p><p>第二部分：payload有效载荷，携带一些自定义，默认的信息</p><p>第三部分：数字签名：防止token被篡改等</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230106085442076.png" alt="image-20230106085442076"></p><blockquote><p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？</p><p>其实在生成JWT令牌时，会对JSON格式的数据进行一次编码：进行base64编码</p><p>Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号</p><p>需要注意的是Base64是编码方式，而不是加密方式。</p></blockquote><p>jwt令牌的应用场景：登录认证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.登陆成功后，生成一个jwt令牌，并且返回给前端</span><br><span class="line"></span><br><span class="line">2.前端拿到存储起来，后续每一次的请求都会将jwt令牌携带到服务器端口</span><br><span class="line"></span><br><span class="line">3.服务器端口，统一拦截请求后，判断和校验jwt令牌，通过即可放行处理</span><br></pre></td></tr></table></figure><p>生成JWT令牌：引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JWT依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调用依赖jar包中的相关函数，实现JWT令牌的生成和校验，具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">signKey</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>;<span class="comment">//签名密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">43200000L</span>; <span class="comment">//有效时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims JWT第二部分负载 payload 中存储的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateJwt</span><span class="params">(Map&lt;String, Object&gt; claims)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .addClaims(claims)<span class="comment">//自定义信息（有效载荷）</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, signKey)<span class="comment">//签名算法（头部）</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expire))<span class="comment">//过期时间</span></span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> jwt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT第二部分负载 payload 中存储的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span>&#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(signKey)<span class="comment">//指定签名密钥</span></span><br><span class="line">                .parseClaimsJws(jwt)<span class="comment">//指定令牌Token</span></span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h4><p>Filter是过滤器，是Javaweb三大组件之一：Servlet，Filter，Listener</p><p>把资源对应的请求拦截下来，实现过滤，过滤器处理完毕以后，才能够访问对应的资源</p><p>应用场景：比如：统一校验，统一编码处理，敏感字符处理等</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230106222559935.png" alt="image-20230106222559935"></p><p><strong>1.定义过滤器</strong>：定义一个类，实现servlet中的Filter接口，并且重写其方法</p><p>Filter中有三个方法，分别对应</p><p>init过滤器的初始化，web服务器启动的时候 会自动创建Filter过滤器对象</p><p>doFilter拦截到后调用，每一次拦截到请求之后都会调用</p><p>destroy销毁方法后调用，关闭服务的时候会调用</p><p><strong>2.配置过滤器</strong>：在Filter类上加@WebFilter注解@WebFilter(urlPatterns &#x3D; “&#x2F;*”)&#x2F;&#x2F;表示拦截所有的请求</p><p>由于springboot中不包含对web组件servlet的支持，所以要在引导类上加@ServletComponentScan</p><p>开启servlet组件的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> <span class="comment">//配置过滤器要拦截的请求路径（ /* 表示拦截浏览器的所有请求 ）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//初始化方法, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 初始化方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//拦截到请求之后调用, 调用多次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo 拦截到了请求...放行前逻辑&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//销毁方法, 只调用一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy 销毁方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程我们搞清楚之后，接下来再来介绍一下过滤器的拦截路径，Filter可以根据需求，配置不同的拦截资源路径：</p><table><thead><tr><th>拦截路径</th><th>urlPatterns值</th><th>含义</th></tr></thead><tbody><tr><td>拦截具体路径</td><td>&#x2F;login</td><td>只有访问 &#x2F;login 路径时，才会被拦截</td></tr><tr><td>目录拦截</td><td>&#x2F;emps&#x2F;*</td><td>访问&#x2F;emps下的所有资源，都会被拦截</td></tr><tr><td>拦截所有</td><td>&#x2F;*</td><td>访问所有资源，都会被拦截</td></tr></tbody></table><p><strong>过滤器链：</strong>一个web中，可以配置多个过滤器，形成一个过滤器链</p><p> <img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230107084730393.png" alt="image-20230107084730393"></p><p>过滤器链的执行顺序：通过注解@WebFilter配置的过滤器，优先级是通过按照过滤器的类名称（字符串)自然排序</p><h4 id="登陆校验流程"><a href="#登陆校验流程" class="headerlink" title="登陆校验流程"></a>登陆校验流程</h4><p>-在doFilter函数中具体要操作的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.获取请求url</span><br><span class="line"></span><br><span class="line">2.判断url中是否包含/login。如果包含，就是第一次登陆，放行</span><br><span class="line"></span><br><span class="line">3.获取请求头中的token的值jwt令牌</span><br><span class="line"></span><br><span class="line">4.判断令牌是否存在，如果不存在，返回错误结果</span><br><span class="line"></span><br><span class="line">5.解析token，如果解析失败，返回错误</span><br><span class="line"></span><br><span class="line">6.成功，放行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> <span class="comment">//拦截所有请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//前置：强制转换为http协议的请求对象、响应对象 （转换原因：要使用子类中特有方法）</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURL().toString();</span><br><span class="line">        log.info(<span class="string">&quot;请求路径：&#123;&#125;&quot;</span>, url); <span class="comment">//请求路径：http://localhost:8080/login</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.判断请求url中是否包含login，如果包含，说明是登录操作，放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;/login&quot;</span>))&#123;</span><br><span class="line">            chain.doFilter(request, response);<span class="comment">//放行请求</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//结束当前方法的执行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取请求头中的令牌（token）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;从请求头中获取的令牌：&#123;&#125;&quot;</span>,token);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断令牌是否存在，如果不存在，返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(token))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;Token不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Result</span> <span class="variable">responseResult</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONObject.toJSONString(responseResult);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//响应</span></span><br><span class="line">            response.getWriter().write(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.解析token，如果解析失败，返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(token);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;令牌解析失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Result</span> <span class="variable">responseResult</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONObject.toJSONString(responseResult);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//响应</span></span><br><span class="line">            response.getWriter().write(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>类似于过滤器，是springboot框架中提供的，用来动态拦截控制方法的执行</p><p>在拦截器中，拦截前端发起的请求，将登陆校验的逻辑全部写在拦截器当中，</p><p>拦截器的使用步骤：1.定义拦截器，2.注册配置拦截器</p><p><strong>自定义拦截器</strong>：实现HandlerInterceptor接口，并且重写其所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义拦截器</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//将该类交给IOC容器管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//目标资源方法执行前执行。 返回true：放行    返回false：不放行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle .... &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true表示放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标资源方法执行后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视图渲染完毕后执行，最后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion .... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册配置拦截器</strong>：实现WebMvcConfigurer接口，并且重写addInterceptor方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//说明该类是配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);<span class="comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拦截路径</strong>：首先我们先来看拦截器的拦截路径的配置，在注册配置拦截器的时候，我们要指定拦截器的拦截路径，通过<code>addPathPatterns(&quot;要拦截路径&quot;)</code>方法，就可以指定要拦截哪些资源。</p><p>在入门程序中我们配置的是<code>/**</code>，表示拦截所有资源，而在配置拦截器时，不仅可以指定要拦截哪些资源，还可以指定不拦截哪些资源，只需要调用<code>excludePathPatterns(&quot;不拦截路径&quot;)</code>方法，指定哪些资源不需要拦截。</p><p>在拦截器中除了可以设置<code>/**</code>拦截所有资源外，还有一些常见拦截路径设置：</p><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>一级路径</td><td>能匹配&#x2F;depts，&#x2F;emps，&#x2F;login，不能匹配 &#x2F;depts&#x2F;1</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2</td></tr><tr><td>&#x2F;depts&#x2F;*</td><td>&#x2F;depts下的一级路径</td><td>能匹配&#x2F;depts&#x2F;1，不能匹配&#x2F;depts&#x2F;1&#x2F;2，&#x2F;depts</td></tr><tr><td>&#x2F;depts&#x2F;**</td><td>&#x2F;depts下的任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2，不能匹配&#x2F;emps&#x2F;1</td></tr></tbody></table><p>拦截器和过滤器的执行流程：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240308102935645.png" alt="image-20240308102935645"></p><p>1.Tomcat并不识别所编写的Controller程序，但是它识别Servlet程序，所以在Spring的Web环境中提供了一个非常核心的Servlet：DispatcherServlet（前端控制器），所有请求都会先进行到DispatcherServlet，再将请求转给Controller。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Filter过滤器和Interceptor拦截器</span><br><span class="line">接口规范不同：Filter是Servlet规范的接口，属于servlet容器的一部分，而interceptor是spring框架中提供的一种拦截机制，属于springMVC中的一部分</span><br><span class="line"></span><br><span class="line">拦截范围不同：过滤器会拦截所有资源，而拦截器只会拦截spring环境中的资源</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>1.在所有的Controller的方法中，进行try…catch处理（代码臃肿）</p><p>2.全局异常处理：定义全局异常处理器</p><ul><li>定义全局异常处理器非常简单，就是定义一个类，在类上加上一个注解@RestControllerAdvice，加上这个注解就代表我们定义了一个全局异常处理器。</li><li>在全局异常处理器当中，需要定义一个方法来捕获异常，在这个方法上需要加上注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定我们要捕获的是哪一类型的异常。</li></ul><p>@RestControllerAdvice<br>public class GlobalExceptionHandler {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span> <span class="comment">//指定能够处理的异常类型</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ex</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();<span class="comment">//打印堆栈中的异常信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//捕获到异常之后，响应一个标准的Result</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;对不起,操作失败,请联系管理员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务管理-AOP"><a href="#事务管理-AOP" class="headerlink" title="事务管理&amp;AOP"></a>事务管理&amp;AOP</h2><p>事务：事务是一组操作的集合，这些操作要么同时成功，要么同时失败</p><p>事务的操作主要有三步：</p><ol><li>开启事务（一组操作开始前，开启事务）：start transaction &#x2F; begin ;</li><li>提交事务（这组操作全部成功后，提交事务）：commit ;</li><li>回滚事务（中间任何一个操作出现异常，回滚事务）：rollback ;</li></ol><p>@Transactional注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Transaction作用：在当前方法执行前开启事务，方法执行完毕后结束事务，如果在这个方法执行的过程中出现了异常，就会进行事务的回滚操作</span><br><span class="line"></span><br><span class="line">作用地点：通常在业务层service层添加注解，因为在业务层中，一个业务的功能可能会包含多个数据操作的访问，在业务层控制事务，就可以将多个数据访问的操作控制在一个事物的范围内</span><br><span class="line"></span><br><span class="line">书写位置：方法：当前方法交给spring进行事务管理</span><br><span class="line">类：当前类中的所有方法都交给事务管理</span><br><span class="line">接口：接口下所有实现类中的所有方法都交给spring事务管理</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="事物进阶："><a href="#事物进阶：" class="headerlink" title="事物进阶："></a>事物进阶：</h3><p>@Transaction中的两个属性</p><p>1.事物回滚的异常属性：rollbackFor():</p><p>2.事物传播行为：propagation()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line"> &gt; 结论：</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 在Spring的事务管理中，默认只有运行时异常 RuntimeException才会回滚。</span><br><span class="line">&gt; - 如果还需要回滚指定类型的异常，可以通过rollbackFor属性来指定。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>propagation：</p><p>用来控制事务的传播属性，就是当一个事物方法被另一个事物方法调用时候，这个事物方法该如何进行事务控制</p><p>我们要想控制事务的传播行为，在@Transactional注解的后面指定一个属性propagation，通过 propagation 属性来指定传播行为。接下来我们就来介绍一下常见的事务传播行为。</p><table><thead><tr><th><strong>属性值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>REQUIRED</td><td>【默认值】需要事务，有则加入，无则创建新事务</td></tr><tr><td>REQUIRES_NEW</td><td>需要新事务，无论有无，总是创建新事务</td></tr><tr><td>SUPPORTS</td><td>支持事务，有则加入，无则在无事务状态中运行</td></tr><tr><td>NOT_SUPPORTED</td><td>不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务</td></tr><tr><td>MANDATORY</td><td>必须有事务，否则抛异常</td></tr><tr><td>NEVER</td><td>必须没事务，否则抛异常</td></tr><tr><td>…</td><td></td></tr></tbody></table><blockquote><p>对于这些事务传播行为，我们只需要关注以下两个就可以了：</p><ol><li>REQUIRED（默认值）</li><li>REQUIRES_NEW</li></ol></blockquote><h3 id="AOP：面相切面编程"><a href="#AOP：面相切面编程" class="headerlink" title="AOP：面相切面编程"></a>AOP：面相切面编程</h3><p>AOP：Aspect Oriented Programming 就是面向特定方法的编程</p><p> 而AOP面向方法编程，就可以做到在不改动这些原始方法的基础上，针对特定的方法进行功能的增强。</p><blockquote><p>AOP的作用：在程序运行期间在不修改源代码的基础上对已有方法进行增强（无侵入性: 解耦）</p></blockquote><p>比如：我们只想通过 部门管理的 list 方法的执行耗时，那就只有这一个方法是原始业务方法。  而如果，我们是先想统计所有部门管理的业务方法执行耗时，那此时，所有的部门管理的业务方法都是 原始业务方法。 <strong>那面向这样的指定的一个或多个方法进行编程，我们就称之为 面向切面编程。</strong></p><p>AOP面向切面编程和OOP面向对象编程一样，它们都仅仅是一种编程思想，而动态代理技术是这种思想最主流的实现方式。而Spring的AOP是Spring框架的高级技术，旨在管理bean对象的过程中底层使用动态代理机制，对特定的方法进行编程(功能增强)。</p><p>优势：减少重复代码。提高开发效率，维护方便</p><h4 id="AOP的快速入门："><a href="#AOP的快速入门：" class="headerlink" title="AOP的快速入门："></a>AOP的快速入门：</h4><p>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.编写AOP入门程序：根据特定方法根据业务需要编程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//当前类为切面类</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//记录方法执行开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录方法执行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算方法执行耗时</span></span><br><span class="line">        log.info(pjp.getSignature()+<span class="string">&quot;执行耗时: &#123;&#125;毫秒&quot;</span>,end-begin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AOP的功能：记录操作日志，权限控制，事务管理</p><p>优势：代码无侵入，减少了重复代码，提高开发效率，维护方便</p><h3 id="AOP的核心概念："><a href="#AOP的核心概念：" class="headerlink" title="AOP的核心概念："></a>AOP的核心概念：</h3><p>1.连接点：JoinPiont，可以被AOP控制的方法</p><p>2.通知：Advice，指哪儿些重复方法，也就是共性功能（最终体现为一个方法），</p><p>3.切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用</p><p>4.切面：Aspect，描述通知与切入点对应关系（通知+切入点），切面在的类，通常用切面类表示，被@Aspect注解标识的类</p><p>5.目标对象：Target，通知所应用的对象</p><p>Spring的AOP底层是基于动态代理的技术来实现的，也就是说，在程序运行的时候，会自动的基于动态代理技术为目标对象生成一个对应的代理对象，在代理对象中就会对目标对象中的原始方法的功能进行增强。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230112161821401.png" alt="image-20230112161821401"></p><h3 id="AOP进阶"><a href="#AOP进阶" class="headerlink" title="AOP进阶"></a>AOP进阶</h3><p>1.通知类型</p><p>Spring中AOP的通知类型：</p><ul><li>@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行</li><li>@Before：前置通知，此注解标注的通知方法在目标方法前被执行</li><li>@After ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行</li><li>@AfterReturning ： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行</li><li>@AfterThrowing ： 异常后通知，此注解标注的通知方法发生异常后执行</li></ul><p> 在使用通知时的注意事项：</p><ul><li>@Around环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行</li><li>@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值，否则原始方法执行完毕，是获取不到返回值的。</li></ul><p>怎么来解决这个切入点表达式重复的问题？ 答案就是：<strong>抽取</strong></p><p>Spring提供了@PointCut注解，该注解的作用是将公共的切入点表达式抽取出来，需要用到时引用该切入点表达式即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切入点方法（公共的切入点表达式）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知（引用切入点）</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;before ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;around before ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用目标对象的原始方法执行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="comment">//原始方法在执行时：发生异常</span></span><br><span class="line">        <span class="comment">//后续代码不在执行</span></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;around after ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回后通知（程序在正常执行的情况下，会执行的后置通知）</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterReturning ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知（程序在出现异常的情况下，执行的后置通知）</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;afterThrowing ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：当切入点方法使用private修饰时，仅能在当前切面类中引用该表达式， 当外部其他切面类中也要引用当前类中的切入点表达式，就需要把private改为public，而在引用的时候，具体的语法为：</p><p>全类名.方法名()，具体形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect2</span> &#123;</span><br><span class="line">    <span class="comment">//引用MyAspect1切面类中的切入点表达式</span></span><br><span class="line">    <span class="meta">@Before(&quot;com.itheima.aspect.MyAspect1.pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect2 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上程序运行可以看出在不同切面类中，默认按照切面类的类名字母排序：</p><ul><li>目标方法前的通知方法：字母排名靠前的先执行</li><li>目标方法后的通知方法：字母排名靠前的后执行</li></ul><p>如果我们想控制通知的执行顺序有两种方式：</p><ol><li>修改切面类的类名（这种方式非常繁琐、而且不便管理）</li><li>使用Spring提供的@Order注解</li></ol><p>使用@Order注解，控制通知的执行顺序：</p><p>通知的执行顺序大家主要知道两点即可：</p><ol><li>不同的切面类当中，默认情况下通知的执行顺序是与切面类的类名字母排序是有关系的</li><li>可以在切面类上面加上@Order注解，来控制不同的切面类通知的执行顺序</li></ol><h4 id="3-切入点表达式"><a href="#3-切入点表达式" class="headerlink" title="3.切入点表达式"></a>3.切入点表达式</h4><p>切入点表达式：</p><ul><li><p>描述切入点方法的一种表达式</p></li><li><p>作用：主要用来决定项目中的哪些方法需要加入通知</p></li><li><p>常见形式：</p><ol><li>execution(……)：根据方法的签名来匹配</li></ol><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20230110214150215.png" alt="image-20230110214150215"><ol start="2"><li>@annotation(……) ：根据注解匹配</li></ol></li></ul><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240311215753015.png" alt="image-20240311215753015"></p><p>excution:主要根据方法的返回值，包名，类名，方法参数，等信息来匹配，语法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;excution(访问修饰符 ? 返回值 包名.类名.?方法名称(方法参数) throws 异常?)&quot;)</span></span><br></pre></td></tr></table></figure><p>其中带<code>?</code>的表示可以省略的部分</p><ul><li><p>访问修饰符：可省略（比如: public、protected）</p></li><li><p>包名.类名： 可省略</p></li><li><p>throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）</p></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))&quot;)</span></span><br></pre></td></tr></table></figure><p>可以使用通配符描述切入点</p><ul><li><p><code>*</code> ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分</p></li><li><p><code>..</code> ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数</p></li></ul><p>切入点表达式的语法规则：</p><ol><li>方法的访问修饰符可以省略</li><li>返回值可以使用<code>*</code>号代替（任意返回值类型）</li><li>包名可以使用<code>*</code>号代替，代表任意包（一层包使用一个<code>*</code>）</li><li>使用<code>..</code>配置包名，标识此包以及此包下的所有子包</li><li>类名可以使用<code>*</code>号代替，标识任意类</li><li>方法名可以使用<code>*</code>号代替，表示任意方法</li><li>可以使用 <code>*</code>  配置参数，一个任意类型的参数</li><li>可以使用<code>..</code> 配置参数，任意个任意类型的参数</li></ol><p><strong>切入点表达式示例</strong></p><ul><li><p>省略方法的修饰符号 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">void</span> com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替返回值类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替包名（一层包使用一个<code>*</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.*.*.DeptServiceImpl.delete(java.lang.Integer))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>..</code>省略包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..DeptServiceImpl.delete(java.lang.Integer))    </span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..*.delete(java.lang.Integer))   </span><br></pre></td></tr></table></figure></li><li><p>使用<code>*</code>代替方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..*.*(java.lang.Integer))   </span><br></pre></td></tr></table></figure></li><li><p>使用 <code>*</code> 代替参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.itheima.service.impl.DeptServiceImpl.delete(*))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>..</code>省略参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com..*.*(..))</span><br></pre></td></tr></table></figure><h4 id="annotation"><a href="#annotation" class="headerlink" title="@annotation"></a>@annotation</h4><p>  要匹配多个无规则的方法，比如list和delete方法，基于excution这种切入表达式描述起来就很不方便，将两个切入点表达式组合在一起，是比较繁琐的</p><p>  实现步骤：</p><p>  1.编写自定义注解</p><p>  2.在业务类要作为连接点的方法上添加自定义注解</p></li></ul><p>自定义注解类：MyLog</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect6</span> &#123;</span><br><span class="line">    <span class="comment">//针对list方法、delete方法进行前置通知和后置通知</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;@annotation(com.itheima.anno.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect6 -&gt; before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;@annotation(com.itheima.anno.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;MyAspect6 -&gt; after ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类：DeptServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@MyLog</span>  <span class="comment">//自定义注解（表示：当前方法属于目标方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 删除部门</span></span><br><span class="line">    deptMapper.delete(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能在调用delete方法的时候，匹配当前定义的注解，执行前置通知和后置通知了</p><p>总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- execution切入点表达式</span><br><span class="line">  - 根据我们所指定的方法的描述信息来匹配切入点方法，这种方式也是最为常用的一种方式</span><br><span class="line">  - 如果我们要匹配的切入点方法的方法名不规则，或者有一些比较特殊的需求，通过execution切入点表达式描述比较繁琐</span><br><span class="line">- annotation 切入点表达式</span><br><span class="line">  - 基于注解的方式来匹配切入点方法。这种方式虽然多一步操作，我们需要自定义一个注解，但是相对来比较灵活。我们需要匹配哪个方法，就在方法上加上对应的注解就可以了</span><br></pre></td></tr></table></figure><h3 id="3-4连接点"><a href="#3-4连接点" class="headerlink" title="3.4连接点"></a>3.4连接点</h3><p>连接点：简单来说就是可以被AOP控制的方法</p><p>在spring中用JoinPoint抽象了连接点，用它可以获得方法执行的先关信息，比如方法的类名，方法名称， 方法参数等等</p><p>1.对于@Around通知，获取连接点的信息只能使用ProceedingJoinPoint类型</p><p>2.对于其他四种，after before AfterReturnning AfterThrowing </p><p>获取连接点的信息只能用JointPoint，它是ProceedingJoinPoint的父类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//获取目标类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pjp.getTarget().getClass().getName();</span><br><span class="line">        log.info(<span class="string">&quot;目标类名：&#123;&#125;&quot;</span>,name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pjp.getSignature().getName();</span><br><span class="line">        log.info(<span class="string">&quot;目标方法名：&#123;&#125;&quot;</span>,methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法执行时需要的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        log.info(<span class="string">&quot;目标方法参数：&#123;&#125;&quot;</span>, Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240312213621023.png" alt="image-20240312213621023"></p><p>AOP 案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">需求：将案例中增、删、改相关接口的操作日志记录到数据库表中</span><br><span class="line"></span><br><span class="line">- 就是当访问部门管理和员工管理当中的增、删、改相关功能接口时，需要详细的操作日志，并保存在数据表中，便于后期数据追踪。</span><br><span class="line"></span><br><span class="line">操作日志信息包含：</span><br><span class="line"></span><br><span class="line">- 操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长</span><br><span class="line"></span><br><span class="line">&gt; 所记录的日志信息包括当前接口的操作人是谁操作的，什么时间点操作的，以及访问的是哪个类当中的哪个方法，在访问这个方法的时候传入进来的参数是什么，访问这个方法最终拿到的返回值是什么，以及整个接口方法的运行时长是多长时间。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实现具体思路</span><br><span class="line"><span class="number">1.</span>数据库建表，包含需要操作的日志段，id，操作人ID，操作时间，方法，参数，返回值，耗时等</span><br><span class="line"><span class="number">2.</span>创建表对应的实体类，操作日志实体类</span><br><span class="line"><span class="number">3.</span>创建mapper接口，定义Insert()方法，使用<span class="meta">@Insert</span>的MySQL注解，写好SQL的插入语句</span><br><span class="line"><span class="number">4.</span>需要记录日志，将横向的关注点从业务的核心业务逻辑中分离出来，就需要AOP面向切面编程，因为只是记录增删改的日志，使用execution的表达式繁琐，所以使用<span class="meta">@annotation</span>的注解的切入点表达式</span><br><span class="line"><span class="number">5.</span>自定义注解类<span class="meta">@Log</span>，</span><br><span class="line">    <span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//当前注解作用在方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//表示是运行时注解</span></span><br><span class="line"><span class="number">6.</span>自定义切面类，使用切面表达式将之前的注解类引用进来</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.itheima.anno.Log)&quot;)</span></span><br><span class="line">    表示：拦截标注了Log的注解的方法，并且在方法执行前后进行环绕通知</span><br><span class="line"><span class="number">7.</span>在切面类中，通过连接点JoinPoint获取相关记录日志的参数，再调用Mapper接口中的Insert方法，将日志数据插入到数据库中</span><br></pre></td></tr></table></figure><h3 id="Springboot原理"><a href="#Springboot原理" class="headerlink" title="Springboot原理"></a>Springboot原理</h3><h4 id="1-配置文件的优先级"><a href="#1-配置文件的优先级" class="headerlink" title="1.配置文件的优先级"></a>1.配置文件的优先级</h4><p>在SpringBoot项目当中，常见的属性配置方式有5种， 3种配置文件，加上2种外部属性的配置(Java系统属性、命令行参数)。通过以上的测试，我们也得出了优先级(从低到高)：</p><ul><li>application.yaml（忽略）</li><li>application.yml</li><li>application.properties</li><li>java系统属性（-Dxxx&#x3D;xxx）</li><li>命令行参数（–xxx&#x3D;xxx）</li></ul><h4 id="2-Bean管理"><a href="#2-Bean管理" class="headerlink" title="2.Bean管理"></a>2.Bean管理</h4><p>前面讲过，通过Spring当中提供的注解@Component以及它的三个衍生注解（@Controller@Service@Repository）来声明IOC容器中的bean对象，同时我们也学习了如何为应用程序注入运行时所需要的依赖的bean对象，也就是依赖注入DI</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总的来说，@Repository 注解用于标识数据访问层的组件，而 @Mapper 注解用于标识 MyBatis 的映射接口。</span><br></pre></td></tr></table></figure><p>1.如何总IOC容器中拿到bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 根据name获取bean</span><br><span class="line"></span><br><span class="line">   Object <span class="title function_">getBean</span><span class="params">(String name)</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 根据类型获取bean</span><br><span class="line"></span><br><span class="line">   &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 根据name获取bean（带类型转换）</span><br><span class="line"></span><br><span class="line">   &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.bean对象的作用域配置</p><p>前面提到的IOC容器中，默认的bean对象是单列模式（只有一个实例对象）那么如何设置bean对象为非单列呢？需要设置bean的作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在Spring中支持五种作用域，后三种在web环境才生效：</span><br><span class="line"></span><br><span class="line">| **作用域**  | **说明**                                        |</span><br><span class="line">| ----------- | ----------------------------------------------- |</span><br><span class="line">| singleton   | 容器内同名称的bean只有一个实例（单例）（默认）  |</span><br><span class="line">| prototype   | 每次使用该bean时会创建新的实例（非单例）        |</span><br><span class="line">| request     | 每个请求范围内会创建新的实例（web环境中，了解） |</span><br><span class="line">| session     | 每个会话范围内会创建新的实例（web环境中，了解） |</span><br><span class="line">| application | 每个应用范围内会创建新的实例（web环境中，了解） |</span><br></pre></td></tr></table></figure><p>如何设置一个bean的作用域呢？借助@Scope注解来进行配置作用域</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240314104531033.png" alt="image-20240314104531033"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//默认bean的作用域为：singleton (单例)</span><br><span class="line">@Lazy //延迟加载（第一次使用bean对象时，才会创建bean对象并交给ioc容器管理）</span><br><span class="line"></span><br><span class="line">@Scope(&quot;prototype&quot;) //bean作用域为非单例</span><br></pre></td></tr></table></figure><p>3.管理第三方的bean对象</p><p>之前我们所配置的bean，像controller、service，dao三层体系下编写的类，这些类都是我们在项目当中自己定义的类(自定义类)。当我们要声明这些bean，也非常简单，我们只需要在类上加上@Component以及它的这三个衍生注解。</p><p>如果这个类不是我们自己编写的，而是第三方提供的，那么如何使用和定义第三方的bean？：使用@Bean注解</p><p>解决方案一：在启动类上添加@Bean标识的方法 &#x2F;&#x2F;保持启动类的干净，不推荐使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明第三方bean</span></span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span></span><br><span class="line"><span class="keyword">public</span> SAXReader <span class="title function_">saxReader</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案二：在配置类中定义@Bean标识的方法</p><p>如果需要第三方定义的Bean时候，通常会单独定义一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类  (在配置类当中对第三方bean进行集中的配置管理)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明第三方bean</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span></span><br><span class="line">          <span class="comment">//通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名</span></span><br><span class="line">    <span class="keyword">public</span> SAXReader <span class="title function_">reader</span><span class="params">(DeptService deptService)</span>&#123;</span><br><span class="line">        System.out.println(deptService);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法上添加一个@Bean注解，Spring容器在启动的时候，会自动的调用这个方法，并将方法的返回值声明为Spring容器当中的Bean对象</p><h3 id="3-Springboot原理"><a href="#3-Springboot原理" class="headerlink" title="3.Springboot原理"></a>3.Springboot原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring 是一款轻量级的java开发框架，一般指的是spring framework,他是很多模块的集合，包括springboot快速启动，springcloud微服务，spring Data数据库等spring全家桶</span><br><span class="line"></span><br><span class="line">springboot就是帮助我们快速的构建应用程序，简化开发，提高效率</span><br></pre></td></tr></table></figure><p>Springboot之所以能简化Spring的开发，是因为SpringBoot底层提供了两个非常重要的功能，一个是起步依赖，一个是自动配置</p><p><strong>起步依赖：</strong></p><p>Springboot所提供的起步依赖，可以大大简化pom文件当中的依赖配置，从而解决了Spring框架中依赖配置繁琐的问题</p><p><strong>自动配置：</strong></p><p>通过自动配置功能就可以打打简化Spring框架在使用Bean的声明以及Bean的配置，我们只需要引入程序开发时候所需要的起步依赖，项目开发时所用到的常见配置都有了，我们直接使用就可以了</p><h4 id="3-1起步依赖："><a href="#3-1起步依赖：" class="headerlink" title="3.1起步依赖："></a>3.1起步依赖：</h4><p>假设没有使用SpringBoot，用的Spring框架进行Web开发，这时候我们需要引入相关依赖</p><p>Spring-webmvc依赖，Servlet依赖，aop依赖，JSON处理依赖，Tomcat依赖，还要保证依赖的版本匹配，避免出现版本冲突的问题</p><p>如果我们使用了SpringBoot，直接引用web开发的起步依赖，springboot-starter-web起步依赖即可，因为有<strong>Maven依赖传递</strong>，所需要的依赖就都有了</p><h4 id="3-2自动配置："><a href="#3-2自动配置：" class="headerlink" title="3.2自动配置："></a>3.2自动配置：</h4><p>概述：Springboot的自动配置，就是当Spring容器启动后，一些配置类，Bean对象就自动存储到了IOC容器中，不需要我们手动声明，从而简化了开发，省去了繁琐的配置操作</p><p>比如：我们要进行事务管理，要进行AOP切面开发，就不需要手动声明这些Bean对象了，直接注入就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在IOC容器中，除了我们自己定义的Bean以外，还有很多配置类，这些配置类都是在SpringBoot启动的时候加载进来的配置类，这些配置类加载进来后，也会生成很多的Bean对象，我们并没有声明，却可以通过@Autowired自动注入Bean对象，</span><br></pre></td></tr></table></figure><p>解析自动配置的原理：分析在Springboot中，我们引入对应的依赖后，Springboot是如何将依赖jar包当中提供的Bean以及配置类直接加载到当前项目的springIOC容器当中的</p><p>我们先引入第三方的依赖，执行测试方法发现：在Spring容器中没有找到com.example.TokenParse类型的bean对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思考：为什么引入的第三方依赖当中的Bean以及配置类，没有生效</span><br><span class="line">1.在类上添加@Component注解来声明Bean对象时候，还要保证Bean对象能被Spring的组件扫描到</span><br><span class="line">2.SpringBoot项目中的@SpringBootApplication注解，具有扫描包的作用，但是只会扫描启动类所在的当前的包，以及其子包</span><br><span class="line">3.没在一个包下，所以扫描不到</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>1.@Component组件扫描、、繁琐不推荐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima&quot;,&quot;com.example&quot;&#125;)</span> <span class="comment">//指定要扫描的包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.@import导入（使用@import导入的类会被Spring加载到IOC容器当中去）</p><p>导入形式主要有以下几种：</p><ol><li>导入普通类</li><li>导入配置类</li><li>导入ImportSelector接口实现类</li></ol><p>不推荐，我们不知道第三方具体类，导入繁琐</p><p>​4.使用第三方提供的@EnableXxxxx注解（推荐），第三方打包好的</p><p>只需要在启动类上加上@EnableXxxxx注解即可</p><h3 id="3-3原理分析：源码跟踪"><a href="#3-3原理分析：源码跟踪" class="headerlink" title="3.3原理分析：源码跟踪"></a>3.3原理分析：源码跟踪</h3><p>SpringBoot启动类的核心注解，@SpringBootApplication开始分析</p><p>在@SpringBootApplication包含了注解如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">四个元注解：</span><br><span class="line">@Retention():表示注解生效的地方，取值如下是</span><br><span class="line">RetentionPolicy.SOURCE：注解仅存在于源代码中，编译时会被忽略。</span><br><span class="line">RetentionPolicy.CLASS：注解存在于类文件中，但在运行时不可见，这是默认值。</span><br><span class="line">RetentionPolicy.RUNTIME：注解存在于类文件中，并在运行时可见，可以通过反射机制读取。</span><br><span class="line"></span><br><span class="line">@Target():表示注解可以修饰的目标元素的范围：取值如下</span><br><span class="line">ElementType.TYPE：可以修饰类、接口、枚举等。</span><br><span class="line">ElementType.FIELD：可以修饰字段、成员变量。</span><br><span class="line">ElementType.METHOD：可以修饰方法。</span><br><span class="line">ElementType.PARAMETER：可以修饰方法的参数。</span><br><span class="line">ElementType.CONSTRUCTOR：可以修饰构造方法。</span><br><span class="line">ElementType.LOCAL_VARIABLE：可以修饰局部变量。</span><br><span class="line">ElementType.ANNOTATION_TYPE：可以修饰注解类型。</span><br><span class="line">ElementType.PACKAGE：可以修饰包。</span><br><span class="line"></span><br><span class="line">@Documented：表示注解将会被标注在Javadoc文档中</span><br><span class="line">@Inherited:表示注解具有继承性</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240315101257039.png" alt="image-20240315101257039"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在@SpringBootApplication注解中包含了：</span><br><span class="line"></span><br><span class="line">- 元注解（不再解释）</span><br><span class="line">- @SpringBootConfiguration：表示SpringBoot启动类是一个配置类</span><br><span class="line">- @EnableAutoConfiguration：</span><br><span class="line">- @ComponentScan：用来进行组件扫描的，扫描范围为启动类所在的包以及其子包下所有被Component及其衍生注解声明的类</span><br><span class="line"></span><br><span class="line">主要的是@EnableAutoConfiguration注解(自动配置核心注解)：</span><br><span class="line">此注解下有两个注解：</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(AutoConfigurationImportSelector.class)：导入接口实现类</span><br><span class="line">public @interface EnableAutoConfiguration &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240315101525188.png" alt="image-20240315101525188"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用@Import注解，导入了实现ImportSelector接口的实现类。</span><br><span class="line">AutoConfigurationImportSelector类是ImportSelector接口的实现类。</span><br><span class="line">AutoConfigurationImportSelector类中重写了ImportSelector接口的selectImports()方法：</span><br><span class="line">selectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合</span><br><span class="line">getAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合</span><br></pre></td></tr></table></figure><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240315101059913.png" alt="image-20240315101059913"></p><p>在起步依赖中打开配置文件的所在位置</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240315101935391.png" alt="image-20240315101935391"></p><p>在测试类的时候，我们直接在测试类中，注入了一个叫gson的Bean对象，用来进行JSON格式转换，虽然我们没有配置对象，但是我们可以直接注入使用，原因就是在SpringBoot在启动时在自动配置类实现了自动配置，我们双击shift进入这个类的源码，</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240315102606421.png" alt="image-20240315102606421"></p><p>@AutoConfiguration底层就封装了@Configuration注解，表示该类是一个配置类</p><p><code>@Configuration</code>注解的类可以使用<code>@Bean</code>注解来声明Bean，Spring容器会根据这些Bean的定义来创建和管理Bean实例，调用配置类中的@Bean标识的方法，并且把方法的返回值注册到IOC容器中去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，那这些bean都会注册到Spring的IOC容器中吗？</span><br><span class="line"></span><br><span class="line">答案：并不是。 在声明bean对象时，上面有加一个以@Conditional开头的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）</span><br></pre></td></tr></table></figure><p>@Conditional注解</p><p>作用：按照一定的条件进行判断，满足相应的条件后，才会注册对应的Bean对象到Spring的IOC容器中</p><p>Conditional 是一个父注解，会派生出大量的子注解：</p><ul><li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li><li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li><li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li><li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li><li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li><li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li><li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li><li><code>@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件</li><li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li><li><code>@ConditionalOnJndi</code>：在 JNDI 存在的条件下差在指定的位置</li><li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下</li><li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项 目的条件下</li></ul><hr><p>主要用的有三个：</p><ul><li>@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。</li><li>@ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。</li><li>@ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。</li></ul><p>底层的自动配置原理总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简单来说就是：SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">详细来说：自动配置的核心就在Spring启动类@SpringBootApplication的注解上，底层包含了</span><br><span class="line">@EnableAutoConfiguration，这个注解才是自动配置的核心</span><br><span class="line"></span><br><span class="line">它封装了一个@import注解，import注解里面制定了一个接口的实现类，在这个实现类中重写了selectImport()方法，而这个方法会去读取对应jar包地下的配置文件，这些配置文件源码都试用贴@Configuration标注，表示是Spring的配置类，方法使用@Bean和@Conditional修饰</span><br><span class="line">表示只要满足了Conditional的条件，才会将这个Bean对象交给IOC容器管理。</span><br></pre></td></tr></table></figure><h3 id="案例：自定义starter分析"><a href="#案例：自定义starter分析" class="headerlink" title="案例：自定义starter分析"></a>案例：自定义starter分析</h3><p>业务场景：</p><p>​我们案例中使用的阿里云oss对象存储服务，阿里云并没有提供起步依赖，这时候用起来就比较繁琐，我们需要1.引入对应依赖 2.在配置文件中配置3.基于官方SDK来改造相应的工具类</p><p>​这时候我们需要自定义一些公共组件，在这些公共组件中，提前把需要配置的Bean都配置好，到时候直接将对应组件的坐标引入进来，交给Spring自动配置，大大简化开发</p><p>需求：自定义起步依赖，完成对阿里云OSS操作工具类AliyunOSSUtils的自动配置</p><p>​引入起步依赖后，要想使用阿里云OSS，注入AliyunOSSUtils直接使用即可</p><p>​<img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240315170105728.png" alt="image-20240315170105728"></p><p>在自定义一个起步依赖starter的时候，按照规范需要定义两个模块:</p><p>1.starter模块：进行依赖管理（程序开发过程所需要的依赖，都定义在starter起步依赖中）</p><p>2.autoconfigure模块：自动配置模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">需求明确了，接下来我们再来分析一下具体的实现步骤：</span><br><span class="line"></span><br><span class="line">- 第1步：创建自定义starter模块（进行依赖管理）</span><br><span class="line">  - 把阿里云OSS所有的依赖统一管理起来</span><br><span class="line">- 第2步：创建autoconfigure模块</span><br><span class="line">  - 在starter中引入autoconfigure （我们使用时只需要引入starter起步依赖即可）</span><br><span class="line">- 第3步：在autoconfigure中完成自动配置</span><br><span class="line">  1. 定义一个自动配置类，在自动配置类中将所要配置的bean都提前配置好</span><br><span class="line">  2. 定义配置文件，把自动配置类的全类名定义在配置文件中</span><br><span class="line"></span><br><span class="line">我们分析完自定义阿里云OSS自动配置的操作步骤了，下面我们就按照分析的步骤来实现自定义starter。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前两步骤好说，在autoconfiguration中配置好相关依赖，再在starter模块中引入autoconfiguration依赖即可</span><br><span class="line"></span><br><span class="line">我们要想引入起步依赖后直接注入AliOSSUtils，就需要定义一个自动配置类，并且自动以自动配置类的的配置文件</span><br><span class="line"></span><br><span class="line">主要难以理解的是，自动配置类怎么去写</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AliOSSUtils <span class="title function_">aliOSSUtils</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AliOSSUtils</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不带参数的配置类，声明Bean，因为需要注入AliOSSUtils，所以声明一个返回值为AliOSSUtils的函数，返回一个AliOSSUtils类型的对象，交给IOC容器管理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但我们声明这个对象是需要来给赋值的，AliOSSUtils中声明了private AliOSSProperties aliOSSProperties，来导入秘钥等配置，我们在声明的时候是需要给这个成员变量赋值的，</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(AliOSSProperties.class)</span></span><br><span class="line"><span class="comment">//它告诉Spring Boot要将配置文件中的属性值绑定到AliOSSProperties类的实例中。</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//定义了一个名为aliOSSUtils的Bean，它的类型是AliOSSUtils，并且依赖于AliOSSProperties类的一个实例。</span></span><br><span class="line">    <span class="keyword">public</span> AliOSSUtils <span class="title function_">aliOSSUtils</span><span class="params">(AliOSSProperties aliOSSProperties)</span>&#123;</span><br><span class="line">        <span class="type">AliOSSUtils</span> <span class="variable">aliOSSUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliOSSUtils</span>();</span><br><span class="line">        aliOSSUtils.setAliOSSProperties(aliOSSProperties);</span><br><span class="line">        <span class="keyword">return</span> aliOSSUtils;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AliOSSAutoConfiguration这个配置类要想被加载到，就需要在一份固定的配置文件中，Spring启动时，会自动加载该文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//org.springframework.boot.autoconfigure.AutoConfiguration.imports</span></span><br><span class="line"><span class="comment">//在此Imports文件中，声明需要被自动配置的类的全类名com.aliyun.oss.AliOSSAutoConfiguration，这样Spring在启动的时候，就会自动加载该配置文件中定义的所有配置类</span></span><br></pre></td></tr></table></figure><h2 id="web开发总结："><a href="#web开发总结：" class="headerlink" title="web开发总结："></a>web开发总结：</h2><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240318210310671.png" alt="image-20240318210310671"></p><p>后端开发流程：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240318210652587.png" alt="image-20240318210652587"></p><p>我们在学习这些web后端开发技术的时候，我们都是基于主流的SpringBoot进行整合使用的。而SpringBoot又是用来简化开发，提高开发效率的。</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240318210736030.png" alt="image-20240318210736030"></p><p>而Spring框架的web开发模块，我们也称为：SpringMVC</p><p>SpringMVC，SpringFramework，Mybatis俗称SSM</p><p>基于传统的SSM框架进行整合项目开发会比较繁琐，而且开发效率低，所以现在的企业开发当中，基本上都是基于SpringBoot整合SSM进行项目开发的</p><p>web后端开发内容完结撒花！</p><h1 id="Maven高级"><a href="#Maven高级" class="headerlink" title="Maven高级"></a>Maven高级</h1><p>Maven高级内容包括:</p><ul><li>分模块设计与开发</li><li>继承与聚合</li><li>私服</li></ul><h3 id="1-分模块设计与开发"><a href="#1-分模块设计与开发" class="headerlink" title="1.分模块设计与开发"></a>1.分模块设计与开发</h3><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240318212929002.png" alt="image-20240318212929002"></p><p>而且分模块设计之后，如果我们需要用到另外一个模块的功能，我们直接依赖模块就可以了。比如商品模块、搜索模块、购物车订单模块都需要依赖于通用组件当中封装的一些工具类，我只需要引入通用组件的坐标就可以了。</p><p><strong>分模块设计就是将项目按照功能&#x2F;结构拆分成若干个子模块，方便项目的管理维护、拓展，也方便模块键的相互调用、资源共享。</strong></p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240318213039063.png" alt="image-20240318213039063"></p><p>方案一：直接依赖我们当前项目 tlias-web-management ，但是存在两大缺点：</p><ul><li>这个项目当中包含所有的业务功能代码，而想共享的资源，仅仅是pojo下的实体类，以及 utils 下的工具类。如果全部都依赖进来，项目在启动时将会把所有的类都加载进来，会<strong>影响性能</strong>。</li><li>如果直接把这个项目都依赖进来了，那也就意味着我们所有的业务代码都对外公开了，这个是非常<strong>不安全</strong>的。</li></ul><p>方案二：分模块设计</p><p>1.将pojo包下的实体类，抽取到一个Maven模块tlias-pojo</p><p>2.将utils包下的工具类，抽取到一个Maven模块中tlias-utils</p><p>3.在具体的工程文件中，直接引入对应的依赖即可</p><p><strong>注意：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。</strong></p><h3 id="2-继承与聚合"><a href="#2-继承与聚合" class="headerlink" title="2.继承与聚合"></a>2.继承与聚合</h3><p>在案例项目分模块开发之后啊，我们会看到tlias-pojo、tlias-utils、tlias-web-management中都引入了一个依赖 lombok 的依赖。我们在三个模块中分别配置了一次。</p><p>功能虽然能实现，但是很繁琐</p><h4 id="2-1继承"><a href="#2-1继承" class="headerlink" title="2.1继承"></a>2.1继承</h4><p>我们可以再创建一个父工程 tlias-parent ，然后让上述的三个模块 tlias-pojo、tlias-utils、tlias-web-management 都来继承这个父工程 。 然后再将各个模块中都共有的依赖，都提取到父工程 tlias-parent中进行配置，只要子工程继承了父工程，依赖它也会继承下来，这样就无需在各个子工程中进行配置了。</p><p>Maven不支持多继承，但是支持多继承，与Java类似</p><p>所有的SpringBoot工程都有一个父工程，spring-boot-starter-parent。</p><p>我们为了将公共的依赖抽离出来，就可以自己创建一个父工程，保存公共的依赖，再由子工程去继承，如下图所示</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240318223702481.png" alt="image-20240318223702481"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tlias-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里打包方式设置为pom，提及到Maven的打包方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Maven打包方式：</span><br><span class="line"></span><br><span class="line">- jar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行）</span><br><span class="line">- war：普通web程序打包，需要部署在外部的tomcat服务器中运行</span><br><span class="line">- pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理</span><br></pre></td></tr></table></figure><p>在子工程的pom文件中，配置继承关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tlias-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../tlias-parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tlias-utils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">注意：relativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找该工程）。</span><br><span class="line"></span><br><span class="line">-  ../ 代表的上一级目录</span><br></pre></td></tr></table></figure><h4 id="2-2版本锁定"><a href="#2-2版本锁定" class="headerlink" title="2.2版本锁定"></a>2.2版本锁定</h4><p>场景：如果项目中各个模块都公共的各部分依赖，我们可以定义在父工程中，从而简化子工程的配置，然而在项目开发中，还有一些模块，并不是各个模块共有的，有可能只有其中的一小部分模块使用到了这个依赖</p><p>问题：如果项目拆分的够多，每次更新版本，我们都找得到这个项目中的每一个模块，一个一个改，很容易出现问题，遗漏掉一个模块，忘记更换版本的情况。</p><p>这时候就需要Maven的版本锁定功能</p><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一管理依赖版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--JWT令牌--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--JWT令牌--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在Maven中，可以在父工程pom文件中，通过&lt;dependencyManagement&gt;来统一管理依赖版本</span><br><span class="line">1.在父工程中的&lt;dependencyManagement&gt;只能统一管理依赖版本，并不会直接将这个依赖引入进来，这点和&lt;dependencies&gt;是不同的</span><br><span class="line">2.子工程要使用这个依赖，还是要引入的，只是此时就无需指定&lt;version&gt;版本，由父工程统一管理，变更依赖版本，只需要在父工程中统一变更。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>属性配置</strong></p><p>我们也可以通过自定义属性以及属性的引用形式，在父工程中，将依赖的版本号进行集中管理和维护，具体的语法为：</p><p>1). 自定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2). 引用属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们就可以在父工程中，将所有的版本号，都集中管理维护出来。</p><p><strong>面试题：<code>&lt;dependencyManagement&gt;</code> 与 <code>&lt;dependencies&gt;</code> 的区别是什么?</strong></p><ul><li><code>&lt;dependencies&gt;</code> 是直接依赖，在父工程配置了依赖，子工程会直接继承下来。 </li><li><code>&lt;dependencyManagement&gt;</code> 是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需依赖(无需指定版本)</li></ul><h4 id="2-3聚合"><a href="#2-3聚合" class="headerlink" title="2.3聚合"></a>2.3聚合</h4><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240319160756422.png" alt="image-20240319160756422" style="zoom:50%;"><p>分模块设计和开发之后，我们的项目被拆分了很多模块，比如如上图，我们在打包management的时候，需要将parent，pojo，utils分别执行install生命周期安装到Maven的本地仓库，在针对management模块执行package打包操作。就很繁琐</p><p>通过Maven聚合就能够实现项目的统一构建（清理，编译，测试，打包，安装等）</p><p><strong>聚合</strong>：将多个模块组织成一个整体</p><p><strong>聚合工程</strong>：一个不具有业务功能的空工程，有且只有一个pom文件，一般来讲，继承关系中的父工程和聚合工程是同一个</p><p><strong>作用</strong>：快速构建项目，无需根据依赖关系构建，直接在聚合工程上构建即可</p><p><strong>实现：</strong>在聚合工程中，通过<moudules>设置当前聚合工程所包含的字模块的名称，我们可以在parent（聚合工程）的pom文件中，添加如下配置</moudules></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--聚合其他模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-utils<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-web-management<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在module中添加聚合模块的名称   ../表示上一级目录--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-继承与聚合对比"><a href="#2-3-继承与聚合对比" class="headerlink" title="2.3 继承与聚合对比"></a>2.3 继承与聚合对比</h3><ul><li><p><strong>作用</strong></p><ul><li><p>聚合用于快速构建项目</p></li><li><p>继承用于简化依赖配置、统一管理依赖</p></li></ul></li><li><p><strong>相同点：</strong></p><ul><li><p>聚合与继承的pom.xml文件打包方式均为pom，通常将两种关系制作到同一个pom文件中</p></li><li><p>聚合与继承均属于设计型模块，并无实际的模块内容</p></li></ul></li><li><p><strong>不同点：</strong></p><ul><li><p>聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些</p></li><li><p>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</p></li></ul></li></ul><h2 id="3-私服"><a href="#3-私服" class="headerlink" title="3.私服"></a>3.私服</h2><p>本地搭建私服，供不同的电脑去访问和上传相应的依赖jar包</p><p><strong>私服：</strong>是一中特殊的远程仓库，架设在局域网内的仓库服务，用来代理与外部的中央仓库，用于解决团队内部资源共享与资源同步问题</p><p><strong>依赖查找顺序</strong>：本地仓库，私服仓库，中央仓库</p><p><strong>资料的上传与下载</strong>：</p><p><img src="https://web-fangyuan.oss-cn-hangzhou.aliyuncs.com/Javaweb/image-20240319173844509.png" alt="image-20240319173844509"></p><p>资源上传与下载，我们需要做三步配置，执行一条指令。</p><p>第一步配置：在maven的配置文件中配置访问私服的用户名、密码。</p><p>第二步配置：在maven的配置文件中配置连接私服的地址(url地址)。</p><p>第三步配置：在项目的pom.xml文件中配置上传资源的位置(url地址)。</p><p>配置好了上述三步之后，要上传资源到私服仓库，就执行执行maven生命周期：deploy。</p><blockquote><p>私服仓库说明：</p><ul><li>RELEASE：存储自己开发的RELEASE发布版本的资源。</li><li>SNAPSHOT：存储自己开发的SNAPSHOT发布版本的资源。</li><li>Central：存储的是从中央仓库下载下来的依赖。</li></ul></blockquote><blockquote><p>项目版本说明：</p><ul><li>RELEASE(发布版本)：功能趋于稳定、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。</li><li>SNAPSHOT(快照版本)：功能不稳定、尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。</li></ul></blockquote><p><strong>具体操作：</strong></p><p><strong>1.设置私服的访问用户名、密码</strong>：在Maven安装目录下conf&#x2F;settings.xml中的servers中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.设置私服依赖下载的仓库组地址（在自己maven安装目录下的conf&#x2F;settings.xml中的mirrors、profiles中配置）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>allow-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.IDEA的maven工程的pom文件中配置上传（发布）地址(直接在tlias-parent中配置发布地址)</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- release版本的发布地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- snapshot版本的发布地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成之后，我们就可以在tlias-parent中执行<strong>deploy</strong>生命周期，将项目发布到私服仓库中。 </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（二）链表篇</title>
      <link href="/2024/03/25/leetcode/lianbiao/"/>
      <url>/2024/03/25/leetcode/lianbiao/</url>
      
        <content type="html"><![CDATA[<h1 id="链表篇"><a href="#链表篇" class="headerlink" title="链表篇"></a>链表篇</h1><h1 id="移除链表元素，设计链表，反转链表，交换链表节点，删除链表，相交链表，环形链表"><a href="#移除链表元素，设计链表，反转链表，交换链表节点，删除链表，相交链表，环形链表" class="headerlink" title="移除链表元素，设计链表，反转链表，交换链表节点，删除链表，相交链表，环形链表"></a>移除链表元素，设计链表，反转链表，交换链表节点，删除链表，相交链表，环形链表</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表这一张，集合中的LinkedList底层实现就是双链表，封装好了增删改查等各种方法，这里相当于是手写源码了属于是</p><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//传入头结点和值，头结点是一个结构体，包含一个值，和下一个节点</span></span><br><span class="line">        <span class="comment">//next，以及三个构造器</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        preNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> preNode;<span class="comment">//定义临时表示当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.val == val)&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手写源码了属于是，定义一个虚拟头结点，确保不用在判断头结点就是要删除的情况，</span></span><br><span class="line"><span class="comment">//其次就是，定义零食变量temp的节点，表示当前结点，以便后续操作</span></span><br></pre></td></tr></table></figure><h3 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h3><p>他奶奶的，人linkedList底层封装好的，要我重新设计，写这些方法，离谱啊，算了，熟能生巧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义链表类，val是当前节点的值，next是指向下一个节点的引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 链表的长度</span></span><br><span class="line">    ListNode head;<span class="comment">// 链表的首节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下标为index节点的数值，如果下标无效，则返回-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            preNode = preNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个值为val的节点差插入到链表第一个元素之前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">        <span class="comment">// ListNode Node = new ListNode(val);</span></span><br><span class="line">        <span class="comment">// Node.next = head.next;</span></span><br><span class="line">        <span class="comment">// head.next = Node;</span></span><br><span class="line">        <span class="comment">// size++;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个值val的节点加入到链表作为链表的最后一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">        <span class="comment">// ListNode Node = head;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; size; i++) &#123;</span></span><br><span class="line">        <span class="comment">// Node = Node.next;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// Node.next = new ListNode(val);</span></span><br><span class="line">        <span class="comment">// size++;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将值为val的节点插入到index节点之前，若index==链表长度，插入最后</span></span><br><span class="line">    <span class="comment">// 若大于链表长度，则不会插入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">Node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        Node.next = temp.next;</span><br><span class="line">        temp.next = Node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果下标有效，则删除这个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = temp.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="comment">/*单链表的具体实现思路是有的，定义，创建，初始化的各种细节都需要熟悉</span></span><br><span class="line"><span class="comment">  不需要定义head头结点之前的虚拟节点，妈的，自动有了，get方法写错，排查了半天，浪费时间</span></span><br><span class="line"><span class="comment">  第二遍重写花了16分钟，还有小瑕疵。边界条件index的判断</span></span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">            t = n.next;<span class="comment">// 先保存这个节点,不然反转后会丢失</span></span><br><span class="line">            n.next = p;</span><br><span class="line">            p = n;<span class="comment">// n和p都向后一位</span></span><br><span class="line">            n = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">// 最后一次n被赋值为null，返回p作为头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单链表无法返回找回，需要临时变量存储下一个节点的位置</span></span><br></pre></td></tr></table></figure><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">n</span> <span class="operator">=</span> pre;</span><br><span class="line">        ListNode t;</span><br><span class="line">        ListNode firstNode;</span><br><span class="line">        ListNode secondNode;</span><br><span class="line">        <span class="keyword">while</span> (n.next != <span class="literal">null</span> &amp;&amp; n.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            t = n.next.next.next;</span><br><span class="line">            firstNode = n.next;</span><br><span class="line">            secondNode = n.next.next;</span><br><span class="line"></span><br><span class="line">            n.next = secondNode;</span><br><span class="line">            secondNode.next = firstNode;</span><br><span class="line">            firstNode.next = t;</span><br><span class="line">            n = firstNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*交换的方法画个图就出来了，三步走，要记录的临时变量太多了，开始写那么多的next的头都写晕了</span></span><br><span class="line"><span class="comment">然后，因为临时变量要不停的变，要在循环内赋值，不能在循环外面赋值</span></span><br><span class="line"><span class="comment">然后，&amp;&amp; 与&amp;的问题，开始写的是，n.next.next != null &amp;&amp; n.next != null，运行错误</span></span><br><span class="line"><span class="comment">&amp; 是两个条件都要判定一下，而&amp;&amp;是第一个不正确就不判断第二个了，当然next都=null了，就更不需要判断后面的了，所以要把小的放在&amp;&amp;的前面</span></span><br></pre></td></tr></table></figure><h3 id="19-删除链表倒数第n个节点"><a href="#19-删除链表倒数第n个节点" class="headerlink" title="19.删除链表倒数第n个节点"></a>19.删除链表倒数第n个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        last.next = last.next.next;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*很巧妙的方法，删除简单，关键是找到链表还是倒数第n个元素，众所周知，链表不好查询</span></span><br><span class="line"><span class="comment">双指针定义了一个长度为n的区间，不停移动 ，直到快指针指向null，慢指针的位置后面就是要删除元素的位置</span></span><br></pre></td></tr></table></figure><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h3><p><img src="/2024/03/25/leetcode/lianbiao/Users\fangyuan\AppData\Roaming\Typora\typora-user-images\image-20240116144358853.png" alt="image-20240116144358853"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*末尾对齐，指针B多移动(lenB-lenA),然后一起向后遍历是否相等</span></span><br><span class="line"><span class="comment">需要注意的是，要判断长度，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">B</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (A != <span class="literal">null</span>) &#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            A = A.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (B != <span class="literal">null</span>) &#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            B = B.next;</span><br><span class="line">        &#125;</span><br><span class="line">        A = headA;<span class="comment">// 刚刚遍历长度到末尾了，再指向头结点</span></span><br><span class="line">        B = headB;</span><br><span class="line">        <span class="keyword">if</span> (lenA &gt; lenB) &#123;<span class="comment">// 交换A，B头结点,确保A短</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> lenA;</span><br><span class="line">            lenA = lenB;</span><br><span class="line">            lenB = t;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">T</span> <span class="operator">=</span> A;</span><br><span class="line">            A = B;</span><br><span class="line">            B = T;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> lenB - lenA;</span><br><span class="line">        <span class="keyword">while</span> (d-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            B = B.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (A != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A == B) &#123;</span><br><span class="line">                <span class="keyword">return</span> A;</span><br><span class="line">            &#125;</span><br><span class="line">            A = A.next;</span><br><span class="line">            B = B.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="142.环形链表"></a>142.环形链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义两个指针，fast，slow，指向链表的head，，fast指针每次走两步，slow指针每次走一步</span></span><br><span class="line"><span class="comment">1：fast指针走到null，说明链表无环，</span></span><br><span class="line"><span class="comment">2.若有环的话，fast一定会遇到slow，&#123;</span></span><br><span class="line"><span class="comment">1.fast先进环，会在环内转圈圈，slow再进环，会在环内相遇</span></span><br><span class="line"><span class="comment">2.假定一个环，fast在任意节点追赶slow指针，无论环数为奇数偶数，初始差多少，这样理解，等同于slow走0步，fast走一步，fast是慢慢接近slow的，所以一定可以重合</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">此时就可以判断链表有环了。如何确定环的入口呢？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.当fast==slow的时候，设置链表前面有a个节点， 链表环有b个节点，</span></span><br><span class="line"><span class="comment">fast走的距离是slow的两倍，f=2s</span></span><br><span class="line"><span class="comment">fast比slow多走了n个环的长度，f = s+n*b,所以，slow走过的长度s=nb,f=2nb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4.让指针一直走，走到链表入口的位置是，a+nb，绕了n圈，而slow指针只走了nb步数，只要再让slow指针走a步数，就能在入口处停下来，如何再让slow指针走a步数&#123;</span></span><br><span class="line"><span class="comment">1.将fast重新指向head头结点</span></span><br><span class="line"><span class="comment">2.fast，slow重新开始走，再次重合是后，刚好走了a步数，fast，slow停留在入口位置</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;<span class="comment">// 有环</span></span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码写出来很简单，但分析过程的时候可不简单</span></span><br></pre></td></tr></table></figure><h3 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328.奇偶链表"></a>328.奇偶链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * ListNode next;</span></span><br><span class="line"><span class="comment"> * ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">oddList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> oddList;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> evenList;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                odd.next = head;</span><br><span class="line">                odd = odd.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                even.next = head;</span><br><span class="line">                even = even.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        even.next = <span class="literal">null</span>;</span><br><span class="line">        odd.next = evenList.next;</span><br><span class="line">        <span class="keyword">return</span> oddList.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（三）哈希表篇</title>
      <link href="/2024/03/25/leetcode/hash/"/>
      <url>/2024/03/25/leetcode/hash/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表篇"><a href="#哈希表篇" class="headerlink" title="哈希表篇"></a>哈希表篇</h1><h1 id="字母异味，数组交集，数字，字符串"><a href="#字母异味，数组交集，数字，字符串" class="headerlink" title="字母异味，数组交集，数字，字符串"></a>字母异味，数组交集，数字，字符串</h1><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="字母异位"><a href="#字母异位" class="headerlink" title="字母异位"></a>字母异位</h2><h3 id="242-有效的字母异位"><a href="#242-有效的字母异位" class="headerlink" title="242.有效的字母异位"></a>242.有效的字母异位</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                map.remove(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (map.get(c) &lt; 0) return false;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.size() == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// return true;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HashMap，put,remove,如果get(元素)&lt;0,返回false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*字符串转数组再排序，判断是否相等</span></span><br><span class="line"><span class="comment">注意：要使用Arrays.equals(str1, str2)，而不是str1.equals(str2)</span></span><br><span class="line"><span class="comment">Arrays.equals(str1, str2) 是用于判断两个数组是否相等的正确表达式。str1.equals(str2) 用于比较字符串对象的内容是否相等，而不是数组，即是这里比较的是地址值，肯定不相等。</span></span><br><span class="line"><span class="comment">正确的数组比较应该使用 Arrays.equals 方法，该方法会逐个比较数组中的元素，确保数组内容相同。</span></span><br></pre></td></tr></table></figure><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h3><p>s字符串是否能由t构成，s中字符只能在t中使用1次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lens</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lent</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="keyword">if</span> (lens &gt; lent) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lent; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lens; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(c) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正常HashMap的put插入覆盖更新，如果表内的value&lt;0.说明s中的新字符或者超过1次的限制</span></span><br></pre></td></tr></table></figure><h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49.字母异位词分组"></a>49.字母异位词分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序后将String作为key，list&lt;String&gt;作为value，寻找相同的string添加list&lt;String&gt;即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            List&lt;String&gt; value = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            value.add(s);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 集合的集大成之作，key，value是集合，ArrayList + HashMap，差点绕晕过去了</span></span><br></pre></td></tr></table></figure><h3 id="438-找到字符串中的所有字母异位词"><a href="#438-找到字符串中的所有字母异位词" class="headerlink" title="438.找到字符串中的所有字母异位词"></a>438.找到字符串中的所有字母异位词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lens</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenp</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="keyword">if</span> (lens &lt; lenp) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] arr = p.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= lens - lenp; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(i, i + lenp);</span><br><span class="line">            <span class="keyword">if</span> (isAnagram(str, p) == <span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        <span class="comment">// Arrays.sort(str2);</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//核心判断是字符串排序后比较值是否相等来判断异位词</span></span><br><span class="line"><span class="comment">//遍历，查找长度一样的字串，substring()提取字串的方法s是小写，没啥说的</span></span><br></pre></td></tr></table></figure><h2 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h2><h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)&#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(i))&#123;</span><br><span class="line">                set2.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : set2)&#123;</span><br><span class="line">            ans[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 思路是，使用set集合存入nums1，再遍历nums2，判断set中是否包含</span></span><br><span class="line"><span class="comment">// 最后将set转为数组</span></span><br><span class="line"><span class="comment">// 要定义两个set，因为包含的也会重复</span></span><br></pre></td></tr></table></figure><h3 id="350-两个数组的交集II"><a href="#350-两个数组的交集II" class="headerlink" title="350.两个数组的交集II"></a>350.两个数组的交集II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*与I不同点在于，I的交集是用set记录去重的，直接用set记录交集就好</span></span><br><span class="line"><span class="comment">II要交集出现的次数，与出现的最小次数一致，正常用map记录nums1的词和次数，再扫描nums2，判断存在就次数--，加入到list中去，直到次数为0，为止，记录list，再转为数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(i) &amp;&amp; map.get(i) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">                map.put(i, map.get(i) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : list) &#123;</span><br><span class="line">            ans[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * list和数组的转换，不能直接int[] ans = list.toArray()</span></span><br><span class="line"><span class="comment"> * 因为，不能把Object集合强转为int类型的，像我那样一个一个遍历又太麻烦了</span></span><br><span class="line"><span class="comment"> list.toArray()只能转换为，没啥用额包装类的类型Object[]，还要转换</span></span><br><span class="line"><span class="comment"> * 正确的写法是</span></span><br><span class="line"><span class="comment"> * Integer[] ans = list.toArray(new Integer[list.size()])</span></span><br><span class="line"><span class="comment"> * 不如一个一个遍历算啦</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路，用set记录和值n的值，不断调用方法，求解下一个n,来判断n是否出现在set集合内，若出现，则判断false</span></span><br><span class="line"><span class="comment"> * 若sum==1，判定为快乐数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !set.contains(n)) &#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = nextNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += Math.pow(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没啥说的，记个时，五分钟内写出来</span></span><br><span class="line"><span class="comment">//用map记录数组元素，以及数组的下标，从i遍历数组，判断map是否存在target-i的值，返回即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, map.get(target - nums[i]) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="454-四数相加"><a href="#454-四数相加" class="headerlink" title="454.四数相加"></a>454.四数相加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：正常四层循环，count++肯定超时,考虑空间换时间</span></span><br><span class="line"><span class="comment"> * 考虑将四层循环减为两层</span></span><br><span class="line"><span class="comment"> * 定义一个map，用于存放两数的和sum，以及和出现的次数</span></span><br><span class="line"><span class="comment"> * 寻找，在3,4表中两层for，寻找-sum出现的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                map.put(i + j, map.getOrDefault(i + j, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                count += map.getOrDefault(-i - j, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// if (map.containsKey(-i - j)) &#123;</span></span><br><span class="line">                <span class="comment">// count += map.get(-i - j);</span></span><br><span class="line">                <span class="comment">// 获取默认值＋0，效率高于查找key再获取值</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="383-赎金信-1"><a href="#383-赎金信-1" class="headerlink" title="383.赎金信"></a>383.赎金信</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断第一个字符串能不能由第二个字符串组成</span></span><br><span class="line"><span class="comment">//思路：map存储第一个字符串以及出现的次数，遍历第二个字符串，将map对应的值-1，再判断当前元素对应的value值，如果&lt;0，即为false</span></span><br><span class="line"><span class="comment">//已经做过了，就写个思路吧</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：两层for循环确定i,j的值。再判断hashmap中是否存在(-i-j)的值,存在放入list&lt;Integer&gt;集合中，</span></span><br><span class="line"><span class="comment">//题目说不能重复的三元组，所以对list集合要去重，可以再定义一个set集合去重，试试</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这样定义ArrayList的每一个对象都是List&lt;Integer&gt;类型的</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 当前i与前一个重复的时候，直接跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[i] - nums[j];</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(target)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (target == nums[i] || target == nums[j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (map.get(target) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="comment">// 只有一个重复的话</span></span><br><span class="line">                            <span class="comment">// map中的个数要&gt;=2才能确保不是自己</span></span><br><span class="line">                            <span class="comment">// 所以&lt;2的时候，直接跳出循环</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (target == nums[i] &amp;&amp; target == nums[j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (map.get(target) &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="comment">// 同理针对都是0的情况，个数要大于3次</span></span><br><span class="line">                            <span class="comment">// 小于3次直接跳出循环</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list = Arrays.asList(nums[i], nums[j], target);</span><br><span class="line">                    Collections.sort(list);<span class="comment">// 排序后加到集合中，方便set去重</span></span><br><span class="line">                    ans.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将ArrayList集合转为set集合，直接定义将结果扔进去就行</span></span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(ans);</span><br><span class="line">        <span class="comment">// 再转为AerrayList集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//思路好理解，去重浪费太多时间了</span></span><br><span class="line"><span class="comment">//我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</span></span><br><span class="line"><span class="comment">//所以这里是有两个重复的维度</span></span><br><span class="line"><span class="comment">//熟悉定理复杂list集合，以及ArrayList和Set集合之间的转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，</span></span><br><span class="line">            <span class="comment">// 那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 去重a</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针的去重逻辑比map简单多了，不用考虑那么多情况，也不用map，set，ArrayList一起用又排序，又去重，还有两个重复的维度，太慢了，再也不头铁了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思路：使用双指针法的话，要O^3，</span></span><br><span class="line"><span class="comment">使用map记录两种和出现的次数，查找另外两个，O^2</span></span><br><span class="line"><span class="comment">先试试map吧，都试试。完全没思路了，去重因为是数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        list = Arrays.asList(nums[i], nums[j], nums[left], nums[right]);</span><br><span class="line">                        <span class="comment">// Collections.sort(list);</span></span><br><span class="line">                        ans.add(list);</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;(ans);</span></span><br><span class="line">        <span class="comment">// return new ArrayList&lt;&gt;(set);</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = t;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没啥说的，或者调用StringBuilder，调用里面的reverse方法</span></span><br></pre></td></tr></table></figure><h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541.反转字符串II"></a>541.反转字符串II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Math.min(i + k - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            arr = subReverse(arr, i, r);</span><br><span class="line">            i = i + <span class="number">2</span> * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] subReverse(<span class="type">char</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//就是判断尾指针的长度，是不能超过数组的长度</span></span><br><span class="line"><span class="comment">//还有就是。是，charAt()只能取值，不能赋值给另一个charAt，涉及到数组字符串交换的，要转为数组处理</span></span><br></pre></td></tr></table></figure><h3 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h3><p>将字符串中的数字替换为字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;number&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不熟悉ACM格式，用StringBuilder秒了，不用扩长度</span></span><br></pre></td></tr></table></figure><h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i--;<span class="comment">// 搜索首个空格出现的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            ans.append(sub);</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//想了半天不知道字符串中间的单词空格怎么处理，直接+&quot;&quot;到后面再trim()处理，真的妙啊</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="右旋字符串"><a href="#右旋字符串" class="headerlink" title="右旋字符串"></a>右旋字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scan.next();</span><br><span class="line">        <span class="type">char</span> arr[] = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">char</span>[] ans = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - k; i &lt; n; i++) &#123;</span><br><span class="line">            ans[j++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - k; i++) &#123;</span><br><span class="line">            ans[j++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ACM模式，开辟了额外空间</span></span><br><span class="line"><span class="comment">//如果O(1),就先倒序，再倒序字串，就行</span></span><br></pre></td></tr></table></figure><h3 id="28-找出字符串中第一个匹配的下标"><a href="#28-找出字符串中第一个匹配的下标" class="headerlink" title="28.找出字符串中第一个匹配的下标"></a>28.找出字符串中第一个匹配的下标</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String h, String n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenh</span> <span class="operator">=</span> h.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenn</span> <span class="operator">=</span> n.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= lenh - lenn; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i, b = <span class="number">0</span>;<span class="comment">// 分别指向两个字符串的指针</span></span><br><span class="line">            <span class="keyword">while</span> (b &lt; lenn &amp;&amp; h.charAt(a) == n.charAt(b)) &#123;</span><br><span class="line">                a++;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b == lenn) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟法。分别指向两个字符串的指针，a是发起点，每循环一次，长的字符串都要有不同的发起点去匹配。y也就是暴力算法，时间复杂度O(m*n)</span></span><br><span class="line"><span class="comment">//KMP算法，</span></span><br></pre></td></tr></table></figure><h3 id="459-重复的字串"><a href="#459-重复的字串" class="headerlink" title="459.重复的字串"></a>459.重复的字串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, i);</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n / i; j++) &#123;</span><br><span class="line">                    sb.append(sub);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sb.toString().equals(s)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力模拟，找出字串，重复n次，判断是否与原有的串相等</span></span><br><span class="line"><span class="comment">//KMP算法，太复杂了不想弄了，就暴力吧</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（五）二叉树篇</title>
      <link href="/2024/03/25/leetcode/tree/"/>
      <url>/2024/03/25/leetcode/tree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树篇"><a href="#二叉树篇" class="headerlink" title="二叉树篇"></a>二叉树篇</h1><h1 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h1><h3 id="树的基础"><a href="#树的基础" class="headerlink" title="树的基础"></a>树的基础</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">节点的度： 一个节点含有的子树的个数称为该节点的度。如上图，T 节点的度为4</span><br><span class="line">树的度： 一颗树中，最大的节点的度称为树的度。如上图，该树的度为4</span><br><span class="line">叶子节点或终端节点： 度为0的节点称为叶子节点。如上图，T4、T11、T21、T22、T31、T32、T33为叶子节点</span><br><span class="line">双亲节点或父节点： 若一个节点含有子节点，则这个节点称为其子节点的父节点。如上图，T 节点是 T4 节点的父节点</span><br><span class="line">孩子节点或子节点： 一个节点含有的子树的根节点称为该节点的子节点。如上图，T4 节点是 T 节点的子节点</span><br><span class="line">根节点： 一颗树中，没有双亲节点的节点称为根节点。如上图，T 节点为根节点</span><br><span class="line">节点的层次： 从根开始定义，根为第1层，根的子节点为第二层，以此类推。如上图，该树有3层</span><br><span class="line">节点的深度： 某节点层次是第几层，则它的深度是多少。如上图，T 节点深度为1，T1 节点深度为2</span><br><span class="line">树的高度： 树中节点的最大层次。如上图，树的高度为3</span><br><span class="line">非终端节点或分支节点： 度不为0的节点。如上图，T、T1、T2、T3 为分支节点</span><br><span class="line">兄弟节点： 父亲节点相同的节点互称为兄弟节点。如上图，T1、T2、T3、T4 互称为兄弟节点</span><br><span class="line">堂兄弟节点： 双亲在同一层次的节点互称为堂兄弟节点。如上图，T11、T21 互称为堂兄弟节点</span><br><span class="line">节点的祖先： 从根节点到该节点所经过分支上的所有节点都称为该节点的祖先。如上图，T、T1 节点都为 T11 节点的祖先</span><br><span class="line">子孙： 以某节点为根的子树中，任意节点都称为该节点的子孙。如上图，该树中除 T 节点其它节点都是 T 节点的子孙</span><br><span class="line">森林： 由 m（m&gt;=0）棵互不相交的树的集合称为森林。</span><br></pre></td></tr></table></figure><p>二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当集合为空时，该二叉树称为空二叉树。</span><br><span class="line">在二叉树中，一个元素也称为一个结点。</span><br><span class="line">每个结点最多有两棵子树，即二叉树不存在度大于2的结点。</span><br><span class="line">二叉树的子树有左右之分，其次子树的次序不能颠倒，因此二叉树是有序树。</span><br></pre></td></tr></table></figure><p>二叉树的种类：</p><p><strong>满二叉树：</strong> 一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树就是满二叉树。<strong>性质：</strong> 如果一个二叉树的层数是k，且节点数是 2k-1，则它就是满二叉树。</p><p><strong>完全二叉树</strong>：在完全二叉树中，除了最后一层的节点没填满以外，其余每层节点数都达到最大值，并且下面一层的节点数都集中在最左边的若干位置，</p><p><strong>二叉搜索树：</strong></p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p><strong>平衡二叉搜索树：</strong>空树，或者它的左右两个树的高度差的绝对值不超过1，并且左右子树都是平衡二叉树</p><h3 id="二叉树的存储方式："><a href="#二叉树的存储方式：" class="headerlink" title="二叉树的存储方式："></a>二叉树的存储方式：</h3><p>链式存储：用指针，（节点元素，左指针 ，右指针）</p><p>顺序存储：用数组，用数组下标记录左孩子右孩子的位置</p><h3 id="二叉树的遍历方式："><a href="#二叉树的遍历方式：" class="headerlink" title="二叉树的遍历方式："></a>二叉树的遍历方式：</h3><p>深度优先遍历：先往深处走，一层一层遍历</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>广度优先遍历：</p><ul><li>层次遍历</li></ul><p>java链式存储二叉树节点的定义方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;<span class="comment">//定义了一个TreeNode的类，用于表示二叉树中的节点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">//节点的值</span></span><br><span class="line">    TreeNode left;<span class="comment">//左子结点</span></span><br><span class="line">    TreeNode right;<span class="comment">//右子节点</span></span><br><span class="line"><span class="comment">//三个构造器，空参构造器，构造器等等</span></span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="144-二叉树的前序，中序，后续遍历（递归）"><a href="#144-二叉树的前序，中序，后续遍历（递归）" class="headerlink" title="144.二叉树的前序，中序，后续遍历（递归）"></a>144.二叉树的前序，中序，后续遍历（递归）</h3><p>145.后序遍历    94.中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        recursive(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursive</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        recursive(root.left, res);</span><br><span class="line">        recursive(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序遍历是，中，左，右</span></span><br><span class="line"><span class="comment">//中序遍历是，左，中，右</span></span><br><span class="line"><span class="comment">//后序遍历是，左，右，中</span></span><br><span class="line"><span class="comment">//只需要在递归函数中 把递归调用的顺序改变就行了</span></span><br></pre></td></tr></table></figure><p>144，二叉树的前序，中序，后序遍历（迭代法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历，中左右</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            res.add(n.val);</span><br><span class="line">            <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(n.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(n.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈空使用isEmpty()函数，不能用！=null来判断</span></span><br><span class="line"><span class="comment">//用栈模拟，进栈顺序为先右后左</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后续遍历，左右中</span></span><br><span class="line"><span class="comment">//需要在先序遍历级基础上，生成中右左，再反转为左右中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            res.add(n.val);</span><br><span class="line">            <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(n.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(n.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//集合的反转不能直接调用reverse();</span></span><br><span class="line"><span class="comment">//Collections.reverse();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历，左中右</span></span><br><span class="line"><span class="comment">//思路就是，用临时变量temp记录当前的节点</span></span><br><span class="line"><span class="comment">//不为空入栈，左移，到最左边的节点后</span></span><br><span class="line"><span class="comment">//为空弹出栈，右移</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(temp);</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> s.pop();</span><br><span class="line">                res.add(n.val);</span><br><span class="line">                temp = n.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);<span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(n.val);</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列模拟，入队，确定队长，循环出队和遍历当前节点的左右子树即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归的方法，还不是很懂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        levelOrderHelper(root, <span class="number">0</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrderHelper</span><span class="params">(TreeNode node, <span class="type">int</span> level, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (level == result.size()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//如果当前层级等于列表结果的大小，则说明当前层级的列表还不存在，需要创建一个新的列表，并且将其添加到结果列表当中</span></span><br><span class="line">        result.get(level).add(node.val);</span><br><span class="line">        <span class="comment">//获取当前层级的列表，并且添加对应的元素值</span></span><br><span class="line">        levelOrderHelper(node.left, level + <span class="number">1</span>, result);</span><br><span class="line">        levelOrderHelper(node.right, level + <span class="number">1</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="107-二叉树的层序遍历II"><a href="#107-二叉树的层序遍历II" class="headerlink" title="107.二叉树的层序遍历II"></a>107.二叉树的层序遍历II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                list.add(n.val);</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans.add(res.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历再反转即可</span></span><br></pre></td></tr></table></figure><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历的基础上，记录循环出队的最后一个元素即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(n.val);</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">                    ans.add(n.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在层遍历的基础上，统计和在平均一下，没啥好说的</span></span><br></pre></td></tr></table></figure><h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);<span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(n.val);</span><br><span class="line">                <span class="keyword">for</span> (Node c : n.children) &#123;</span><br><span class="line">                    queue.offer(c);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//二叉树这里是遍历左右子树，N叉树这里直接循环遍历所有的子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="515-在每个树中找出最大值"><a href="#515-在每个树中找出最大值" class="headerlink" title="515.在每个树中找出最大值"></a>515.在每个树中找出最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                max = n.val &gt; max ? n.val : max;</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="116-（117）填充每个节点的下一个右侧节点指针"><a href="#116-（117）填充每个节点的下一个右侧节点指针" class="headerlink" title="116.（117）填充每个节点的下一个右侧节点指针"></a>116.（117）填充每个节点的下一个右侧节点指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;<span class="comment">//最右边不连接</span></span><br><span class="line">                    n.next = q.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列的peek()方法，获得队首的值，但是不出队</span></span><br><span class="line"><span class="comment">//最末尾的不连接，链接前size-1个元素的值即可</span></span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，len值++</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(n.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，当同时满足，节点的左右节点都为null时候，返回此时的len值</span></span><br><span class="line"><span class="keyword">if</span> (n.left == <span class="literal">null</span> &amp;&amp; n.right == <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归，翻转左右子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        swap(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归我还是很不熟练，自己调用自己</span></span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(left.left,right.right) &amp;&amp; compare(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归判断，判断左右节点非空，再判断左对右，右对左的数值是否相等</span></span><br></pre></td></tr></table></figure><h3 id="104-完全二叉树的节点个数"><a href="#104-完全二叉树的节点个数" class="headerlink" title="104.完全二叉树的节点个数"></a>104.完全二叉树的节点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，记录count值，或者递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right)&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getHeight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getHeight(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个计算当前二叉树高度的函数getheight</span></span><br><span class="line"><span class="comment">//满足平衡二叉树的定义:</span></span><br><span class="line"><span class="comment">//1.左右节点的高度差不超过1</span></span><br><span class="line"><span class="comment">//2.当前节点的左右节点都是为平衡二叉树</span></span><br><span class="line"><span class="comment">//知道这两个原理了，就很好写代码，不知道的话，就写不出来</span></span><br></pre></td></tr></table></figure><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, String path, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点不为空，拼接节点到当前路劲下</span></span><br><span class="line">            path += Integer.toString(node.val);</span><br><span class="line">            <span class="comment">// 如果节点到为叶子结点，添加到当前路径中</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                res.add(path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 非叶子节点，添加路径符号，继续遍历左右子树</span></span><br><span class="line">                path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                dfs(node.left, path, res);</span><br><span class="line">                dfs(node.right, path, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重要点是记录当前的路径</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（四）栈与队列篇</title>
      <link href="/2024/03/25/leetcode/stack-queue/"/>
      <url>/2024/03/25/leetcode/stack-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="栈与队列篇"><a href="#栈与队列篇" class="headerlink" title="栈与队列篇"></a>栈与队列篇</h1><h1 id="用队列实现栈，有效的括号，逆波兰表达式，滑动窗口最大值，前K个高频元素"><a href="#用队列实现栈，有效的括号，逆波兰表达式，滑动窗口最大值，前K个高频元素" class="headerlink" title="用队列实现栈，有效的括号，逆波兰表达式，滑动窗口最大值，前K个高频元素"></a>用队列实现栈，有效的括号，逆波兰表达式，滑动窗口最大值，前K个高频元素</h1><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();<span class="comment">// 负责进栈</span></span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();<span class="comment">// 负责出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队的操作,过程即将数据压入进栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InTuOut</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stackOut.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackIn.isEmpty()) &#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从队列的开头移除元素，将In栈的元素全部放到out栈中，</span></span><br><span class="line">    <span class="comment">// 再从out栈移除即可，所以需要写一个移动函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        InTuOut();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        InTuOut();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟，理清思路路，用两个栈模拟队列，入栈的时候，入栈IN，出栈的时候，将In栈内元素全部转到OUT栈，再出栈，</span></span><br></pre></td></tr></table></figure><h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用两个队列，实现。这样实现没什么意思不想写了</span></span><br></pre></td></tr></table></figure><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || c != stack.pop()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匹配括号，检测到左括号，就入栈右括号即可，最后栈空，或者栈顶元素不等于匹配的元素，就返回false</span></span><br></pre></td></tr></table></figure><h3 id="1047-删除字符串中所有相邻的重复项"><a href="#1047-删除字符串中所有相邻的重复项" class="headerlink" title="1047.删除字符串中所有相邻的重复项"></a>1047.删除字符串中所有相邻的重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || c != stack.peek()) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// StringBuilder sb = new StringBuilder();</span></span><br><span class="line">        <span class="comment">// while (!stack.isEmpty()) &#123;</span></span><br><span class="line">        <span class="comment">// sb.append(stack.pop());</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// sb.reverse();</span></span><br><span class="line">        <span class="comment">// return sb.toString();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            str = stack.pop() + str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用栈，栈空或者下一个字符与栈不同，则入栈，反之出栈，</span></span><br><span class="line"><span class="comment">//使用StringBuilder循环接受出栈元素</span></span><br><span class="line"><span class="comment">//或者直接拼接，为什么直接拼接190ms比循环遍历反转80ms慢了这么多？搞不懂了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="150-逆波兰表达式"><a href="#150-逆波兰表达式" class="headerlink" title="150.逆波兰表达式"></a>150.逆波兰表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路很简单，遇到数字压入栈，遇到字符出栈，计算结果并且入栈，</span></span><br><span class="line"><span class="comment">/*实现过程中的问题，可是给的是String类型的数组，不能用==判断，==判断的是地址值是否相等，charAt()转为字符类型后，因为后面运算要使用Intege.valueOf()把String转为int类型的，所以直接用Sting类型的，调用equals方法去比较值的相等即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tokens.length;</span><br><span class="line">        Stack&lt;Integer&gt; sk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> tokens[i];</span><br><span class="line">            <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    sk.push(sk.pop() + sk.pop());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    sk.push(-sk.pop() + sk.pop());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    sk.push(sk.pop() * sk.pop());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    <span class="comment">// sk.push(sk.pop() / sk.pop());</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> sk.pop();</span><br><span class="line">                    sk.push(end / first);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    sk.push(Integer.valueOf(s));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意乘法和加法无所谓，没有顺序，除法和减法有顺序的，要注意先后顺序</span></span><br></pre></td></tr></table></figure><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i + k - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left + <span class="number">1</span>; j &lt;= right; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; max) &#123;</span><br><span class="line">                    max = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : list) &#123;</span><br><span class="line">            ans[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力法，在滑动的数组中寻找最大值，再赋值给数组，复杂度O(n^2)，暴力超时</span></span><br><span class="line"><span class="comment">//可以考虑使用一个双端队列，记录首个范围的最大值max，入队操作，若right大，则左边的全部出队，若已有的大，入队就行（长度大于k左边出队），模拟是这个模拟，代码谢不出来</span></span><br></pre></td></tr></table></figure><h3 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="347.前k个高频元素"></a>347.前k个高频元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="comment">// map记录元素以及元素出现的次数</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将map中所有key-value的集合转换为list集合</span></span><br><span class="line">        <span class="comment">// Map.Entry表示java中操作键值对的接口，Map 接口的实现类（如 HashMap）的 entrySet() 方法返回一个包含 Map.Entry</span></span><br><span class="line">        <span class="comment">// 对象的集合</span></span><br><span class="line">        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(map.entrySet());</span><br><span class="line">        <span class="comment">// 重写comparator方法。通过比较value的值进行排序</span></span><br><span class="line">        list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 排序后输出前k个高频元素的key值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans[i] = list.get(i).getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*能想到的常规思路只有，使用HashMap计数，再通过value的值排序，得到前k个高频次的元素，在对map中的value值排序中遇到的问题已经写在了注释里</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">其他题解：使用优先队列，使用堆，我都看不懂</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷Leecode笔记（一）数组篇</title>
      <link href="/2024/03/25/leetcode/shuzu/"/>
      <url>/2024/03/25/leetcode/shuzu/</url>
      
        <content type="html"><![CDATA[<h1 id="数组篇"><a href="#数组篇" class="headerlink" title="数组篇"></a>数组篇</h1><h1 id="两数之和，二分查找，移除元素，长度最小子数组，螺旋矩阵"><a href="#两数之和，二分查找，移除元素，长度最小子数组，螺旋矩阵" class="headerlink" title="两数之和，二分查找，移除元素，长度最小子数组，螺旋矩阵"></a>两数之和，二分查找，移除元素，长度最小子数组，螺旋矩阵</h1><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常规两层for循环，注意同一个元素不能再匹配一次，所以，内层循环从J=i+1开始</span></span><br><span class="line"><span class="comment">//区别常规的，判断冒泡排序的算法，内层是n-i-1,因为每次已经将前i个元素排号了，所以内层循环要减去</span></span><br><span class="line"><span class="comment">//时间复杂度是O(n^2)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用map集合简化时间复杂度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意put放入元素的顺序，不能先放入元素，再查找，这样会查到到自己本身，会重复，</span></span><br><span class="line"><span class="comment">//先查找，再放入元素能完美的避开这一点</span></span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 while(left &lt; right) 还是 while(left &lt;= right)，到底是right = middle呢，还是要right = middle - 1呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这就涉及到区间的问题哦，使用while(left&lt;=right)，说明区间是[left.right],所以right开始要赋值为nums.length-1，当(mid&gt;target)时候，因为相等的时候已经判断过了，所以不需要再判断了，所以right=mid-1,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当使用while(left&lt;right)时候 ，说明区间是[left,right),所以开始right要赋值为nums.length，因为取不到，当(mid &gt; right)的时候，因为又开区间，相等的时候没没判断过。所欲right=mid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总之区间的问题，只要熟悉一种写法就够了</span></span><br></pre></td></tr></table></figure><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标准的二分查找，注意理解题目要求返回的东西，被顺序插入的地方，不一定是返回mid的位置，因为mid有可能找到 ，也有可能没有无法找到</span></span><br></pre></td></tr></table></figure><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                left = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; left, right &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常规暴力思路，两次for循环分别找第一个位置和最后一个位置，复杂度0(n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                first = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;<span class="comment">// 相等后继续从左区间找到首次位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">// 相等后继续从右区间找到最后位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; first, end &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为有重复的元素，所以二分法在相等后还需要调整区间，确保找到首次末次的，时间复杂度O(log(n))</span></span><br></pre></td></tr></table></figure><h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69. x的平方根"></a>69. x的平方根</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &gt; x) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &lt; x) &#123;</span><br><span class="line">                ans = mid;<span class="comment">//因为平方根向下取整，所以要在小于的时候，记录ans的值</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(long)mid*mid，乘法注意强转为long类型的，防止溢出报错</span></span><br></pre></td></tr></table></figure><h3 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367.有效的完全平方数"></a>367.有效的完全平方数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &gt; num) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &lt; num) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//熟能生巧，没啥说的，一遍过</span></span><br></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通用解法，遍历，对于不是目标元素的，在原有基础上覆盖，时间O(n)，空间O(1)</span></span><br><span class="line"><span class="comment">//这就是双指针，快指针指向全部元素，判断符合条件的赋值给慢指针，最后返回慢指针的个数即可</span></span><br></pre></td></tr></table></figure><h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>; fast &lt; nums.length ; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针，注意边界的取值问题，fast从1开始，确保能取值到数组末端，且能够跟前一位比较，而不发生数组溢出的问题，slow从1开始，因为第一个元素必定不重复，送0开始会漏掉第一个元素。</span></span><br></pre></td></tr></table></figure><h3 id="283-移动0"><a href="#283-移动0" class="headerlink" title="283.移动0"></a>283.移动0</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, fast, slow);</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换的解法</span></span><br><span class="line"><span class="comment">//1.交换过程一定要把要交换的数据放入，传入的数据不能只是swap(int a,int b)，不然无法交换</span></span><br><span class="line"><span class="comment">//2.判断交换的条件，开始想着必须nums[slow]==0并且nums[fast]!=0，看起来对，但是这样条件苛刻会导致slow无法执行++的操作，进而一直指向某一位不动，无法继续，所以nums[fast]不为0交换即可实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> slow; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不用交换，直接覆盖，再把之后的赋值为0就行</span></span><br></pre></td></tr></table></figure><h3 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844.比较含退格的字符串"></a>844.比较含退格的字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                s1.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                s1.deleteCharAt(s1.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                t1.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                t1.deleteCharAt(t1.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.toString().equals(t1.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StringBuilder工具类的方法还是不熟悉，detete(int start,int end),deleteCharAt(int index),还有就是比较的时候，转化为字符串调用String类中的equals()方法比较。这其实就是栈的数据结构，进栈，出栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//使用栈方式，如果字符为#，则出栈顶元素，如果是普通字符，则压栈</span></span><br><span class="line">        Stack&lt;Character&gt; stacks=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        Stack&lt;Character&gt; stackt=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                stacks.push(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stacks.isEmpty())&#123;</span><br><span class="line">                    stacks.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i)!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                stackt.push(t.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stackt.isEmpty())&#123;</span><br><span class="line">                    stackt.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stacks.equals(stackt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈数据结构的方法：Stack&lt;Character&gt; s = new Stack()</span></span><br><span class="line"><span class="comment">//s.push()压栈</span></span><br><span class="line"><span class="comment">//              s.pop()出栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">countS</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录s中#的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">countT</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录t中#的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    countS++;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span> &amp;&amp; countS != <span class="number">0</span>) &#123;</span><br><span class="line">                    countS--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    countT++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span> &amp;&amp; countT != <span class="number">0</span>) &#123;</span><br><span class="line">                    countT--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) != t.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*   双指针。</span></span><br><span class="line"><span class="comment">准备两个指针i,j，指向两个字符串的末尾，从后往前扫描，准备两个变量countS,countT,记录扫描到的#的个数</span></span><br><span class="line"><span class="comment">1.若当前字符是#，count++,继续扫描j--</span></span><br><span class="line"><span class="comment">2.若当前不是#，并且当前的s的count！=0，说明字符后面有退格，字符被抵消，count--，i--;</span></span><br><span class="line"><span class="comment">3,若当前不是#，并且当前的s的count==0，说明当前字符没有退格，跳出S的循环，等待t找出没有退格的字符，在进行比较。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当i,j都&gt;=0，没有越界的时候，比较，不相等返回false</span></span><br><span class="line"><span class="comment">当都小于0 时候，退格空字符串也是空串，说明两个都是空串，返回true</span></span><br><span class="line"><span class="comment">其他情况，返回false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ans[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//平方再排序，时间复杂度O(n*log(n))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &gt;= nums[j] * nums[j]) &#123;</span><br><span class="line">                ans[k--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[k--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针，因为本来数组就有序，所以定义首尾指针，判断平方后的大小放入新数组即可</span></span><br></pre></td></tr></table></figure><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">substring</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; l; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                    substring = j - i + <span class="number">1</span>;</span><br><span class="line">                    ans = Math.min(ans, substring);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力解法，java中int类型的最大值的表示方式，Integer.MAX_VALUE,Integer.MIN_VALUE</span></span><br><span class="line"><span class="comment">//需要先把ans设置为最大值，要不然调用Math.min()的时候，一直就是0了。然后最后判断ans是否被赋值了再返回答案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">substring</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//滑动窗口起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                substring = j - i + <span class="number">1</span>;</span><br><span class="line">                ans = Math.min(ans, substring);</span><br><span class="line">                sum -= nums[i];<span class="comment">//窗口滑动，从sum中减去左边的值</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i记录左边窗口的位置，当sum&gt;target的时候，记录当前的substring，再减去左边窗口的位置，其他流程不变，核心代码为： sum-=nums[i++];</span></span><br></pre></td></tr></table></figure><h3 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904.水果成篮"></a>904.水果成篮</h3><p><strong>（找最多包含两种元素的最长字串，并且返回其长度。）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fruits.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> fruits[right];<span class="comment">// 快指针遍历的值</span></span><br><span class="line">            map.put(a, map.getOrDefault(a, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将a的值与a元素的个数加入</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> fruits[left];<span class="comment">// 慢指针遍历的值</span></span><br><span class="line">                map.put(b, map.get(b) - <span class="number">1</span>);<span class="comment">// 将慢指针遍历的个数-1</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(b) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(b);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针+HashMap</span></span><br><span class="line"><span class="comment">/*使用双指针形成窗口，使用HashMap存储窗口 中的元素和元素的个数，记录此时临时窗口的长度为：     right-left+1，当hash表长度＞2时候，即出现第三个元素，我们将left++，左边元素的个数+1</span></span><br><span class="line"><span class="comment">滑动窗口，滑动的是数组fruits的窗口，与right与left有关，而与HashMap的a,b无关</span></span><br><span class="line"><span class="comment">窗口不断滑动，右边次数+1，左边次数-1，左边为0时候，remove即可，不停的记录窗口的长度，返回最大值即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">map中的函数，getOrDefault(key,default),因为开始存入都没有数值，会出现null的情况，所以需要设置默认值，其他没什么了，这题，花了俩小时，还是看答案+花示例图才理解原因，对双指针+map组合的解法，又了解了许多</span></span><br></pre></td></tr></table></figure><h3 id="76-覆盖最小字串"><a href="#76-覆盖最小字串" class="headerlink" title="76.覆盖最小字串"></a>76.覆盖最小字串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>();  <span class="comment">// 用来记录窗口中的字符和数量</span></span><br><span class="line">        Map&lt;Character,Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>();  <span class="comment">// 需要凑齐的字符和数量</span></span><br><span class="line">        <span class="comment">// 构建need字符集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">needChar</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            need.put(needChar,need.getOrDefault(needChar,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = <span class="number">0</span>,valid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// valid是用来记录窗口中满足need要求的字符和数量的数目，比如need中要求字符a数量为2，如果window中的a字符的数量等于了2，valid就＋1，反之-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;  <span class="comment">// 记录最小字串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 记录最小字串的起始位置</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">addChar</span> <span class="operator">=</span> s.charAt(right);  <span class="comment">// 即将要加入window的字符</span></span><br><span class="line">            window.put(addChar,window.getOrDefault(addChar,<span class="number">0</span>) + <span class="number">1</span>);  </span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 如果加入的字符是need中要求的字符，并且数量已经达到了need要求的数量，则valid+1</span></span><br><span class="line">            <span class="comment">// 这里和下面都有个坑，window.get(addChar)和need.get(addChar)返回的都是对象，最好用.equals()方法比较大小</span></span><br><span class="line">            <span class="keyword">if</span>(need.containsKey(addChar) &amp;&amp; window.get(addChar).equals(need.get(addChar)))&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 当window中记录的字符和数量满足了need中要求的字符和数量，考虑缩窗口</span></span><br><span class="line">            <span class="keyword">while</span>(valid == need.size())&#123;</span><br><span class="line">                <span class="comment">// 先判断当前的最小覆盖字串是否比之前的最小覆盖字串短</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; len)&#123;  <span class="comment">// 注意，这里上面已经对right实施了++操作，所以这里的长度不是right - left + 1</span></span><br><span class="line">                    len = right - left ;</span><br><span class="line">                    start = left;  <span class="comment">// 如果最短，则记录下该最小覆盖字串的起始位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">removeChar</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="comment">// 开始缩减窗口，left右移，如果要从window删除的字符正好是need中需要的并且，数目也等于need中需要的数目，则删减后，该该字符要求的数量</span></span><br><span class="line">                <span class="comment">// 显然不满足need要求的数量，所以valid要-1；</span></span><br><span class="line">                <span class="keyword">if</span>(need.containsKey(removeChar) &amp;&amp; window.get(removeChar).equals(need.get(removeChar)))&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(removeChar,window.get(removeChar) - <span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最小覆盖字串的长度相对于定义时没变，则t不包含s中所有的字符，返回&quot;&quot;,如果长度改变过，说明存在这样的最小覆盖字串，直接输出。</span></span><br><span class="line">        <span class="keyword">return</span> len == Integer.MAX_VALUE?<span class="string">&quot;&quot;</span>:s.substring(start,start+len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个HashMap+滑动窗口，如何判断当前窗口包含t的所有字符呢？使用一个哈希表t记录t中所有的字符和个数，使用一个哈希表记录窗口中的所有字符以及个数，如果动态表中的t包含哈希表中的所有字符，并且对应个数不小于t中的个数，那么当前窗口是可行的</span></span><br><span class="line"><span class="comment">//代码我是写不出来了，copy一份吧，不浪费时间了</span></span><br></pre></td></tr></table></figure><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> ans[][] = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 循环次数</span></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录起始位置,控制遍历长度</span></span><br><span class="line">        <span class="comment">//int site = 1;// 控制每条边的遍历长度，每次遍历收缩1位</span></span><br><span class="line">        <span class="keyword">while</span> ((loop++) &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = start; j &lt; n - start - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans[start][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = start; i &lt; n - start - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                ans[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; start; j--) &#123;</span><br><span class="line">                ans[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; start; i--) &#123;</span><br><span class="line">                ans[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            <span class="comment">// site++;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*loop控制循环次数,</span></span><br><span class="line"><span class="comment">site控制每条边的遍历长度,初始为1，每次遍历[ , )，左闭右开区间的数据，写入</span></span><br><span class="line"><span class="comment">最后奇数写入中间的即可，或者不用site，用start-1控制也行，一样</span></span><br><span class="line"><span class="comment">i,j分别表示横纵坐标，所以开始先从j开始，</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对不是不是正方形的矩阵，即m不等于n，上述算法要改进，我开始按照上面的做，寻找m,n的最小值的一半作为循环条件，进入循环，但是最后的结果不对，只有最外圈的成功，内圈如果min(m,n)有奇数的话，进入最后一轮，就会赋值重复，(debug发现因为左右没有值，所以上下，在下上，赋值会重复)，所以需要单独给矩阵最中间的位置赋值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Math.min(m, n);</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">starty</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((loop++) &lt; l / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = startx; j &lt; n - startx - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                list.add(matrix[startx][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = starty; i &lt; m - starty - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; startx; j--) &#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; starty; i--) &#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = startx; j &lt; n - startx; j++) &#123;</span><br><span class="line">                    list.add(matrix[startx][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = starty; i &lt; m - starty; i++) &#123;</span><br><span class="line">                    list.add(matrix[i][starty]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意边界条件，单独给矩阵中间赋值的边界条件，画个图一下子就看出来了</span></span><br></pre></td></tr></table></figure><h3 id="LCR-146-螺旋遍历二维数组"><a href="#LCR-146-螺旋遍历二维数组" class="headerlink" title="LCR 146. 螺旋遍历二维数组"></a>LCR 146. 螺旋遍历二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralArray(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[m * n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Math.min(m, n);</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">starty</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((loop++) &lt; l / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = startx; j &lt; n - startx - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans[count++] = matrix[startx][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = starty; i &lt; m - starty - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                ans[count++] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; startx; j--) &#123;</span><br><span class="line">                ans[count++] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; starty; i--) &#123;</span><br><span class="line">                ans[count++] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = startx; j &lt; n - startx; j++) &#123;</span><br><span class="line">                    ans[count++] = matrix[startx][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = starty; i &lt; m - starty; i++) &#123;</span><br><span class="line">                    ans[count++] = matrix[i][starty];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//思路一样，只是返回值变成了数组</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
